/* Output from p2c 1.21alpha-07.Dec.93, the Pascal-to-C translator */
/* From input file "coco_d_p2c.p" */


/*@+"constants.p"*/

/*@-"foreign.h"*/
/*@-"p2c.H"*/
/*@-"p2clib.C"*/

/*@-"constants.h"*/

/*

  " Copyright (c) 1991, 1996, 2002, by Jens Henrik Badsberg "

  The source code in C for this version of CoCo is available free of
  charge for non-commercial use.

  The source code may only be read and edited for the purpose of
  compiling CoCo, and porting CoCo to machines not currently
  supported by the author.
  No new features may be added to CoCo and no parts of the program
  may be included in other systems or new interface-procedures (at
  the C-side) to R, Splus, XLISP-STAT or other programs made without
  the written permission from the author.

*/


/* Options to 'p2c': */






#ifndef CoCo_Cygwin
   #include "foreign.h"
#else /* CoCo_Cygwin */
   #include "foreign-cygwin.h"
#endif /* CoCo_Cygwin */
   #include "p2c/p2c.h"
   #include "p2c/p2clib.c"

   #ifndef HAS_NOT_VALUES
   #include <limits.h>
   #else
   #endif

   #ifndef MAXDOUBLE
   #define MAXDOUBLE 3.4028234e38
   #endif
   #ifndef MAXFLOAT
   #define MAXFLOAT  3.4028234e38
   #endif

   #include <stdio.h>
   #include <unistd.h>

   #ifndef CHAR_MAX
   #define CHAR_MAX        '~'
   #endif

 


   #ifdef ANSIGCC
   extern double log(double x);
   extern double exp(double x);
   extern double floor(double x);
   extern double sqrt(double x);
   extern double fabs(double x);
   extern double pow(double x, double y);
   # endif

 

/* #  ifdef CC-Ansi-plus
   #  endif CC-Ansi-plus */

/* #  ifdef CC-minus     





     #  endif CC-minus */



/*$ifdef On-DOS
program coco_mips(input, output);
 $endif On-DOS*/


/*
> pi        3.14159 26535 89793 23846 26433
> (log pi)  1.14472 98858 49400 17414 34273
> (log 2)   0.69314 71805 59945 30941 72321
*/

/* _MIPS_LOG_L_ROUND_ERROR = 1E-6; */



#define TRACE_FLAG_FACTOR  10
#define N_START         1
#define P_START         0
#define Q_START         0
#define R_START         0
#define S_START         0
#define T_START         0
#define SS_START        0
#define FIRST_INDEX     0
#define MINUS_FIRST_INDEX  0
#define FIRST_LEVEL     0

#define LN_2_PI_HALF    0.9189385332046727
/* _PI = 3.141592653589793; */

#define DISCRETE_DIMENSION_SHIFT  1

#define Ended_CoCo      2147483647L
#define Fixed_CoCo      2147483646L

#define No_ifail        0
#define No_ifail_return  (-1)
#define CoCo_ended_ifail  1

#define PCH_START       1
#define PCH_END         255
#define EM_UNIFORM      1
#define EM_FIRST        2
#define EM_LAST         3
#define EM_MEAN         4
#define EM_RANDOM       5
#define EM_INPUT        6
#define SWITCH_OFFSET   99
#define VALUE_OFFSET    100
#define MAX_NUMBER_OF_TABLE_VALUES  32
#define NUMBER_OF_MENUS  43
#define VERSION_A       140
#define VERSION_B       1
#define mach            1
#define arch            1
#define type_a          0
#define type_b          0

#define VERSION         " 1.6.5               Mon Sep 19 16:00:00 CEST 2005"
/* #  ifdef CC-minus     
#define COMP_TIME       "                                                  "
#define COMP_MACH       " Compiled with pc, a Sun Pascal compiler for Sun4 "
     #  endif CC-minus */

   #ifdef ANSIGCC
   #define COMP_TIME " Compile-time: " __DATE__ ", " __TIME__ ".             "
   #ifndef COMP_MACH
   #define COMP_MACH " Compiled with cc or gcc, a C compiler for ...    "
   # endif
   #else
   #define COMP_TIME "                                                  "
   #ifndef COMP_MACH
   #define COMP_MACH " Compiled with cc or gcc, a C compiler for ...    "
   # endif
   # endif
 
#define COPYRIGHT       " Copyright (c) 1996, 2003, by Jens Henrik Badsberg"
#define LICENSE         " Licensed to ...                                  "
#define DEFAULT_SPECIFICATION  "COCO.DAT                                "
#define DEFAULT_OBSERVATION  "COCO.DAT                                "
#define DEFAULT_TMP     "CoCo.tmp.YYY.XXXXXXX                    "
#define DEFAULT_DIARY   "CoCo.diary.YYY.XXXXXXX                  "
#define DEFAULT_REPORT  "CoCo.report.YYY.XXXXXXX                 "
#define DEFAULT_LOG     "CoCo.log.YYY.XXXXXXX                    "
#define DEFAULT_DUMP    "CoCo.dump.YYY.XXXXXXX                   "
#define FILE_NAME_NEW_HELP  "HELP.NEW                                "
#define FILE_NAME_HLP   "COCO.HLP                                "
#define FILE_NAME_DOC   "COCO.DOC                                "
#define FILE_NAME_TABLE  "COCO.TAB                                "
#define FILE_NAME_INIT  "INIT.TAB                                "
#define FILE_NAME_START_UP_HOME  ".cocolibrc                              "
#define FILE_NAME_START_UP  ".cocorc                                 "

   #ifdef __Windows_95_names__
#define DEFAULT_TMP              "tmp.CoCo.YYY.XXXXXXX                    "
#define DEFAULT_DIARY            "tmp.dia.YYY.XXXXXXX                     "
#define DEFAULT_REPORT           "tmp.rpt.YYY.XXXXXXX                     "
#define DEFAULT_LOG              "tmp.log.YYY.XXXXXXX                     "
#define DEFAULT_DUMP             "tmp.dmp.YYY.XXXXXXX                     "
#define FILE_NAME_START_UP_HOME  "CoCoLib.src                             "
#define FILE_NAME_START_UP       "CoCo.src                                "
   #else
   # endif
 

#define TURBO_PC        false

#define MIN_VERTEX      0
#ifdef VAR1024
#define MAX_HALF_VERTEX   512
#define MAX_VERTEX       1022
#define NULL_VERTEX      1023
#define MAX_DIMENSION    1024
#define MAX_2_DIMENSION  2048
#define VARINSHORT       true
#else
#ifdef VAR512
#define MAX_HALF_VERTEX   256
#define MAX_VERTEX        510
#define NULL_VERTEX       511
#define MAX_DIMENSION     512
#define MAX_2_DIMENSION  1024
#define VARINSHORT       true
#else
#ifdef VAR256
#define MAX_HALF_VERTEX   128
#define MAX_VERTEX        254
#define NULL_VERTEX       255
#define MAX_DIMENSION     256
#define MAX_2_DIMENSION   512
#define VARINSHORT       true
#else
#define MAX_HALF_VERTEX    64
#define MAX_VERTEX        126
#define NULL_VERTEX       127
#define MAX_DIMENSION     128
#define MAX_2_DIMENSION   256
#endif
#endif
#endif
#define MAX_OFFSET_DIM  10

#define MAX_COUNT_NUMBER  2147483647L
#define MAX_CELL_NUMBER_MAX  1048576L
#define MAX_CELL_NUMBER_INIT  131071L
#define MAX_OFFSET_MAX  2147483646L
#define MAX_OFFSET      131072L
#define MAX_P_CELL_NUMBER_MAX  1048576L
#define MAX_P_CELL_NUMBER_INIT  131073L
#define MAX_Q_CELL_NUMBER_MAX  1048576L

#define MAX_Q_CELL_NUMBER_INIT  1024

#define MAX_R_CELL_NUMBER_MAX  1048576L
#define MAX_R_CELL_NUMBER_INIT  131075L
#define MAX_S_CELL_NUMBER_MAX  1048576L
#define MAX_S_CELL_NUMBER_INIT  131076L
#define MAX_SS_CELL_NUMBER_MAX  1048576L
#define MAX_SS_CELL_NUMBER_INIT  131077L
#define MAX_T_CELL_NUMBER_MAX  1048576L
#define MAX_T_CELL_NUMBER_INIT  131078L

#define MAX_OFFSET_CELL_NUMBER  1024
#define MAX_LEVEL       255
#define MAX_PAGE_LENGTH  256
#define MAX_LINE_LENGTH  128

#define NULL_CHAR       '@'
#define MIN_NAME        '\0'
#define MAX_NAME        CHAR_MAX

#define FILE_NAME_LENGTH  255
#define COMMAND_LENGTH  4
#define MAX_NUMBER_OF_PRODUCTIONS  1024
#define MAX_NUMBER_OF_COMMANDS  255
#define MAX_N_OF_COMMAND_TESTS  3
#define MISSING_LEVEL   255
#define _UNDEF_LEVEL    254
#define _INVALID_LEVEL  253

#define _UNDEF_REAL     (-MAXDOUBLE)
#define _INVALID_REAL   (-MAXDOUBLE)
#define MISSING_REAL    MAXDOUBLE
#define _INFINITY_REAL  MAXDOUBLE
#define _INVALID_SHORT_REAL  (-MAXFLOAT)
#define _INFINITY_SHORT_REAL  MAXFLOAT
#define ROUND_ERROR     1e-15

#define MAX_FIND_ALL    8
#define N_LIMIT         1000

#define N_LIMIT_T       0.5

#define MAX_CASES_IN_LIST  100000L
#define MAXIMAL_COUNT   2147483643L
#define MAXIMAL         2147483643L
#define STRUCT_ZERO_COUNT  2147483644L
#define STRUCT_ZERO     2147483644L
#define _INVALID_COUNT  2147483645L
#define _INVALID        2147483645L
#define _UNDEF_COUNT    2147483646L
#define _UNDEF          2147483646L
#define MISSING         2147483647L
#define _INFINITY       2147483647L

#define _INFINITY_SHORT  32767
#define MAX_FACT        1000
#define DELTA_INTERRUPT  500


/*$ifdef On-DOS
trace_flag_factor = 1;
n_start = 1;
p_start = 0;
q_start = 0;
r_start = 0;
s_start = 0;
t_start = 0;
ss_start = 0;
first_index = 0;
minus_first_index = 0;
first_level = 0;
ln_2_pi_half = 0.9189385332046727;
discrete_dimension_shift = 1;
ended_coco = 2147483647;
fixed_coco = 2147483646;
no_ifail = 0;
no_ifail_return = -1;
coco_ended_ifail = 1;
pch_start = 1;
pch_end = 255;
em_uniform = 1;
em_first = 2;
em_last = 3;
em_mean = 4;
em_random = 5;
em_input = 6;
switch_offset = 99;
value_offset = 100;
max_number_of_table_values = 32;
number_of_menus = 43;
version_a = 140;
version_b = 1;
mach = 1;
arch = 1;
type_a = 0;
type_b = 0;
version = ' Version 1.4.Beta.R1   Sat Jun 1 12:00:00 MET 1996';
comp_time = '                                                  ';
comp_mach = ' Compiled with Borland Pascal 7.0 for PC          ';
copyright = ' Copyright (c) 1996, 2003, by Jens Henrik Badsberg';
license = ' Licensed to ...                                  ';
default_specification = 'COCO.DAT                                ';
default_observation = 'COCO.DAT                                ';
default_diary = 'COCOYYY.DIA                             ';
default_log = 'COCOYYY.LOG                             ';
default_report = 'COCOYYY.RPT                             ';
default_tmp = 'COCOYYY.TMP                             ';
default_dump = 'COCOYYY.DMP                             ';
file_name_new_help = 'HELP.NEW                                ';
file_name_hlp = 'COCO.HLP                                ';
file_name_doc = 'COCO.DOC                                ';
file_name_table = 'COCO.TAB                                ';
file_name_init = 'INIT.TAB                                ';
file_name_start_up_home = 'COCOLIB.SRC                             ';
file_name_start_up = 'COCO.SRC                                ';
min_char = #00;
max_char = #127;
null_char = min_char;
minchar = min_char;
maxchar = max_char;
turbo_pc = true;
min_vertex = 0;
max_vertex = 63;
max_half_vertex = 32;
null_vertex = 64;
max_dimension = 64;
max_2_dimension = 128;
max_offset_dim = 9;
max_count_number = 65535;
max_cell_number_max = 1048576;
max_cell_number = 32766;
max_p_cell_number_max = 1048576;
max_p_cell_number = 10921;
max_offset_max = 2147482646;
max_offset = 65534;
max_offset_cell_number = 512;
max_level = 63;
max_page_length = 256;
max_line_length = 128;
min_name = minchar;
max_name = maxchar;
file_name_length = 255;
command_length = 4;
max_number_of_productions = 1024;
max_number_of_commands = 255;
max_n_of_command_tests = 3;
missing_level = 63;
_undef_level = 62;
_invalid_level = 61;
_undef_real = -MAXDOUBLE;
_invalid_real = -MAXDOUBLE;
missing_real = MAXDOUBLE;
infinity_real = MAXDOUBLE;
_invalid_short_real = -MAXFLOAT;
infinity_short_real = MAXFLOAT;
round_error = 1e-15;
max_find_all = 6;
n_limit = 1000;
n_limit_t = 5;
max_cases_in_list = 200;
maximal_count = 65532;
maximal = 65532;
struct_zero_count = 65532;
struct_zero = 65532;
_invalid_count = 65533;
_invalid = 65533;
_undef_count = 65534;
_undef = 65534;
missing = 65535;
infinity = 2147483647;
infinity_short = 32767;
max_q_cell_number_max = 2147482646;
max_q_cell_number = 1024;
max_r_cell_number_max = 2147482646;
max_r_cell_number = 10921;
max_s_cell_number_max = 2147482646;
max_s_cell_number = 10921;
max_ss_cell_number_max = 2147482646;
max_ss_cell_number = 10921;
max_t_cell_number_max = 2147482646;
max_t_cell_number = 10921;
max_fact = 1000;
delta_interrupt = 500;
 $endif On-DOS*/

/*@+"types.p"*/
/*@-"types.h"*/

typedef Char pch2[2];
typedef Char pch10[10];
typedef Char pch20[20];
typedef Char pch30[30];
typedef Char pch40[40];
typedef Char pch50[50];
typedef Char pch_long[PCH_END - PCH_START + 1];
typedef pch_long t_arr_of_pch_long[2];

/* t_shortreal = shortreal; */

typedef float t_real;

typedef double t_long_real;


/*$ifdef On-DOS
t_real = real;
t_long_real = double;
 $endif On-DOS*/

/* Ifail, code, #variables, ... */
/* t_shortinteger = integer; */
/* Indices of arrays: */
typedef long t_integer;

/* Model dimension: */

typedef long t_long_integer;


/*$ifdef On-DOS
t_long_integer = longint;
 $endif On-DOS*/

#ifdef VARINSHORT
typedef short t_0_max_dimension;

typedef short t_1_max_dimension;
#else
typedef uchar t_0_max_dimension;

typedef uchar t_1_max_dimension;
#endif

typedef Char t_command_name[COMMAND_LENGTH];
typedef uchar t_command_level;

typedef pch_long t_line;

typedef struct t_command_des {
  t_command_level current_level, next_level, offset;
  t_command_name name;
} t_command_des;

typedef t_command_des t_command_array[MAX_NUMBER_OF_PRODUCTIONS];
typedef pch30 t_command_text[MAX_NUMBER_OF_COMMANDS + 1];
typedef enum {
  all, necessary, list_file, both
} t_datastructure;
typedef enum {
  normal_ips, arithmetic, geometric, harmonic
} t_mean_ips_in_use;
typedef enum {
  menu, command
} t_mode;

#ifdef VARINSHORT
typedef short t_vertex;

typedef short t_discrete_vertex;

typedef short t_continuous_vertex;
#else
typedef char t_vertex;

typedef char t_discrete_vertex;

typedef char t_continuous_vertex;
#endif


typedef long t_vertex_set[NULL_VERTEX / 32 + 2];

typedef long t_discrete_vertex_set[NULL_VERTEX / 32 + 2];

typedef long t_continuous_vertex_set[NULL_VERTEX / 32 + 2];

#ifdef VARINSHORT
typedef struct t_vertex_list {
  unsigned vertex : 10;
  struct t_vertex_list *pointer;
} t_vertex_list;

typedef struct t_edge_list {
  unsigned v : 10, w : 10;
  struct t_edge_list *pointer;
} t_edge_list;
#else
typedef struct t_vertex_list {
  unsigned vertex : 7;
  struct t_vertex_list *pointer;
} t_vertex_list;

typedef struct t_edge_list {
  unsigned v : 7, w : 7;
  struct t_edge_list *pointer;
} t_edge_list;
#endif

typedef struct t_list_of_vertex_lists {
  t_vertex_list *vertex_list;
  struct t_list_of_vertex_lists *pointer;
} t_list_of_vertex_lists;

typedef struct t_set_list {
  t_vertex_set vertex_set;
  struct t_set_list *pointer;
} t_set_list;

typedef struct t_g_c_list {
  t_set_list *g_c;
  struct t_g_c_list *pointer;
} t_g_c_list;

typedef t_integer t_level_arr_of_integer[MAX_LEVEL];
typedef t_integer t_level_2_arr_of_integer[MAX_LEVEL][MAX_LEVEL];
typedef boolean t_u_v_arr_of_boolean[NULL_VERTEX - MIN_VERTEX + 1];
typedef uchar t_v_arr_of_boolean[(NULL_VERTEX - MIN_VERTEX + 8) / 8];
typedef t_vertex t_v_arr_of_vertex[NULL_VERTEX - MIN_VERTEX + 1];
typedef t_vertex_set t_v_arr_of_v_sets[NULL_VERTEX - MIN_VERTEX + 1];
typedef t_vertex_list *t_v_arr_of_v_lists[NULL_VERTEX - MIN_VERTEX + 1];
typedef t_set_list t_v_arr_of_set_lists[NULL_VERTEX - MIN_VERTEX + 1];
typedef short t_v_arr_of_order[NULL_VERTEX - MIN_VERTEX + 1];
typedef t_vertex t_o_arr_of_vertex[MAX_DIMENSION];
typedef t_long_integer t_v_arr_of_integer[NULL_VERTEX - MIN_VERTEX + 1];
typedef long t_cell_count;


typedef long t_cell_index;

typedef long t_e_cell_index;

typedef long t_p_cell_index;

typedef long t_e_p_cell_index;

typedef long t_q_cell_index;

typedef long t_e_q_cell_index;

typedef long t_r_cell_index;

typedef long t_e_r_cell_index;

typedef long t_s_cell_index;

typedef long t_e_s_cell_index;

typedef long t_t_cell_index;

typedef long t_e_t_cell_index;

typedef long t_ss_cell_index;

typedef long t_e_ss_cell_index;

typedef long t_array_index;

typedef t_cell_count t_n[MAX_CELL_NUMBER_MAX + 1];
typedef t_real t_p[MAX_P_CELL_NUMBER_MAX + 1];
typedef t_long_real t_r_array[MAX_R_CELL_NUMBER_MAX + 1];

typedef struct t_r_r {
  double *z;
} t_r_r;

typedef t_long_real t_s_array[MAX_S_CELL_NUMBER_MAX + 1];

typedef struct t_s_r {
  double *z;
} t_s_r;

typedef t_long_real t_t_array[MAX_T_CELL_NUMBER_MAX + 1];

typedef struct t_t_r {
  double *z;
} t_t_r;

typedef t_long_real t_ss_array[MAX_SS_CELL_NUMBER_MAX + 1];

typedef struct t_ss_r {
  double *z;
} t_ss_r;

/*$ifdef On-DOS
t_cell_index = 0..max_cell_number;
t_e_cell_index = minus_first_index..max_cell_number;
t_p_cell_index = 0..max_p_cell_number;
t_e_p_cell_index = minus_first_index..max_p_cell_number;
t_q_cell_index = 0..max_q_cell_number;
t_e_q_cell_index = minus_first_index..max_q_cell_number;
t_r_cell_index = 0..max_r_cell_number;
t_e_r_cell_index = minus_first_index..max_r_cell_number;
t_s_cell_index = 0..max_s_cell_number;
t_e_s_cell_index = minus_first_index..max_s_cell_number;
t_t_cell_index = 0..max_t_cell_number;
t_e_t_cell_index = minus_first_index..max_t_cell_number;
t_ss_cell_index = 0..max_ss_cell_number;
t_e_ss_cell_index = minus_first_index..max_ss_cell_number;
t_array_index = 0..1023;
t_n_array = packed array [t_cell_index] of t_cell_count;
t_n = ^ t_n_array;
t_p_array = array [t_p_cell_index] of t_real;
t_p = ^ t_p_array;
t_r_array = array [t_r_cell_index] of t_long_real;
t_r_p = ^ t_r_array;
t_r = ^ t_r_r;
t_r_r = record
           z: t_r_p;
        end;
t_s_array = array [t_s_cell_index] of t_long_real;
t_s_p = ^ t_s_array;
t_s = ^ t_s_r;
t_s_r = record
           z: t_s_p;
        end;
t_t_array = array [t_t_cell_index] of t_long_real;
t_t_p = ^ t_t_array;
t_t = ^ t_t_r;
t_t_r = record
           z: t_t_p;
        end;
t_ss_array = array [t_ss_cell_index] of t_long_real;
t_ss_p = ^ t_ss_array;
t_ss = ^ t_ss_r;
t_ss_r = record
            z: t_ss_p;
         end;
 $endif On-DOS*/
typedef Char t_char_array[MAX_P_CELL_NUMBER_MAX + 1];
typedef t_char_array t_string_array[1];
typedef boolean t_boolean_array[MAX_P_CELL_NUMBER_MAX + 1];

typedef t_integer t_int_array[MAX_P_CELL_NUMBER_MAX + 1];

/*$ifdef On-DOS
t_int_array = array [t_array_index] of t_long_integer;
 $endif On-DOS*/
typedef t_long_integer t_long_array[MAX_P_CELL_NUMBER_MAX + 1];
typedef t_real t_float_array[MAX_P_CELL_NUMBER_MAX + 1];
typedef t_long_real t_double_array[MAX_P_CELL_NUMBER_MAX + 1];
typedef t_long_integer t_q[MAX_Q_CELL_NUMBER_MAX + 1];
typedef uchar t_level;

typedef t_level t_cell[NULL_VERTEX - MIN_VERTEX + 1];
typedef t_level t_integer_vector[NULL_VERTEX - MIN_VERTEX + 1];
typedef t_real t_real_vector[NULL_VERTEX - MIN_VERTEX + 1];

typedef struct t_cell_list {
  t_vertex_list *vertex_list;
  t_cell cell;
  struct t_cell_list *pointer;
} t_cell_list;

typedef enum {
  discrete, continuous
} t_variable_type;

typedef struct t_variable {
  t_variable_type variable_type_type;
  union {
    t_level i;
    t_real x;
  } UU;
} t_variable;

typedef struct t_variable_list {
  struct t_variable_list *pointer;
  t_variable *variable;
} t_variable_list;

typedef struct t_iterate_pack {
  t_long_real start_clock, old_l, max_suff, epsilon, min_d;
  t_long_integer cycle_number, bad_count, max_cycle_number;
  unsigned iterate : 1, outer : 1;
  double *differences;
} t_iterate_pack;

typedef struct t_item {
  t_level *integer_vector;
  float *real_vector;
} t_item;

typedef struct t_item_list {
  t_item item;
  struct t_item_list *pointer;
} t_item_list;

typedef struct t_case_list {
  t_cell cell;
  struct t_case_list *pointer;
} t_case_list;

typedef char t_vertex_name;

typedef pch_long t_long_vertex_name;
typedef long t_name_set[MAX_NAME / 32 + 2];

typedef struct t_variable_description_node {
  t_vertex_name name;
  Char *long_name;
  t_integer stratum;
  t_variable_type variable_type;
  union {
    struct {
      t_level levels_total, levels_missing, levels;
      boolean ordinal;
    } U0;
    boolean missing_values;
  } UU;
} t_variable_description_node;

typedef t_variable_description_node *t_variable_descriptions[NULL_VERTEX -
							     MIN_VERTEX + 1];
typedef t_variable_description_node *t_discrete_variable_descriptions[NULL_VERTEX -
    MIN_VERTEX + 1];
typedef t_variable_description_node *t_continuous_variable_descriptions[NULL_VERTEX -
    MIN_VERTEX + 1];
typedef t_vertex t_name_to_vertex[MAX_NAME - MIN_NAME + 1];

typedef struct t_vertex_name_list {
  t_vertex vertex;
  t_integer length;
  pch_long name;
  struct t_vertex_name_list *pointer;
} t_vertex_name_list;

typedef struct t_real_list {
  t_long_real x;
  struct t_real_list *pointer;
} t_real_list;

typedef struct t_integer_list {
  t_long_integer x;
  struct t_integer_list *pointer;
} t_integer_list;

typedef struct t_two_integers_list {
  t_long_integer a, b;
  struct t_two_integers_list *pointer;
} t_two_integers_list;

typedef long t_offset;


/*$ifdef On-DOS
t_offset = -1..max_offset;
 $endif On-DOS*/
typedef short t_offset_index;

typedef t_offset t_offset_array[MAX_OFFSET_CELL_NUMBER];
typedef long t_t_offset;

typedef struct t_t_offset_list {
  t_vertex_set vertex_set;
  t_offset t_offset_;
  t_t_r *t;
  struct t_t_offset_list *pointer;
} t_t_offset_list;

typedef struct t_t_list {

  long fta, top;

  /*$ifdef On-DOS
  fta, top: minus_first_index..max_t_cell_number;
   $endif On-DOS*/
  t_t_r *t;
  struct t_t_list *pointer;
} t_t_list;

typedef long t_s_offset;

typedef struct t_s_offset_list {
  t_vertex_set vertex_set;
  t_offset s_offset;
  t_s_r *s;
  struct t_s_offset_list *pointer;
} t_s_offset_list;

typedef struct t_s_list {

  long fsa, top;

  /*$ifdef On-DOS
  fsa, top: minus_first_index..max_s_cell_number;
   $endif On-DOS*/
  t_s_r *s;
  struct t_s_list *pointer;
} t_s_list;

typedef long t_ss_offset;

typedef struct t_ss_offset_list {
  t_vertex_set vertex_set;
  t_offset ss_offset;
  t_ss_r *ss;
  struct t_ss_offset_list *pointer;
} t_ss_offset_list;

typedef struct t_ss_list {

  long fssa, top;

  /*$ifdef On-DOS
  fssa, top: minus_first_index..max_ss_cell_number;
   $endif On-DOS*/
  t_ss_r *ss;
  struct t_ss_list *pointer;
} t_ss_list;

typedef long t_r_offset;

typedef struct t_r_offset_list {
  t_vertex_set vertex_set;
  t_offset r_offset;
  t_r_r *r;
  struct t_r_offset_list *pointer;
} t_r_offset_list;

typedef struct t_r_list {

  long fra, top;

  /*$ifdef On-DOS
  fra, top: minus_first_index..max_r_cell_number;
   $endif On-DOS*/
  t_r_r *r;
  struct t_r_list *pointer;
} t_r_list;

typedef struct t_offset_list {
  t_vertex_set vertex_set;
  t_offset offset;
  struct t_offset_list *pointer;
} t_offset_list;

typedef struct t_expression {
  t_vertex_set vertex_set;
  t_long_integer factor, card;
  t_offset offset;
  struct t_expression *pointer;
} t_expression;

/* t_link_continuous_expression = ^ t_continuous_expression;
   t_continuous_expression = packed
   record
      vertex_set: t_vertex_set;
      pointer: t_link_continuous_expression
   end; */

typedef struct t_discrete_generator {
  t_vertex_set d;
  t_offset n_d_offset;
  struct t_discrete_generator *pointer;
} t_discrete_generator;   /* packed */

typedef struct t_linear_generator {
  boolean line_search;
  t_vertex_set d, c;
  t_s_r *O_s_d;
  t_offset O_s_d_offset, n_d_offset;
  struct t_linear_generator *pointer;
} t_linear_generator;   /* packed */

typedef struct t_linear_and_quadratic_generator {
  boolean line_search;
  t_vertex_set b, c, d;
  t_vertex lambda;
  t_s_r *O_ssd_b;
  t_offset O_ssd_b_offset;
  t_s_r *O_s_d;
  t_offset O_s_d_offset, n_b_offset, n_d_offset;
  struct t_linear_and_quadratic_generator *pointer;
} t_linear_and_quadratic_generator;   /* packed */

typedef struct t_single_quadratic_generator {
  boolean line_search;
  t_vertex_set d;
  t_vertex lambda;
  t_s_r *O_ssd_d;
  t_offset O_ssd_d_offset;
  /* O_s_d     : t_s;
     O_s_d_offset   : t_s_offset; */
  t_offset n_d_offset;
  struct t_single_quadratic_generator *pointer;
} t_single_quadratic_generator;   /* packed */

typedef struct t_quadratic_pair_generator {
  boolean line_search;
  t_vertex_set d;
  t_vertex lambda, my;
  t_s_r *O_ssd_d;
  t_offset O_ssd_d_offset;
  /* O_s_d     : t_s;
     O_s_d_offset   : t_s_offset; */
  t_offset n_d_offset;
  struct t_quadratic_pair_generator *pointer;
} t_quadratic_pair_generator;   /* packed */

typedef struct t_mips_generators {
  t_discrete_generator *discrete_generators;
  t_linear_generator *linear_generators;
  t_linear_and_quadratic_generator *linear_and_quadratic_generators;
  t_single_quadratic_generator *single_quadratic_generators;
  t_quadratic_pair_generator *quadratic_pair_generators;
} t_mips_generators;   /* packed */

typedef struct t_find_ghk_element {
  t_offset r_upper_offset;
  t_t_r *r_upper;
  t_offset k_upper_offset;
  t_t_r *k_upper;
  t_offset r_lower_offset;
  t_t_r *r_lower;
  t_offset k_lower_offset;
  t_t_r *k_lower;
} t_find_ghk_element;   /* packed */

typedef struct t_mixed_characteristics {
  boolean mim_model, degenerated, d_collapsible, mean_linear, q_equivalent;
} t_mixed_characteristics;   /* packed */

typedef struct t_mips_element {
  t_mips_generators *generators;
  /* sub_estimate_model, prepare_mixed_item_for_mips,
     sub_sub_do_add_hk, sub_sub_do_find_ssd, find_log_l_c_ips: */
  boolean complete, convergence, fund_ghk;
  t_integer ifail, cycles;
  t_long_real mips_delta, log_likelihood, min_l, max_l;
  t_offset r_offset;
  t_t_r *r;
  t_offset ss_offset;
  t_ss_r *ss;
  /* upper       : t_vertex_set; */
  t_set_list *discrete_, *linear, *quadratic;
  t_offset n_offset;
  t_mixed_characteristics *mixed_characteristics;
  t_find_ghk_element *ghk_work;
} t_mips_element;   /* packed */

typedef struct t_list_mips_elements {
  t_mips_element mips_element;
  struct t_list_mips_elements *pointer;
} t_list_mips_elements;

typedef struct t_cips_set_list {
  t_offset r_offset;
  t_t_r *r;   /* ghK = `inverse'(ssd) */
  t_vertex_set vertex_set;
  t_continuous_vertex_set vertex_set_continuous;
  struct t_cips_set_list *pointer;
} t_cips_set_list;   /* packed */

typedef struct t_cips_element {
  t_cips_set_list *generators;
  /* complete       : boolean; */
  boolean convergence, fund_ghk;
  t_integer ifail, cycles;
  t_long_real cips_delta, log_likelihood, min_l, max_l;
  t_offset r_offset;
  t_t_r *r;
  t_offset ss_offset;
  t_ss_r *ss;   /* For MIPS deviance */
  /* upper       : t_vertex_set; */
  /* m_ips_leaf       : t_link_mips_element; */
} t_cips_element;

typedef struct t_list_cips_elements {
  t_cips_element *link_cips_element;
  struct t_list_cips_elements *pointer;
} t_list_cips_elements;

typedef struct t_ips_set_list {
  t_vertex_set vertex_set;
  t_offset n_offset;
  struct t_ips_set_list *pointer;
} t_ips_set_list;

typedef struct t_ips_element {
  boolean radim_part;
  t_vertex_set a;
  t_offset p_offset, n_offset;
  t_offset_list *link_q_tables;
  t_ips_set_list *gen_class;
} t_ips_element;

typedef struct t_list_ips_elements {
  t_ips_element ips_element;
  struct t_list_ips_elements *pointer;
} t_list_ips_elements;

typedef struct t_radim_part {
  t_offset_list *generators, *upper, *lower, *from;
  struct t_radim_part *pointer;
} t_radim_part;

typedef struct t_radim_element {
  t_radim_part *radim_parts;
  t_list_ips_elements *ips_list;
  /* Used in sub_return_expression and find_log_l_r_ips */
  t_vertex_set a;
  t_integer_list *lower_n_offsets;
  t_offset_list *link_q_tables;
  t_ips_set_list *gen_class;
} t_radim_element;

typedef struct t_list_radim_elements {
  t_radim_element radim_element;
  struct t_list_radim_elements *pointer;
} t_list_radim_elements;

typedef struct t_power_set {
  t_vertex_set a;
  t_long_integer factor, cardinality;
  t_offset offset;
} t_power_set;

typedef struct t_decomposition_element {
  struct t_model *left_model, *right_model;
  struct t_formula_node *separator;
  /* For mixed-models the separator is not
     used (15. september 2003: not true!!!):
     `Information' is found in LeftModel! */
} t_decomposition_element;

typedef enum {
  null_node, decomposition_node, d_complete_node, c_complete_node,
  m_complete_node, d_ips_node, r_ips_node, c_ips_node, m_ips_node
} t_formula_node_type;

typedef struct t_formula_node {
  t_mips_element *tmp_m_ips_leaf;
  t_formula_node_type node_type;
  union {
    t_decomposition_element *decomposition_node_;
    t_power_set *d_complete_leaf;
    t_power_set *c_complete_leaf;
    t_power_set *m_complete_leaf;
    t_ips_element *d_ips_leaf;
    t_radim_element *r_ips_leaf;
    t_cips_element *c_ips_leaf;
    t_mips_element *m_ips_leaf;
  } UU;
} t_formula_node;

typedef enum {
  pure_discrete, mixed, cg_regression, pure_continuous
} t_model_type;


typedef struct t_model_specification {
  t_vertex_set vertices;
  t_long_integer paritet;
  t_set_list *causal_structure;
  t_model_type model_type;
  union {
    t_set_list *g_c_log_linear;
    struct {
      t_set_list *g_c_discrete, *g_c_linear, *g_c_quadratic;
      /* edges_linear, edges_quadratic: t_link_set_list; */
      boolean decompose, full_specified, homogeneous;
    } U1;
    t_set_list *g_c_covariance;
  } UU;
} t_model_specification;

typedef struct t_model {
  t_model_specification *id;
  boolean copy, graphical, decomposable, found_expression, found_ps,
	  found_log_l;
  /* exclude_set      : t_vertex_set; */
  t_long_real constant, log_l;
  t_long_integer dim, dimdec;
  t_integer model_number, model_ifail;
  t_formula_node *formula_node;
} t_model;

typedef struct t_model_list {
  t_model *model;
  struct t_model_list *pointer;
} t_model_list;

typedef struct t_list_of_model_lists {
  t_model_list *model_list;
  t_long_integer model_number;
  struct t_list_of_model_lists *pointer;
} t_list_of_model_lists;

typedef struct t_model_references {
  t_model_list *link_current, *link_base;
  struct t_model_references *pointer;
} t_model_references;

typedef struct t_list_of_model_tree_nodes {
  struct t_model_tree_node *node;
  struct t_list_of_model_tree_nodes *pointer;
} t_list_of_model_tree_nodes;

typedef struct t_model_tree_node {
  t_model_list *link_model;
  t_list_of_model_tree_nodes *sub_models;
} t_model_tree_node;

typedef t_model_type t_test_type;

typedef struct t_stepwise_options {
  boolean reversed, sorted_list, export_list, unordered_list, short_report,
	  decomposable, graphical, hierarchical, recursive, coherent,
	  headlong, follow, blockwise, separators, partitioning, alternative;
} t_stepwise_options;   /* packed */

typedef struct t_test_write_options {
  boolean examin_terms, write_test, line_form, write_models;
} t_test_write_options;   /* packed */

typedef enum {
  _string_label, _set_label, _pair_label
} t_test_label_type;

typedef struct t_test_labels {
  t_long_integer indent;
  boolean short_report, separators, reused_test;
  t_test_label_type write_type;
  union {
    struct {
      pch20 label_string;
      t_integer width;
    } U0;
    t_vertex_set vertex_set;
    struct {
      t_vertex u, v;
    } U2;
  } UU;
} t_test_labels;   /* packed */

typedef struct t_test {
  t_long_integer n_count, number_of_tables, test_ifail, paritet, df, adj,
		 f_test_df, beta_df;
  t_long_real x_power, x_pearson, x_deviance, x_f_test, beta, df_real, gamma,
	      s, s1, mcep_gamma_1, mcep_gamma_2, mcep_power, mcep_pearson,
	      mcep_deviance, mcep_f_test;
  boolean ok;
  /* cs, g_c_1, g_c_2    : t_link_set_list; */
  t_model_specification *id_1, *id_2;
  t_long_integer class_;
  boolean in_eh, graphical, decomposable;
  t_test_labels *test_label;
  t_model_type test_type;
  union {
    int empty_union;   /* Pascal variant record was empty */
  } UU;
} t_test;   /* packed */

typedef struct t_test_list {
  t_test test;
  struct t_test_list *pointer;
} t_test_list;

typedef struct t_part_list {
  t_test_list *link_test_list;
  struct t_part_list *pointer;
} t_part_list;

typedef struct t_sort_list {
  t_long_real x;
  t_vertex_set vertex_set;
  t_test_list *link_test_list;
  t_part_list *link_part_list, *link_sepa_list;
  struct t_sort_list *pointer;
} t_sort_list;

typedef struct t_file_list {
  FILE *com_file;
  pch_long name;
  struct t_file_list *pointer;
} t_file_list;

typedef t_real_list *t_cutpoints[NULL_VERTEX - MIN_VERTEX + 1];

typedef struct t_product_list {
  t_vertex_set c_in_a;
  t_long_integer product;
  t_v_arr_of_integer prod_1, prod_2;
  struct t_product_list *pointer;
} t_product_list;

typedef struct t_adj_set_list {
  t_v_arr_of_v_sets adj_set;
  struct t_adj_set_list *pointer;
} t_adj_set_list;

typedef struct t_eh_pack {
  boolean graphical_search, fix_in, fix_out;
  t_long_real search_time;
  t_long_integer search_strategy, search_opt;
  t_vertex_set g;
  t_model_list *link_base;
  t_set_list *fix_out_gc_x, *fix_in_gc_x, *fix_out_gc, *fix_in_gc;
  t_g_c_list *d_a, *d_r, *a, *r;
  t_v_arr_of_v_sets fix_out_adj_set, fix_in_adj_set;
} t_eh_pack;

typedef struct t_cell_element {
  t_long_integer n;
  t_long_real p;
  t_cell cell;
} t_cell_element;

typedef struct t_slice_pack {
  t_v_arr_of_integer levels, product_a_v, product_b_v, product_a_w,
		     product_b_w, product_a_vw, product_b_vw;
  t_cell_index p_vc_v, p_wc_w, p_vwc_v, p_vwc_w;
  t_long_integer marginal_dimension_c;
  t_vertex l;
} t_slice_pack;

typedef struct t_fast_next_offset_pack {
  t_u_v_arr_of_boolean c_in_a;
  t_v_arr_of_integer increments, decrements, levels;
  t_vertex l;
} t_fast_next_offset_pack;

typedef enum {
  first, not_first
} t_am_node_type;

typedef struct t_am_node {
  struct t_am_edge_list *link_edge;
  struct t_am_node *forward_link;
  t_am_node_type node_type;
  union {
    struct t_am_node *backward_link;
    t_vertex vertex;
  } UU;
} t_am_node;

typedef t_am_node *t_v_arr_of_am_nodes[NULL_VERTEX - MIN_VERTEX + 1];

typedef struct t_am_node_ref {
  t_am_node *node;
  struct t_am_node_ref *pointer;
} t_am_node_ref;

typedef struct t_am_edge_list {
  t_integer size, card, beta, gamma;
  struct t_hyper_set_node *hyper_set_node;
  t_vertex_set vertex_set;
  t_am_node_ref *nodes;
  struct t_am_edge_list *forward_link, *backward_link;
} t_am_edge_list;

typedef struct t_adjacency_matrix {
  t_v_arr_of_am_nodes vertex_list;
  t_am_edge_list *am_edge_list;
} t_adjacency_matrix;

typedef struct t_hyper_set_node {
  t_am_edge_list *link_edge;
  struct t_hyper_set_list *hyper_set;
  struct t_hyper_set_node *forward_link, *backward_link;
} t_hyper_set_node;

typedef struct t_hyper_set_list {
  t_hyper_set_node *node;
  struct t_hyper_set_list *forward_link, *backward_link;
} t_hyper_set_list;

typedef t_integer t_2_3_key;

typedef enum {
  t_offset_tree, ss_offset_tree, s_offset_tree, r_offset_tree, offset_tree,
  test_tree, model_tree
} t_2_3_tree_type;

typedef struct t_2_3_element {
  long key;
  t_2_3_tree_type tree_type;
  union {
    t_r_offset_list *r_offset_element;
    t_s_offset_list *s_offset_element;
    t_ss_offset_list *ss_offset_element;
    t_t_offset_list *t_offset_element;
    t_offset_list *offset_element;
    t_test_list *test_element;
    t_model_list *model_element;
  } UU;
} t_2_3_element;

typedef struct t_2_3_leaf {
  long key, count;
  t_2_3_tree_type tree_type;
  union {
    t_r_offset_list *r_offset_list;
    t_s_offset_list *s_offset_list;
    t_ss_offset_list *ss_offset_list;
    t_t_offset_list *t_offset_list_;
    t_offset_list *offset_list;
    t_part_list *test_list;
    t_model_list *model_list;
  } UU;
} t_2_3_leaf;

typedef enum {
  leaf, interior
} t_2_3_node_type;

typedef struct t_2_3_node {
  long count;
  t_2_3_node_type node_type;
  union {
    t_2_3_leaf *leaf_;
    struct {
      struct t_2_3_node *firstchild, *secondchild, *thirdchild;
      long lowofsecond, lowofthird;
    } U1;
  } UU;
} t_2_3_node;

/*@+"variables.p"*/
/*@-"variables.c"*/


/* #  ifdef Multiple-Objects-minus */
/* #  endif Multiple-Objects-minus */

Static char command_test[MAX_NUMBER_OF_COMMANDS + 1][MAX_N_OF_COMMAND_TESTS];
Static t_mode mode;
Static t_command_array command_array;
Static t_long_integer number_of_productions, menu_number,
		      first_model_available, em_initial, em_max_it,
		      ips_max_it, cips_max_it, mips_max_it, number_of_tables,
		      seed, max_fact_found, pid, sigall, tmp_count,
		      char_count, line_count;
Static long command_char[9];
Static t_command_text command_text;
Static pch10 prompt;
Static t_integer prompt_length;
Static long begin_set[9], end_set[9], end_gc[9], end_gc_list[9], end_mark[9],
	    end_mark_plus[9], order_mark[9];

Static FILE *data_file, *spec_file;

/*$ifdef On-DOS
   command_file, output, output, data_file, spec_file: text;
 $endif On-DOS*/
Static FILE *file_read, *file_excluded;
/* file_items_read, file_items_excluded: t_item_file; */
Static t_case_list *case_list_read, *case_list_excluded, *case_list;
Static t_item_list *item_list_read, *item_list_excluded, *item_list;
Static boolean print_case_list, space_for_case_list;
Static pch_long file_name_read, file_name_excluded, command_name,
		results_name, response_name, data_name, spec_name;
Static boolean term, terminal, read_spec, read_obs;
Static t_offset_array offset;
Static t_offset_list *link_offset_list;
Static t_2_3_node *offset_2_3_tree;
Static t_s_offset_list *link_s_offset_list;
Static t_r_offset_list *link_r_offset_list;
Static t_2_3_node *r_offset_2_3_tree, *s_offset_2_3_tree;
Static t_ss_offset_list *link_ss_offset_list;
Static t_2_3_node *ss_offset_2_3_tree;
Static t_t_offset_list *link_t_offset_list;
/* t_offset_2_3_tree: t_link_2_3_tree; */
Static t_cell_index fna;
Static t_e_p_cell_index fpa;
Static t_e_q_cell_index fqa;
Static t_e_r_cell_index fra;
Static t_e_s_cell_index fsa;
Static t_e_ss_cell_index fssa;
Static t_e_t_cell_index fta;

/* #  ifdef Resize-post-minus   

Static t_n n;
Static t_p p;
Static t_q q_array;

   #  endif Resize-post-minus */


/* #  ifdef Resize-post-plus-x */

 Static long   *n;
 Static float  *p;
 Static long   *q_array;

  /* #  endif Resize-post-plus-x */


Static t_r_list *r_list;
Static t_s_list *s_list;
Static t_ss_list *ss_list;
Static t_t_list *t_list;
Static t_offset_list *q_tables_offsets;
Static t_set_list *g_c_q_tables;
Static t_cell first_cell;
/* , full_last_cell */
Static t_cell last_cell;
Static t_vertex double_vertex, first_vertex, last_vertex, full_last_vertex,
		last_discrete_vertex, last_continuous_vertex,
		first_discrete_vertex, first_continuous_vertex,
		full_last_discrete_vertex, full_last_continuous_vertex;
Static t_variable_descriptions variable_description,
			       full_variable_description;
Static t_discrete_variable_descriptions discrete_variable_description,
					full_discrete_variable_description;
Static t_continuous_variable_descriptions continuous_variable_description,
					  full_continuous_variable_description;
Static t_name_to_vertex name_to_vertex, full_name_to_vertex;
Static t_vertex_set delta, full_delta, gamma_, full_gamma, delta_gamma,
		    full_delta_gamma;
/* explanatory, full_explanatory: t_vertex_set; */
/* response, full_response: t_vertex_set; */
Static t_set_list *causal_structure;
Static t_name_set empty_name_set, names, full_names;
#ifdef VARINSHORT
Static short dimension, full_dimension;
#else
Static uchar dimension, full_dimension;
#endif
/* , full_continuous_name_list */
Static t_vertex_name_list *continuous_name_list;
/* , full_discrete_name_list */
Static t_vertex_name_list *discrete_name_list, *name_list, *full_name_list;
Static t_v_arr_of_vertex full_to_discrete, full_to_continuous, to_discrete,
			 to_continuous;
Static t_cell_index number_of_cells;
Static t_datastructure datastructure;
Static boolean mixed_data, datastructure_selected, hash_overflow,
	       permit_log_l, large, sorted, read_subset, long_names;
Static t_vertex_set double_vertex_set, empty_set, discrete_subset,
		    continuous_subset, subset, response_variables,
		    ordinal_factors;
/* discrete_cutpoints, */
Static t_cutpoints cutpoints;
Static boolean reject_missing, exclude_missing;
Static t_vertex_set delta_missing_excluded;
Static t_cell_list *link_select, *link_reject;
Static t_model_list *link_model_list, *link_current, *link_base, *link_full;
/* internal_model_list: t_link_model_list; */
Static t_model_references *model_references;
Static t_list_of_model_lists *internal_model_list;
Static t_2_3_node *model_2_3_tree, *test_2_3_tree;
Static t_test_list *link_test_list;
Static t_part_list *link_part_list;
Static char mips_in_use, cips_in_use, ips_in_use;
Static t_mean_ips_in_use mean_ips_in_use;
Static t_stepwise_options *global_stepwise_options;
Static t_test_write_options *global_write_options;
Static t_test_labels *global_test_labels;
Static char c_factorizes;
Static boolean in_fact_inter, in_test, in_search, partitioning_output,
	       c_partitioning, ordinal_tests, initial_values_for_ips,
	       exact_test_for_test_models, exact_test_for_partitioning,
	       exact_test_for_sum_up, exact_test, exact_log_l, fast, ic, bic;
/* reversed, sorted_list, short_report, alternative, direct, coherent,
   follow, separators, blockwise, brute, random_order, */
Static boolean graph_mode, decomposable_mode, re_use_test, homogeneous_mode,
	       adj_df, decompose_incomplete, incomplete_table, em,
	       pause_output, timer, echo, echo_note, trace, debug,
	       note_warnings, permit_condensed, dummy_option, std_input_set,
	       file_read_set, file_excluded_set, spec_file_set, data_file_set;
/* page_count, */
Static t_long_integer page_length, page_pause_length, line_length, prob_width,
		      prob_dec, x_width, x_dec, print_width, print_dec, width,
		      decprob, decexpt, decdiff, init_n_of_tables,
		      observation_line_number, data_line_number,
		      data_line_position, last_interrupt_time_1,
		      last_interrupt_time_2, interrupt_count;
Static t_long_real alfa_, alfa_reject, asymptotic_limit, parts_limit,
		   separators_limit, exact_epsilon, ic_lambda, lambda,
		   ips_epsilon, cholesky_epsilon, cips_epsilon, mips_epsilon,
		   mips_init_epsilon, mips_log_l_round_error,
		   mips_random_noise, mips_min_lambda, em_epsilon,
		   my_var_na_double;
Static char test_choice;
Static t_two_integers_list *link_n_of_tables;
Static t_long_real fact_array[MAX_FACT + 1];
Static t_long_integer half_sqr_array[MAX_DIMENSION + 1];
/* fix_edges_gc_x, */
Static t_set_list *fix_edges_gc;
Static t_v_arr_of_v_sets fix_edges_adj_set;
Static t_eh_pack *link_eh_pack;
/*$ifdef TRACE*/
/*$endif TRACE*/
Static boolean boolean_option[128];
/* boolean_flag: array [0..4095] of boolean; */
Static boolean trace_flag[32768];
/*$ifdef TRACE*/
/*$endif TRACE*/
Static t_real my_var_na_float;
Static pch_long last_data_line;

/* #  ifdef Multiple-Objects-minus */
/* #  endif Multiple-Objects-minus */

/* #  ifdef Multiple-Objects-plus
   #  endif Multiple-Objects-plus */

Static FILE *diary_file, *log_file, *dump_file, *report_file;
Static pch_long diary_name, log_name, dump_name, report_name;
Static boolean diary, log_on, log_data_on, dump, report, diary_set, log_set,
	       dump_set, report_set, default_dump_set, exit_after_start_up;
/* interrupt_x, */
Static boolean interrupt_1, interrupt_2, interrupt_3;
Static Char *link_coco_tmp;
/* , link_coco_home */
Static Char *link_coco_lib;
/*$ifdef On-DOS
   traceoverlay: boolean;
   useroverlaysize: longint;
   userretrysize: longint;
   stdovrreadbuf: ovrreadfunc;
 $endif On-DOS*/
Static t_long_integer max_cases_in_list_var, max_cell_number,
		      max_p_cell_number, max_q_cell_number, max_r_cell_number,
		      max_t_cell_number, max_s_cell_number,
		      max_ss_cell_number;


/*@+"io.p"*/

Static boolean is_infinity_real(x)
t_long_real x;
{
  return (fabs(x) > 0.999 * _INFINITY_REAL);
}  /* is_infinity_real */


Static boolean is_invalid_real(x)
t_long_real x;
{
  boolean is_invalid = false;

  /* Core: */
  if (true)
    is_invalid = (fabs(x) > fabs(0.999 * _INVALID_REAL));
  return is_invalid;
}  /* is_invalid_real */


Static boolean is_invalid_short_real(x)
t_long_real x;
{
  boolean is_invalid = false;

  /* Core: */
  if (true)
    is_invalid = (fabs(x) > fabs(0.999 * _INVALID_REAL));
  if (!is_invalid)
    is_invalid = (fabs(x) > fabs(0.999 * _INVALID_SHORT_REAL));
  return is_invalid;
}  /* is_invalid_short_real */


/* Read from Stdin: */

Static Void read_stdio_char(f, c)
FILE *f;
Char *c;
{
  *c = getc(f);
  if (*c == EOF)
    _EscIO(EndOfFile);
  if (*c == '\n')
    *c = ' ';
}  /* read_text_char */


Static Void read_stdin_ln()
{
  if (scanf("%*[^\n]") == EOF)
    _EscIO(EndOfFile);
  if (getchar() == EOF)
    _EscIO(EndOfFile);
}  /* readln_stdin */


Static boolean eoln_stdin()
{
  return P_eoln(stdin);
}  /* eoln_stdin */


Static boolean eolnnotf(f)
FILE *f;
{
  if (P_eof(f))
    return false;
  else
    return P_eoln(f);
}  /* eolnnotf */


Static boolean eolnorf(f)
FILE *f;
{
  if (P_eoln(f))
    return true;
  else
    return P_eof(f);
}  /* eolnorf */


Static boolean eoln_command(command_file)
FILE *command_file;
{
  return P_eoln(command_file);
}  /* eoln_command */


Static boolean eof_command(command_file)
FILE *command_file;
{
  return P_eof(command_file);
}  /* eof_command */


Static boolean eolnnotf_command(command_file)
FILE *command_file;
{
  if (eof_command(command_file))
    return false;
  else
    return (eoln_command(command_file));
}  /* eolnnotf_command */


Static boolean eolnorf_command(command_file)
FILE *command_file;
{
  if (eoln_command(command_file))
    return true;
  else
    return (eof_command(command_file));
}  /* eolnorf_command */


Static boolean eoln_data(data_file)
FILE *data_file;
{
  return P_eoln(data_file);
}  /* eoln_data */


Static boolean eof_data(data_file)
FILE *data_file;
{
  return P_eof(data_file);
}  /* eof_data */


Static boolean eolnnotf_data(data_file)
FILE *data_file;
{
  if (eof_data(data_file))
    return false;
  else
    return (eoln_data(data_file));
}  /* eolnnotf_data */


Static boolean eolnorf_data(data_file)
FILE *data_file;
{
  if (eoln_data(data_file))
    return true;
  else
    return (eof_data(data_file));
}  /* eolnorf_data */


/* Read from text-file: */

Static Void read_text_char(f, c)
FILE *f;
Char *c;
{
  *c = getc(f);
  if (*c == EOF)
    _EscIO(EndOfFile);
  if (*c == '\n')
    *c = ' ';
}  /* read_text_char */


Static Void read_text_ln(f)
FILE *f;
{
#ifndef CoCo_Cygwin
  if (fscanf(f, "%*[^\n]") == EOF)
#else /* CoCo_Cygwin */
  /* */
  char *buf;
  int n;

  buf = (char *)Malloc(128);
  if (buf == NULL)
    _OutMem();
#ifdef DEBUG_F
  /* F */ printf("read_text_ln [ ");
  /* F */ printf("read_text_ln [ ");
#endif /* F */
  n = 0 /* fscanf(f, "%*[^\n]") */ /* fgets(buf, 10, f) */ ;
#ifdef DEBUG_F
  /* F */ printf(" n: %*ld ; buf: `", 2, n);
  /* F */ printf(buf);
#endif /* F */
  if (n == EOF)
#endif /* CoCo_Cygwin */
    _EscIO(EndOfFile);
#ifndef CoCo_Cygwin
  if (getc(f) == EOF)
#else /* CoCo_Cygwin */
#ifdef DEBUG_F
  /* F */ printf("' ; ");
#endif /* F */
  n = getc(f);
#ifdef DEBUG_F
  /* F */ printf(" getc: %*ld ", 2, n);
#endif /* F */
  if (n == EOF)
#endif /* CoCo_Cygwin */
    _EscIO(EndOfFile);
#ifdef CoCo_Cygwin
#ifdef DEBUG_F
  /* F */ printf(" ] \n");
#endif /* F */
  _Free(buf);
  /* */

  /*  if (fscanf(f, "%*[^\n]") == EOF)
    _EscIO(EndOfFile);
  if (getc(f) == EOF)
  _EscIO(EndOfFile); */
#endif /* CoCo_Cygwin */
}  /* read_text_ln */


Static Void read_text_integer(f, w, i)
FILE *f;
t_integer w;
t_long_integer *i;
{
#ifndef CoCo_Cygwin
  if (fscanf(f, "%ld", i) == EOF)
#else /* CoCo_Cygwin */
  /* */
  char *buf;

#ifdef DEBUG_F
  /* F */ printf("read_text_integer [ ");
#endif /* F */
  buf = (char *)Malloc(128);
#ifdef DEBUG_F
  /* F */ printf(" w: %*ld ; buf: `", 2, w);
#endif /* F */
  if (buf == NULL)
    _OutMem();
  buf = fgets(buf, w+1, f);
#ifdef DEBUG_F
  /* F */ printf(buf);
  /* F */ printf("' ; ");
#endif /* F */
  if (buf == NULL)
#endif /* CoCo_Cygwin */
    _EscIO(EndOfFile);
#ifdef CoCo_Cygwin
  else
    sscanf(buf, "%ld", i);
    _Free(buf);
#ifdef DEBUG_F
  /* F */ printf(" i: %*ld ] \n", 4, *i);
#endif /* F */
  /* */

  /* if (fscanf(f, "%ld", i) == EOF)
     _EscIO(EndOfFile); */
#endif /* CoCo_Cygwin */
}  /* read_text_integer */



/* Read from Guide: */

Static Void read_guide_char(guide, c)
FILE *guide;
Char *c;
{
  *c = getc(guide);
  if (*c == EOF)
    _EscIO(EndOfFile);
  if (*c == '\n')
    *c = ' ';
}  /* read_guide_char */


Static Void read_guide_integer(guide, w, i)
FILE *guide;
t_integer w;
t_long_integer *i;
{
  read_text_integer(guide, w, i);
}  /* read_guide_integer */


Static Void read_guide_ln(guide)
FILE *guide;
{
  read_text_ln(guide);
}  /* read_guide_ln */


Static boolean eoln_guide(guide)
FILE *guide;
{
  return P_eoln(guide);
}  /* eoln_guide */


Static boolean eof_guide(guide)
FILE *guide;
{
  return P_eof(guide);
}  /* eof_guide */


Static boolean eolnnotf_guide(guide)
FILE *guide;
{
  if (eof_guide(guide))
    return false;
  else
    return (eoln_guide(guide));
}  /* eolnnotf_guide */


Static boolean eolnorf_guide(guide)
FILE *guide;
{
  if (eoln_guide(guide))
    return true;
  else
    return (eof_guide(guide));
}  /* eolnorf_guide */


/* Read from Parser: */

Static Void read_parser_char(parser, c)
FILE *parser;
Char *c;
{
  *c = getc(parser);
  if (*c == EOF)
    _EscIO(EndOfFile);
  if (*c == '\n')
    *c = ' ';
}  /* read_parser_char */


Static Void read_parser_integer(parser, w, i)
FILE *parser;
t_integer w;
t_long_integer *i;
{
  read_text_integer(parser, w, i);
}  /* read_parser_integer */


Static Void read_parser_level(parser, w, l)
FILE *parser;
t_integer w;
t_command_level *l;
{
  t_long_integer i;

  read_text_integer(parser, w, &i);
  *l = i;
}  /* read_parser_level */


Static Void read_parser_ln(parser)
FILE *parser;
{
  read_text_ln(parser);
}  /* read_parser_ln */


Static boolean eoln_parser(parser)
FILE *parser;
{
  return P_eoln(parser);
}  /* eoln_parser */


Static boolean eof_parser(parser)
FILE *parser;
{
  return P_eof(parser);
}  /* eof_parser */


Static boolean eolnnotf_parser(parser)
FILE *parser;
{
  if (eof_parser(parser))
    return false;
  else
    return (eoln_parser(parser));
}  /* eolnnotf_parser */


Static boolean eolnorf_parser(parser)
FILE *parser;
{
  if (eoln_parser(parser))
    return true;
  else
    return (eof_parser(parser));
}  /* eolnorf_parser */


/* Reset / rewind */

Static Void reset_(f)
FILE *f;
{
#ifndef CoCo_Cygwin
  rewind(f);
#else /* CoCo_Cygwin */
  fseek(f, 0L, SEEK_SET);
#endif /* CoCo_Cygwin */
}


Static Void reset_level_file(f)
FILE *f;
{
#ifndef CoCo_Cygwin
  rewind(f);
#else /* CoCo_Cygwin */
  reset_(f);
#endif /* CoCo_Cygwin */
}  /* reset_level_file */


Static Void reset_integer_file(f)
FILE *f;
{
#ifndef CoCo_Cygwin
  rewind(f);
#else /* CoCo_Cygwin */
  reset_(f);
#endif /* CoCo_Cygwin */
}  /* reset_integer_file */


Static Void reset_real_file(f)
FILE *f;
{
#ifndef CoCo_Cygwin
  rewind(f);
#else /* CoCo_Cygwin */
  reset_(f);
#endif /* CoCo_Cygwin */
}  /* reset_real_file */


/* Write / putc - stdout */

#ifdef CoCo_Cygwin

Static Void print_my_c(c)
Char c;
{
  Char c_str[2];

  c_str[0] = c;
  c_str[1] = '\0';
  printf(c_str);
}  /* print_my_c */


#endif /* CoCo_Cygwin */
Static Void write_char_stdout(c)
Char c;
{
#ifndef CoCo_Cygwin
  putchar(c);
#else /* CoCo_Cygwin */

  print_my_c(c);
  /* putchar(c); */
#endif /* CoCo_Cygwin */
}  /* write_char_stdout */


Static Void write_line_stdout()
{
#ifndef CoCo_Cygwin
  putchar('\n');
#else /* CoCo_Cygwin */
#ifdef DEBUG_F
  /* F */ printf("write_line_stdout 1 \n");
#endif /* F */
  printf("\n");
  /* putchar('\n'); */
#endif /* CoCo_Cygwin */
}  /* write_line_stdout */


/* Write / putc */

Static Void write_char_text(f, c)
FILE *f;
Char c;
{
#ifdef CoCo_Cygwin
#ifdef DEBUG_F
  /* F */ printf("write_char_text [ c: `");
#endif /* F */
  if (f == stdout) {
    print_my_c(c);
  } else
#endif /* CoCo_Cygwin */
  putc(c, f);
#ifdef CoCo_Cygwin
#ifdef DEBUG_F
  /* F */ printf("' ] \n");
#endif /* F */
#endif /* CoCo_Cygwin */
}  /* write_char_text */


Static Void writeln_pch_50_text(f, c, str, w)
FILE *f;
Char c;
Char *str;
t_integer w;
{
  t_long_integer i;

#ifdef CoCo_Cygwin
  if (f == stdout) {
    print_my_c(c);
    for (i = 0; i < w; i++)
      print_my_c(str[i]);
    print_my_c('\n');
  } else {
    putc(c, f);
    for (i = 0; i < w; i++)
      putc(str[i], f);
    putc('\n', f);
  }
#else /* CoCo_Cygwin */
  putc(c, f);
  for (i = 0; i < w; i++)
    putc(str[i], f);
  putc('\n', f);
#endif /* CoCo_Cygwin */
}  /* writeln_pch_50_text */


Static Void write_space_text(f, w)
FILE *f;
t_integer w;
{
  t_long_integer i;

  for (i = 1; i <= w; i++)
#ifdef CoCo_Cygwin
    if (f == stdout)
      printf(" ");
    else
#endif /* CoCo_Cygwin */
    putc(' ', f);
}  /* write_space_text */


Static Void write_boolean_text(f, b, w)
FILE *f;
boolean b;
t_integer w;
{
  fputs(b ? " TRUE" : "FALSE", f);
}  /* write_boolean_text */


Static Void write_char_n_text(f, c, w)
FILE *f;
Char c;
t_integer w;
{
  t_long_integer i;

#ifdef CoCo_Cygwin
#ifdef DEBUG_F
  /* F */ printf("write_char_n_text [ c: `");
#endif /* F */
#endif /* CoCo_Cygwin */
  for (i = 1; i <= w; i++)
#ifdef CoCo_Cygwin
    if (f == stdout) {
      print_my_c(c);
    } else
#endif /* CoCo_Cygwin */
    putc(c, f);
#ifdef CoCo_Cygwin
#ifdef DEBUG_F
  /* F */ printf("` ]");
#endif /* F */
#endif /* CoCo_Cygwin */
}  /* write_char_n_text */


Static Void write_pch_2_text(f, c)
FILE *f;
Char *c;
{
  t_long_integer i;

  for (i = 0; i <= 1; i++)
    putc(c[i], f);
}  /* write_pch_2_text */


Static Void write_pch_10_text(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  t_long_integer i;

#ifndef CoCo_Cygwin
  for (i = 0; i < w; i++)
    putc(c[i], f);
#else /* CoCo_Cygwin */
  if (f == stdout)
    printf("%.*s", (int)w, c);  
  else
  fprintf(f, "%.*s", (int)w, c);
#endif /* CoCo_Cygwin */
}  /* write_pch_10_text */


Static Void write_pch_20_text(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  t_long_integer i;

#ifndef CoCo_Cygwin
  for (i = 0; i < w; i++)
    putc(c[i], f);
#else /* CoCo_Cygwin */
  if (f == stdout)
    printf("%.*s", (int)w, c);  
  else
  fprintf(f, "%.*s", (int)w, c);
#endif /* CoCo_Cygwin */
}  /* write_pch_20_text */


Static Void write_pch_30_text(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  t_long_integer i;

#ifndef CoCo_Cygwin
  for (i = 0; i < w; i++)
    putc(c[i], f);
#else /* CoCo_Cygwin */
  if (f == stdout)
    printf("%.*s", (int)w, c);  
  else
  fprintf(f, "%.*s", (int)w, c);
#endif /* CoCo_Cygwin */
}  /* write_pch_30_text */


Static Void write_pch_40_text(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  t_long_integer i;

#ifndef CoCo_Cygwin
  for (i = 0; i < w; i++)
    putc(c[i], f);
#else /* CoCo_Cygwin */
  if (f == stdout)
    printf("%.*s", (int)w, c);  
  else
  fprintf(f, "%.*s", (int)w, c);
#endif /* CoCo_Cygwin */
}  /* write_pch_40_text */


Static Void write_pch_50_text(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  t_long_integer i;

#ifndef CoCo_Cygwin
  for (i = 0; i < w; i++)
    putc(c[i], f);
#else /* CoCo_Cygwin */
  if (f == stdout)
    printf("%.*s", (int)w, c);  
  else
  fprintf(f, "%.*s", (int)w, c);
#endif /* CoCo_Cygwin */
}  /* write_pch_50_text */


Static Void write_pch_text(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  t_long_integer i;

#ifndef CoCo_Cygwin
  for (i = 0; i < w; i++)
    putc(c[i], f);
#else /* CoCo_Cygwin */
  if (f == stdout)
    printf("%.*s", (int)w, c);  
  else
  fprintf(f, "%.*s", (int)w, c);
#endif /* CoCo_Cygwin */
}  /* write_pch_text */


Static Void write_char_w_text(f, c, w)
FILE *f;
Char c;
t_integer w;
{
#ifdef CoCo_Cygwin
  if (f == stdout)
    printf("%*c", (int)(w), c);
  else
#endif /* CoCo_Cygwin */
  fprintf(f, "%*c", (int)w, c);
}  /* write_char_w_text */


Static Void write_line_text(f)
FILE *f;
{
#ifdef CoCo_Cygwin
#ifdef DEBUG_E
  /* E */ printf("write_line_text 1 \n");
#endif /* E */
  if (f == stdout)
    printf("\n");
  else
#endif /* CoCo_Cygwin */
    putc('\n', f);
#ifdef CoCo_Cygwin
#ifdef DEBUG_E
  /* E */ printf("write_line_text 9 \n");
#endif /* E */
#endif /* CoCo_Cygwin */
}  /* write_line_text */


Static Void write_level_text(f, i, w)
FILE *f;
t_level *i;
t_integer w;
{
#ifdef CoCo_Cygwin
  t_long_integer j;
  long len;
  Char str[255];

  len = sprintf(str, "%*ld", (int)(w), (long)(*i));
  for (j = 0; j < len; j++)
    write_char_text(f, str[j]);
#else /* CoCo_Cygwin */
  fprintf(f, "%*d", (int)w, *i);
#endif /* CoCo_Cygwin */
}  /* write_level_text */


Static Void write_integer_text(f, i, w)
FILE *f;
t_long_integer i;
t_integer w;
{
#ifdef CoCo_Cygwin
  t_long_integer j;
  long len;
  Char str[255];

  len = sprintf(str, "%*ld", (int)(w), i);
  for (j = 0; j < len; j++)
    write_char_text(f, str[j]);
#else /* CoCo_Cygwin */
  fprintf(f, "%*ld", (int)w, i);
#endif /* CoCo_Cygwin */
}  /* write_integer_text */


Static Void write_offset_text(f, i, w)
FILE *f;
t_offset *i;
t_integer w;
{
#ifdef CoCo_Cygwin
  t_long_integer j;
  long len;
  Char str[255];

  len = sprintf(str, "%*ld", (int)w, *i);
  for (j = 0; j < len; j++)
    write_char_text(f, str[j]);
#else /* CoCo_Cygwin */
  fprintf(f, "%*ld", (int)w, *i);
#endif /* CoCo_Cygwin */
}  /* write_offset_text */


Static Void write_cell_count_text(f, i, w)
FILE *f;
t_cell_count *i;
t_integer w;
{
#ifdef CoCo_Cygwin
  t_long_integer j;
  long len;
  Char str[255];

  len = sprintf(str, "%*ld", (int)w, *i);
  for (j = 0; j < len; j++)
    write_char_text(f, str[j]);
#else /* CoCo_Cygwin */
  fprintf(f, "%*ld", (int)w, *i);
#endif /* CoCo_Cygwin */
}  /* write_cell_count_text */


Static Void write_cell_index_text(f, i, w)
FILE *f;
t_cell_index *i;
t_integer *w;
{
#ifdef CoCo_Cygwin
  t_long_integer j;
  long len;
  Char str[255];

  len = sprintf(str, "%*ld", (int)(*w), *i);
  for (j = 0; j < len; j++)
    write_char_text(f, str[j]);
#else /* CoCo_Cygwin */
  fprintf(f, "%*ld", (int)(*w), *i);
#endif /* CoCo_Cygwin */
}  /* write_cell_index_text */


Static Void write_e_cell_index_text(f, i, w)
FILE *f;
t_e_cell_index *i;
t_integer w;
{
#ifdef CoCo_Cygwin
  t_long_integer j;
  long len;
  Char str[255];

  len = sprintf(str, "%*ld", (int)w, *i);
  for (j = 0; j < len; j++)
    write_char_text(f, str[j]);
#else /* CoCo_Cygwin */
  fprintf(f, "%*ld", (int)w, *i);
#endif /* CoCo_Cygwin */
}  /* write_e_cell_index_text */


Static Void write_short_real_text(f, x, v, w)
FILE *f;
t_real *x;
t_integer v, w;
{
  long len;
  Char str[255];
#ifdef CoCo_Cygwin
  t_long_integer j;

  /*
  printf("write_short_text 1 \n");
  printf("\n");
  */

#ifdef DEBUG_E
  write_char_text(f, '/');
  write_integer_text(f, v, 2);
  write_char_text(f, ',');
  write_integer_text(f, w, 2);
  write_char_text(f, '/');
#endif /* E */

  if (w == 0) {
    len = sprintf(str, "% .*e", P_max((int)v - 7, 1), *x);
    if (len == v + 1)
      len = sprintf(str, "% .*e", P_max((int)v - 8, 1), *x);
  } else
    len = sprintf(str, "%*.*f", (int)v, (int)w, *x);
  for (j = 0; j < len; j++)
    write_char_text(f, str[j]);

#else /* CoCo_Cygwin */
  if (w == 0) {
    len = sprintf(str, "% .*e", P_max((int)v - 7, 1), *x);
    if (len == v + 1)
      fprintf(f, "% .*E", P_max((int)v - 8, 1), *x);
    else
      fprintf(f, "% .*E", P_max((int)v - 7, 1), *x);
  } else
    fprintf(f, "%*.*f", (int)v, (int)w, *x);
#endif /* CoCo_Cygwin */
}  /* write_short_real_text */


Static Void write_invalid(f, width)
FILE *f;
t_long_integer width;
{
  write_space_text(f, labs(width) - 1);
  write_char_text(f, '-');
}  /* write_invalid */


Static Void write_real_text_fix_float(f, x, v, w, flt)
FILE *f;
t_long_real *x;
t_integer v, w;
boolean flt;
{
  long len;
  Char str[255];
#ifdef CoCo_Cygwin
  t_long_integer j;

  /*
  printf("write_real_text 1 \n");
  printf("\n");
  */

#ifdef DEBUG_E
  write_char_text(f, '/');
  write_integer_text(f, v, 2);
  write_char_text(f, ',');
  write_integer_text(f, w, 2);
  write_char_text(f, '/');
#endif /* E */

  if (is_infinity_real(*x)) {
    write_invalid(f, v);
    return;
  }
  if (w == 0) {
    len = sprintf(str, "% .*e", P_max((int)v - 7, 1), *x);
    if (len == v + 1)
      len = sprintf(str, "% .*e", P_max((int)v - 8, 1), *x);
  } else
    len = sprintf(str, "%*.*f", (int)v, (int)w, *x);
  for (j = 0; j < len; j++)
    write_char_text(f, str[j]);
#else /* CoCo_Cygwin */
  if (is_infinity_real(*x)) {
    write_invalid(f, v);
    return;
  }
  if ((log(fabs(*x)) / log(10.0) > v - w - 2 || w == 0) && flt) { /* abs */
    len = sprintf(str, "% .*e", P_max((int)v - 7, 1), *x);
    if (len == v + 1)
      fprintf(f, "% .*E", P_max((int)v - 8, 1), *x);
    else
      fprintf(f, "% .*E", P_max((int)v - 7, 1), *x);
  } else
    fprintf(f, "%*.*f", (int)v, (int)w, *x);
#endif /* CoCo_Cygwin */
}  /* write_real_text */


Static Void write_real_text(f, x, v, w)
FILE *f;
t_long_real x;
t_integer v, w;
{
  if (v < 0)
    write_real_text_fix_float(f, &x, -v, w, false);
  else
    write_real_text_fix_float(f, &x, v, w, true);
}  /* write_real_text */


Static Void write_time_text(f, c, u, now_clock, start_clock, v, w)
FILE *f;
Char *c;
t_integer u;
t_long_real now_clock, start_clock;
t_integer v, w;
{
  write_pch_10_text(f, c, u);
  write_real_text(f, (now_clock - start_clock) / 1000, v, w);
  write_pch_10_text(f, "s.", 2L);
}  /* write_time_text */


Static Void write_valid_real_text(f, invalid, x, v, w)
FILE *f;
boolean invalid;
t_long_real *x;
t_integer v, w;
{
  if (invalid)
    write_invalid(f, v);
  else
    write_real_text(f, *x, v, w);
}  /* write_real_text */


/* Local variables for write_level_file: */
struct LOC_write_level_file {
  t_level l;
} ;


/* Write / fwrite */

Static Void write_level_file(f, l_)
FILE *f;
t_level l_;
{
  struct LOC_write_level_file Local_Var;

  Local_Var.l = l_;
#ifndef NO_LEVEL_FILE
  /* LEVEL_FILE is used for DATASTRUCTURE 'list_file' and 'both' */
  fwrite(&Local_Var.l, sizeof(t_level), 1, f);
#endif /* NO_LEVEL_FILE */
}  /* write_level_file */


Static Void write_integer_file(f, i)
FILE *f;
t_long_integer i;
{
#ifdef CoCo_Cygwin
  printf("write_integer_file 1 \n");
  printf("\n");
#endif /* CoCo_Cygwin */
#ifndef NO_INT_FILE
  /* INTEGER_FILE is used for FIND_LOG_L_FILE from FIND_LOG_L_LARGE */
  fwrite(&i, sizeof(long), 1, f);
#endif /* NO_INT_FILE */
}  /* write_integer_file */


Static Void write_integer_list(f, p)
FILE *f;
t_integer_list *p;
{
#ifndef NO_INT_FILE
  while (p != NULL) {
    fwrite(&p->x, sizeof(long), 1, f);
    p = p->pointer;
  }
#endif /* NO_INT_FILE */
}  /* write_integer_list */


Static Void write_real_file(f, x)
FILE *f;
t_long_real x;
{
#ifdef CoCo_Cygwin
  printf("write_real_file 1 \n");
  printf("\n");
#endif /* CoCo_Cygwin */
#ifndef NO_REAL_FILE
  /* REAL_FILE is used for DESCRIBE */
  fwrite(&x, sizeof(double), 1, f);
#endif /* NO_REAL_FILE */
}  /* write_real_file */


Static Void write_dump_char(c)
Char c;
{
  putc(c, dump_file);
}  /* write_dump_char */


Static Void write_dump_pch10(c, w)
Char *c;
t_long_integer w;
{
  t_long_integer i;

  for (i = 0; i < w; i++)
    putc(c[i], dump_file);
}  /* write_dump_pch10 */


Static Void write_dump_pch20(c, w)
Char *c;
t_long_integer w;
{
  t_long_integer i;

  for (i = 0; i < w; i++)
    putc(c[i], dump_file);
}  /* write_dump_pch20 */


Static Void write_line_dump()
{
  write_line_text(dump_file);
}  /* write_line_dump */


Static Void write_dump_real(x, width, decdiff)
t_long_real x;
t_long_integer width, decdiff;
{
  if (is_invalid_real(x))
    fprintf(dump_file, "%*c-", (int)(labs(width) - 1), ' ');
  else
    fprintf(dump_file, "%*.*f", (int)labs(width), (int)decdiff, x);
}  /* write_dump_real */


Static Void write_dump_integer(c, width)
t_long_integer c, width;
{
  if (c == _INVALID)
    fprintf(dump_file, "%*c-", (int)(labs(width) - 1), ' ');
  else
    fprintf(dump_file, "%*ld", (int)labs(width), c);
}  /* write_dump_integer */


Static Void write_dump_cond_real(ok, x, width, decdiff)
boolean ok;
t_long_real x;
t_long_integer width, decdiff;
{
  if ((!ok) | is_invalid_real(x))
    write_invalid(dump_file, width);
  else
    write_real_text(dump_file, x, labs(width), decdiff);
}  /* write_dump_cond_real */


Static Void write_dump_cond_integer(ok, c, width)
boolean ok;
t_long_integer c, width;
{
  if (!ok || c == _INVALID)
    write_invalid(dump_file, width);
  else
    write_integer_text(dump_file, c, labs(width));
}  /* write_dump_cond_integer */


/* Read / fread */

Static Void read_level_file(f, l)
FILE *f;
t_level *l;
{
#ifndef NO_LEVEL_FILE
  if (fread(l, sizeof(t_level), 1, f) != 1)
    _EscIO(EndOfFile);
#endif /*  NO_LEVEL_FILE */
}  /* read_level_file */


Static boolean eof_level_file(f)
FILE *f;
{
  return P_eof(f);
}  /* eof_level_file */


Static Void read_integer_file(f, i)
FILE *f;
t_long_integer *i;
{
#ifndef NO_INT_FILE
  if (fread(i, sizeof(long), 1, f) != 1)
    _EscIO(EndOfFile);
#endif /* NO_INT_FILE */
}  /* read_integer_file */


Static boolean eof_integer_file(f)
FILE *f;
{
  return P_eof(f);
}  /* eof_integer_file */


Static Void read_integer_list(f, p)
FILE *f;
t_integer_list *p;
{
#ifndef NO_INT_FILE
  while (p != NULL) {
    if (fread(&p->x, sizeof(long), 1, f) != 1)
      _EscIO(EndOfFile);
    p = p->pointer;
  }
#endif /* NO_INT_FILE */
}  /* read_integer_list */


Static Void read_real_file(f, x)
FILE *f;
t_long_real *x;
{
#ifndef NO_REAL_FILE
  if (fread(x, sizeof(double), 1, f) != 1)
    _EscIO(EndOfFile);
#endif /* NO_REAL_FILE */
}  /* read_real_file */


Static boolean eof_real_file(f)
FILE *f;
{
  return P_eof(f);
}  /* eof_real_file */


/* Rewrite */

Static Void rewrite_(f)
FILE *f;
{
  if (f != NULL)
#ifndef CoCo_Cygwin
    rewind(f);
#else /* CoCo_Cygwin */
    fseek(f, 0L, SEEK_SET);
#endif /* CoCo_Cygwin */
  else
    f = tmpfile();
  if (f == NULL)
    _EscIO(FileNotFound);
}


Static Void rewrite_file(f)
FILE *f;
{
  rewrite_(f);
}


Static Void rewrite_cell_file(f)
FILE *f;
{
  if (f != NULL)
#ifndef CoCo_Cygwin
    rewind(f);
#else /* CoCo_Cygwin */
    rewrite_(f);
#endif /* CoCo_Cygwin */
  else
    f = tmpfile();
  if (f == NULL)
    _EscIO(FileNotFound);
}


Static Void rewrite_level_file(f)
FILE *f;
{
  if (f != NULL)
#ifndef CoCo_Cygwin
    rewind(f);
#else /* CoCo_Cygwin */
    rewrite_(f);
#endif /* CoCo_Cygwin */
  else
    f = tmpfile();
  if (f == NULL)
    _EscIO(FileNotFound);
}


Static Void rewrite_integer_file(f)
FILE *f;
{
  if (f != NULL)
#ifndef CoCo_Cygwin
    rewind(f);
#else /* CoCo_Cygwin */
    rewrite_(f);
#endif /* CoCo_Cygwin */
  else
    f = tmpfile();
  if (f == NULL)
    _EscIO(FileNotFound);
}


Static Void rewrite_real_file(f)
FILE *f;
{
  if (f != NULL)
#ifndef CoCo_Cygwin
    rewind(f);
#else /* CoCo_Cygwin */
    rewrite_(f);
#endif /* CoCo_Cygwin */
  else
    f = tmpfile();
  if (f == NULL)
    _EscIO(FileNotFound);
}


Static Void rewrite_text_file(f)
FILE *f;
{
  if (f != NULL)
#ifndef CoCo_Cygwin
    rewind(f);
#else /* CoCo_Cygwin */
    rewrite_(f);
#endif /* CoCo_Cygwin */
  else
    f = tmpfile();
  if (f == NULL)
    _EscIO(FileNotFound);
}


/*@+"assign.p"*/
/*@-"assignunix.c"*/





   #include "assign.c"
 

/* #  ifdef CC-minus     




Static t_long_integer random_init()
{
  return my_clock()/1;
}


Static Void monitor_note_exact(txt, w, a, b, c)
Char *txt;
t_long_integer w, a, b, c;
{
}


Static Void my_strchr(s, c, i, length)
Char *s;
Char c;
t_integer *i, length;
{
  while (s[*i - PCH_START] != '\0' && s[*i - PCH_START] != c && *i < length)
    (*i)++;
  printf("My_strchr: ");
  printf("%.*s", (int)(PCH_END - PCH_START + 1), s);
  putchar('|');
  putchar(c);
  putchar('|');
  printf("%4ld", *i);
  printf("%4ld\n", length);
}


Static Void my_strdhr(s, c1, c2, i, length)
Char *s;
Char c1, c2;
t_integer *i, length;
{
  while (s[*i - PCH_START] != '\0' && s[*i - PCH_START] != c1 &&
	 s[*i - PCH_START] != c2 && *i < length)
    (*i)++;
  printf("My_strdhr: ");
  printf("%.*s", (int)(PCH_END - PCH_START + 1), s);
  putchar('|');
  putchar(c1);
  putchar('|');
  putchar(c2);
  putchar('|');
  printf("%4ld", *i);
  printf("%4ld\n", length);
}


Static Void my_strcat(dst, src, c, i, j, length)
Char *dst, *src;
Char c;
t_integer *i, *j, length;
{
  while (src[*j - PCH_START] != '\0' && src[*j - PCH_START] != c &&
	 *i + *j <= length) {
    dst[*i - PCH_START + *j - PCH_START] = src[*j - PCH_START];
    (*j)++;
  }
  dst[*i - PCH_START + *j - PCH_START] = '\0';
  printf("My_strcat: ");
  printf("%.*s", (int)(PCH_END - PCH_START + 1), dst);
  putchar('|');
  printf("%.*s", (int)(PCH_END - PCH_START + 1), src);
  putchar('|');
  printf("%4ld", *i);
  printf("%4ld", *j);
  printf("%4ld\n", length);
}


Static Void my_strncp(dst, src, c, i, j, n, length)
Char *dst, *src;
Char c;
t_integer *i, *j, *n, length;
{
  t_integer j_start;

  j_start = *j;
  while (src[*j - PCH_START] != '\0' && src[*j - PCH_START] != c &&
	 *j - j_start < *n && *j < length) {
    dst[*i - PCH_START] = src[*j - PCH_START];
    (*j)++;
    (*i)++;
  }
  dst[*j - PCH_START] = '\0';
  printf("My_strncp: ");
  printf("%.*s", (int)(PCH_END - PCH_START + 1), dst);
  putchar('|');
  printf("%.*s", (int)(PCH_END - PCH_START + 1), src);
  putchar('|');
  putchar(c);
  putchar('|');
  printf("%4ld", *i);
  printf("%4ld", *n);
  printf("%4ld\n", length);
}


Static Void my_strcct(dst, c, i, length)
Char *dst;
Char c;
t_integer *i, length;
{
  dst[*i - PCH_START] = c;
  (*i)++;
  dst[*i - PCH_START] = '\0';
  printf("My_strcct: ");
  printf("%.*s", (int)(PCH_END - PCH_START + 1), dst);
  putchar('|');
  putchar(c);
  putchar('|');
  printf("%4ld", *i);
  printf("%4ld\n", length);
}


Static Void my_strclr(dst, c, i, length)
Char *dst;
Char c;
t_integer i, length;
{
  while (i <= length) {
    dst[i - PCH_START] = c;
    i++;
  }
  if (false)
    dst[i - PCH_START - 1] = '\0';
  printf("My_strcct: ");
  printf("%.*s", (int)(PCH_END - PCH_START + 1), dst);
  putchar('|');
  putchar(c);
  putchar('|');
  printf("%4ld", i);
  printf("%4ld\n", length);
}


extern Void getenv_cocolib PP((Const long lb, Const long ub, Char *dir));

extern Void getenv_tmp PP((Const long lb, Const long ub, Char *dir));

extern Void ok_to_reset_file PP((Const long lb, Const long ub, Char *name,
				 boolean *ok));


Static Void get_cocolib(name, ok)
Char *name;
boolean *ok;
{
  Char *dir;
  t_integer i = 1;

  if (link_coco_lib != NULL)
    dir = link_coco_lib;
  else {
    getenv_cocolib((long)PCH_START, (long)PCH_END, dir);
    link_coco_lib = (Char *)Malloc(sizeof(pch_long));
    if (link_coco_lib == NULL)
      _OutMem();
    memcpy(link_coco_lib, dir, sizeof(pch_long));
  }
  *ok = true;
  my_strchr(dir, ' ', &i, (long)FILE_NAME_LENGTH);
  if (dir[i - PCH_START - 1] != '\\' && dir[i - PCH_START - 1] != '/' &&
      i < FILE_NAME_LENGTH)
    my_strcct(dir, '/', &i, (long)FILE_NAME_LENGTH);
  my_strclr(dir, ' ', i, (long)FILE_NAME_LENGTH);
  memcpy(name, dir, sizeof(pch_long));
}


Static Void get_cocotmp(name, ok)
Char *name;
boolean *ok;
{
  Char *dir;
  t_integer i = 1;

  if (link_coco_tmp != NULL)
    memcpy(name, link_coco_tmp, sizeof(pch_long));
  else {
    getenv_tmp((long)PCH_START, (long)PCH_END, dir);
    link_coco_tmp = (Char *)Malloc(sizeof(pch_long));
    if (link_coco_tmp == NULL)
      _OutMem();
    memcpy(link_coco_tmp, dir, sizeof(pch_long));
  }
  *ok = true;
  my_strchr(dir, ' ', &i, (long)FILE_NAME_LENGTH);
  if (dir[i - PCH_START - 1] != '\\' && dir[i - PCH_START - 1] != '/' &&
      i < FILE_NAME_LENGTH)
    my_strcct(dir, '/', &i, (long)FILE_NAME_LENGTH);
  my_strclr(dir, ' ', i, (long)FILE_NAME_LENGTH);
  memcpy(name, dir, sizeof(pch_long));
}


Static Void assign_read(f, name_, ok)
FILE **f;
Char *name_;
boolean *ok;
{
  pch_long name;
  Char STR1[256];

  memcpy(name, name_, sizeof(pch_long));
  *ok = true;
  ok_to_reset_file((long)PCH_START, (long)PCH_END, name, ok);
  if (!*ok)
    return;
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "r", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "r");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void assign_binary_read(f, name_, ok)
FILE **f;
Char *name_;
boolean *ok;
{
  pch_long name;
  Char STR1[256];

  memcpy(name, name_, sizeof(pch_long));
  *ok = true;
  ok_to_reset_file((long)PCH_START, (long)PCH_END, name, ok);
  if (!*ok)
    return;
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "r", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "r");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void assign_read_cocolib(f, name, ok)
FILE **f;
Char *name;
boolean *ok;
{
  pch_long dir;
  t_integer i = 1, j = 1;

  get_cocolib(dir, ok);
  if (!*ok)
    return;
  my_strchr(dir, ' ', &i, (long)FILE_NAME_LENGTH);
  if (dir[i - PCH_START - 1] != '\\' && dir[i - PCH_START - 1] != '/' &&
      i < FILE_NAME_LENGTH)
    my_strcct(dir, '/', &i, (long)FILE_NAME_LENGTH);
  my_strcat(dir, name, ' ', &i, &j, (long)FILE_NAME_LENGTH);
  my_strclr(dir, ' ', i + j, (long)FILE_NAME_LENGTH);
  memcpy(name, dir, sizeof(pch_long));
  assign_read(f, name, ok);
}


Static Void assign_write(f, name, ok)
FILE **f;
Char *name;
boolean *ok;
{
  Char STR1[256];

  *ok = true;
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "w", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "w");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void assign_binary_write(f, name, ok)
FILE **f;
Char *name;
boolean *ok;
{
  Char STR1[256];

  *ok = true;
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "w", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "w");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void flush_file(f)
FILE **f;
{
  fflush(*f);
  P_ioresult = 0;
}








Static Void close_file(dummy_f)
FILE *dummy_f;
{
}


Static Void close_level_file(dummy_f)
FILE *dummy_f;
{
}








extern Void mktemp PP((Const long lb, Const long ub, Char *cmd));

extern Void unlink PP((Const long lb, Const long ub, Char *cmd));





Static Void get_tmp_name(ok, name, tmp_count)
boolean *ok;
Char *name;
t_long_integer *tmp_count;
{
  pch_long dir;
  t_integer i = 1, j = 1;
  Char c;

  get_cocotmp(dir, ok);
  if (!*ok)
    return;
  my_strchr(dir, ' ', &i, (long)FILE_NAME_LENGTH);
  if (dir[i - PCH_START - 1] != '\\' && dir[i - PCH_START - 1] != '/' &&
      i < FILE_NAME_LENGTH)
    my_strcct(dir, '/', &i, (long)FILE_NAME_LENGTH);
  my_strcat(dir, name, ' ', &i, &j, (long)FILE_NAME_LENGTH);
  my_strclr(dir, ' ', i + j, (long)FILE_NAME_LENGTH);
  memcpy(name, dir, sizeof(pch_long));
  (*tmp_count)++;
  i = 1;
  my_strdhr(name, ' ', 'Y', &i, (long)FILE_NAME_LENGTH);
  c = (Char)(labs(*tmp_count) / 100 + '0');
  my_strcct(name, c, &i, (long)FILE_NAME_LENGTH);
  c = (Char)(labs(*tmp_count) % 100 / 10 + '0');
  my_strcct(name, c, &i, (long)FILE_NAME_LENGTH);
  c = (Char)(labs(*tmp_count) % 10 + '0');
  my_strcct(name, c, &i, (long)FILE_NAME_LENGTH);
  my_strchr(name, ' ', &i, (long)FILE_NAME_LENGTH);
  my_strcct(name, '\0', &i, (long)FILE_NAME_LENGTH);
  mktemp((long)PCH_START, (long)PCH_END, name);
}


Static Void assign_tmp_write(f, name, tmp_count, ok)
FILE **f;
Char *name;
t_long_integer *tmp_count;
boolean *ok;
{
  Char STR1[256];

  get_tmp_name(ok, name, tmp_count);
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "w", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "w");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void unlink_tmp_file(f, name, file_set)
FILE **f;
Char *name;
boolean file_set;
{
  flush_file(f);
  if (!file_set)
    unlink((long)PCH_START, (long)PCH_END, name);
}


Static Void assign_tmp_cell_write(f, name, tmp_count)
FILE **f;
Char *name;
t_long_integer *tmp_count;
{
  boolean ok;
  Char STR1[256];

  get_tmp_name(&ok, name, tmp_count);
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "wb", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "wb");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void unlink_cell_file(f, name)
FILE **f;
Char *name;
{
  fflush(*f);
  P_ioresult = 0;
  unlink((long)PCH_START, (long)PCH_END, name);
}


Static Void reassign_tmp_cell_write(f, name)
FILE **f;
Char *name;
{
  Char STR1[256];

  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "wb", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "wb");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void assign_tmp_level_write(f, name, tmp_count)
FILE **f;
Char *name;
t_long_integer *tmp_count;
{
  boolean ok;
  Char STR1[256];

  get_tmp_name(&ok, name, tmp_count);
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "wb", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "wb");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
  unlink((long)PCH_START, (long)PCH_END, name);
}


Static Void reassign_tmp_level_file_write(f, name)
FILE **f;
Char *name;
{
  Char STR1[256];

  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "wb", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "wb");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void assign_integer_file_write(f, name, tmp_count)
FILE **f;
Char *name;
t_long_integer *tmp_count;
{
  boolean ok;
  Char STR1[256];

  get_tmp_name(&ok, name, tmp_count);
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "wb", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "wb");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void unlink_integer_file(f, name)
FILE **f;
Char *name;
{
  fflush(*f);
  P_ioresult = 0;
  unlink((long)PCH_START, (long)PCH_END, name);
}


Static Void reassign_integer_file_write(f, name)
FILE **f;
Char *name;
{
  Char STR1[256];

  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "wb", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "wb");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void assign_real_file_write(f, name, tmp_count)
FILE **f;
Char *name;
t_long_integer *tmp_count;
{
  boolean ok;
  Char STR1[256];

  get_tmp_name(&ok, name, tmp_count);
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "wb", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "wb");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}


Static Void assign_tmp_real_write(f, name, tmp_count)
FILE **f;
Char *name;
t_long_integer *tmp_count;
{
  boolean ok;
  Char STR1[256];

  get_tmp_name(&ok, name, tmp_count);
  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "wb", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "wb");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
  unlink((long)PCH_START, (long)PCH_END, name);
}


Static Void unlink_real_file(f, name)
FILE **f;
Char *name;
{
  fflush(*f);
  P_ioresult = 0;
  unlink((long)PCH_START, (long)PCH_END, name);
}


Static Void reassign_real_file_write(f, name)
FILE **f;
Char *name;
{
  Char STR1[256];

  if (*f != NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = freopen(STR1, "wb", *f);
  } else {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    *f = fopen(STR1, "wb");
  }
  if (*f == NULL) {
    sprintf(STR1, "%.*s", PCH_END - PCH_START + 1, name);
    _EscIO2(FileNotFound, STR1);
  }
}








Static long inter_1(i)
long i;
{
  interrupt_1 = true;
  if (my_clock()/1 - last_interrupt_time_1 < DELTA_INTERRUPT)
    interrupt_2 = true;
  interrupt_count++;
  printf("Interrupt (1):  %2ld%2ld%10ld\n",
	 interrupt_count, i, my_clock()/1 - last_interrupt_time_1);
  fprintf(log_file, "# Interrupt (1):  %2ld%2ld%10ld\n",
	  interrupt_count, i, my_clock()/1 - last_interrupt_time_1);
  last_interrupt_time_1 = my_clock()/1;
  return 0;
}


Static long inter_2(i)
long i;
{
  interrupt_1 = true;
  interrupt_2 = true;
  if (my_clock()/1 - last_interrupt_time_2 < DELTA_INTERRUPT)
    interrupt_3 = true;
  interrupt_count++;
  printf("Interrupt (2):  %2ld%2ld%10ld\n",
	 interrupt_count, i, my_clock()/1 - last_interrupt_time_2);
  fprintf(log_file, "# Interrupt (2):  %2ld%2ld%10ld\n",
	  interrupt_count, i, my_clock()/1 - last_interrupt_time_2);
  last_interrupt_time_2 = my_clock()/1;
  return 0;
}



extern Void signal PP((long sig, _PROCEDURE inter));


Static Void set_interrupt()
{
  _PROCEDURE TEMP;

  interrupt_count = 0;
  interrupt_1 = false;
  interrupt_2 = false;
  interrupt_3 = false;
  last_interrupt_time_1 = my_clock()/1;
  last_interrupt_time_2 = my_clock()/1;
  TEMP.proc = (Anyptr)inter_1;
  TEMP.link = (Anyptr)NULL;
  signal(2L, TEMP);
  TEMP.proc = (Anyptr)inter_2;
  TEMP.link = (Anyptr)NULL;
  signal(3L, TEMP);
}


#define sigint          2
#define sigquit         3


Static Void set_interrupt_on_off(code)
long code;
{
}

#undef sigint
#undef sigquit





     #  endif CC-minus */

/* #  ifdef Multiple-Objects-plus


procedure coco;

 var

  #  endif Multiple-Objects-plus */





/*@-"assigntail.c"*/


Static Void dummy_dummy(dummy_f)
FILE **dummy_f;
{
}




Static boolean RESIZE_N(n, size, max_cell_number)
t_cell_count *n;
t_long_integer size, *max_cell_number;
{

  /*$ifdef On-DOS
function resize_n(var n      : t_n;
                        size      : t_long_integer;
                    var max_cell_number : t_long_integer): boolean;
   $endif On-DOS*/
  return (size <= *max_cell_number);
}


Static boolean RESIZE_P(p, size, max_cell_number)
float *p;
t_long_integer size, *max_cell_number;
{

  /*$ifdef On-DOS
function resize_p(var p      : t_p;
                        size      : t_long_integer;
                    var max_cell_number : t_long_integer): boolean;
   $endif On-DOS*/
  return (size <= *max_cell_number);
}


Static boolean RESIZE_Q(q, size, max_cell_number)
long *q;
t_long_integer size, *max_cell_number;
{

  /*$ifdef On-DOS
function resize_q(var q      : t_q;
                        size      : t_long_integer;
                    var max_cell_number : t_long_integer): boolean;
   $endif On-DOS*/
  return (size <= *max_cell_number);
}


Static boolean MALLOC_N(n, size, max_cell_number)
t_cell_count *n;
t_long_integer size, *max_cell_number;
{

  /*$ifdef On-DOS
function malloc_n(var n      : t_n;
                        size      : t_long_integer;
                    var max_cell_number : t_long_integer): boolean;
   $endif On-DOS*/
  return (size <= *max_cell_number);
}


Static boolean MALLOC_P(p, size, max_cell_number)
float *p;
t_long_integer size, *max_cell_number;
{

  /*$ifdef On-DOS
function malloc_p(var p      : t_p;
                        size      : t_long_integer;
                    var max_cell_number : t_long_integer): boolean;
   $endif On-DOS*/
  return (size <= *max_cell_number);
}


Static boolean MALLOC_Q(q, size, max_cell_number)
long *q;
t_long_integer size, *max_cell_number;
{

  /*$ifdef On-DOS
function malloc_q(var q      : t_q;
                        size      : t_long_integer;
                    var max_cell_number : t_long_integer): boolean;
   $endif On-DOS*/
  return (size <= *max_cell_number);
}


Static boolean RESIZE_R(r, increment, current, max_cell_number)
double **r;
t_long_integer increment, current, *max_cell_number;
{

  /*$ifdef On-DOS
function resize_r(var r : t_r_p;
                        increment, current : t_long_integer;
                    var max_cell_number : t_long_integer): boolean;
   $endif On-DOS*/
  return (increment + current <= *max_cell_number);
}


Static boolean RESIZE_S(s, increment, current, max_cell_number)
double **s;
t_long_integer increment, current, *max_cell_number;
{

  /*$ifdef On-DOS
function resize_s(var s : t_s_p;
                        increment, current : t_long_integer;
                    var max_cell_number : t_long_integer): boolean;
   $endif On-DOS*/
  return (increment + current <= *max_cell_number);
}


Static boolean RESIZE_Ss(ss, increment, current, max_cell_number)
double **ss;
t_long_integer increment, current, *max_cell_number;
{

  /*$ifdef On-DOS
function resize_ss(var ss  : t_ss_p;
                         increment, current : t_long_integer;
                     var max_cell_number  : t_long_integer): boolean;
   $endif On-DOS*/
  return (increment + current <= *max_cell_number);
}


Static boolean RESIZE_T(t, increment, current, max_cell_number)
double **t;
t_long_integer increment, current, *max_cell_number;
{

  /*$ifdef On-DOS
function resize_t(var t : t_t_p;
                        increment, current : t_long_integer;
                     var max_cell_number : t_long_integer): boolean;
   $endif On-DOS*/
  return (increment + current <= *max_cell_number);
}


Static Void MALLOC_SS_ARRAY(size, ss_list)
t_long_integer size;
t_ss_list **ss_list;
{
  t_ss_list *p;

  p = (t_ss_list *)Malloc(sizeof(t_ss_list));
  if (p == NULL)
    _OutMem();
  p->ss = (t_ss_r *)Malloc(sizeof(t_ss_r));
  if (p->ss == NULL)
    _OutMem();
  p->ss->z = (double *)Malloc(sizeof(t_ss_array));
  if (p->ss->z == NULL)
    _OutMem();
  p->fssa = SS_START - FIRST_INDEX;
  p->top = 0;
  p->pointer = *ss_list;
  *ss_list = p;
}  /* malloc_ss_array */


Static Void MALLOC_S_ARRAY(size, s_list)
t_long_integer size;
t_s_list **s_list;
{
  t_s_list *p;

  p = (t_s_list *)Malloc(sizeof(t_s_list));
  if (p == NULL)
    _OutMem();
  p->s = (t_s_r *)Malloc(sizeof(t_s_r));
  if (p->s == NULL)
    _OutMem();
  p->s->z = (double *)Malloc(sizeof(t_s_array));
  if (p->s->z == NULL)
    _OutMem();
  p->fsa = S_START - FIRST_INDEX;
  p->top = 0;
  p->pointer = *s_list;
  *s_list = p;
}  /* malloc_s_array */


Static Void MALLOC_R_ARRAY(size, r_list)
t_long_integer size;
t_r_list **r_list;
{
  t_r_list *p;

  p = (t_r_list *)Malloc(sizeof(t_r_list));
  if (p == NULL)
    _OutMem();
  p->r = (t_r_r *)Malloc(sizeof(t_r_r));
  if (p->r == NULL)
    _OutMem();
  p->r->z = (double *)Malloc(sizeof(t_r_array));
  if (p->r->z == NULL)
    _OutMem();
  p->fra = R_START - FIRST_INDEX;
  p->top = 0;
  p->pointer = *r_list;
  *r_list = p;
}  /* malloc_r_array */


Static Void MALLOC_T_ARRAY(size, t_list)
t_long_integer size;
t_t_list **t_list;
{
  t_t_list *p;

  p = (t_t_list *)Malloc(sizeof(t_t_list));
  if (p == NULL)
    _OutMem();
  p->t = (t_t_r *)Malloc(sizeof(t_t_r));
  if (p->t == NULL)
    _OutMem();
  p->t->z = (double *)Malloc(sizeof(t_t_array));
  if (p->t->z == NULL)
    _OutMem();
  p->fta = T_START - FIRST_INDEX;
  p->top = 0;
  p->pointer = *t_list;
  *t_list = p;
}  /* malloc_t_array */


/*@-"write.c"*/
/*@-"fisher.p"*/

/*

  223:    +++  ++
  224:    +++  ++
  225:    ---  -- p/fisher.p          3      15     153 p/fisher.p
  226: |   33:    function ffisher
  227: |   95:    function student
  228: |  101:    function deviance_to_f_value
  229:    +++  ++
  230:    +++  ++

*/


/*
  fisher.c - compute the two-tailed probability of correct rejection of the null
  hypothesis with an F-ratio of x, for m degrees of freedom in the numerator and
  n degrees of freedom in the denominator.  In the special case of only two
  populations, this is equivalent to Student's t-test with m=1 and x=t**2.
  Coded by Matthew Belmonte <mkb4@Cornell.edu>, 28 September 1995.  This
  implementation Copyright (c) 1995 by Matthew Belmonte.  Permission for use and
  distribution is hereby granted, subject to the restrictions that this
  copyright notice and reference list be included in its entirety, and that any
  and all changes made to the program be clearly noted in the program text.

 C code transformed into Pascal code by Jens Henrik Badsberg, 20. November 1999.

  This software is provided 'as is', with no warranty, express or implied,
  including but not limited to warranties of merchantability or fitness for a
  particular purpose.  The user of this software assumes liability for any and
  all damages, whether direct or consequential, arising from its use.  The
  author of this implementation will not be liable for any such damages.

  References:

  Egon Dorrer, "Algorithm 322: F-Distribution [S14]", Communications of the
  Association for Computing Machinery 11:2:116-117 (1968).

  J.B.F. Field, "Certification of Algorithm 322 [S14] F-Distribution",
  Communications of the Association for Computing Machinery 12:1:39 (1969).

  Hubert Tolman, "Remark on Algorithm 322 [S14] F-Distribution", Communications
  of the Association for Computing Machinery 14:2:117 (1971).

 */

Static t_long_real ffisher(m, n, x)
t_long_integer m, n;
t_long_real x;
{
  t_long_integer a, b, i, j;
  t_long_real w, y, z, zk, d, p;

  if (x <= 0)
    return 0.0;
  else {   /* Take care !!! */
    a = m / 2 * 2 - m + 2;   /* Take care !!! */
    b = n / 2 * 2 - n + 2;
    w = x * m / n;
    z = 1.0 / (1.0 + w);
    if (a == 1) {
      if (b == 1) {
	p = sqrt(w);
	y = 0.3183098862;
	d = y * z / p;
	p = 2.0 * y * atan(p);   /* arctg */
      } else {
	p = sqrt(w * z);
	d = 0.5 * p * z / w;
      }
    } else if (b == 1) {
      p = sqrt(z);
      d = 0.5 * z * p;
      p = 1.0 - p;
    } else {
      d = z * z;
      p = w * z;
    }
    y = 2.0 * w / z;
    if (a == 1) {
      j = b + 2;
      while (j <= n) {
	d *= (1.0 + 1.0 / (j - 2)) * z;
	p += d * y / (j - 1);
	j += 2;
      }
    } else {
      zk = exp(log(z) * ((n - 1) / 2));   /* Take care !!! */
      d = d * zk * n / b;
      p = p * zk + w * z * (zk - 1.0) / (z - 1.0);
    }
    y = w * z;
    z = 2.0 / z;
    b = n - 2;
    i = a + 2;
    while (i <= m) {
      j = i + b;
      d = d * y * j / (i - 2);
      p -= z * d / j;
      i += 2;
    }
    if (p < 0)
      return 0.0;
    else if (p > 1)
      return 0.0;
    else
      return p;
  }
}


Static t_long_real student(df, t)
t_long_integer df;
t_long_real t;
{
  return (ffisher(1L, df, t * t));
}


Static t_long_real deviance_to_f_value(df, n_total, f_df, deviance)
t_long_integer df, n_total, f_df;
t_long_real deviance;
{
  t_long_real f;

  if (is_invalid_real(deviance) || df == 0 || n_total == 0)
    return _INVALID_REAL;
  else {
    f = exp(deviance / n_total);
    f--;
    f = f * (n_total - f_df) / df;
    return f;
  }
}


/*@+"write.p"*/


/*

  259:    +++  ++
  260:    +++  ++
  261:    ---  -- p/write.p         28     110    1182 p/write.p
  262: |    3:    procedure pause
  263: |   18:    procedure page
  264: |   29:    procedure write_line
  265: |   41:    procedure note_command_end_line
  266: |   47:    procedure write_line_diary
  267: |   61:    procedure write_new_line
  268: |   74:    procedure write_char
  269: |   85:    procedure write_space
  270: |  100:    procedure write_boolean
  271: |  111:    procedure write_integer
  272: |  135:    procedure write_real_fix_float
  273: |  187:    procedure write_real
  274: |  197:    procedure write_command_name
  275: |  210:    procedure write_pch
  276: |  226:    procedure note_command_end_pch
  277: |  234:    procedure write_pch_r
  278: |  248:    procedure write_pch
  279: |  266:    procedure note_command_end_pch
  280: |  274:    procedure write_pch
  281: |  290:    procedure note_command_end_pch
  282: |  298:    procedure write_pch
  283: |  314:    procedure write_pch
  284: |  330:    procedure write_pch_r
  285: |  340:    procedure write_pch_r
  286: |  350:    procedure write_pch_r
  287: |  360:    procedure write_pch
  288: |  380:    procedure write_pch_to_blank
  289: |  393:    procedure note_error
  290:    +++  ++
  291:    +++  ++

*/


Static Void pause_stdout(f, page)
FILE *f;
boolean page;
{
  if (!pause_output)
    return;
  if (!(eoln_stdin() && line_count > 0 &&
	(page && line_count % page_pause_length > 5 ||
	 !page && line_count % page_pause_length == 0)))
    return;
  flush_file(&f);
  write_line_text(f);
  write_pch_30_text(f, "Press ``Return'' to continue", 28L);
  write_line_text(f);
  read_stdin_ln();
}  /* pause_stdout */


Static Void page(f)
FILE *f;
{
  pause_stdout(f, true);
  line_count = 0;
  if (page_length >= MAX_PAGE_LENGTH)
    return;
  write_char_text(f, '\f');
  if (diary)
    write_char_text(diary_file, '\f');
}  /* page */


Static Void write_line(f)
FILE *f;
{
  write_line_text(f);
  if (diary)
    write_line_text(diary_file);
  pause_stdout(f, false);
  if (line_count + 1 > page_length)
    page(f);
  line_count++;
  char_count = 0;
}  /* write_line */


Static Void note_command_end_line(f)
FILE *f;
{
  if (echo_note)
    write_line(f);
}  /* note_command_end_line */


Static Void write_line_diary()
{
  if (!diary)
    return;
  write_line_text(diary_file);
  if (line_count + 1 > page_length) {
    line_count = 0;
    if (page_length < MAX_PAGE_LENGTH)
      write_char_text(diary_file, '\f');
  }
  line_count++;
  char_count = 0;
}  /* write_line_diary */


Static Void write_new_line(f)
FILE *f;
{
  if (line_length >= MAX_LINE_LENGTH)
    return;
  write_line(f);
  write_char_text(f, '/');
  write_char_text(f, '/');
  write_char_text(f, ' ');
  /* write_pch_10_text(f, '// @@@@@@@', 3); */
  if (diary)
    write_pch_10_text(diary_file, "// ", 3L);
}  /* write_new_line */


Static Void write_char(f, c)
FILE *f;
Char c;
{
  if (char_count > line_length + 9)
    write_new_line(f);
  char_count++;
  write_char_text(f, c);
  if (diary)
    write_char_text(diary_file, c);
}  /* write_char */


Static Void write_space(f, w)
FILE *f;
t_long_integer w;
{
  t_long_integer i;

  if (char_count + w > line_length)
    write_new_line(f);
  char_count += w;
  for (i = 1; i <= w; i++)
    write_char_text(f, ' ');
  if (diary) {
    for (i = 1; i <= w; i++)
      write_char_text(diary_file, ' ');
  }
}  /* write_space */


Static Void write_boolean(f, b)
FILE *f;
boolean b;
{
  if (char_count + 5 > line_length)
    write_new_line(f);
  char_count += 5;
  write_boolean_text(f, b, 5L);
  if (diary)
    write_boolean_text(diary_file, b, 5L);
}  /* write_boolean */


Static Void write_integer(f, c, w)
FILE *f;
t_long_integer c, w;
{
  if (w < 0)
    w = -w;
  if (char_count + w > line_length)
    write_new_line(f);
  char_count += w;
  if (c == _INFINITY) {
    write_char_w_text(f, '?', w);
    if (diary)
      write_char_w_text(diary_file, '?', w);
    return;
  }
  if (c == _INVALID) {
    write_char_w_text(f, '-', w);
    if (diary)
      write_char_w_text(diary_file, '-', w);
    return;
  }
  write_integer_text(f, c, w);
  if (diary)
    write_integer_text(diary_file, c, w);
}  /* write_integer */


Static Void write_real_fix_float(f, c, w, d, flt)
FILE *f;
t_long_real c;
t_long_integer w, d;
boolean flt;
{
  t_long_real log_c;
  t_long_integer ci;

  if (fabs(c) > fabs(0.9 * _INVALID_REAL)) {
    write_space(f, w - 1);
    write_char(f, '-');
    return;
  }
  if (char_count + w > line_length)
    write_new_line(f);
  char_count += w;
  if (d > 0 || TURBO_PC) {
    if (c == 0)
      log_c = 1.0;
    else
      log_c = log(fabs(c)) / log(10.0);
    if (((TURBO_PC && w > 9 || !TURBO_PC && w > 7) && log_c >= w - d - 2 ||
	 ((TURBO_PC && w > 9 || !TURBO_PC && w > 7) &&
	  log_c < 2 - d - ROUND_ERROR)) && flt) {
      write_real_text_fix_float(f, &c, w, 0L, true);
      if (diary)
	write_real_text_fix_float(diary_file, &c, w, 0L, true);
      return;
    }
    write_real_text_fix_float(f, &c, w, d, flt);
    if (diary)
      write_real_text_fix_float(diary_file, &c, w, d, flt);
    return;
  }
  if (w > 10) {
    write_space(f, w - 10);
    w = 10;
  }
  if (c > LONG_MAX) {
    write_real_text_fix_float(f, &c, w, 0L, flt);
    if (diary)
      write_real_text_fix_float(diary_file, &c, w, 0L, flt);
    return;
  }
  ci = (long)floor(c + 0.5);
  write_integer_text(f, ci, w);
  if (diary)
    write_integer_text(diary_file, ci, w);
}  /* write_real_fix_float */


Static Void write_real(f, c, w, d)
FILE *f;
t_long_real c;
t_long_integer w, d;
{
  if (w < 0)
    write_real_fix_float(f, c, -w, d, false);
  else
    write_real_fix_float(f, c, w, d, true);
}  /* write_real */


Static Void write_command_name(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  t_long_integer i;

  for (i = 0; i < w; i++)
    write_char_text(f, c[i]);
  if (diary) {
    for (i = 0; i < w; i++)
      write_char_text(diary_file, c[i]);
  }
}  /* write_command_name */


Static Void write_pch(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  t_long_integer i;

  if (char_count + w > line_length)
    write_new_line(f);
  char_count += w;
  for (i = 0; i < w; i++)
    write_char_text(f, c[i]);
  if (diary) {
    for (i = 0; i < w; i++)
      write_char_text(diary_file, c[i]);
  }
}


Static Void note_command_end_pch(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  if (echo_note)
    write_pch(f, c, w);
}


Static Void write_pch_r(f, c, w, l)
FILE *f;
Char *c;
t_long_integer w, l;
{
  write_space(f, l - w);
  write_pch(f, c, w);
  write_char(f, ':');
  write_space(f, 1L);
}


/* #  ifdef CC-minus     


Static Void write_pch(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  t_long_integer i;

  if (w > 20)
    w = 20;
  if (char_count + w > line_length)
    write_new_line(f);
  char_count += w;
  for (i = 0; i < w; i++)
    write_char_text(f, c[i]);
  if (diary) {
    for (i = 0; i < w; i++)
      write_char_text(diary_file, c[i]);
  }
}


Static Void note_command_end_pch(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  if (echo_note)
    write_pch(f, c, w);
}


Static Void write_pch(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  t_long_integer i;

  if (char_count + w > line_length)
    write_new_line(f);
  char_count += w;
  for (i = 0; i < w; i++)
    write_char_text(f, c[i]);
  if (diary) {
    for (i = 0; i < w; i++)
      write_char_text(diary_file, c[i]);
  }
}


Static Void note_command_end_pch(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  if (echo_note)
    write_pch(f, c, w);
}


Static Void write_pch(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  t_long_integer i;

  if (char_count + w > line_length)
    write_new_line(f);
  char_count += w;
  for (i = 0; i < w; i++)
    write_char_text(f, c[i]);
  if (diary) {
    for (i = 0; i < w; i++)
      write_char_text(diary_file, c[i]);
  }
}


Static Void write_pch(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  t_long_integer i;

  if (char_count + w > line_length)
    write_new_line(f);
  char_count += w;
  for (i = 0; i < w; i++)
    write_char_text(f, c[i]);
  if (diary) {
    for (i = 0; i < w; i++)
      write_char_text(diary_file, c[i]);
  }
}


Static Void write_pch_r(f, c, w, l)
FILE *f;
Char *c;
t_long_integer w, l;
{
  write_space(f, l - w);
  write_pch(f, c, w);
  write_char(f, ':');
  write_space(f, 1L);
}


Static Void write_pch_r(f, c, w, l)
FILE *f;
Char *c;
t_long_integer w, l;
{
  write_space(f, l - w);
  write_pch(f, c, w);
  write_char(f, ':');
  write_space(f, 1L);
}


Static Void write_pch_r(f, c, w, l)
FILE *f;
Char *c;
t_long_integer w, l;
{
  write_space(f, l - w);
  write_pch(f, c, w);
  write_char(f, ':');
  write_space(f, 1L);
}


Static Void write_pch(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  t_long_integer i;

  if (char_count + w > line_length)
    write_new_line(f);
  char_count += w;
  for (i = 1; i <= w; i++)
    write_char_text(f, c[i - PCH_START]);
  if (diary) {
    for (i = 1; i <= w; i++)
      write_char_text(diary_file, c[i - PCH_START]);
  }
}


     #  endif CC-minus */


Static Void write_pch_to_blank(f, c, w)
FILE *f;
Char *c;
t_long_integer w;
{
  t_long_integer i = 1;

  while (c[i - PCH_START] != '\0' && c[i - PCH_START] != ' ' && i <= w)
    i++;
  i--;
  write_pch(f, c, i);
}  /* write_pch_to_blank */


Static Void note_error(error)
t_integer error;
{
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " Please ignore: ", 16L);
  write_pch(stdout, " Error number: ", 15L);
  write_integer(stdout, error, 5L);
  write_line(stdout);
  write_line(stdout);
}  /* note_error */


/*@-"trace.c"*/
/*@+"mat.p"*/

/*

  231:    +++  ++
  232:    +++  ++
  233:    ---  -- p/mat.p           23      88    1224 p/mat.p
  234: |    4:    function floor_x
  235: |   14:    function ceil_x
  236: |   24:    function exp_2
  237: |   29:    function power2
  238: |   34:    function exp10
  239: |   39:    function log_10
  240: |   44:    function delta_round
  241: |   52:    procedure scale
  242: |  102:    function log_fact
  243: |  125:    function uniform
  244: |  131:    function tailnorm
  245: |  208:    function pnormal
  246: |  213:    function chi_squared_prob
  247: |  223:    function lngamma
  248: |  264:    function chi_squared_prob_approx
  249: |  272:    function normal_prob_approx
  250: |  300:    function normal_percent_point_approx
  251: |  322:    function khi
  252: |  338:    function sub_select_p_value
  253: |  340:    function compute_crit
  254: |  358:    function compute_crit_real
  255: |  414:    function select_p_value
  256: |  419:    function select_asymptotic_p_value
  257:    +++  ++
  258:    +++  ++

*/

Static boolean trace_flag_set(w, o, p)
t_long_integer w, o, p;
{
  t_long_integer q;

  q = TRACE_FLAG_FACTOR * o;
  if (w <= 20 || trace_flag[w] || trace_flag[127]) {
    if (trace_flag[q])
      return true;
    else if ((p == 1 || p == 8) && trace_flag[q+9])
      return true;
    else if (trace_flag[q + p])
      return true;
    else
      return false;
  } else
    return false;
}


Static boolean is_invalid_short_real_imported(x)
t_real x;
{
  boolean is_invalid;

  /* For (imported) missing values: */

/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
#ifdef CoCo_Cygwin
   is_invalid = false;
#else /* CoCo_Cygwin */
   is_invalid = isnan(x);
#endif /* CoCo_Cygwin */
/* p2c: coco_d_p2c.p, line 3633:
 * Warning: Symbol 'ISNAN' is not defined [221] */

  if (!is_invalid)
    is_invalid = (fabs((x - my_var_na_float) / x) < 0.0001);
  return is_invalid;
}  /* is_invalid_short_real_imported */


/* Not used: */
/**/
Static boolean is_invalid_long_real_imported(x)
t_long_real x;
{
  boolean is_invalid = false;

  if (true)
    is_invalid = (fabs((x - my_var_na_double) / x) < 0.0001);
  return is_invalid;
}


/**/
/* is_invalid_long_real_imported */
/* is_invalid := isnan(x); */

Static t_long_integer myaddi(x, y)
t_long_integer *x, *y;
{
  long Result = _INFINITY;

  if (*x >= _INFINITY)
    return Result;
  if (*y < _INFINITY) {
    if (*x < _INFINITY - *y)
      return (*x + *y);
  }
  return Result;
}  /* myaddi */


Static t_long_integer mysubi(x, y)
t_long_integer *x, y;
{
  long Result = _INFINITY;

  if (*x < _INFINITY) {
    if (y < _INFINITY) {
      /* if x < _INFINITY + y then */
      return (*x - y);
    }
  }
  return Result;
}  /* mysubi */


Static t_long_integer myaddsigni(x, y, c)
t_long_integer *x, *y;
t_integer c;
{
  long Result = _INFINITY;

  if (*x < _INFINITY) {
    if (*y < _INFINITY) {
      /* if x < _INFINITY - c * y then */
      return (*x + c * *y);
    }
  }
  return Result;
}  /* myaddsigni */


Static t_long_integer myaddsubi(x, y, z)
t_long_integer *x, *y, *z;
{
  t_long_integer a;

  a = myaddi(x, y);
  return (mysubi(&a, *z));
}  /* myaddsubi */


Static t_long_integer mymulti(x, c)
t_long_integer *x, c;
{
  long Result = _INFINITY;

  if (*x >= _INFINITY)
    return Result;
  if (c < _INFINITY) {
    if (*x < (double)_INFINITY / c)
      return (c * *x);
  }
  return Result;
}  /* mymulti */


Static t_long_integer diff_long_infinity(x, y)
t_long_integer *x, *y;
{
  /* mysubi */
  if (*x < _INFINITY && *y < _INFINITY)
    return (*x - *y);
  else
    return _INFINITY;
}  /* diff_long_infinity */


/* myaddi */
/* Not used:
function add_long_infinity(var x, y: t_long_integer): t_long_integer;
begin
   if (x < _INFINITY) and (y < _INFINITY) then
      add_long_infinity := x + y
   else
      add_long_infinity := _INFINITY
end; */
/* add_long_infinity */

Static t_long_real addprod(x, y, z)
t_long_real *x, *y, *z;
{
  if (is_invalid_real(*x) | is_invalid_real(*y) | is_invalid_real(*z))
    return _INVALID_REAL;
  else
    return (*x + *y * *z);
}  /* addprod */


Static t_long_real my_add_long_real(x, y)
t_long_real *x, *y;
{
  if (is_invalid_real(*x) | is_invalid_real(*y))
    return _INVALID_REAL;
  else
    return (*x + *y);
}  /* my_add_long_real */


Static t_long_real my_sub_long_real(x, y)
t_long_real *x, *y;
{
  if (is_invalid_real(*x) | is_invalid_real(*y))
    return _INVALID_REAL;
  else
    return (*x - *y);
}  /* my_sub_long_real */


Static t_long_real ddiff(x, y)
t_long_real *x, *y;
{
  if (is_invalid_real(*x) | is_invalid_real(*y))
    return _INVALID_REAL;
  else
    return (2.0 * (*x - *y));
}  /* ddiff */


Static boolean different_reals(x, y)
t_long_real *x, *y;
{
  if (is_invalid_real(*x) | is_invalid_real(*y))
    return (is_invalid_real(*x) != is_invalid_real(*y));
  else
    return (fabs((*x - *y) / (*x + *y)) > sqrt(ROUND_ERROR));
}  /* different_reals */


Static t_long_integer floor_x(x)
t_long_real x;
{
  if (fabs(x - (long)x) < ROUND_ERROR)
    return ((long)x);
  else if (x < 0)
    return ((long)x - 1);
  else
    return ((long)x);
}  /* floor_x */


Static t_long_integer ceil_x(x)
t_long_real x;
{
  if (fabs(x - (long)x) < ROUND_ERROR)
    return ((long)x);
  else if (x < 0)
    return ((long)x);
  else
    return ((long)x + 1);
}  /* ceil_x */


Static t_long_real exp_2(x)
t_long_real x;
{
  return exp(x * log(2.0));
}  /* exp_2 */


Static t_long_integer power2(x)
t_long_real x;
{
  return ((long)floor(exp(x * log(2.0)) + 0.5));
}  /* power2 */


Static t_long_real exp10_(x)
t_long_real x;
{
  return exp(x * log(10.0));
}  /* exp10 */


Static t_long_real log_10(x)
t_long_real x;
{
  return (log(x) / log(10.0));
}  /* log_10 */


Static t_long_real delta_round(x, delta)
t_long_real x, delta;
{
  if (fabs(x) < ROUND_ERROR * delta)
    return 0.0;
  else
    return x;
}  /* delta_round */


Static Void scale(min, max, max_int, a, b, delta, n_int)
t_long_real min, max;
t_long_integer max_int;
t_long_real *a, *b, *delta;
t_long_integer *n_int;
{
  t_long_integer n_int_0 = max_int;
  t_long_integer factor;
  t_long_real d;

  if (min == max) {
    *delta = 0.0;
    return;
  }
  do {
    *delta = (max - min) / n_int_0;
    factor = floor_x(log_10(*delta));
    d = *delta / exp10_((double)factor);
    if (d <= 1.00)
      d = 1.00;
    else if (d <= 1.25)
      d = 1.25;
    else if (d <= 1.50)
      d = 1.50;
    else if (d <= 2.00)
      d = 2.00;
    else if (d <= 2.50)
      d = 2.50;
    else if (d <= 3.00)
      d = 3.00;
    else if (d <= 4.00)
      d = 4.00;
    else if (d <= 5.00)
      d = 5.00;
    else if (d <= 6.00)
      d = 6.00;
    else if (d <= 7.00)
      d = 7.00;
    else if (d <= 8.00)
      d = 8.00;
    else if (d <= 9.00)
      d = 9.00;
    else if (d <= 10.00)
      d = 10.00;
    *delta = d * exp10_((double)factor);
    *a = floor_x(min / *delta) * *delta;
    *b = ceil_x(max / *delta) * *delta;
    n_int_0--;
    *n_int = (long)floor((*b - *a) / *delta + 0.5);
  } while (*n_int > max_int);   /* scale */
}


Static t_long_real log_fact(i)
t_long_integer i;
{
  t_long_integer j;
  t_long_real x;

  if (i <= MAX_FACT) {
    if (i <= max_fact_found)
      return (fact_array[i]);
    if (max_fact_found == -1) {
      max_fact_found = 0;
      fact_array[0] = 0.0;
    }
    x = fact_array[max_fact_found];
    for (j = max_fact_found + 1; j <= i; j++) {
      x += log((double)j);
      fact_array[j] = x;
    }
    max_fact_found = i;
    return (fact_array[i]);
  } else
    return ((0.5 + i) * log((double)i) + 0.9189385335 - i + 1.0 / 12 / i);
}  /* log_fact */


Static t_long_real uniform(dummy)
t_long_integer *dummy;
{
  *dummy = (*dummy * 7141 + 54773L) % 259200L;
  return ((*dummy + 0.5) / 259200L);
}  /* uniform */


#define c1_             0.3989422804014327

#define bigx            170


Static double tailnorm(x, upper)
double x;
boolean upper;
{
  t_long_real n, p1, p2, q1, q2, m, x2, y, s, t;
  long i;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 290L, 1L)) {
    write_real(stdout, x, 10L, 6L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (x == 0)
    return 0.5;
  else {
    if (x < 0)
      upper = !upper;
    x = fabs(x);
    x2 = x * x;
    if (x2 / 2 < bigx)
      y = c1_ * exp(-0.5 * x2);
    else
      y = 0.0;
    n = y / x;
    if (!upper && n == 0)
      return 1.0;
    else if (upper && n == 0)
      return 0.0;
    else {
      if (upper && x > 2.32 || !upper && x > 3.5) {
	q1 = x;
	p2 = y * x;
	i = 1;
	p1 = y;
	q2 = x2 + i;
	if (upper) {
	  s = p1 / q1;
	  m = s;
	  t = p2 / q2;
	} else {
	  s = i - p1 / q1;
	  m = s;
	  t = i - p2 / q2;
	}
	while ((different_reals(&m, &t) & different_reals(&s, &t)) &&
	       i < 10000) {
	  /*$ifdef TRACE*/
	  if (trace_flag_set(20L, 290L, 1L)) {
	    write_integer_text(stdout, i, 4L);
	    write_real(stdout, m, 10L, 6L);
	    write_real(stdout, m - t, 10L, 6L);
	    write_real(stdout, s, 10L, 6L);
	    write_real(stdout, s - t, 10L, 6L);
	    write_real(stdout, t, 10L, 6L);
	    write_line(stdout);
	  }
	  /*$endif TRACE*/
	  i++;
	  s = x * p2 + i * p1;
	  p1 = p2;
	  p2 = s;
	  s = x * q2 + i * q1;
	  q1 = q2;
	  q2 = s;
	  s = m;
	  m = t;
	  if (upper)
	    t = p2 / q2;
	  else
	    t = 1 - p2 / q2;
	}
	return t;
      } else {
	s = y * x;
	x = y * x;
	i = 1;
	t = 0.0;
	while (different_reals(&s, &t) && i < 10000) {
	  /*$ifdef TRACE*/
	  if (trace_flag_set(20L, 290L, 1L)) {
	    write_integer_text(stdout, i, 4L);
	    write_real(stdout, x, 10L, 6L);
	    write_real(stdout, x2, 10L, 6L);
	    write_real(stdout, s, 10L, 6L);
	    write_real(stdout, t, 10L, 6L);
	    write_real(stdout, s - t, 10L, 6L);
	    write_line(stdout);
	  }
	  /*$endif TRACE*/
	  i += 2;
	  t = s;
	  x = x * x2 / i;
	  s += x;
	}
	if (upper)
	  return (0.5 - s);
	else
	  return (0.5 + s);
      }
    }
  }
}  /* tailnorm */

#undef c1_
#undef bigx


Static double pnormal(u)
double u;
{
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 291L, 1L)) {
    write_real(stdout, u, 10L, 6L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  return (tailnorm(u, true));
}  /* pnormal */


#define a0_             0.57236494


Local t_long_real lngamma(w)
t_long_real w;
{
  t_long_real sum = 0.0;

  w--;
  while (w > 0.0) {
    sum += log(w);
    w--;
  }
  if (w < 0.0)
    return (sum + a0_);
  else
    return sum;
}  /* lngamma */

#undef a0_


Static t_long_real chi_squared_prob(x, k)
t_long_real x;
t_long_integer k;
{
  double Result;
  t_long_real factor, g, k1;
  t_long_real sum = 0.0;
  t_long_real term, x1;

  x1 = 0.5 * x;
  k1 = 0.5 * k;
  g = lngamma(k1 + 1);
  if (k1 * log(x1) - g - x1 > -1000)
    factor = exp(k1 * log(x1) - g - x1);
  else
    factor = 0.0;
  if (factor > 0) {
    term = 1.0;
    sum = 1.0;
    while (term / sum > 1e-6) {
      k1++;
      term = term * x1 / k1;
      sum += term;
    }
  }
  Result = sum * factor;
  if (factor <= 0)
    return 1.0;
  return Result;
}  /* chi_squared_prob */


#define a1              0.196854
#define a2              0.115194
#define a3              0.000344
#define a4              0.019527


Local t_long_real normal_prob_approx(z)
t_long_real z;
{
  t_long_real w;

  w = fabs(z);
  w = 1 + w * (a1 + w * (a2 + w * (a3 + w * a4)));
  w *= w * w * w;
  w = 1 - 0.5 / w;
  if (z >= 0)
    return w;
  else
    return (1 - w);
}  /* normal_prob_approx */

#undef a1
#undef a2
#undef a3
#undef a4


Static t_long_real chi_squared_prob_approx(x, k)
t_long_real x;
t_long_integer k;
{
  t_long_real a, w1, w2, f_third, z;

  a = 2.0 / (9.0 * k);
  f_third = exp(log(x / k) / 3.0);
  w1 = f_third + a - 1;
  w2 = a;
  z = w1 / sqrt(w2);
  return (normal_prob_approx(z));
}  /* chi_squared_prob_approx */


#define a1              2.30753
#define a2              0.27061
#define a3              0.99229
#define a4              0.04481


Static t_long_real normal_percent_point_approx(p)
t_long_real p;
{
  t_long_real w, p1, t;

  p1 = 0.5 + fabs(p - 0.5);
  t = sqrt(-2.0 * log(1 - p1));
  w = a1 + a2 * t;
  w /= 1.0 + t * (a3 + a4 * t);
  w = t - w;
  if (p >= 0.5)
    return w;
  else
    return (-w);
}  /* normal_percent_point_approx */

#undef a1
#undef a2
#undef a3
#undef a4


Static t_long_real khi(df, q)
t_long_integer df;
t_long_real q;
{
  double Result = _INVALID_REAL;

  if (is_invalid_real(q) || df == _INFINITY)
    return Result;
  if (df > 0 && q > 0) {
    if (df < 5)
      return (1 - chi_squared_prob(q, df));
    else
      return (1 - chi_squared_prob_approx(q, df));
  }
  if (df > 0)
    return 1.0;
  if (df == 0 && q <= sqrt(ROUND_ERROR))
    return 1.0;
  return Result;
}  /* khi */


/* Local variables for sub_select_p_value: */
struct LOC_sub_select_p_value {
  t_test *test;
} ;

Local t_long_real compute_crit(df, q, LINK)
t_long_integer df;
t_long_real q;
struct LOC_sub_select_p_value *LINK;
{
  if (ic) {
    if (df < _INFINITY) {
      if (bic && exclude_missing) {
	if (LINK->test->n_count == _INVALID_COUNT)
	  return _INVALID_REAL;
	else
	  return (log((double)LINK->test->n_count) * df - q);
      } else
	return (ic_lambda * df - q);
    } else
      return (-q);
  } else
    return (khi(df, q));
}  /* compute_crit */

Local t_long_real compute_crit_real(df, q, LINK)
t_long_real df, q;
struct LOC_sub_select_p_value *LINK;
{
  if (ic) {
    if (bic && exclude_missing) {
      if (LINK->test->n_count == _INVALID_COUNT)
	return _INVALID_REAL;
      else
	return (log((double)LINK->test->n_count) * df - q);
    } else
      return (ic_lambda * df - q);
  } else
    return _INVALID_REAL;
}  /* compute_crit_real */


Static t_long_real sub_select_p_value(test_)
t_test *test_;
{
  struct LOC_sub_select_p_value Local_Var;
  double Result;
  t_long_real statistic;
  t_test *WITH;

  Local_Var.test = test_;
  WITH = Local_Var.test;
  if (((exact_test && ordinal_tests) & (!is_invalid_real(WITH->gamma))) &&
      WITH->mcep_gamma_1 > -1)
    return (WITH->mcep_gamma_2);
  else if ((ordinal_tests & (!is_invalid_real(WITH->gamma)) &
	    (!is_invalid_real(WITH->s))) && WITH->s > 0)
    return (2 * pnormal(fabs(WITH->gamma / sqrt(WITH->s))));
  else if (exact_test && (WITH->mcep_deviance > -1 && test_choice == 1 ||
			  WITH->mcep_pearson > -1 && test_choice > 1)) {
    switch (test_choice) {

    case 1:
      Result = WITH->mcep_deviance;
      break;

    case 2:
      Result = WITH->mcep_pearson;
      break;

    case 3:
      Result = WITH->mcep_power;
      break;
    }
    return Result;
  } else {
    switch (test_choice) {

    case 1:
      statistic = WITH->x_deviance;
      break;

    case 2:
      statistic = WITH->x_pearson;
      break;

    case 3:
      statistic = WITH->x_power;
      break;
    }
    if (!is_invalid_real(statistic)) {
      if (WITH->df < _INFINITY || ic && !bic && ic_lambda == 0) {
	if (adj_df && WITH->adj != _INFINITY)
	  return (compute_crit(WITH->df - WITH->adj, statistic, &Local_Var));
	else
	  return (compute_crit(WITH->df, statistic, &Local_Var));
      } else
	return (compute_crit_real(WITH->df_real, statistic, &Local_Var));
    } else
      return _INVALID_REAL;
  }
  return Result;
}  /* sub_select_p_value */


Static t_long_real select_p_value(link_test_list)
t_test_list *link_test_list;
{
  return (sub_select_p_value(&link_test_list->test));
}  /* select_p_value */


Static t_long_real select_asymptotic_p_value(link_test_list)
t_test_list *link_test_list;
{
  t_long_real statistic;
  t_test *WITH;

  WITH = &link_test_list->test;
  switch (test_choice) {

  case 1:
    statistic = WITH->x_deviance;
    break;

  case 2:
    statistic = WITH->x_pearson;
    break;

  case 3:
    statistic = WITH->x_power;
    break;
  }
  if (!is_invalid_real(statistic)) {
    if (adj_df)
      return (khi(WITH->df - WITH->adj, statistic));
    else
      return (khi(WITH->df, statistic));
  } else
    return 1.0;
}  /* select_asymptotic_p_value */


/*@-"hash.c"*/
/*@+"marginal.p"*/


/*

  359:    +++  ++
  360:    +++  ++
  361:    ---  -- p/marginal.p        19      84    1110 p/marginal.p
  362: |    4:    function return_first_vertex_in_set
  363: |   13:    function return_next_vertex_in_set
  364: |   25:    function cardinality
  365: |   40:    function count_continuous
  366: |   52:    procedure return_ghk_size
  367: |   59:    function count_discrete
  368: |   71:    procedure next_cell
  369: |   89:    function marginal_dimension_tf
  370: |  125:    function marginal_dimension
  371: |  145:    function last_index
  372: |  150:    function marginal_dimension_real
  373: |  162:    function ok_to_find_marginal_hash
  374: |  167:    function marginal_hash
  375: |  198:    procedure to_continuous_set
  376: |  214:    procedure to_discrete_set
  377: |  230:    function discrete_marginal_hash
  378: |  261:    procedure next_marginal_cell
  379: |  286:    procedure next_marginal_cell_list
  380: |  304:    function large_table
  381:    +++  ++
  382:    +++  ++

*/


Static boolean return_first_vertex_in_set(v, a)
t_vertex *v;
long *a;
{
  *v = first_vertex;
  while (!P_inset(*v, a) && *v < last_vertex)
    (*v)++;
  return P_inset(*v, a);
}  /* return_first_vertex_in_set */


Static boolean return_next_vertex_in_set(v, a)
t_vertex *v;
long *a;
{
  if (*v < last_vertex) {
    (*v)++;
    while (!P_inset(*v, a) && *v < last_vertex)
      (*v)++;
    return P_inset(*v, a);
  } else
    return false;
}  /* return_next_vertex_in_set */


Static t_long_integer cardinality(a)
long *a;
{
  t_vertex v;
  t_long_integer card = 0;
  boolean ok;

  ok = return_first_vertex_in_set(&v, a);
  while (ok) {
    card++;
    ok = return_next_vertex_in_set(&v, a);
  }
  return card;
}  /* cardinality */


Static t_long_integer count_continuous(a)
long *a;
{
  t_vertex v;
  t_long_integer count = 0;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a) & P_inset(v, gamma_))
      count++;
  }
  return count;
}  /* count_continuous */


Static Void return_ghk_size(a, m1, m2)
long *a;
t_integer *m1, *m2;
{
  *m1 = count_continuous(a);
  *m2 = *m1 + *m1 * (*m1 + 1) / 2 + 1;
}  /* return_ghk_size */


#ifdef CoCo_Cygwin
#ifdef DEBUG_E
  /* E */ printf("write_integer 1 \n");
  /* E */ printf("\n");
#endif /* E */
#endif /* CoCo_Cygwin */
Static Void next_cell(i)
t_level *i;
{
  t_vertex v;

  v = first_vertex;
  while (i[v - MIN_VERTEX] ==
	 FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1 &&
	 v < last_vertex) {
    i[v - MIN_VERTEX] = FIRST_LEVEL;
    v++;
  }
  if (v == last_vertex &&
      i[v - MIN_VERTEX] ==
      FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1)
    i[v - MIN_VERTEX] = FIRST_LEVEL;
  else
    i[v - MIN_VERTEX]++;
}  /* next_cell */


Static t_long_integer marginal_dimension_tf(a, total, full)
long *a;
boolean total, full;
{
  t_long_integer levels;
  t_long_integer product = 1;
  boolean ok = true;
  t_vertex v, w;

  if (full)
    w = full_last_vertex;
#ifdef CoCo_Cygwin
#ifdef DEBUG_E
  /* E */ printf("write_real_fix_float 1 \n");
  /* E */ printf("\n");
#endif /* E */
#endif /* CoCo_Cygwin */
  else
    w = last_vertex;
  for (v = first_vertex; v <= w; v++) {
    if (P_inset(v, a) &
	((full & P_inset(v, full_delta)) | ((!full) & P_inset(v, delta)))) {
      if (full) {
	if (total)
	  levels = full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total;
	else
	  levels = full_variable_description[v - MIN_VERTEX]->UU.U0.levels;
      } else if (total)
	levels = variable_description[v - MIN_VERTEX]->UU.U0.levels_total;
      else
	levels = variable_description[v - MIN_VERTEX]->UU.U0.levels;
      if (product > (double)_INFINITY / levels)
	ok = false;
      else
	product *= levels;
    }
  }
  if (ok)
    return product;
  else
    return _INFINITY;
}  /* marginal_dimension_tf */


Static t_long_integer marginal_dimension(a)
long *a;
{
  t_long_integer product = 1;
  boolean ok = true;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a) & P_inset(v, delta)) {
      if (product >
	  (double)_INFINITY / variable_description[v - MIN_VERTEX]->UU.U0.levels)
	ok = false;
      else
	product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
    }
  }
  if (ok)
    return product;
  else
    return _INFINITY;
}  /* marginal_dimension */
#ifdef CoCo_Cygwin
#ifdef DEBUG_E
  /* E */ printf("write_real 1 \n");
  /* E */ printf("\n");
#endif /* E */
#endif /* CoCo_Cygwin */


Static t_long_integer last_index(a)
long *a;
{
  return (FIRST_INDEX + marginal_dimension(a) - 1);
}  /* last_index */


Static t_long_real marginal_dimension_real(a)
long *a;
{
  t_long_real product = 1.0;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a) & P_inset(v, delta))
      product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
  }
  return product;
}  /* marginal_dimension_real */


Static boolean ok_to_find_marginal_hash(a)
long *a;
{
  return (marginal_dimension(a) < _INFINITY);
}  /* ok_to_find_marginal_hash */


Static t_cell_index marginal_hash(a, i)
long *a;
t_level *i;
{
  t_cell_index sum, product;
  t_vertex v, f, l;
  t_vertex_set b;

  if (P_setequal(a, empty_set)) {
    sum = FIRST_INDEX;
    return sum;
  }
  f = first_vertex;
  while (!P_inset(f, a))
    f++;
  sum = FIRST_INDEX + i[f - MIN_VERTEX] - FIRST_LEVEL;
  P_addset(P_expset(b, 0L), f);   /* empty_set + */
  if (P_setequal(a, b))
    return sum;
  l = last_vertex;
  while (!P_inset(l, a))
    l--;
  product = variable_description[f - MIN_VERTEX]->UU.U0.levels;
  for (v = f + 1; v <= l - 1; v++) {
    if (P_inset(v, a) & P_inset(v, delta)) {
      sum += (i[v - MIN_VERTEX] - FIRST_LEVEL) * product;
      product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
    }
  }
  sum += (i[l - MIN_VERTEX] - FIRST_LEVEL) * product;
  return sum;
}  /* marginal_hash */


Static Void to_continuous_set(a, b)
long *a;
long *b;
{
  t_vertex v;
  t_continuous_vertex w;

  w = first_continuous_vertex;
  P_setcpy(b, empty_set);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, gamma_)) {
      if (P_inset(v, a))
	P_addset(b, w);
      w++;
    }
  }
}  /* to_continuous_set */


Static Void to_discrete_set(a, b)
long *a;
long *b;
{
  t_vertex v;
  t_discrete_vertex w;

  w = first_discrete_vertex;
  P_setcpy(b, empty_set);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, delta)) {
      if (P_inset(v, a))
	P_addset(b, w);
      w++;
    }
  }
}  /* to_discrete_set */


Static t_cell_index discrete_marginal_hash(a, i)
long *a;
t_level *i;
{
  t_cell_index sum, product;
  t_discrete_vertex v, f, l;
  t_discrete_vertex_set b;

  if (P_setequal(a, empty_set)) {
    sum = FIRST_INDEX;
    return sum;
  }
  f = first_discrete_vertex;
  while (!P_inset(f, a))
    f++;
  sum = FIRST_INDEX + i[f - MIN_VERTEX] - FIRST_LEVEL;
  P_addset(P_expset(b, 0L), f);   /* empty_set + */
  if (P_setequal(a, b))
    return sum;
  l = last_vertex;
  while (!P_inset(l, a))
    l--;
  product = discrete_variable_description[f - MIN_VERTEX]->UU.U0.levels;
  for (v = f + 1; v <= l - 1; v++) {
    if (P_inset(v, a)) {
      sum += (i[v - MIN_VERTEX] - FIRST_LEVEL) * product;
      product *= discrete_variable_description[v - MIN_VERTEX]->UU.U0.levels;
    }
  }
  sum += (i[l - MIN_VERTEX] - FIRST_LEVEL) * product;
  return sum;
}  /* marginal_hash */


Static Void next_marginal_cell(a, i)
long *a;
t_level *i;
{
  t_vertex v;
  t_vertex_set b;

  v = first_vertex;
  P_setdiff(b, delta_gamma, a);
  while (P_inset(v, b) && v < last_vertex)
    v++;
  while (((i[v - MIN_VERTEX] ==
	   FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1) |
	  P_inset(v, b)) && v < last_vertex) {
    if (P_inset(v, a))
      i[v - MIN_VERTEX] = FIRST_LEVEL;
    v++;
  }
  if (!P_inset(v, a))
    return;
  if (v == last_vertex &&
      i[v - MIN_VERTEX] ==
      FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1)
    i[v - MIN_VERTEX] = FIRST_LEVEL;
  else
    i[v - MIN_VERTEX]++;
}  /* next_marginal_cell */


Static Void next_marginal_cell_list(p, i)
t_vertex_list *p;
t_level *i;
{
  if (p == NULL)
    return;
  while (i[p->vertex - MIN_VERTEX] ==
	 FIRST_LEVEL + variable_description[p->vertex - MIN_VERTEX]->
		       UU.U0.levels - 1 && p->pointer != NULL) {
    i[p->vertex - MIN_VERTEX] = FIRST_LEVEL;
    p = p->pointer;
  }
  if (p->pointer == NULL &&
      i[p->vertex - MIN_VERTEX] ==
      FIRST_LEVEL + variable_description[p->vertex - MIN_VERTEX]->UU.U0.levels - 1)
    i[p->vertex - MIN_VERTEX] = FIRST_LEVEL;
  else
    i[p->vertex - MIN_VERTEX]++;
}  /* next_marginal_cell_list */


Static boolean large_table(a, n)
long *a;
t_cell_count *n;
{
  t_long_integer size;

  if (ok_to_find_marginal_hash(a)) {
    size = marginal_dimension(a);
    /*$ifdef TRACE*/
    if (!(boolean_option[3] || boolean_option[4]))
      return ((datastructure == list_file) &
	      (size > *n * log((double)(*n)) * (cardinality(a) + 1)));
    write_pch_10_text(stdout, " Size: ", 7L);
    write_integer_text(stdout, size, 20L);
    write_real_text(stdout, *n * log((double)(*n)) * (cardinality(a) + 1),
		    20L, 0L);
    write_line_text(stdout);
    /*$endif TRACE*/
    return ((datastructure == list_file) &
	    (size > *n * log((double)(*n)) * (cardinality(a) + 1)));
  } else
    return true;
}  /* large_table */


Static Void find_min_count(a, n_offset, min_count)
long *a;
t_offset *n_offset;
t_integer *min_count;
{
  t_integer count, i;
  t_vertex_set b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  *min_count = n[0];
  P_setint(b, a, delta);
  for (i = *n_offset; i < *n_offset + marginal_dimension(b); i++) {
    count = n[i];
    if (count < *min_count)
      *min_count = count;
  }
}  /* min_count */


/*@-"odr.c"*/
/*@+"out.p"*/


/*

  451:    +++  ++
  452:    +++  ++
  453:    ---  -- p/out.p         47     189    2539 p/out.p
  454: |    4:    function long_name_set_width
  455: |   22:    procedure print_vertex_on_report
  456: |   47:    procedure print_vertex_on_file
  457: |   74:    procedure print_discrete_vertex_on_file
  458: |   99:    procedure print_continuous_vertex_on_file
  459: |  124:    procedure print_full_vertex_on_file
  460: |  150:    procedure print_vertex
  461: |  155:    procedure print_discrete_vertex
  462: |  160:    procedure print_continuous_vertex
  463: |  165:    procedure print_edge
  464: |  186:    procedure switch_new
  465: |  188:    procedure switch_var
  466: |  311:    procedure switch
  467: |  316:    procedure print_table_type
  468: |  354:    function current
  469: |  363:    function base
  470: |  372:    function current_and_base
  471: |  383:    function current_ifail
  472: |  393:    function base_ifail
  473: |  403:    function current_and_base_ifail
  474: |  415:    procedure print_vertex_set_on_report
  475: |  428:    procedure print_vertex_set_x_on_report
  476: |  440:    procedure print_set_list_on_report
  477: |  445:    procedure print_vertex_set_x
  478: |  477:    procedure print_vertex_set
  479: |  490:    procedure print_discrete_vertex_set
  480: |  503:    procedure print_continuous_vertex_set
  481: |  516:    procedure print_vertex_set_table
  482: |  541:    procedure print_vertex_set_table_full
  483: |  562:    procedure print_g_c_from_stop
  484: |  592:    procedure print_g_c_from
  485: |  600:    procedure print_g_c
  486: |  608:    procedure print_g_c_slash
  487: |  617:    procedure print_g_c_stop
  488: |  624:    procedure print_g_c_list
  489: |  636:    procedure print_triple_g_c
  490: |  644:    procedure write_model_type
  491: |  661:    procedure print_model_g_c
  492: |  685:    procedure print_test_of
  493: |  695:    procedure print_vertex_list
  494: |  705:    procedure print_edge_list
  495: |  727:    procedure warning_begin
  496: |  737:    procedure warning_end
  497: |  750:    procedure write_warning
  498: |  760:    procedure write_warning_sets
  499: |  778:    procedure warning_different_reals
  500: |  804:    procedure check_model_constant
  501:    +++  ++
  502:    +++  ++

*/

Static t_integer long_name_set_width(a)
long *a;
{
  t_vertex_name_list *p_name_list;
  t_integer i;

  if (P_inset(double_vertex, a))
    i = 2;
  else
    i = 0;
  p_name_list = name_list;
  while (p_name_list != NULL) {
    if (P_inset(p_name_list->vertex, a))
      i += p_name_list->length + 1;
    p_name_list = p_name_list->pointer;
  }
  return i;
}  /* long_name_set_width */


Static Void write_long_name_text(f, c, l, w)
FILE *f;
Char *c;
t_integer l, w;
{
  if (w == 0) {
    write_char_text(f, ':');
    write_pch_text(f, c, l);
    return;
  }
  if (l >= labs(w)) {
    write_char_text(f, ':');
    write_pch_text(f, c, labs(w) - 1);
    return;
  }
  if (w < 0)
    write_space_text(f, w - l - 1);
  write_char_text(f, ':');
  write_pch_text(f, c, l);
  if (w > 0)
    write_space_text(f, w - l - 1);
}  /* write_long_name_text */


Static Void write_long_name(f, c, l, w)
FILE *f;
Char *c;
t_integer l, w;
{
  if (w == 0) {
    write_char(f, ':');
    write_pch(f, c, l);
    return;
  }
  if (l >= labs(w)) {
    write_char(f, ':');
    write_pch(f, c, labs(w) - 1);
    return;
  }
  if (w < 0)
    write_space(f, -w - l - 1);
  write_char(f, ':');
  write_pch(f, c, l);
  if (w > 0)
    write_space(f, w - l - 1);
}  /* write_long_name */


Static Void print_vertex_on_report(f, v, w)
FILE *f;
t_vertex v;
t_integer w;
{
  t_vertex_name_list *p_name_list;

  if (v == double_vertex) {
    write_char_text(f, '^');
    return;
  }
  if (!long_names) {
    write_char_text(f, variable_description[v - MIN_VERTEX]->name);
    return;
  }
  p_name_list = name_list;
  if (p_name_list != NULL && p_name_list->vertex != v) {
    while (p_name_list->pointer != NULL && p_name_list->vertex != v)
      p_name_list = p_name_list->pointer;
  }
  if (p_name_list == NULL) {
    write_pch_10_text(f, " Invalid", 8L);
    return;
  }
  if (p_name_list->vertex == v)
    write_long_name_text(f, p_name_list->name, p_name_list->length, w);
  else
    write_pch_10_text(f, " Invalid", 8L);
}  /* print_vertex_on_report */


Static Void print_vertex_on_file(f, v, w)
FILE *f;
t_vertex v;
t_integer w;
{
  t_vertex_name_list *p_name_list;

  if (v > last_vertex) {
    write_char(f, '%');
    return;
  }
  if (v == double_vertex) {
    write_char(f, '^');
    return;
  }
  if (!long_names) {
    write_char(f, variable_description[v - MIN_VERTEX]->name);
    return;
  }
  p_name_list = name_list;
  if (p_name_list != NULL && p_name_list->vertex != v) {
    while (p_name_list->pointer != NULL && p_name_list->vertex != v)
      p_name_list = p_name_list->pointer;
  }
  if (p_name_list == NULL) {
    write_pch(f, "<Invalid>", 9L);
    return;
  }
  if (p_name_list->vertex == v)
    write_long_name(f, p_name_list->name, p_name_list->length, w);
  else
    write_pch(f, "<Invalid>", 9L);
}  /* print_vertex_on_file */


Static Void print_discrete_vertex_on_file(f, v, w)
FILE *f;
t_discrete_vertex v;
t_integer w;
{
  t_vertex_name_list *p_name_list;

  if (v == double_vertex) {
    write_char(f, '^');
    return;
  }
  if (!long_names) {
    write_char(f, discrete_variable_description[v - MIN_VERTEX]->name);
    return;
  }
  p_name_list = discrete_name_list;
  if (p_name_list != NULL && p_name_list->vertex != v) {
    while (p_name_list->pointer != NULL && p_name_list->vertex != v)
      p_name_list = p_name_list->pointer;
  }
  if (p_name_list == NULL) {
    write_pch(f, "<Invalid>", 9L);
    return;
  }
  if (p_name_list->vertex == v)
    write_long_name(f, p_name_list->name, p_name_list->length, w);
  else
    write_pch(f, "<Invalid>", 9L);
}  /* print_discrete_vertex_on_file */


Static Void print_continuous_vertex_on_file(f, v, w)
FILE *f;
t_continuous_vertex v;
t_integer w;
{
  t_vertex_name_list *p_name_list;

  if (v == double_vertex) {
    write_char(f, '^');
    return;
  }
  if (!long_names) {
    write_char(f, continuous_variable_description[v - MIN_VERTEX]->name);
    return;
  }
  p_name_list = continuous_name_list;
  if (p_name_list != NULL && p_name_list->vertex != v) {
    while (p_name_list->pointer != NULL && p_name_list->vertex != v)
      p_name_list = p_name_list->pointer;
  }
  if (p_name_list == NULL) {
    write_pch(f, "<Invalid>", 9L);
    return;
  }
  if (p_name_list->vertex == v)
    write_long_name(f, p_name_list->name, p_name_list->length, w);
  else
    write_pch(f, "<Invalid>", 9L);
}  /* print_continuous_vertex_on_file */


Static Void print_full_vertex_on_file(f, v, w)
FILE *f;
t_vertex v;
t_integer w;
{
  t_vertex_name_list *p_name_list;

  if (v == double_vertex) {
    write_char(f, '^');
    return;
  }
  if (!long_names) {
    write_char(f, full_variable_description[v - MIN_VERTEX]->name);
    return;
  }
  p_name_list = full_name_list;
  if (p_name_list != NULL && p_name_list->vertex != v) {
    while (p_name_list->pointer != NULL && p_name_list->vertex != v)
      p_name_list = p_name_list->pointer;
  }
  if (p_name_list == NULL) {
    write_pch(f, "<Invalid>", 9L);
    return;
  }
  if (p_name_list->vertex == v)
    write_long_name(f, p_name_list->name, p_name_list->length, w);
  else
    write_pch(f, "<Invalid>", 9L);
}  /* print_full_vertex_on_file */


Static Void print_vertex(v)
t_vertex v;
{
  print_vertex_on_file(stdout, v, 0L);
}  /* print_vertex */


Static Void print_discrete_vertex(v, w)
t_discrete_vertex v;
t_integer w;
{
  print_discrete_vertex_on_file(stdout, v, w);
}  /* print_discrete_vertex */


Static Void print_continuous_vertex(v, w)
t_continuous_vertex v;
t_integer w;
{
  print_continuous_vertex_on_file(stdout, v, w);
}  /* print_continuous_vertex */


Static Void print_edge(f, write_options, test_labels, v, w)
FILE *f;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_vertex v, w;
{
  if ((*write_options)->line_form) {
    if ((*write_options)->write_models)
      write_space(f, 3L);
    write_char(f, '[');
    print_vertex_on_file(f, v, 0L);
    print_vertex_on_file(f, w, 0L);
    write_char(f, ']');
    return;
  }
  write_pch(f, " Edge: [", 8L);
  print_vertex_on_file(f, v, 0L);
  print_vertex_on_file(f, w, 0L);
  write_char(f, ']');
  write_line(f);
}  /* print_edge */


Local Void switch_var(val, hit, c, w)
boolean *val;
t_integer *hit;
Char *c;
t_integer w;
{
  if (*hit == 2) {
    if (*val)
      *hit = 1;
    else
      *hit = 0;
    return;
  }
  switch (*hit) {

  case -1:
    *val = false;
    break;

  case 0:
    *val = !*val;
    break;

  case 1:
    *val = true;
    break;
  }
  write_pch(stdout, c, w);
  write_pch(stdout, " set", 4L);
  if (*val)
    write_pch(stdout, " ON  TRUE ", 3L);
  else
    write_pch(stdout, " OFF FALSE", 4L);
}  /* switch_var */

Local Void set_flag(val, hit, number)
boolean *val;
t_integer *hit, number;
{
  if (*hit != 2)
    return;
  switch (number) {

  case 1:
    trace_flag[TRACE_FLAG_FACTOR * 826 + 9] = *val;   /* 1 0   */
    /*   1 */
    trace_flag[TRACE_FLAG_FACTOR * 828 + 9] = *val;
    /* 0 0   */
    /*   1 */
    trace_flag[TRACE_FLAG_FACTOR * 941 + 9] = *val;
    /* 0 0   */
    /*   1 */
    trace_flag[TRACE_FLAG_FACTOR * 943 + 9] = *val;
    /* 0 0   */
    /*   1 */
    trace_flag[TRACE_FLAG_FACTOR * 957 + 9] = *val;
    /* 0 0   */
    /*   1 */
    trace_flag[TRACE_FLAG_FACTOR * 975 + 9] = *val;
    break;
    /* 0 1   */

  case 2:
    trace_flag[TRACE_FLAG_FACTOR * 821 + 9] = *val;   /* 1 0 !+*/
    /*   2 */
    trace_flag[TRACE_FLAG_FACTOR * 823 + 9] = *val;
    /* 0 0   */
    /*   2 */
    trace_flag[TRACE_FLAG_FACTOR * 1864 + 9] = *val;
    break;
    /* 0 1   */

  case 3:
    trace_flag[TRACE_FLAG_FACTOR * 883 + 9] = *val;   /* 1 0 !+*/
    /*   3 */
    trace_flag[TRACE_FLAG_FACTOR * 886 + 9] = *val;
    /* 0 0   */
    /*   3 */
    trace_flag[TRACE_FLAG_FACTOR * 1533 + 9] = *val;
    /* 0 0   */
    /*   3 */
    trace_flag[TRACE_FLAG_FACTOR * 1534 + 9] = *val;
    /* 0 0   */
    /*   3 */
    trace_flag[TRACE_FLAG_FACTOR * 1537 + 9] = *val;
    /* 0 0   */
    /*   3 */
    trace_flag[TRACE_FLAG_FACTOR * 1544 + 9] = *val;
    /* 0 0   */
    /*   3 */
    trace_flag[TRACE_FLAG_FACTOR * 1545 + 9] = *val;
    /* 0 0   */
    /*   3 */
    trace_flag[TRACE_FLAG_FACTOR * 1548 + 9] = *val;
    /* 0 0   */
    /*   3 */
    trace_flag[TRACE_FLAG_FACTOR * 1603 + 9] = *val;
    break;
    /* 0 1   */

  case 4:
    trace_flag[TRACE_FLAG_FACTOR * 1517 + 9] = *val;   /* 1 0   */
    /*   4 */
    trace_flag[TRACE_FLAG_FACTOR * 1520 + 9] = *val;
    /* 0 0   */
    /*   4 */
    trace_flag[TRACE_FLAG_FACTOR * 1522 + 9] = *val;
    /* 0 0   */
    /*   4 */
    trace_flag[TRACE_FLAG_FACTOR * 1523 + 9] = *val;
    /* 0 0   */
    /*   4 */
    trace_flag[TRACE_FLAG_FACTOR * 1525 + 9] = *val;
    /* 0 0   */
    /*   4 */
    trace_flag[TRACE_FLAG_FACTOR * 2268 + 9] = *val;
    /* 0 0   */
    /*   4 */
    trace_flag[TRACE_FLAG_FACTOR * 2280 + 9] = *val;
    break;
    /* 0 1   */

  case 5:
    trace_flag[TRACE_FLAG_FACTOR * 1103 + 9] = *val;   /* 1 0 !+*/
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1108 + 9] = *val;
    /* 0 0   */
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1166 + 9] = *val;
    /* 0 0   */
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1167 + 9] = *val;
    /* 0 0   */
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1177 + 9] = *val;
    /* 0 0   */
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1181 + 9] = *val;
    /* 0 0   */
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1182 + 9] = *val;
    /* 0 0   */
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1183 + 9] = *val;
    /* 0 0   */
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1184 + 9] = *val;
    /* 0 0   */
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1238 + 9] = *val;
    /* 0 0   */
    /*   5 */
    trace_flag[TRACE_FLAG_FACTOR * 1287 + 9] = *val;
    break;
    /* 0 1   */

  case 6:
    trace_flag[TRACE_FLAG_FACTOR * 1026 + 9] = *val;   /* 1 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1156 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1209 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1210 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1218 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1237 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1245 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1246 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1251 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1253 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1254 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1255 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1260 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1281 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1681 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 1952 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 2011 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 2013 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 2016 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 2018 + 9] = *val;
    /* 0 0   */
    /*   6 */
    trace_flag[TRACE_FLAG_FACTOR * 2020 + 9] = *val;
    break;
    /* 0 1   */

  case 7:
    trace_flag[TRACE_FLAG_FACTOR * 636 + 9] = *val;   /* 1 0   */
    /*   7 */
    trace_flag[TRACE_FLAG_FACTOR * 1140 + 9] = *val;
    /* 0 0   */
    /*   7 */
    trace_flag[TRACE_FLAG_FACTOR * 1141 + 9] = *val;
    /* 0 0   */
    /*   7 */
    trace_flag[TRACE_FLAG_FACTOR * 1255 + 9] = *val;
    break;
    /* 0 1   */

  case 8:
    trace_flag[TRACE_FLAG_FACTOR * 2358 + 9] = *val;
    break;
    /* 1 1   */

  case 9:
    trace_flag[TRACE_FLAG_FACTOR * 883 + 9] = *val;   /* 1 0 !+*/
    /*   9 */
    trace_flag[TRACE_FLAG_FACTOR * 1226 + 9] = *val;
    break;
    /* 0 1   */

  case 10:
    trace_flag[TRACE_FLAG_FACTOR * 1193 + 9] = *val;   /* 1 0   */
    /*  10 */
    trace_flag[TRACE_FLAG_FACTOR * 1203 + 9] = *val;
    /* 0 0   */
    /*  10 */
    trace_flag[TRACE_FLAG_FACTOR * 1209 + 9] = *val;
    /* 0 0   */
    /*  10 */
    trace_flag[TRACE_FLAG_FACTOR * 1210 + 9] = *val;
    /* 0 0   */
    /*  10 */
    trace_flag[TRACE_FLAG_FACTOR * 1281 + 9] = *val;
    /* 0 0   */
    /*  10 */
    trace_flag[TRACE_FLAG_FACTOR * 1771 + 9] = *val;
    /* 0 0   */
    /*  10 */
    trace_flag[TRACE_FLAG_FACTOR * 1778 + 9] = *val;
    /* 0 0   */
    /*  10 */
    trace_flag[TRACE_FLAG_FACTOR * 1779 + 9] = *val;
    /* 0 0   */
    /*  10 */
    trace_flag[TRACE_FLAG_FACTOR * 1780 + 9] = *val;
    /* 0 0   */
    /*  10 */
    trace_flag[TRACE_FLAG_FACTOR * 1782 + 9] = *val;
    break;
    /* 0 1   */

  case 11:
    trace_flag[TRACE_FLAG_FACTOR * 1636 + 9] = *val;
    break;
    /* 1 1   */

  case 12:
    trace_flag[TRACE_FLAG_FACTOR * 1633 + 9] = *val;   /* 1 0   */
    /*  12 */
    trace_flag[TRACE_FLAG_FACTOR * 1635 + 9] = *val;
    /* 0 0   */
    /*  12 */
    trace_flag[TRACE_FLAG_FACTOR * 1636 + 9] = *val;
    break;
    /* 0 1   */

  case 13:
    trace_flag[TRACE_FLAG_FACTOR * 1792 + 9] = *val;   /* 1 0 ! */
    /*  13 */
    trace_flag[TRACE_FLAG_FACTOR * 1793 + 9] = *val;
    break;
    /* 0 1   */

  case 14:
    trace_flag[TRACE_FLAG_FACTOR * 928 + 9] = *val;   /* 1 0   */
    /*  14 */
    trace_flag[TRACE_FLAG_FACTOR * 1795 + 9] = *val;
    /* 0 0   */
    /*  14 */
    trace_flag[TRACE_FLAG_FACTOR * 1796 + 9] = *val;
    /* 0 0   */
    /*  14 */
    trace_flag[TRACE_FLAG_FACTOR * 1797 + 9] = *val;
    /* 0 0   */
    /*  14 */
    trace_flag[TRACE_FLAG_FACTOR * 1798 + 9] = *val;
    break;
    /* 0 1   */

  case 15:
    trace_flag[TRACE_FLAG_FACTOR * 1997 + 9] = *val;
    break;
    /* 1 1   */

  case 16:
    trace_flag[TRACE_FLAG_FACTOR * 1995 + 9] = *val;   /* 1 0   */
    /*  16 */
    trace_flag[TRACE_FLAG_FACTOR * 1996 + 9] = *val;
    /* 0 0   */
    /*  16 */
    trace_flag[TRACE_FLAG_FACTOR * 2685 + 9] = *val;
    break;
    /* 0 1   */

  case 17:
    trace_flag[TRACE_FLAG_FACTOR * 899 + 9] = *val;   /* 1 0 ! */
    /*  17 */
    trace_flag[TRACE_FLAG_FACTOR * 900 + 9] = *val;
    break;
    /* 0 1   */

  case 18:
    trace_flag[TRACE_FLAG_FACTOR * 1060 + 9] = *val;
    break;
    /* 1 1   */

  case 19:
    trace_flag[TRACE_FLAG_FACTOR * 1882 + 9] = *val;   /* 1 0   */
    /*  19 */
    trace_flag[TRACE_FLAG_FACTOR * 2114 + 9] = *val;
    /* 0 0   */
    /*  19 */
    trace_flag[TRACE_FLAG_FACTOR * 2115 + 9] = *val;
    break;
    /* 0 1   */

  case 20:
    trace_flag[TRACE_FLAG_FACTOR * 2287 + 9] = *val;   /* 1 0 !+*/
    /*  20 */
    trace_flag[TRACE_FLAG_FACTOR * 2306 + 9] = *val;
    /* 0 0   */
    /*  20 */
    trace_flag[TRACE_FLAG_FACTOR * 2327 + 9] = *val;
    /* 0 0   */
    /*  20 */
    trace_flag[TRACE_FLAG_FACTOR * 2328 + 9] = *val;
    /* 0 0   */
    /*  20 */
    trace_flag[TRACE_FLAG_FACTOR * 2332 + 9] = *val;
    break;
    /* 0 1   */

  case 21:
    trace_flag[TRACE_FLAG_FACTOR * 1161 + 9] = *val;   /* 1 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1170 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1316 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1317 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1318 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1319 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1320 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1321 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1322 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1323 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1324 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1328 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1329 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1335 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1336 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1337 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1338 + 9] = *val;
    /* 0 0   */
    /*  21 */
    trace_flag[TRACE_FLAG_FACTOR * 1646 + 9] = *val;
    break;
    /* 0 1   */

  case 22:
    trace_flag[TRACE_FLAG_FACTOR * 1155 + 9] = *val;   /* 1 0   */
    /*  22 */
    trace_flag[TRACE_FLAG_FACTOR * 1156 + 9] = *val;
    break;
    /* 0 1   */

  case 23:
    trace_flag[TRACE_FLAG_FACTOR * 329 + 9] = *val;   /* 1 0   */
    /*  23 */
    trace_flag[TRACE_FLAG_FACTOR * 341 + 9] = *val;
    /* 0 0   */
    /*  23 */
    trace_flag[TRACE_FLAG_FACTOR * 694 + 9] = *val;
    /* 0 0   */
    /*  23 */
    trace_flag[TRACE_FLAG_FACTOR * 696 + 9] = *val;
    /* 0 0   */
    /*  23 */
    trace_flag[TRACE_FLAG_FACTOR * 698 + 9] = *val;
    /* 0 0   */
    /*  23 */
    trace_flag[TRACE_FLAG_FACTOR * 2252 + 9] = *val;
    /* 0 0   */
    /*  23 */
    trace_flag[TRACE_FLAG_FACTOR * 2286 + 9] = *val;
    /* 0 0   */
    /*  23 */
    trace_flag[TRACE_FLAG_FACTOR * 2287 + 9] = *val;
    /* 0 0   */
    /*  23 */
    trace_flag[TRACE_FLAG_FACTOR * 2288 + 9] = *val;
    /* 0 0   */
    /*  23 */
    trace_flag[TRACE_FLAG_FACTOR * 2599 + 9] = *val;
    break;
    /* 0 1   */

  case 24:
    trace_flag[TRACE_FLAG_FACTOR * 718 + 9] = *val;   /* 1 0   */
    /*  24 */
    trace_flag[TRACE_FLAG_FACTOR * 2704 + 9] = *val;
    /* 0 0   */
    /*  24 */
    trace_flag[TRACE_FLAG_FACTOR * 2810 + 9] = *val;
    /* 0 0   */
    /*  24 */
    trace_flag[TRACE_FLAG_FACTOR * 2812 + 9] = *val;
    break;
    /* 0 1   */

  case 25:
    trace_flag[TRACE_FLAG_FACTOR * 1810 + 9] = *val;   /* 1 0   */
    /*  25 */
    trace_flag[TRACE_FLAG_FACTOR * 1816 + 9] = *val;
    /* 0 0   */
    /*  25 */
    trace_flag[TRACE_FLAG_FACTOR * 1824 + 9] = *val;
    /* 0 0   */
    /*  25 */
    trace_flag[TRACE_FLAG_FACTOR * 1825 + 9] = *val;
    /* 0 0   */
    /*  25 */
    trace_flag[TRACE_FLAG_FACTOR * 1827 + 9] = *val;
    break;
    /* 0 1   */

  case 26:
    trace_flag[TRACE_FLAG_FACTOR * 1731 + 9] = *val;   /* 1 0   */
    /*  26 */
    trace_flag[TRACE_FLAG_FACTOR * 1732 + 9] = *val;
    /* 0 0   */
    /*  26 */
    trace_flag[TRACE_FLAG_FACTOR * 1737 + 9] = *val;
    /* 0 0   */
    /*  26 */
    trace_flag[TRACE_FLAG_FACTOR * 1738 + 9] = *val;
    break;
    /* 0 1   */

  case 27:
    trace_flag[TRACE_FLAG_FACTOR * 647 + 9] = *val;   /* 1 0 !+*/
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 649 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 760 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 761 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 762 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 763 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 764 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 769 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 770 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1085 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1108 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1110 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1310 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1712 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1715 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1716 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1717 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1718 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1720 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1916 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 1922 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2580 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2583 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2630 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2668 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2679 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2680 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2681 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2684 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2687 + 9] = *val;
    /* 0 0   */
    /*  27 */
    trace_flag[TRACE_FLAG_FACTOR * 2695 + 9] = *val;
    break;
    /* 0 1   */

  case 28:
    trace_flag[TRACE_FLAG_FACTOR * 844 + 9] = *val;   /* 1 0 !+*/
    /*  28 */
    trace_flag[TRACE_FLAG_FACTOR * 845 + 9] = *val;
    /* 0 0   */
    /*  28 */
    trace_flag[TRACE_FLAG_FACTOR * 849 + 9] = *val;
    break;
    /* 0 1   */

  case 29:
    trace_flag[TRACE_FLAG_FACTOR * 779 + 9] = *val;   /* 1 0   */
    /*  29 */
    trace_flag[TRACE_FLAG_FACTOR * 2554 + 9] = *val;
    /* 0 0   */
    /*  29 */
    trace_flag[TRACE_FLAG_FACTOR * 2557 + 9] = *val;
    break;
    /* 0 1   */

  case 30:
    trace_flag[TRACE_FLAG_FACTOR * 1156 + 9] = *val;   /* 1 0 !+*/
    /*  30 */
    trace_flag[TRACE_FLAG_FACTOR * 1254 + 9] = *val;
    /* 0 0   */
    /*  30 */
    trace_flag[TRACE_FLAG_FACTOR * 1368 + 9] = *val;
    /* 0 0   */
    /*  30 */
    trace_flag[TRACE_FLAG_FACTOR * 1369 + 9] = *val;
    /* 0 0   */
    /*  30 */
    trace_flag[TRACE_FLAG_FACTOR * 1487 + 9] = *val;
    /* 0 0   */
    /*  30 */
    trace_flag[TRACE_FLAG_FACTOR * 1488 + 9] = *val;
    /* 0 0   */
    /*  30 */
    trace_flag[TRACE_FLAG_FACTOR * 1489 + 9] = *val;
    /* 0 0   */
    /*  30 */
    trace_flag[TRACE_FLAG_FACTOR * 1494 + 9] = *val;
    break;
    /* 0 1   */

  case 31:
    trace_flag[TRACE_FLAG_FACTOR * 883 + 9] = *val;
    break;
    /* 1 1 !+*/

  case 32:
    trace_flag[TRACE_FLAG_FACTOR * 1555 + 9] = *val;   /* 1 0   */
    /*  32 */
    trace_flag[TRACE_FLAG_FACTOR * 1556 + 9] = *val;
    break;
    /* 0 1   */

  case 33:
    trace_flag[TRACE_FLAG_FACTOR * 1557 + 9] = *val;   /* 1 0   */
    /*  33 */
    trace_flag[TRACE_FLAG_FACTOR * 1558 + 9] = *val;
    /* 0 0   */
    /*  33 */
    trace_flag[TRACE_FLAG_FACTOR * 1561 + 9] = *val;
    break;
    /* 0 1   */

  case 34:
    trace_flag[TRACE_FLAG_FACTOR * 1396 + 9] = *val;   /* 1 0   */
    /*  34 */
    trace_flag[TRACE_FLAG_FACTOR * 1409 + 9] = *val;
    /* 0 0   */
    /*  34 */
    trace_flag[TRACE_FLAG_FACTOR * 1418 + 9] = *val;
    /* 0 0   */
    /*  34 */
    trace_flag[TRACE_FLAG_FACTOR * 1428 + 9] = *val;
    break;
    /* 0 1   */

  case 35:
    trace_flag[TRACE_FLAG_FACTOR * 1362 + 9] = *val;   /* 1 0   */
    /*  35 */
    trace_flag[TRACE_FLAG_FACTOR * 1547 + 9] = *val;
    break;
    /* 0 1   */

  case 36:
    break;
    /* 1 1 ? */

  case 37:
    trace_flag[TRACE_FLAG_FACTOR * 2200 + 9] = *val;
    break;
    /* 1 1   */

  case 38:
    break;
    /* 1 1 ? */

  case 39:
    trace_flag[TRACE_FLAG_FACTOR * 1485 + 9] = *val;
    break;
    /* 1 1   */

  case 40:
    break;
    /* 1 1 ? */

  case 41:
    trace_flag[TRACE_FLAG_FACTOR * 1346 + 9] = *val;
    break;
    /* 1 1   */

  case 42:
    trace_flag[TRACE_FLAG_FACTOR * 1347 + 9] = *val;
    break;
    /* 1 1   */

  case 43:
    trace_flag[TRACE_FLAG_FACTOR * 1367 + 9] = *val;
    break;
    /* 1 1   */

  case 44:
    trace_flag[TRACE_FLAG_FACTOR * 1368 + 9] = *val;   /* 1 0   */
    /*  44 */
    trace_flag[TRACE_FLAG_FACTOR * 1369 + 9] = *val;
    /* 0 0   */
    /*  44 */
    trace_flag[TRACE_FLAG_FACTOR * 1487 + 9] = *val;
    break;
    /* 0 1   */

  case 45:
    trace_flag[TRACE_FLAG_FACTOR * 1371 + 9] = *val;   /* 1 0   */
    /*  45 */
    trace_flag[TRACE_FLAG_FACTOR * 1488 + 9] = *val;
    /* 0 0   */
    /*  45 */
    trace_flag[TRACE_FLAG_FACTOR * 1489 + 9] = *val;
    /* 0 0   */
    /*  45 */
    trace_flag[TRACE_FLAG_FACTOR * 1494 + 9] = *val;
    break;
    /* 0 1   */

  case 46:
    trace_flag[TRACE_FLAG_FACTOR * 1358 + 9] = *val;   /* 1 0   */
    /*  46 */
    trace_flag[TRACE_FLAG_FACTOR * 1359 + 9] = *val;
    /* 0 0   */
    /*  46 */
    trace_flag[TRACE_FLAG_FACTOR * 1360 + 9] = *val;
    /* 0 0   */
    /*  46 */
    trace_flag[TRACE_FLAG_FACTOR * 1361 + 9] = *val;
    break;
    /* 0 1   */

  case 47:
    trace_flag[TRACE_FLAG_FACTOR * 1352 + 9] = *val;   /* 1 0   */
    /*  47 */
    trace_flag[TRACE_FLAG_FACTOR * 1353 + 9] = *val;
    break;
    /* 0 1   */

  case 48:
    trace_flag[TRACE_FLAG_FACTOR * 1354 + 9] = *val;   /* 1 0   */
    /*  48 */
    trace_flag[TRACE_FLAG_FACTOR * 1355 + 9] = *val;
    /* 0 0   */
    /*  48 */
    trace_flag[TRACE_FLAG_FACTOR * 1357 + 9] = *val;
    break;
    /* 0 1   */

  case 49:
    trace_flag[TRACE_FLAG_FACTOR * 1366 + 9] = *val;   /* 1 0   */
    /*  49 */
    trace_flag[TRACE_FLAG_FACTOR * 1492 + 9] = *val;
    break;
    /* 0 1   */

  case 50:
    trace_flag[TRACE_FLAG_FACTOR * 1463 + 9] = *val;
    break;
    /* 1 1   */

  case 51:
    trace_flag[TRACE_FLAG_FACTOR * 1384 + 9] = *val;   /* 1 0   */
    /*  51 */
    trace_flag[TRACE_FLAG_FACTOR * 1400 + 9] = *val;
    /* 0 0   */
    /*  51 */
    trace_flag[TRACE_FLAG_FACTOR * 1411 + 9] = *val;
    /* 0 0   */
    /*  51 */
    trace_flag[TRACE_FLAG_FACTOR * 1419 + 9] = *val;
    /* 0 0   */
    /*  51 */
    trace_flag[TRACE_FLAG_FACTOR * 1430 + 9] = *val;
    /* 0 0   */
    /*  51 */
    trace_flag[TRACE_FLAG_FACTOR * 1471 + 9] = *val;
    /* 0 0   */
    /*  51 */
    trace_flag[TRACE_FLAG_FACTOR * 1484 + 9] = *val;
    break;
    /* 0 1   */

  case 52:
    trace_flag[TRACE_FLAG_FACTOR * 1437 + 9] = *val;   /* 1 0   */
    /*  52 */
    trace_flag[TRACE_FLAG_FACTOR * 1438 + 9] = *val;
    /* 0 0   */
    /*  52 */
    trace_flag[TRACE_FLAG_FACTOR * 1439 + 9] = *val;
    /* 0 0   */
    /*  52 */
    trace_flag[TRACE_FLAG_FACTOR * 1440 + 9] = *val;
    /* 0 0   */
    /*  52 */
    trace_flag[TRACE_FLAG_FACTOR * 1441 + 9] = *val;
    /* 0 0   */
    /*  52 */
    trace_flag[TRACE_FLAG_FACTOR * 1472 + 9] = *val;
    /* 0 0   */
    /*  52 */
    trace_flag[TRACE_FLAG_FACTOR * 1491 + 9] = *val;
    /* 0 0   */
    /*  52 */
    trace_flag[TRACE_FLAG_FACTOR * 1545 + 9] = *val;
    break;
    /* 0 1   */

  case 53:
    trace_flag[TRACE_FLAG_FACTOR * 1442 + 9] = *val;   /* 1 0   */
    /*  53 */
    trace_flag[TRACE_FLAG_FACTOR * 1443 + 9] = *val;
    /* 0 0   */
    /*  53 */
    trace_flag[TRACE_FLAG_FACTOR * 1444 + 9] = *val;
    /* 0 0   */
    /*  53 */
    trace_flag[TRACE_FLAG_FACTOR * 1445 + 9] = *val;
    /* 0 0   */
    /*  53 */
    trace_flag[TRACE_FLAG_FACTOR * 1446 + 9] = *val;
    /* 0 0   */
    /*  53 */
    trace_flag[TRACE_FLAG_FACTOR * 1458 + 9] = *val;
    break;
    /* 0 1   */

  case 54:
    trace_flag[TRACE_FLAG_FACTOR * 1459 + 9] = *val;   /* 1 0   */
    /*  54 */
    trace_flag[TRACE_FLAG_FACTOR * 1463 + 9] = *val;
    break;
    /* 0 1   */

  case 55:
    trace_flag[TRACE_FLAG_FACTOR * 1450 + 9] = *val;   /* 1 0   */
    /*  55 */
    trace_flag[TRACE_FLAG_FACTOR * 1452 + 9] = *val;
    /* 0 0   */
    /*  55 */
    trace_flag[TRACE_FLAG_FACTOR * 1456 + 9] = *val;
    /* 0 0   */
    /*  55 */
    trace_flag[TRACE_FLAG_FACTOR * 1457 + 9] = *val;
    /* 0 0   */
    /*  55 */
    trace_flag[TRACE_FLAG_FACTOR * 1461 + 9] = *val;
    /* 0 0   */
    /*  55 */
    trace_flag[TRACE_FLAG_FACTOR * 1465 + 9] = *val;
    break;
    /* 0 1   */

  case 56:
    trace_flag[TRACE_FLAG_FACTOR * 999 + 9] = *val;   /* 1 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 999 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1000 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1002 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1438 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1439 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1440 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1441 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1465 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1474 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1494 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1497 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1498 + 9] = *val;
    /* 0 0   */
    /*  56 */
    trace_flag[TRACE_FLAG_FACTOR * 1544 + 9] = *val;
    break;
    /* 0 1   */

  case 57:
    trace_flag[TRACE_FLAG_FACTOR * 1383 + 9] = *val;   /* 1 0   */
    /*  57 */
    trace_flag[TRACE_FLAG_FACTOR * 1396 + 9] = *val;
    /* 0 0   */
    /*  57 */
    trace_flag[TRACE_FLAG_FACTOR * 1409 + 9] = *val;
    /* 0 0   */
    /*  57 */
    trace_flag[TRACE_FLAG_FACTOR * 1418 + 9] = *val;
    /* 0 0   */
    /*  57 */
    trace_flag[TRACE_FLAG_FACTOR * 1428 + 9] = *val;
    break;
    /* 0 1   */

  case 58:
    trace_flag[TRACE_FLAG_FACTOR * 1395 + 9] = *val;   /* 1 0   */
    /*  58 */
    trace_flag[TRACE_FLAG_FACTOR * 1407 + 9] = *val;
    break;
    /* 0 1   */

  case 59:
    trace_flag[TRACE_FLAG_FACTOR * 1408 + 9] = *val;   /* 1 0   */
    /*  59 */
    trace_flag[TRACE_FLAG_FACTOR * 1426 + 9] = *val;
    /* 0 0   */
    /*  59 */
    trace_flag[TRACE_FLAG_FACTOR * 1481 + 9] = *val;
    /* 0 0   */
    /*  59 */
    trace_flag[TRACE_FLAG_FACTOR * 1482 + 9] = *val;
    /* 0 0   */
    /*  59 */
    trace_flag[TRACE_FLAG_FACTOR * 1483 + 9] = *val;
    /* 0 0   */
    /*  59 */
    trace_flag[TRACE_FLAG_FACTOR * 1490 + 9] = *val;
    /* 0 0   */
    /*  59 */
    trace_flag[TRACE_FLAG_FACTOR * 1545 + 9] = *val;
    break;
    /* 0 1   */

  case 60:
    trace_flag[TRACE_FLAG_FACTOR * 1369 + 9] = *val;
    break;
    /* 1 1 !+*/

  case 61:
    break;
    /* 1 1 !+*/

  case 62:   /* trace_flag[ 1472 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0 !+*/
    /*  62 */
    /* trace_flag[ 1498 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  62 */
    /* trace_flag[ 1558 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  62 */
    /* trace_flag[ 1597 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  62 */
    /* trace_flag[ 2201 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 63:   /* trace_flag[ 1387 * TRACE_FLAG_FACTOR + 9] := val */
    break;
    /* 1 1   */

  case 64:
    break;
    /* 1 1 !+*/

  case 65:   /* trace_flag[ 2196 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /*  65 */
    /* trace_flag[ 2201 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  65 */
    /* trace_flag[ 2204 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 66:
    break;
    /* 1 1 !+*/

  case 67:
    break;
    /* 1 1 !+*/

  case 68:
    break;
    /* 1 1 ? */

  case 69:
    break;
    /* 1 1 !+*/

  case 70:   /* trace_flag[ 1587 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0 !+*/
    /*  70 */
    /* trace_flag[ 1589 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  70 */
    /* trace_flag[ 1590 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  70 */
    /* trace_flag[ 1591 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  70 */
    /* trace_flag[ 1992 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  70 */
    /* trace_flag[ 2014 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  70 */
    /* trace_flag[ 2018 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  70 */
    /* trace_flag[ 2020 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 71:   /* trace_flag[ 1603 * TRACE_FLAG_FACTOR + 9] := val */
    break;
    /* 1 1   */

  case 72:
    break;
    /* 1 1 !+*/

  case 73:   /* trace_flag[ 1266 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /*  73 */
    /* trace_flag[ 1272 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  73 */
    /* trace_flag[ 1281 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 74:   /* trace_flag[ 1300 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /*  74 */
    /* trace_flag[ 1779 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1780 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1782 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1854 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1855 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1859 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1860 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1861 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1862 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1890 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1891 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1892 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  74 */
    /* trace_flag[ 1893 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 75:   /* trace_flag[ 1870 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /*  75 */
    /* trace_flag[ 1871 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 76:   /* trace_flag[ 1874 * TRACE_FLAG_FACTOR + 9] := val */
    break;
    /* 1 1   */

  case 77:   /* trace_flag[  421 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /*  77 */
    /* trace_flag[  426 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  77 */
    /* trace_flag[  620 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  77 */
    /* trace_flag[  639 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  77 */
    /* trace_flag[  642 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  77 */
    /* trace_flag[ 1266 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  77 */
    /* trace_flag[ 1272 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  77 */
    /* trace_flag[ 1281 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  77 */
    /* trace_flag[ 1289 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  77 */
    /* trace_flag[ 2754 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 78:   /* trace_flag[ 1760 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /*  78 */
    /* trace_flag[ 1761 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  78 */
    /* trace_flag[ 1946 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  78 */
    /* trace_flag[ 1955 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  78 */
    /* trace_flag[ 1960 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  78 */
    /* trace_flag[ 1962 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  78 */
    /* trace_flag[ 2755 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 79:   /* trace_flag[ 1218 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /*  79 */
    /* trace_flag[ 1598 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  79 */
    /* trace_flag[ 1602 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  79 */
    /* trace_flag[ 1744 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  79 */
    /* trace_flag[ 1745 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  79 */
    /* trace_flag[ 1746 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  79 */
    /* trace_flag[ 1747 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  79 */
    /* trace_flag[ 1755 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  79 */
    /* trace_flag[ 1903 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 80:   /* trace_flag[ 2740 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /*  80 */
    /* trace_flag[ 2741 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  80 */
    /* trace_flag[ 2745 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  80 */
    /* trace_flag[ 2746 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  80 */
    /* trace_flag[ 2747 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  80 */
    /* trace_flag[ 2756 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 81:
    break;
    /* 1 1 !+*/

  case 82:   /* trace_flag[ 2757 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /*  82 */
    /* trace_flag[ 2758 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /*  82 */
    /* trace_flag[ 2759 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 83:
    break;
    /* 1 1 !+*/

  case 84:
    break;
    /* 1 1 !+*/

  case 85:
    break;
    /* 1 1 !+*/

  case 86:
    break;
    /* 1 1 !+*/

  case 87:
    break;
    /* 1 1 !+*/

  case 88:
    break;
    /* 1 1 !+*/

  case 89:
    break;
    /* 1 1 !+*/

  case 90:
    break;
    /* 1 1 !+*/

  case 91:
    break;
    /* 1 1 !+*/

  case 92:
    break;
    /* 1 1 !+*/

  case 93:
    break;
    /* 1 1 !+*/

  case 94:
    break;
    /* 1 1 !+*/

  case 95:
    break;
    /* 1 1 !+*/

  case 96:
    break;
    /* 1 1 !+*/

  case 97:
    break;
    /* 1 1 !+*/

  case 98:
    break;
    /* 1 1 !+*/

  case 99:
    break;
    /* 1 1 !+*/

  case 100:
    break;
    /* 1 1 !+*/

  case 101:
    trace_flag[TRACE_FLAG_FACTOR * 1281 + 9] = *val;
    break;
    /* 1 1 !+*/

  case 102:
    trace_flag[TRACE_FLAG_FACTOR * 420 + 9] = *val;   /* 1 0 !+*/
    /* 102 */
    trace_flag[TRACE_FLAG_FACTOR * 425 + 9] = *val;
    /* 0 0   */
    /* 102 */
    trace_flag[TRACE_FLAG_FACTOR * 430 + 9] = *val;
    /* 0 0   */
    /* 102 */
    trace_flag[TRACE_FLAG_FACTOR * 431 + 9] = *val;
    /* 0 0   */
    /* 102 */
    trace_flag[TRACE_FLAG_FACTOR * 441 + 9] = *val;
    /* 0 0   */
    /* 102 */
    trace_flag[TRACE_FLAG_FACTOR * 442 + 9] = *val;
    /* 0 0   */
    /* 102 */
    trace_flag[TRACE_FLAG_FACTOR * 877 + 9] = *val;
    /* 0 0   */
    /* 102 */
    trace_flag[TRACE_FLAG_FACTOR * 879 + 9] = *val;
    break;
    /* 0 1   */

  case 103:
    trace_flag[TRACE_FLAG_FACTOR * 812 + 9] = *val;
    break;
    /* 1 1 !+*/

  case 104:
    break;
    /* 1 1 !+*/

  case 105:
    trace_flag[TRACE_FLAG_FACTOR * 1471 + 9] = *val;
    break;
    /* 1 1 !+*/

  case 106:
    break;
    /* 1 1 !+*/

  case 107:   /* trace_flag[ 1303 * TRACE_FLAG_FACTOR + 9] := val; */
    break;
    /* 1 0   */
    /* 107 */
    /* trace_flag[ 1784 * TRACE_FLAG_FACTOR + 9] := val; */
    /* 0 0   */
    /* 107 */
    /* trace_flag[ 2642 * TRACE_FLAG_FACTOR + 9] := val */
    /* 0 1   */

  case 108:
    break;
    /* 1 1 !+*/

  case 109:
    break;
    /* 1 1 !+*/

  case 110:
    break;
    /* 1 1 !+*/

  case 111:
    break;
    /* 1 1 !+*/

  case 112:
    break;
    /* 1 1 !+*/

  case 113:
    break;
    /* 1 1 !+*/

  case 114:
    break;
    /* 1 1 !+*/

  case 115:
    break;
    /* 1 1 !+*/

  case 116:
    trace_flag[TRACE_FLAG_FACTOR * 1493 + 9] = *val;
    break;
    /* 1 1 !+*/

  case 117:
    break;
    /* 1 1 !+*/

  case 118:
    break;
    /* 1 1 !+*/

  case 119:
    break;
    /* 1 1 !+*/

  case 120:
    break;
    /* 1 1 ? */

  case 121:
    break;
    /* 1 1 !+*/

  case 122:
    break;
    /* 1 1 !+*/

  case 123:
    break;
    /* 1 1 !+*/

  case 124:
    trace_flag[TRACE_FLAG_FACTOR * 2641 + 9] = *val;
    break;
    /* 1 1 !+*/

  case 125:
    trace_flag[TRACE_FLAG_FACTOR * 624 + 9] = *val;   /* 1 0 !+*/
    /* 125 */
    trace_flag[TRACE_FLAG_FACTOR * 625 + 9] = *val;
    break;
    /* 0 1   */

  case 126:
    trace_flag[TRACE_FLAG_FACTOR * 926 + 9] = *val;   /* 1 0 !+*/
    /* 126 */
    trace_flag[TRACE_FLAG_FACTOR * 1906 + 9] = *val;
    /* 0 0   */
    /* 126 */
    trace_flag[TRACE_FLAG_FACTOR * 1954 + 9] = *val;
    /* 0 0   */
    /* 126 */
    trace_flag[TRACE_FLAG_FACTOR * 2434 + 9] = *val;
    break;
    /* 0 1   */

  case 127:
    trace_flag[TRACE_FLAG_FACTOR * 615 + 9] = *val;   /* 1 0 !+*/
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 647 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 727 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 736 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 767 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 769 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 770 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 926 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 929 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 930 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1251 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1281 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1676 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1681 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1921 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1927 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1929 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1932 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1947 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 1959 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2004 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2005 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2145 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2210 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2211 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2217 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2466 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2481 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2554 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2559 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2561 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2562 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2580 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2583 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2585 + 9] = *val;
    /* 0 0   */
    /* 127 */
    trace_flag[TRACE_FLAG_FACTOR * 2641 + 9] = *val;
    break;
    /* 0 1   */

  case 128:
    break;
    /* 1 1 ? */
  }
}  /* set_flag */


Static Void switch_new(number, hit)
t_integer *number, *hit;
{
  if (*number <= 40) {
    switch (*number) {

    case 1:
      switch_var(&c_partitioning, hit, " Partitioning", 13L);
      break;

    case 2:
      switch_var(&terminal, hit, " Keyboard", 9L);
      break;

    case 3:
      switch_var(&echo, hit, " Echo", 5L);
      break;

    case 4:
      switch_var(&diary, hit, " Diary", 6L);
      break;

    case 5:
      switch_var(&timer, hit, " Timer", 6L);
      break;

    case 6:
      switch_var(&graph_mode, hit, " Graph mode", 11L);
      break;

    case 7:
      switch_var(&decomposable_mode, hit, " Decomposable mode", 18L);
      break;

    case 8:
      switch_var(&large, hit, " Large", 6L);
      break;

    case 9:
      switch_var(&global_write_options->line_form, hit,
		 " Short test output", 18L);
      break;

    case 10:
      switch_var(&report, hit, " Report", 7L);
      break;

    case 11:
      switch_var(&re_use_test, hit, " Reuse tests", 12L);
      break;

    case 12:
      switch_var(&adj_df, hit, " Adjusted df", 12L);
      break;

    case 13:
      switch_var(&trace, hit, " Trace", 6L);
      break;

    case 14:
      switch_var(&exact_test, hit, " Exact test", 11L);
      break;

    case 15:
      switch_var(&exact_log_l, hit, " Only Exact Deviance", 20L);
      break;

    case 16:
      switch_var(&fast, hit, " Fast", 5L);
      break;

    case 17:
      switch_var(&exact_test_for_sum_up, hit, " Exact test total", 17L);
      break;

    case 18:
      switch_var(&exact_test_for_partitioning, hit, " Exact test parts",
		 17L);
      break;

    case 19:
      switch_var(&exact_test_for_test_models, hit, " Exact test unparted",
		 20L);
      break;

    case 20:
      switch_var(&link_eh_pack->graphical_search, hit, " Graphical search",
		 17L);
      break;

    case 21:
      switch_var(&echo_note, hit, " Note", 5L);
      break;

    case 22:
      switch_var(&debug, hit, " Debug", 6L);
      break;

    case 23:
      switch_var(&dummy_option, hit, " Option", 7L);
      break;

    case 24:
      switch_var(&log_on, hit, " Log", 4L);
      break;

    case 25:
      switch_var(&dump, hit, " Dump", 5L);
      break;

    case 26:
      switch_var(&sorted, hit, " Sorted", 7L);
      break;

    case 27:
      switch_var(&diary_set, hit, " Keep Diary", 11L);
      break;

    case 28:
      switch_var(&report_set, hit, " Keep Report", 12L);
      break;

    case 29:
      switch_var(&log_set, hit, " Keep Log", 9L);
      break;

    case 30:
      switch_var(&log_data_on, hit, " Log Data", 9L);
      break;

    case 31:
      switch_var(&dump_set, hit, " Keep Dump", 10L);
      break;

    case 32:
      switch_var(&pause_output, hit, " Pausing of output", 18L);
      break;

    case 33:
      switch_var(&permit_log_l, hit, " Huge", 5L);
      break;

    case 34:
      switch_var(&ic, hit, " IC", 3L);
      break;

    case 35:
      switch_var(&bic, hit, " BIC", 4L);
      break;

    case 36:
      switch_var(&em, hit, " EM", 3L);
      break;

    case 37:
      switch_var(&note_warnings, hit, " Warnings", 9L);
      break;

    case 38:
      switch_var(&permit_condensed, hit, " Permit condensed", 17L);
      break;

    case 39:
      switch_var(&decompose_incomplete, hit, " Decompose incomplet", 20L);
      break;

    case 40:
      switch_var(&homogeneous_mode, hit, " Homogeneous mode", 17L);
      break;
    }
    /*$ifdef TRACE*/
    return;
  }
  if (99 < *number && *number < 228) {
    switch_var(&boolean_option[*number - 100], hit, " Debugging option",
	       17L);
    set_flag(&boolean_option[*number - 100], hit, *number - 100);
    write_pch(stdout, " Switch set (1): ", 17L);
    write_integer(stdout, *number - 100, 3L);
    return;
  }
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (282 < *number && *number < 2829) {
    switch_var(&trace_flag[*number * TRACE_FLAG_FACTOR + 9], hit,
	       " ", 0L);
    write_pch(stdout, " Switch set (2): ", 17L);
    write_integer(stdout, *number * TRACE_FLAG_FACTOR + 9, 3L);
    return;
  }
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (2828 >= *number || *number >= 30000) {
    write_pch(stdout, " Invalid switch: ", 17L);
    write_integer(stdout, *number, 3L);
    return;
  }
  /*$endif TRACE*/
  switch_var(&trace_flag[*number], hit, " ", 0L);
  write_pch(stdout, " Switch set (3): ", 17L);
  write_integer(stdout, *number, 3L);
}  /* switch_new */


Static Void switch_(number, hit)
t_integer number, hit;
{
  switch_new(&number, &hit);
}  /* switch */


Static Void print_table_type(table_type, log_trans)
t_integer table_type;
boolean log_trans;
{
  if (log_trans)
    write_pch(stdout, "Log(", 4L);
  if (table_type < MAX_NUMBER_OF_TABLE_VALUES * 2 - 2)
    table_type &= MAX_NUMBER_OF_TABLE_VALUES - 1;
  switch (table_type) {

  case 0:
    write_pch(stdout, "Observed", 8L);
    break;

  case 1:
    write_pch(stdout, "Probabilities", 13L);
    break;

  case 2:
    write_pch(stdout, "Expected", 8L);
    break;

  case 3:
    write_pch(stdout, "Residuals: Abs", 14L);
    break;

  case 4:
    write_pch(stdout, "Residuals: F-res", 16L);
    break;

  case 5:
    write_pch(stdout, "Residuals: Res-F", 16L);
    break;

  case 6:
    write_pch(stdout, "Residuals: G-res", 16L);
    break;

  case 7:
    write_pch(stdout, "Residuals: Res-G", 16L);
    break;

  case 8:
    write_pch(stdout, "Adjusted", 8L);
    break;

  case 9:
    write_pch(stdout, "Standardized", 12L);
    break;

  case 10:
    write_pch(stdout, "Residuals: L-res", 16L);
    break;

  case 11:
    write_pch(stdout, "Freeman-Tukey dev. ", 19L);
    break;

  case 12:
    write_pch(stdout, "2(/n-/m)", 8L);
    break;

  case 13:
    write_pch(stdout, "Power-divergence ", 17L);
    break;

  case 14:
    write_pch(stdout, "Table index", 11L);
    break;

  case 15:
    write_pch(stdout, "Structural Zero", 15L);
    break;

  case 16:
    write_pch(stdout, "Leverage", 8L);
    break;

  case 63:
    write_pch(stdout, "Obs. for Struct.Zero", 20L);
    break;

  case 101:
    write_pch(stdout, "Uniform", 7L);
    break;

  case 102:
    write_pch(stdout, "Rankit", 6L);
    break;

  case 103:
    write_pch(stdout, "Normal", 6L);
    break;

  case 104:
    write_pch(stdout, "Base", 4L);
    break;

  case 105:
    write_pch(stdout, "Current", 7L);
    break;

  case 106:
    write_pch(stdout, "Complete", 8L);
    break;

  case 107:
    write_pch(stdout, "Log", 3L);
    break;
  }
  if (log_trans)
    write_char(stdout, ')');
}  /* print_table_type */


Static boolean current()
{
  if (link_current == NULL) {
    write_pch(stdout, " No CURRENT model", 17L);
    return false;
  } else
    return true;
}  /* current */


Static boolean base()
{
  if (link_base == NULL) {
    write_pch(stdout, " No BASE model", 14L);
    return false;
  } else
    return true;
}  /* base */


Static boolean current_and_base()
{
  boolean Result;

  Result = current();
  if (link_base != NULL)
    return Result;
  if (link_current == NULL)
    write_line(stdout);
  write_pch(stdout, " No BASE model", 14L);
  return false;
/* p2c: coco_d_p2c.p: Note: Deleting unreachable code [255] */
}  /* current_and_base */


Static boolean current_ifail(ifail)
t_integer *ifail;
{
  if (link_current == NULL) {
    /* write_pch(output, ' No CURRENT model@@@', 17); */
    *ifail = 22;
    return false;
  } else
    return true;
}  /* current_ifail */


Static boolean base_ifail(ifail)
t_integer *ifail;
{
  if (link_base == NULL) {
    /* write_pch(output, ' No BASE model@@@@@@', 14); */
    *ifail = 23;
    return false;
  } else
    return true;
}  /* base_ifail */


Static boolean current_and_base_ifail(ifail)
t_integer *ifail;
{
  boolean Result;

  Result = current_ifail(ifail);
  if (link_base == NULL) {
    /* if link_current = nil then
       write_line(output);
    write_pch(output, ' No BASE model@@@@@@', 14); */
    *ifail = 23;
    return false;
  }
  return Result;
}  /* current_and_base_ifail */


Static Void print_vertex_set_on_report(f, a)
FILE *f;
long *a;
{
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      print_vertex_on_report(f, v, 0L);
  }
  if (P_inset(double_vertex, a))
    write_char_text(f, '^');
  write_char_text(f, '.');
}  /* print_vertex_set_on_report */


Static Void print_vertex_set_x_on_report(f, a)
FILE *f;
long *a;
{
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      print_vertex_on_report(f, v, 0L);
  }
  if (P_inset(double_vertex, a))
    write_char_text(f, '^');
}  /* print_vertex_set_x_on_report */


Local Void print_vertex_set_x(f, a)
FILE *f;
long *a;
{
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      print_vertex_on_report(f, v, 0L);
  }
  if (P_inset(double_vertex, a))
    write_char_text(f, '^');
}  /* print_vertex_set_x */


Static Void print_set_list_on_report(f, p)
FILE *f;
t_set_list *p;
{
  t_integer line_count = 20;
  t_integer set_width;

  while (p != NULL) {
    if (long_names) {
      set_width = long_name_set_width(p->vertex_set);
      if (line_count + set_width > line_length &&
	  line_length < MAX_LINE_LENGTH) {
	write_line_text(f);
	line_count = 0;
      }
      line_count += set_width;
    }
    print_vertex_set_x(f, p->vertex_set);
    p = p->pointer;
    if (p != NULL)
      write_char_text(f, ',');
  }
  write_char_text(f, '.');
}  /* print_set_list_on_report */


Static Void print_triple_g_c_report(f, g_c_1, g_c_2, g_c_3, start)
FILE *f;
t_set_list **g_c_1, **g_c_2, **g_c_3;
t_integer start;
{
  print_set_list_on_report(f, *g_c_1);
  write_pch_10_text(f, " / ", 3L);
  print_set_list_on_report(f, *g_c_2);
  write_pch_10_text(f, " / ", 3L);
  print_set_list_on_report(f, *g_c_3);
}  /* print_triple_g_c_report */


Static Void print_vertex_set(a)
long *a;
{
  t_vertex v;

  write_char(stdout, '[');
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      print_vertex(v);
  }
  if (P_inset(double_vertex, a))
    write_char(stdout, '^');
  write_char(stdout, ']');
}  /* print_vertex_set */


Static Void print_discrete_vertex_set(a)
long *a;
{
  t_discrete_vertex v;

  write_char(stdout, '[');
  for (v = first_discrete_vertex; v <= last_discrete_vertex; v++) {
    if (P_inset(v, a))
      print_discrete_vertex(v, 0L);
  }
  if (P_inset(double_vertex, a))
    write_char(stdout, '^');
  write_char(stdout, ']');
}  /* print_discrete_vertex_set */


Static Void print_continuous_vertex_set(a)
long *a;
{
  t_continuous_vertex v;

  write_char(stdout, '[');
  for (v = first_continuous_vertex; v <= last_continuous_vertex; v++) {
    if (P_inset(v, a))
      print_continuous_vertex(v, 0L);
  }
  if (P_inset(double_vertex, a))
    write_char(stdout, '^');
  write_char(stdout, ']');
}  /* print_continuous_vertex_set */


Static Void print_vertex_set_table(a)
long *a;
{
  t_vertex v;
  t_integer x = 0;
  t_integer y;

  write_char(stdout, '[');
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      print_vertex(v);
    else
      x++;
  }
  if (P_inset(double_vertex, a))
    write_char(stdout, '^');
  else
    x++;
  write_char(stdout, ']');
  if (x > 12) {
    for (y = 1; y <= x % 10; y++)
      write_char(stdout, ' ');
  } else {
    for (y = 1; y <= x; y++)
      write_char(stdout, ' ');
  }
}  /* print_vertex_set_table */


Static Void print_vertex_set_table_full(a)
long *a;
{
  t_vertex v;
  t_integer x = 0;
  t_integer y;

  write_char(stdout, '[');
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      print_vertex(v);
    else
      x++;
  }
  if (P_inset(double_vertex, a))
    write_char(stdout, '^');
  else
    x++;
  write_char(stdout, ']');
  for (y = 1; y <= x; y++)
    write_char(stdout, ' ');
}  /* print_vertex_set_table_full */


Static Void print_g_c_from_stop(p, from, start, line_length, stop)
t_set_list *p;
t_integer from, start, line_length, *stop;
{
  t_integer set_width;

  write_char(stdout, '[');
  *stop = from;
  while (p != NULL) {
    if (long_names)
      set_width = long_name_set_width(p->vertex_set) + 2;
    else
      set_width = cardinality(p->vertex_set) + 2;
    if ((*stop != start ||
	 *stop + set_width - start > (line_length - start) / 2) &&
	*stop + set_width > line_length && line_length < MAX_LINE_LENGTH) {
      write_line(stdout);
      if (long_names && start > 10)
	write_space(stdout, 10L);
      else
	write_space(stdout, start);
      *stop = start;
    }
    print_vertex_set(p->vertex_set);
    *stop += set_width;
    p = p->pointer;
  }
  write_char(stdout, ']');
}  /* print_g_c_from_stop */


Static Void print_g_c_from(p, from, start, line_length)
t_set_list *p;
t_integer from, start, line_length;
{
  t_integer stop;

  print_g_c_from_stop(p, from, start, line_length, &stop);
}  /* print_g_c_from */


Static Void print_g_c(p, start, line_length)
t_set_list *p;
t_integer start, line_length;
{
  t_integer stop;

  print_g_c_from_stop(p, start, start, line_length, &stop);
}  /* print_g_c */


Static Void print_g_c_slash(p, start, line_length)
t_set_list *p;
t_integer start, line_length;
{
  t_integer stop;

  print_g_c_from_stop(p, start, start, line_length, &stop);
  write_pch(stdout, " / ", 3L);
}  /* print_g_c_slash */


Static Void print_g_c_stop(p, start, line_length, stop)
t_set_list *p;
t_integer start, line_length, *stop;
{
  print_g_c_from_stop(p, start, start, line_length, stop);
}  /* print_g_c_stop */


Static Void print_g_c_list(a)
t_g_c_list *a;
{
  write_line(stdout);
  while (a != NULL) {
    write_space(stdout, 5L);
    print_g_c_from(a->g_c, 5L, 6L, line_length);
    write_line(stdout);
    a = a->pointer;
  }
  /* write_line(output) */
}  /* print_g_c_list */


Static Void print_triple_g_c(g_c_1, g_c_2, g_c_3, start)
t_set_list **g_c_1, **g_c_2, **g_c_3;
t_integer start;
{
  print_g_c_slash(*g_c_1, start, line_length);
  print_g_c_slash(*g_c_2, start, line_length);
  print_g_c(*g_c_3, start, line_length);
}  /* print_triple_g_c */


Static Void write_id_type(id)
t_model_specification **id;
{
  if (*id == NULL) {
    write_pch(stdout, " Model is corrupted!", 20L);
    return;
  }
  if ((*id)->model_type == pure_discrete) {
    write_pch(stdout, " Model is discrete", 18L);
    return;
  }
  if ((*id)->model_type == pure_continuous) {
    write_pch(stdout, " Model is continuous", 20L);
    return;
  }
  if ((*id)->UU.U1.homogeneous)
    write_pch(stdout, " Modl is homogeneous", 20L);
  else
    write_pch(stdout, " Model is mixed", 15L);
}  /* write_id_type */


Static Void write_model_type(model)
t_model **model;
{
  write_id_type(&(*model)->id);
}  /* write_model_type */


Static Void print_id_from_stop(identification, print_causal, from, start,
			       line_length, stop)
t_model_specification **identification;
boolean print_causal;
t_integer from, start, line_length, *stop;
{
  if (*identification == NULL) {
    write_pch(stdout, " ?: Error - Invalid model.", 26L);
    return;
  }
  if ((*identification)->model_type == pure_discrete)
    print_g_c_from_stop((*identification)->UU.g_c_log_linear, from, start,
			line_length, stop);
  else if ((*identification)->model_type == pure_continuous)
    print_g_c_from_stop((*identification)->UU.g_c_covariance, from, start,
			line_length, stop);
  else if ((*identification)->model_type == mixed) {
    print_g_c_from_stop((*identification)->UU.U1.g_c_discrete, from, start,
			line_length, stop);
    write_pch(stdout, " / ", 3L);
    from = *stop;
    print_g_c_from_stop((*identification)->UU.U1.g_c_linear, from, start,
			line_length, stop);
    write_pch(stdout, " / ", 3L);
    from = *stop;
    print_g_c_from_stop((*identification)->UU.U1.g_c_quadratic, from, start,
			line_length, stop);
  }
  if (!(print_causal && (*identification)->causal_structure != NULL))
    return;
  if (P_setequal((*identification)->causal_structure->vertex_set, empty_set))
    return;
  write_pch(stdout, " | ", 3L);
  if ((*identification)->causal_structure->pointer == NULL &&
      P_setequal((*identification)->causal_structure->vertex_set, empty_set))
    write_pch(stdout, " ? ", 3L);
  else
    print_g_c_from_stop((*identification)->causal_structure, from, start,
			line_length, stop);
}  /* print_model_g_c_from_stop */


Static Void print_id_from(identification, print_causal, from, start,
			  line_length)
t_model_specification **identification;
boolean print_causal;
t_integer from, start, line_length;
{
  t_integer stop;

  print_id_from_stop(identification, print_causal, from, start, line_length,
		     &stop);
}  /* print_id_from */


Static Void print_id(identification, print_causal, start, line_length)
t_model_specification **identification;
boolean print_causal;
t_integer start, line_length;
{
  t_integer stop;

  print_id_from_stop(identification, print_causal, start, start, line_length,
		     &stop);
}  /* print_id */


Static Void print_model_g_c(model, start)
t_model **model;
t_integer start;
{
  t_integer stop;

  print_id_from_stop(&(*model)->id, true, start, start, line_length, &stop);
}  /* print_model_g_c */


Static Void print_model_g_c_report(f, model, start)
FILE *f;
t_model **model;
t_integer start;
{
  if (*model == NULL)
    return;
  if ((*model)->id == NULL) {
    write_pch_30_text(f, " ?: Error - Invalid model.", 26L);
    return;
  }
  print_vertex_set_on_report(f, (*model)->id->vertices);
  write_char_text(f, '/');
  write_char_text(f, '/');
  if ((*model)->id->model_type == pure_discrete)
    print_set_list_on_report(f, (*model)->id->UU.g_c_log_linear);
  else if ((*model)->id->model_type == pure_continuous)
    print_set_list_on_report(f, (*model)->id->UU.g_c_covariance);
  else if ((*model)->id->model_type == mixed) {
    print_set_list_on_report(f, (*model)->id->UU.U1.g_c_discrete);
    write_pch_10_text(f, " / ", 3L);
    print_set_list_on_report(f, (*model)->id->UU.U1.g_c_linear);
    write_pch_10_text(f, " / ", 3L);
    print_set_list_on_report(f, (*model)->id->UU.U1.g_c_quadratic);
  }
  if ((*model)->id->causal_structure == NULL)
    return;
  if (!P_setequal((*model)->id->causal_structure->vertex_set, empty_set)) {
    write_pch_10_text(f, " | ", 3L);
    print_set_list_on_report(f, (*model)->id->causal_structure);
  }
}  /* print_model_g_c_report */


Static Void print_model_g_c_and_type(model, start)
t_model **model;
t_integer start;
{
  write_space(stdout, start);
  write_pch(stdout, "# ", 2L);
  write_model_type(model);
  if (mixed_data && (*model)->id->model_type == mixed) {
    write_space(stdout, 1L);
    write_boolean(stdout, (*model)->id->UU.U1.homogeneous);
    write_space(stdout, 1L);
    write_boolean(stdout, (*model)->id->UU.U1.full_specified);
  }
  write_pch(stdout, ": ", 2L);
  print_vertex_set((*model)->id->vertices);
  write_pch(stdout, " // ", 4L);
  print_model_g_c(model, start);
  write_line(stdout);
}  /* print_model_g_c_and_type */


Static Void print_test_of(current, base)
t_model **current, **base;
{
  write_pch(stdout, " Test of ", 9L);
  print_model_g_c(current, 10L);
  write_line(stdout);
  write_pch(stdout, " against ", 9L);
  print_model_g_c(base, 10L);
  write_line(stdout);
}  /* print_test_of */


Static Void print_vertex_list(p)
t_vertex_list *p;
{
  write_char(stdout, '[');
  while (p != NULL) {
    print_vertex(p->vertex);
    p = p->pointer;
  }
  write_char(stdout, ']');
}  /* print_vertex_list */


Static Void print_edge_list(p, start, line_length)
t_edge_list *p;
t_integer start, line_length;
{
  t_integer stop = start;

  while (p != NULL) {
    if (stop + 4 > line_length && stop != start &&
	line_length < MAX_LINE_LENGTH) {
      write_line(stdout);
      write_space(stdout, start);
      stop = start;
    }
    write_char(stdout, '[');
    print_vertex(p->v);
    print_vertex(p->w);
    write_char(stdout, ']');
    stop += 4;
    p = p->pointer;
  }
}  /* print_edge_list */


Static Void warning_begin(f, in_line)
FILE *f;
boolean in_line;
{
  if (in_line && global_write_options->line_form)
    write_line(f);
  write_line(f);
  write_pch(f, " *** WARNING *** ", 17L);
  write_line(f);
}  /* warning_begin */


Static Void warning_end(f, in_line)
FILE *f;
boolean in_line;
{
  write_line(f);
  write_pch(f, " *** WARNING *** ", 17L);
  write_line(f);
  if (!in_line)
    return;
  write_line(f);
  if (global_write_options->line_form)
    write_space(f, 7L);
}  /* warning_end */


Static Void begin_error(f, number, c, w, in_line)
FILE *f;
t_integer number;
Char *c;
t_integer w;
boolean in_line;
{
  if (dump) {
    write_pch_20_text(dump_file, " <** Error location:", 20L);
    write_integer_text(dump_file, number, 5L);
    write_pch_20_text(dump_file, c, w);
  }
  if (in_line && global_write_options->line_form)
    write_line(f);
  write_line(f);
  write_pch(f, " <** Error location:", 20L);
  write_integer(f, number, 5L);
  write_pch(f, " *** ", 5L);
  write_pch(f, c, w);
  write_line(f);
}  /* begin_error */


Static Void end_error(f, number, in_line)
FILE *f;
t_integer number;
boolean in_line;
{
  if (dump) {
    write_pch_20_text(dump_file, " *** Error number:  ", 20L);
    write_integer_text(dump_file, number, 5L);
    write_pch_20_text(dump_file, " **> @@@@@          ", 5L);
    write_line_text(dump_file);
    flush_file(&dump_file);
  }
  write_line(f);
  write_pch(f, " *** Error number:  ", 20L);
  write_integer(f, number, 5L);
  write_pch(f, " **> ", 5L);
  write_line(f);
  if (!in_line)
    return;
  write_line(f);
  if (global_write_options->line_form)
    write_space(f, 7L);
}  /* end_error */


Static Void note_error_id(f, location, error_number, c, identification,
			  in_line)
FILE *f;
t_integer location, error_number;
Char *c;
t_model_specification *identification;
boolean in_line;
{
  begin_error(f, location, c, 20L, false);
  /* if dump then
       print_id__report(dump_file, identification, 0); */
  print_id(&identification, true, 0L, line_length);
  end_error(f, error_number, false);
}  /* note_error_id */


Static Void note_error_model(f, location, error_number, c, model, in_line)
FILE *f;
t_integer location, error_number;
Char *c;
t_model *model;
boolean in_line;
{
  begin_error(f, location, c, 20L, false);
  if (dump)
    print_model_g_c_report(dump_file, &model, 0L);
  print_model_g_c(&model, 0L);
  end_error(f, error_number, false);
}  /* note_error_model */


Static Void note_error_sets(f, location, error_number, c, a_, b_, in_line)
FILE *f;
t_integer location, error_number;
Char *c;
long *a_, *b_;
boolean in_line;
{
  t_vertex_set a, b;

  P_setcpy(a, a_);
  P_setcpy(b, b_);
  begin_error(f, location, c, 20L, false);
  if (dump) {
    write_pch_20_text(dump_file, c, 20L);
    write_line_text(dump_file);
    write_char_text(dump_file, ':');
    write_char_text(dump_file, ' ');
    print_vertex_set_on_report(dump_file, a);
    write_char_text(dump_file, ' ');
    write_char_text(dump_file, '/');
    write_char_text(dump_file, ' ');
    print_vertex_set_on_report(dump_file, b);
    write_char_text(dump_file, ' ');
    write_char_text(dump_file, '/');
    write_char_text(dump_file, ' ');
    flush_file(&dump_file);
  }
  write_pch(f, c, 20L);
  write_char(f, ':');
  write_char(f, ' ');
  print_vertex_set(a);
  write_char(f, ' ');
  write_char(f, '/');
  write_char(f, ' ');
  print_vertex_set(b);
  end_error(f, error_number, false);
}  /* note_error_sets */


Static Void note_error_g_c(f, location, error_number, c, g_c, a, b, in_line)
FILE *f;
t_integer location, error_number;
Char *c;
t_set_list *g_c;
long *a, *b;
boolean in_line;
{
  begin_error(f, location, c, 20L, false);
  if (dump)
    print_set_list_on_report(dump_file, g_c);
  write_pch(f, c, 20L);
  write_char(f, ':');
  write_char(f, ' ');
  print_vertex_set(a);
  write_char(f, ' ');
  write_char(f, '/');
  write_char(f, ' ');
  print_vertex_set(b);
  write_char(f, ' ');
  write_char(f, '/');
  write_char(f, ' ');
  print_g_c(g_c, 0L, line_length);
  end_error(f, error_number, false);
}  /* note_error_g_c */


Static Void note_error_triple_g_c(f, location, error_number, c, g_c_d, g_c_l,
				  g_c_q, a, b, in_line)
FILE *f;
t_integer location, error_number;
Char *c;
t_set_list *g_c_d, *g_c_l, *g_c_q;
long *a, *b;
boolean in_line;
{
  begin_error(f, location, c, 20L, false);
  if (dump)
    print_triple_g_c_report(dump_file, &g_c_d, &g_c_l, &g_c_q, 0L);
  write_pch(f, c, 20L);
  write_char(f, ':');
  write_char(f, ' ');
  print_vertex_set(a);
  write_char(f, ' ');
  write_char(f, '/');
  write_char(f, ' ');
  print_vertex_set(b);
  write_char(f, ' ');
  write_char(f, '/');
  write_char(f, ' ');
  print_triple_g_c(&g_c_d, &g_c_l, &g_c_q, 0L);
  end_error(f, error_number, false);
}  /* note_error_triple_g_c */


Static Void note_error_triple_g_c_int(f, location, error_number, c, g_c_d,
				      g_c_l, g_c_q, a, b, in_line)
FILE *f;
t_integer location, error_number;
Char *c;
t_set_list *g_c_d, *g_c_l, *g_c_q;
t_long_integer a, b;
boolean in_line;
{
  begin_error(f, location, c, 20L, false);
  if (dump)
    print_triple_g_c_report(dump_file, &g_c_d, &g_c_l, &g_c_q, 0L);
  write_pch(f, c, 20L);
  write_char(f, ':');
  write_char(f, ' ');
  write_integer(f, b - a, 5L);
  write_char(f, ' ');
  write_char(f, '/');
  write_char(f, ' ');
  write_integer(f, a, 5L);
  write_char(f, ' ');
  write_char(f, '/');
  write_char(f, ' ');
  write_integer(f, b, 5L);
  write_char(f, ' ');
  write_char(f, '/');
  write_char(f, ' ');
  print_triple_g_c(&g_c_d, &g_c_l, &g_c_q, 0L);
  end_error(f, error_number, false);
}  /* note_error_triple_g_c_int */


Static Void note_replace_gc(f, txt, c, w, print_note, p, q)
FILE *f;
Char *txt;
Char *c;
t_integer w;
boolean *print_note;
t_set_list **p, **q;
{
  if (!*print_note)
    return;
  write_line(f);
  write_char(f, ' ');
  write_pch(f, txt, 20L);
  write_char(f, '/');
  write_pch(f, c, w);
  write_pch(f, " generating class ", 18L);
  print_g_c(*p, 0L, line_length);
  if (long_names)
    write_line(f);
  write_pch(f, " replaced by ", 13L);
  print_g_c(*q, 0L, line_length);
  write_char(f, '.');
}  /* note_replace_gc */


Static Void write_warning(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  warning_begin(f, false);
  write_char(f, ' ');
  write_pch(f, c, w);
  warning_end(f, false);
}  /* write_warning */


Static Void write_warning_em(f, number, c)
FILE *f;
t_integer number;
Char *c;
{
  warning_begin(f, false);
  write_char(f, ' ');
  write_integer(f, number, 5L);
  write_char(f, ':');
  write_pch(f, c, 20L);
  write_pch(f, " / CoCo should not be here when EM used.", 40L);
  warning_end(f, false);
}  /* write_warning_em */


Static Void write_warning_sets(f, c, w, a, b)
FILE *f;
Char *c;
t_integer w;
long *a, *b;
{
  warning_begin(f, false);
  write_char(f, ' ');
  write_pch(f, c, w);
  write_char(f, ':');
  write_char(f, ' ');
  print_vertex_set(a);
  write_char(f, ' ');
  write_char(f, '/');
  write_char(f, ' ');
  print_vertex_set(b);
  warning_end(f, false);
}  /* write_warning_sets */


Static Void write_different_reals(a, b, c, model_1, model_2, gc)
t_long_real a, b;
Char *c;
t_model *model_1, *model_2;
t_set_list *gc;
{
  write_pch(stdout, c, 20L);
  write_char(stdout, '/');
  write_pch(stdout, " Different values:  ", 20L);
  if (is_invalid_real(a))
    write_pch(stdout, " Invalid first  ", 16L);
  else if (is_invalid_real(b))
    write_pch(stdout, " Invalid second ", 16L);
  if (model_1 != NULL) {
    print_vertex_set(model_1->id->vertices);
    write_char(stdout, '/');
    write_char(stdout, '/');
    print_model_g_c(&model_1, 10L);
    write_char(stdout, ':');
  }
  if (model_2 != NULL) {
    print_vertex_set(model_2->id->vertices);
    write_char(stdout, '/');
    write_char(stdout, '/');
    print_model_g_c(&model_2, 10L);
    write_char(stdout, ':');
  }
  if (gc != NULL) {
    print_g_c(gc, 0L, line_length);
    write_char(stdout, ':');
  }
  write_line(stdout);
  write_pch(stdout, c, 20L);
  write_char(stdout, '/');
  if (is_invalid_real(a))
    write_pch(stdout, " Invalid first:   ", 18L);
  else if (is_invalid_real(b))
    write_pch(stdout, " Invalid second:  ", 18L);
  else
    write_pch(stdout, " Different values:", 18L);
  write_real(stdout, a, 14L, 4L);
  write_char(stdout, '-');
  write_real(stdout, b, 14L, 4L);
  write_char(stdout, '=');
  write_real(stdout, a - b, 14L, 4L);
}  /* write_different_reals */


Static Void warning_different_reals(a, b, c, model_1, model_2, gc)
t_long_real a, b;
Char *c;
t_model *model_1, *model_2;
t_set_list *gc;
{
  warning_begin(stdout, true);
  write_different_reals(a, b, c, model_1, model_2, gc);
  warning_end(stdout, true);
}  /* warning_different_reals */


Static Void note_error_reals(f, location, error_number, c, a, b, model_1,
			     model_2)
FILE *f;
t_integer location, error_number;
Char *c;
t_long_real a, b;
t_model *model_1, *model_2;
{
  begin_error(f, location, c, 20L, false);
  if (dump) {
    write_dump_real(a, print_width, print_dec);
    write_char_text(dump_file, '-');
    write_dump_real(b, print_width, print_dec);
    write_char_text(dump_file, '=');
    write_dump_real(a - b, print_width, print_dec);
    write_char_text(dump_file, ':');
    print_model_g_c_report(dump_file, &model_1, 0L);
    write_char_text(dump_file, '/');
    print_model_g_c_report(dump_file, &model_2, 0L);
  }
  write_different_reals(a, b, c, model_1, model_2, NULL);
  write_line(f);
  end_error(f, error_number, false);
}  /* note_error_reals */


Static Void check_model_constant(model, c)
t_model **model;
Char *c;
{
  t_vertex_set a;
  t_long_real constant;

  P_setdiff(a, delta_gamma, (*model)->id->vertices);
  P_setint(a, a, delta);
  constant = 1 / marginal_dimension_real(a);
  if (different_reals(&constant, &(*model)->constant)) {
    note_error_reals(stdout, 500L, 1L, c, constant, (*model)->constant,
		     *model, NULL);
    (*model)->constant = constant;
  }
}  /* check_model_constant */


/*@+"trace.p"*/


/*

  292:    +++  ++
  293:    +++  ++
  294:    ---  -- p/trace.p         29     146    1509 p/trace.p
  295: |    4:    function do_trace
  296: |   10:    procedure note_mixed
  297: |   24:    procedure note_trace
  298: |   39:    procedure note_trace_4
  299: |   58:    procedure note_trace_char
  300: |   76:    procedure note_trace_boolean
  301: |   97:    procedure note_trace_3_booleans
  302: |  126:    procedure note_trace_txt_boolean
  303: |  149:    procedure note_trace_real
  304: |  167:    procedure note_trace_6_real
  305: |  193:    procedure note_trace_double_real
  306: |  214:    procedure note_trace_model
  307: |  224:    procedure note_trace_expression
  308: |  236:    procedure note_trace_g_c
  309: |  255:    procedure note_trace_triple_g_c
  310: |  282:    procedure note_trace_g_c_list
  311: |  304:    procedure note_trace_set_and_g_c
  312: |  328:    procedure note_trace_vertex_and_set
  313: |  351:    procedure note_trace_set
  314: |  370:    procedure note_trace_set_and_boolean
  315: |  397:    procedure note_trace_3_sets
  316: |  420:    procedure note_trace_4_sets
  317: |  445:    procedure write_txt_boolean
  318: |  459:    procedure note_trace_model_numbers
  319: |  482:    procedure note_trace_model_g_c
  320: |  510:    procedure note_trace_cips_item
  321: |  530:    procedure note_trace_cips_item_short
  322: |  550:    procedure note_trace_mixed_item
  323: |  589:    procedure note_trace_mixed_item_short
  324:    +++  ++
  325:    +++  ++

*/

/*$ifdef TRACE*/

Static Void note_mixed(report_file, c, w)
FILE *report_file;
Char *c;
t_long_integer w;
{
  if (!mixed_data)
    return;
  if (!trace_flag_set(20L, 328L, 1L))
    return;
  write_pch_10_text(report_file, " MIXED: ", 8L);
  write_pch_20_text(report_file, c, w);
  write_line_text(report_file);
  flush_file(&report_file);
}


Static boolean do_trace(c, w, o, p, n, m)
Char *c;
t_long_integer w, o, p, n, m;
{
  boolean ok;

  ok = trace_flag_set(w, o, p);
  if (!ok)
    return false;
  write_char(stdout, ' ');
  write_char(stdout, '(');
  write_integer(stdout, o, 5L);
  write_char(stdout, '/');
  write_integer(stdout, p, 1L);
  write_char(stdout, ')');
  write_char(stdout, ' ');
  write_pch(stdout, c, w);
  write_char(stdout, ':');
  write_integer(stdout, n, 4L);
  write_char(stdout, '/');
  write_integer(stdout, m, 4L);
  write_char(stdout, '/');
  write_char(stdout, '/');
  return true;
}


Static Void ntr(c, w, o, p, n, m)
Char *c;
t_long_integer w, o, p, n, m;
{
  FILE *TEMP;

  if (do_trace(c, w, o, p, n, m)) {
    write_line(stdout);
    TEMP = stdout;
    flush_file(&TEMP);
  }
}


Static Void ntr_4(c, w, o, p, i, j, n, m)
Char *c;
t_long_integer w, o, p, i, j, n, m;
{
  FILE *TEMP;

  if (!do_trace(c, w, o, p, n, m))
    return;
  write_integer(stdout, i, 3L);
  write_char(stdout, '/');
  write_integer(stdout, j, 3L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_char(t, w, o, p, n, m, c)
Char *t;
t_long_integer w, o, p, n, m;
Char c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, c);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_boolean(t, w, o, p, n, m, ok)
Char *t;
t_long_integer w, o, p, n, m;
boolean ok;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  if (ok)
    write_pch(stdout, " TRUE     ", 10L);
  else
    write_pch(stdout, " FALSE    ", 10L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_3_booleans(t, w, o, p, n, m, a, b, c)
Char *t;
t_long_integer w, o, p, n, m;
boolean a, b, c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  if (a)
    write_pch(stdout, " TRUE     ", 10L);
  else
    write_pch(stdout, " FALSE    ", 10L);
  if (b)
    write_pch(stdout, " TRUE     ", 10L);
  else
    write_pch(stdout, " FALSE    ", 10L);
  if (c)
    write_pch(stdout, " TRUE     ", 10L);
  else
    write_pch(stdout, " FALSE    ", 10L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


/* Not used:
procedure ntr_txt_boolean(    t    : pch20;
                              w, o, p, n, m : t_long_integer;
                          var s    : pch20;
                              ok    : boolean);
begin
   if do_trace(t, w, o, p, n, m) then begin
      write_pch(output, s, 20);
      if ok then
         write_pch(output, ' TRUE     ', 10)
      else
         write_pch(output, ' FALSE    ', 10);
      write_line(output);
      flush_file(output)
   end
end; */

Static Void ntr_long_txt(t, w, o, p, n, m, s)
Char *t;
t_long_integer w, o, p, n, m;
Char *s;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_pch(stdout, s, m);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_real(t, w, o, p, n, m, x)
Char *t;
t_long_integer w, o, p, n, m;
double *x;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_real(stdout, *x, 12L, 5L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_short_real(t, w, o, p, n, m, x)
Char *t;
t_long_integer w, o, p, n, m;
t_real *x;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_real(stdout, *x, 12L, 5L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_6_real(t, w, o, p, i, j, k, l, n, m, x)
Char *t;
t_long_integer w, o, p, i, j, k, l, n, m;
double *x;
{
  FILE *TEMP;

  if (!trace_flag_set(w, o, p))
    return;
  write_pch(stdout, t, w);
  write_char(stdout, ':');
  write_integer(stdout, i, 3L);
  write_char(stdout, '/');
  write_integer(stdout, j, 3L);
  write_char(stdout, '/');
  write_integer(stdout, k, 3L);
  write_char(stdout, '/');
  write_integer(stdout, l, 3L);
  write_char(stdout, '/');
  write_integer(stdout, n, 3L);
  write_char(stdout, '/');
  write_integer(stdout, m, 3L);
  write_char(stdout, '/');
  write_real(stdout, *x, 12L, 5L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_double_real(t, w, o, p, n, m, x, y)
Char *t;
t_long_integer w, o, p, n, m;
double x, y;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_real(stdout, x, 12L, 5L);
  write_real(stdout, y, 12L, 5L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_triple_reals(t, w, o, p, n, m, x, y, z)
Char *t;
t_long_integer w, o, p, n, m;
double *x, *y, *z;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_real(stdout, *x, 12L, 5L);
  write_real(stdout, *y, 12L, 5L);
  write_real(stdout, *z, 12L, 5L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_4_reals(t, w, o, p, n, m, x, y, z, u)
Char *t;
t_long_integer w, o, p, n, m;
double *x, y, *z, *u;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_real(stdout, *x, 12L, 5L);
  write_real(stdout, y, 12L, 5L);
  write_real(stdout, *z, 12L, 5L);
  write_real(stdout, *u, 12L, 5L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_6_reals(t, w, o, p, n, m, x, y, u, v, a, b)
Char *t;
t_long_integer w, o, p, n, m;
double *x, *y, *u, *v, *a, *b;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_real(stdout, *x, 9L, 5L);
  write_real(stdout, *y, 9L, 5L);
  write_real(stdout, *y - *x, 9L, 5L);
  write_real(stdout, *u, 9L, 5L);
  write_real(stdout, *v, 9L, 5L);
  write_real(stdout, *v - *u, 9L, 5L);
  write_real(stdout, *a, 12L, 5L);
  write_real(stdout, *b, 12L, 5L);
  write_real(stdout, *b - *a, 12L, 5L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_double_short_real(t, w, o, p, n, m, x, y)
Char *t;
t_long_integer w, o, p, n, m;
t_real *x, *y;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_real(stdout, *x, 12L, 5L);
  write_real(stdout, *y, 12L, 5L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


/*Has-forward-1*/

Static Void ntr_model PP((Char *t, t_long_integer w, t_long_integer o,
			  t_long_integer p, t_long_integer n,
			  t_long_integer m, t_model *model));

Static Void ntr_expression PP((Char *t, t_long_integer w, t_long_integer o,
			       t_long_integer p, t_long_integer n,
			       t_long_integer m, t_model *model));


/*Has-forward-1*/


/*$endif TRACE*/

/*$ifdef TRACE*/

Static Void ntr_g_c(t, w, o, p, n, m, g_c)
Char *t;
t_long_integer w, o, p, n, m;
t_set_list **g_c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_g_c(*g_c, 10L, line_length);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_double_g_c(t, w, o, p, n, m, g_c_1, g_c_2, ok)
Char *t;
t_long_integer w, o, p, n, m;
t_set_list **g_c_1, **g_c_2;
boolean ok;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  if (ok)
    write_pch(stdout, " TRUE     ", 10L);
  else
    write_pch(stdout, " FALSE    ", 10L);
  write_char(stdout, ' ');
  write_char(stdout, '|');
  write_char(stdout, ' ');
  print_g_c(*g_c_1, 10L, line_length);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_char(stdout, ' ');
  print_g_c(*g_c_2, 10L, line_length);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_triple_g_c(t, w, o, p, n, m, g_c_1, g_c_2, g_c_3)
Char *t;
t_long_integer w, o, p, n, m;
t_set_list **g_c_1, **g_c_2, **g_c_3;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_g_c(*g_c_1, 10L, line_length);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_char(stdout, ' ');
  print_g_c(*g_c_2, 10L, line_length);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_char(stdout, ' ');
  print_g_c(*g_c_3, 10L, line_length);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_g_c_list(t, w, o, p, n, m, gc_list)
Char *t;
t_long_integer w, o, p, n, m;
t_g_c_list *gc_list;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  while (gc_list != NULL) {
    print_g_c(gc_list->g_c, 0L, line_length);
    gc_list = gc_list->pointer;
  }
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_set_and_g_c(t, w, o, p, n, m, vertex_set, g_c)
Char *t;
t_long_integer w, o, p, n, m;
long *vertex_set;
t_set_list **g_c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_set(vertex_set);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_char(stdout, ' ');
  print_g_c(*g_c, 10L, line_length);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_vertex(t, w, o, p, n, m, vertex)
Char *t;
t_long_integer w, o, p, n, m;
t_vertex *vertex;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex(*vertex);
  write_char(stdout, '/');
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_discrete_vertex(t, w, o, p, n, m, vertex)
Char *t;
t_long_integer w, o, p, n, m;
t_discrete_vertex *vertex;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_discrete_vertex(*vertex, 0L);
  write_char(stdout, '/');
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_vertex_list(t, w, o, p, n, m, vertex_list)
Char *t;
t_long_integer w, o, p, n, m;
t_vertex_list **vertex_list;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_list(*vertex_list);
  write_char(stdout, '/');
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_vertex_and_set(t, w, o, p, n, m, vertex, vertex_set)
Char *t;
t_long_integer w, o, p, n, m;
t_vertex *vertex;
long *vertex_set;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex(*vertex);
  write_char(stdout, '/');
  write_char(stdout, ' ');
  print_vertex_set(vertex_set);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_vertex_pair_and_g_c(t, w, o, p, n, m, u, v, g_c)
Char *t;
t_long_integer w, o, p, n, m;
t_vertex *u, *v;
t_set_list **g_c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, '<');
  print_vertex(*u);
  write_char(stdout, ',');
  print_vertex(*v);
  write_char(stdout, ';');
  print_g_c(*g_c, 0L, line_length);
  write_char(stdout, '>');
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_set(t, w, o, p, n, m, vertex_set)
Char *t;
t_long_integer w, o, p, n, m;
long *vertex_set;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_set(vertex_set);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_continuous_set(t, w, o, p, n, m, vertex_set)
Char *t;
t_long_integer w, o, p, n, m;
long *vertex_set;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_set(vertex_set);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


/* Not used:
procedure ntr_set_table(    t  : pch20;
                            w, o, p, n, m : t_long_integer;
                        var vertex_set  : t_vertex_set);
begin
   if trace_flag_set(w, o, p) then begin
      print_vertex_set_table(vertex_set);
      write_integer(output, m, 10);
      write_line(output);
      write_space(output, 30);
      flush_file(output)
   end
end; */

Static Void ntr_set_and_boolean(t, w, o, p, n, m, vertex_set, ok)
Char *t;
t_long_integer w, o, p, n, m;
long *vertex_set;
boolean ok;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_set(vertex_set);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_char(stdout, ' ');
  if (ok)
    write_pch(stdout, " TRUE     ", 10L);
  else
    write_pch(stdout, " FALSE    ", 10L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_split_set(t, w, o, p, n, m, a, a_discrete, a_continuous)
Char *t;
t_long_integer w, o, p, n, m;
long *a;
long *a_discrete;
long *a_continuous;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_set(a);
  write_char(stdout, ' ');
  print_discrete_vertex_set(a_discrete);
  write_char(stdout, ' ');
  print_continuous_vertex_set(a_continuous);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_2_sets(t, w, o, p, n, m, a, b)
Char *t;
t_long_integer w, o, p, n, m;
long *a, *b;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_set(a);
  write_char(stdout, ' ');
  print_vertex_set(b);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_3_sets(t, w, o, p, n, m, a, b, c)
Char *t;
t_long_integer w, o, p, n, m;
long *a, *b, *c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_set(a);
  write_char(stdout, ' ');
  print_vertex_set(b);
  write_char(stdout, ' ');
  print_vertex_set(c);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_4_sets(t, w, o, p, n, m, a, b, c, d)
Char *t;
t_long_integer w, o, p, n, m;
long *a, *b, *c, *d;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_set(a);
  write_char(stdout, ' ');
  print_vertex_set(b);
  write_char(stdout, ' ');
  print_vertex_set(c);
  write_char(stdout, ' ');
  print_vertex_set(d);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void write_txt_boolean(output, t, w, b)
FILE *output;
Char *t;
t_long_integer w;
boolean b;
{
  if (w > 0)
    write_pch(output, t, w);
  if (b)
    write_pch(output, " TRUE  ", 7L);
  else
    write_pch(output, " FALSE ", 7L);
  write_line(output);
}


Static Void ntr_model_numbers(t, w, o, p, n, m, model)
Char *t;
t_long_integer w, o, p, n, m;
t_model **model;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_integer(stdout, (*model)->model_ifail, 4L);
  write_integer(stdout, (*model)->model_number, 4L);
  write_integer(stdout, (*model)->id->paritet, 6L);
  write_integer(stdout, (*model)->dim, 6L);
  write_real(stdout, (*model)->constant, 14L, 4L);
  write_real(stdout, (*model)->log_l, 14L, 4L);
  write_line(stdout);
  write_txt_boolean(stdout, " FoundPs:           ", 19L, (*model)->found_ps);
  /* write_line(output); */
  write_txt_boolean(stdout, " FoundLogL:         ", 19L,
		    (*model)->found_log_l);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_id(t, w, o, p, n, m, id)
Char *t;
t_long_integer w, o, p, n, m;
t_model_specification **id;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_vertex_set_table((*id)->vertices);
  write_char(stdout, '/');
  write_char(stdout, '/');
  write_id_type(id);
  write_char(stdout, ' ');
  print_id(id, true, 10L, line_length);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_double_id(t, w, o, p, n, m, id_a, id_b)
Char *t;
t_long_integer w, o, p, n, m;
t_model_specification **id_a, **id_b;
{
  ntr_id(t, w, o, p, n, m, id_a);
  ntr_id(t, w, o, p, n, m, id_b);
}


Static Void ntr_model_g_c(t, w, o, p, n, m, model)
Char *t;
t_long_integer w, o, p, n, m;
t_model **model;
{
  ntr_id(t, w, o, p, n, m, &(*model)->id);
}


Static Void ntr_cips_item(t, w, o, p, n, m, link_element, g_c)
Char *t;
t_long_integer w, o, p, n, m;
t_cips_element **link_element;
t_set_list **g_c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_g_c_slash(*g_c, 10L, line_length);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_cips_item_short(t, w, o, p, n, m, link_element, g_c)
Char *t;
t_long_integer w, o, p, n, m;
t_cips_element **link_element;
t_set_list **g_c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_g_c_slash(*g_c, 10L, line_length);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_mixed_item(t, w, o, p, n, m, mixed_item, g_c)
Char *t;
t_long_integer w, o, p, n, m;
t_mips_element *mixed_item;
t_set_list **g_c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_g_c_slash(*g_c, 10L, line_length);
  print_g_c_slash(mixed_item->discrete_, 10L, line_length);
  print_g_c_slash(mixed_item->linear, 10L, line_length);
  print_g_c_slash(mixed_item->quadratic, 10L, line_length);
  write_line(stdout);
  /* write_txt_boolean(output, ' Full specified:    ', 19,
  mixed_item.full_specified); */
  if (mixed_item->mixed_characteristics != NULL) {
    write_txt_boolean(stdout, " Mim model:         ", 19L,
		      mixed_item->mixed_characteristics->mim_model);
    write_txt_boolean(stdout, " Degenerated:       ", 19L,
		      mixed_item->mixed_characteristics->degenerated);
    write_txt_boolean(stdout, " Delta-collapsible: ", 19L,
		      mixed_item->mixed_characteristics->d_collapsible);
    write_txt_boolean(stdout, " Mean-linear:       ", 19L,
		      mixed_item->mixed_characteristics->mean_linear);
    write_txt_boolean(stdout, " Q-equivalent:      ", 19L,
		      mixed_item->mixed_characteristics->q_equivalent);
    /* write_txt_boolean(output, ' Homogeneous:       ', 19,
    mixed_item.homogeneous) */
  }
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_mixed_item_short(t, w, o, p, n, m, mixed_item, g_c)
Char *t;
t_long_integer w, o, p, n, m;
t_mips_element *mixed_item;
t_set_list **g_c;
{
  FILE *TEMP;

  if (!do_trace(t, w, o, p, n, m))
    return;
  write_char(stdout, ' ');
  print_g_c_slash(mixed_item->discrete_, 10L, line_length);
  print_g_c_slash(mixed_item->linear, 10L, line_length);
  print_g_c_slash(mixed_item->quadratic, 10L, line_length);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void trace_mixed_case(j, x)
t_level *j;
float *x;
{
  t_discrete_vertex v;
  t_continuous_vertex w;
  t_vertex u;
  t_integer width;

  for (u = first_vertex; u <= full_last_vertex; u++) {
    if (P_inset(u, full_delta)) {
      v = full_to_discrete[u - MIN_VERTEX];
      if (full_variable_description[u - MIN_VERTEX]->UU.U0.levels_total > 99)
	width = 4;
      else if (full_variable_description[u - MIN_VERTEX]->UU.U0.levels_total > 9)
	width = 3;
      else
	width = 2;
      write_char(stdout, ' ');
      write_char(stdout, '(');
      write_integer(stdout, j[v - MIN_VERTEX] - FIRST_LEVEL + 1L, width);
      write_char(stdout, ')');
    } else {
      w = full_to_continuous[u - MIN_VERTEX];
      write_char(stdout, ' ');
      write_real(stdout, x[w - MIN_VERTEX], 5L, 2L);
      if (is_invalid_real(x[w - MIN_VERTEX]))
	write_char(stdout, '*');
    }
  }
  write_line(stdout);
}


Static Void ntr_array(txt_1, txt_2, ref, offset, index, z, x, c, txt_3, w, o,
		      p)
Char *txt_1, *txt_2;
t_long_integer ref;
t_e_cell_index offset, *index;
double z, x;
t_long_integer c;
Char *txt_3;
t_long_integer *w, *o, *p;
{
  if (!trace_flag[TRACE_FLAG_FACTOR * 292])
    return;
  write_integer_text(report_file, ref, 12L);
  write_integer_text(report_file, *index, 5L);
  write_integer_text(report_file, offset, 5L);
  write_integer_text(report_file, *o, 5L);
  write_integer_text(report_file, *p, 5L);
  write_char_text(report_file, ' ');
  write_pch_10_text(report_file, txt_1, 4L);
  write_pch_10_text(report_file, txt_2, 4L);
  write_real_text(report_file, z, 15L, 6L);
  write_char_text(report_file, ' ');
  if (c == 0) {
    if (is_invalid_real(z))
      write_char_text(report_file, '%');
    else if (is_invalid_real(x) || *p == 0)
      write_char_text(report_file, ' ');
    else
      write_char_text(report_file, ':');
  } else if (c == 10) {
    if (is_invalid_real(x) || *p == 0)
      write_char_text(report_file, ' ');
    else
      write_char_text(report_file, ':');
  } else if (c == 1)
    write_char_text(report_file, '+');
  else if (c == -1)
    write_char_text(report_file, '-');
  else if (c == 3)
    write_char_text(report_file, '*');
  else if (c == -3)
    write_char_text(report_file, '/');
  else
    write_char_text(report_file, '?');
  write_char_text(report_file, ' ');
  write_real_text(report_file, x, 15L, 6L);
  write_char_text(report_file, ' ');
  if (is_invalid_real(x) && (labs(c) == 1 || labs(c) == 1))
    write_char_text(report_file, '#');
  else
    write_char_text(report_file, '=');
  write_char_text(report_file, ' ');
  if (c == 0 || c == 10) {
    if (is_invalid_real(x) || *p == 0) {
      if (c == 10)
	write_pch_20_text(report_file, "                  ? ", 15L);
      else
	write_pch_20_text(report_file, "                    ", 15L);
    } else
      write_real_text(report_file, z - x, 15L, 6L);
  } else if (c == 1)
    write_real_text(report_file, z + x, 15L, 6L);
  else if (c == -1)
    write_real_text(report_file, z - x, 15L, 6L);
  else if (c == 3)
    write_real_text(report_file, z * x, 15L, 6L);
  else if (c == -3)
    write_real_text(report_file, z / x, 15L, 6L);
  write_pch_20_text(report_file, txt_3, *w);
  write_line_text(report_file);
}


Static Void ntr_n_ref(n, n_offset, index, txt_, w, o, p)
t_cell_count *n;
t_offset n_offset;
t_e_cell_index index;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("N,        ", "Ref:      ", -1L, n_offset, &index,
	      (double)n[index], _INVALID_REAL, 0L, txt, &w, &o, &p);
}


Static Void ntr_r_ref(r, r_offset, index, txt_, w, o, p)
t_r_r **r;
t_r_offset *r_offset;
t_e_cell_index index;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("R,        ", "Ref:      ", (*r)->z, *r_offset, &index,
	      (*r)->z[index], _INVALID_REAL, 0L, txt, &w, &o, &p);
}


Static Void ntr_r_ass(r, r_offset, index, x, txt_, w, o, p)
t_r_r **r;
t_r_offset *r_offset;
t_e_cell_index index;
double x;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("R,        ", "Ass:      ", (*r)->z, *r_offset, &index,
	      (*r)->z[index], x, 10L, txt, &w, &o, &p);
}


Static Void ntr_r_upd(r, r_offset, index, x, c, txt_, w, o, p)
t_r_r **r;
t_r_offset *r_offset;
t_e_cell_index index;
double x;
t_long_integer c;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("R,        ", "Upd:      ", (*r)->z, *r_offset, &index,
	      (*r)->z[index], x, c, txt, &w, &o, &p);
}


Static Void ntr_s_ref(s, s_offset, index, txt_, w, o, p)
t_s_r **s;
t_s_offset *s_offset;
t_e_cell_index index;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("S,        ", "Ref:      ", (*s)->z, *s_offset, &index,
	      (*s)->z[index], _INVALID_REAL, 0L, txt, &w, &o, &p);
}


Static Void ntr_s_ass(s, s_offset, index, x, txt_, w, o, p)
t_s_r **s;
t_s_offset *s_offset;
t_e_cell_index index;
double x;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("S,        ", "Ass:      ", (*s)->z, *s_offset, &index,
	      (*s)->z[index], x, 10L, txt, &w, &o, &p);
}


Static Void ntr_s_upd(s, s_offset, index, x, c, txt_, w, o, p)
t_s_r **s;
t_s_offset *s_offset;
t_e_cell_index index;
double x;
t_long_integer c;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("S,        ", "Upd:      ", (*s)->z, *s_offset, &index,
	      (*s)->z[index], x, c, txt, &w, &o, &p);
}


Static Void ntr_ss_ref(ss, ss_offset, index, txt_, w, o, p)
t_ss_r **ss;
t_ss_offset *ss_offset;
t_e_cell_index index;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("SS,       ", "Ref:      ", (*ss)->z, *ss_offset, &index,
	      (*ss)->z[index], _INVALID_REAL, 0L, txt, &w, &o, &p);
}


Static Void ntr_ss_ass(ss, ss_offset, index, x, txt_, w, o, p)
t_ss_r **ss;
t_ss_offset *ss_offset;
t_e_cell_index index;
double x;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("SS,       ", "Ass:      ", (*ss)->z, *ss_offset, &index,
	      (*ss)->z[index], x, 10L, txt, &w, &o, &p);
}


Static Void ntr_ss_upd(ss, ss_offset, index, x, c, txt_, w, o, p)
t_ss_r **ss;
t_ss_offset *ss_offset;
t_e_cell_index index;
double x;
t_long_integer c;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("SS,       ", "Upd:      ", (*ss)->z, *ss_offset, &index,
	      (*ss)->z[index], x, c, txt, &w, &o, &p);
}


Static Void ntr_t_ref(t, t_offset_, index, txt_, w, o, p)
t_t_r **t;
t_t_offset *t_offset_;
t_e_cell_index index;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("T,        ", "Ref:      ", (*t)->z, *t_offset_, &index,
	      (*t)->z[index], _INVALID_REAL, 0L, txt, &w, &o, &p);
}


Static Void ntr_t_ass(t, t_offset_, index, x, txt_, w, o, p)
t_t_r **t;
t_t_offset *t_offset_;
t_e_cell_index index;
double x;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("T,        ", "Ass:      ", (*t)->z, *t_offset_, &index,
	      (*t)->z[index], x, 10L, txt, &w, &o, &p);
}


Static Void ntr_t_upd(t, t_offset_, index, x, c, txt_, w, o, p)
t_t_r **t;
t_t_offset *t_offset_;
t_e_cell_index index;
double x;
t_long_integer c;
Char *txt_;
t_long_integer w, o, p;
{
  pch20 txt;

  memcpy(txt, txt_, sizeof(pch20));
  if (trace_flag[TRACE_FLAG_FACTOR * 292])
    ntr_array("T,        ", "Upd:      ", (*t)->z, *t_offset_, &index,
	      (*t)->z[index], x, c, txt, &w, &o, &p);
}


/*$endif TRACE*/
/*@+"in.p"*/


/*

  326:    +++  ++
  327:    +++  ++
  328:    ---  -- p/in.p           28     113    1255 p/in.p
  329: |    4:    procedure read_char
  330: |   24:    procedure read_line
  331: |   37:    procedure read_char_non_echo
  332: |   47:    procedure read_line_non_echo
  333: |   56:    procedure read_line_plus
  334: |   65:    procedure read_char_data
  335: |   79:    procedure read_line_data
  336: |   96:    procedure read_line_data_plus
  337: |  113:    procedure copy_string
  338: |  132:    procedure copy_pch_long
  339: |  144:    procedure read_file_name
  340: |  188:    procedure default_to_file_name
  341: |  204:    procedure read_character
  342: |  225:    procedure read_line_end
  343: |  237:    procedure skip_word
  344: |  263:    procedure seek_non_blank
  345: |  287:    procedure seek_non_blank_data
  346: |  295:    function seek_word
  347: |  342:    procedure read_integer_separator
  348: |  389:    procedure read_integer
  349: |  414:    procedure read_integer_data
  350: |  425:    procedure sub_read_list_level
  351: |  444:    procedure read_list_level
  352: |  455:    procedure read_level
  353: |  462:    procedure write_level
  354: |  472:    procedure read_real_separator
  355: |  571:    procedure read_real
  356: |  591:    procedure read_real_data
  357:    +++  ++
  358:    +++  ++

*/


Static Void read_char(f, c)
FILE *f;
Char *c;
{
  read_text_char(f, c);
  if (log_on)
    write_char_text(log_file, *c);
  if (diary && !echo)
    write_char_text(diary_file, *c);
  if (echo) {
    /*$ifdef TRACE*/
    write_char(stdout, *c);
  }
  /*$endif TRACE*/
  ntr_char(" ReadChar           ", 20L, 329L, 1L, 0L, 0L, *c);
}  /* read_char */


Static Void read_line(f)
FILE *f;
{
  read_text_ln(f);
  if (log_on)
    write_line_text(log_file);
  if (!echo)
    write_line_diary();
  if (echo) {
    write_line(stdout);
    write_char(stdout, ' ');
  }
}  /* read_line */


Static Void read_char_non_echo(f, c)
FILE *f;
Char *c;
{
  read_text_char(f, c);
  if (log_on)
    write_char_text(log_file, *c);
  if (diary && !echo)
    write_char_text(diary_file, *c);
}  /* read_char_non_echo */


Static Void read_line_non_echo(f)
FILE *f;
{
  read_text_ln(f);
  if (log_on)
    write_line_text(log_file);
  if (!echo)
    write_line_diary();
}  /* read_line_non_echo */


Static Void read_line_plus(f)
FILE *f;
{
  read_text_ln(f);
  if (log_on)
    write_line_text(log_file);
  write_line_diary();
  write_pch(stdout, " + ->", 5L);
}  /* read_line_plus */


Static Void read_char_data(f, c)
FILE *f;
Char *c;
{
  read_text_char(f, c);
  if (data_line_position < PCH_END) {
    data_line_position++;
    last_data_line[data_line_position - PCH_START] = *c;
  }
  if (log_on && log_data_on)
    write_char_text(log_file, *c);
  if (term && diary)
    write_char_text(diary_file, *c);
}  /* read_char_data */


Static Void read_line_data(f)
FILE *f;
{
  read_text_ln(f);
  data_line_position = 0;
  data_line_number++;
  if (log_on && log_data_on)
    write_line_text(log_file);
  if (!term) {
    if (log_on && log_data_on)
      write_pch_10_text(log_file, "#Data: ", 7L);
    return;
  }
  if (diary) {
    write_line_diary();
    write_char_text(diary_file, ' ');
  }
  write_pch(stdout, " DATA->", 7L);
}  /* read_line_data */


Static Void read_line_data_plus(f)
FILE *f;
{
  read_text_ln(f);
  data_line_position = 0;
  data_line_number++;
  if (log_on && log_data_on)
    write_line_text(log_file);
  if (!term) {
    if (log_on && log_data_on)
      write_pch_10_text(log_file, "#Data: ", 7L);
    return;
  }
  if (diary) {
    write_line_diary();
    write_char_text(diary_file, ' ');
  }
  write_pch(stdout, " + DATA-> ", 10L);
}  /* read_line_data_plus */


Static Void copy_string(a, b, count, ifail)
Char *a, *b;
t_integer count, *ifail;
{
  t_integer i = PCH_START;

  while (a[i - PCH_START] != '\0' && a[i - PCH_START] != ' ' && i < count) {
    b[i - PCH_START] = a[i - PCH_START];
    i++;
  }
  b[i - PCH_START] = '\0';
  if (a[i - PCH_START] != '\0' && a[i - PCH_START] != ' ') {
    while (a[i - PCH_START] != '\0' && a[i - PCH_START] != ' ' && i < PCH_END)
      i++;
    *ifail = 70;
  }
  count = i;
}  /* copy_string */


Static Void copy_pch_long(a, b)
Char *a, *b;
{
  t_integer i = PCH_START;

  while (a[i - PCH_START] != '\0' && a[i - PCH_START] != ' ' && i < PCH_END) {
    b[i - PCH_START] = a[i - PCH_START];
    i++;
  }
  b[i - PCH_START] = '\0';
}  /* copy_pch_long */


Static Void read_file_name(f, name)
FILE *f;
Char *name;
{
  t_integer i;
  Char c;
  Char d = '@';

  for (i = PCH_START; i <= FILE_NAME_LENGTH; i++)
    name[i - PCH_START] = ' ';
  while (eolnnotf_command(f)) {
    read_line_non_echo(f);
    write_pch(stdout, " FILE->", 7L);
  }
  if (echo) {
    write_line_diary();
    write_pch(stdout, " FILE->", 7L);
  }
  if (eof_command(f))
    c = '@';
  else
    read_char(f, &c);
  while ((c == ' ') & (!eolnorf_command(f)))
    read_char(f, &c);
  i = PCH_START;
  while (((c != ';' || c == ';' && d == '\\') && i <= FILE_NAME_LENGTH) &
	 (!eolnorf_command(f))) {
    if (c != '\\' || c == '\\' && d == '\\')
      name[i - PCH_START] = c;
    if (c == '\\' && d == '\\')
      c = '@';
    d = c;
    read_char(f, &c);
    if (c != '\\' || c == '\\' && d == '\\')
      i++;
  }
  if ((c != ';' || c == ';' && d == '\\') & eoln_command(f)) {
    name[i - PCH_START] = c;
    name[i - PCH_START + 1] = '\0';
  } else
    name[i - PCH_START] = '\0';
  if (echo)
    write_line(stdout);
}  /* read_file_name */


Static Void default_to_file_name(default_name, file_name)
Char *default_name;
Char *file_name;
{
  t_integer i = PCH_START;

  while (default_name[i-1] != ' ' && i <= 40) {
    file_name[i - PCH_START] = default_name[i-1];
    i++;
  }
  while (i <= FILE_NAME_LENGTH) {
    file_name[i - PCH_START] = ' ';
    i++;
  }
}  /* default_to_file_name */


Static Void read_character(fil, command_, keyboard, c)
FILE *fil;
boolean command_, keyboard;
Char *c;
{
  if (command_)
    read_char_non_echo(fil, c);
  else if (keyboard)
    read_text_char(fil, c);
  else {
    /*$ifdef TRACE*/
    read_char_data(fil, c);
  }
  /*$endif TRACE*/
  ntr_char(" ReadChar           ", 20L, 341L, 1L, 0L, 0L, *c);
}  /* read_character */


Static Void read_line_end(fil, command_, keyboard)
FILE *fil;
boolean command_, keyboard;
{
  if (command_) {
    read_line_plus(fil);
    return;
  }
  if (keyboard)
    read_text_ln(fil);
  else
    read_line_data_plus(fil);
}  /* read_line_end */


Static Void skip_word(data_file, c, skip_count, echo)
FILE *data_file;
Char c;
t_integer *skip_count;
boolean echo;
{
  pch_long d;
  t_integer i = 1;

  (*skip_count)++;
  if (echo) {
    write_pch(stdout, " Skipping:", 10L);
    write_space(stdout, 2L);
  }
  d[i - PCH_START] = c;
  while (!(eolnnotf_data(data_file) || d[i - PCH_START] == ' ')) {
    i++;
    read_char_data(data_file, &d[i - PCH_START]);
  }
  if (echo) {
    write_pch(stdout, d, i);
    write_line(stdout);
  }
}  /* skip_word */


Static Void seek_non_blank(fil, command_, keyboard, promb, w, c)
FILE *fil;
boolean command_, keyboard;
Char *promb;
t_integer w;
Char *c;
{
  *c = ' ';
  do {
    while (eolnnotf_command(fil)) {
      read_line_end(fil, command_ && !keyboard, keyboard);
      if (command_)
	write_pch(stdout, promb, w);
    }
    if (eof_command(fil))
      *c = '/';
    else {
      read_character(fil, command_, keyboard, c);
      while ((*c == ' ' || *c == '\t' || *c == ',') & (!eolnorf_command(fil)))
	read_character(fil, command_, keyboard, c);
    }
  } while (!(*c != ' ' && *c != '\t' && *c != ',' || command_ || keyboard));
      /* seek_non_blank */
}


Static Void seek_non_blank_data(fil, command_, keyboard, c)
FILE *fil;
boolean command_, keyboard;
Char *c;
{
  seek_non_blank(fil, command_, keyboard, "1234567890", 0L, c);
}  /* seek_non_blank_data */


Static boolean seek_word(data_file, command_, keyboard, word_to_find, i,
			 length, skip_count, echo)
FILE *data_file;
boolean command_, keyboard;
Char *word_to_find;
t_integer i, length, skip_count;
boolean echo;
{
  Char c = ' ', d = '@';
  boolean ok = true;

  while (ok && i <= length) {
    if (eolnorf_command(data_file)) {
      ok = false;
      break;
    }
    read_character(data_file, command_, keyboard, &c);
    if (isupper(c))
      d = c + 32;
    else
      d = c;
    if (d == word_to_find[i-1])
      i++;
    else
      ok = false;
  }
  if (ok & (!eolnorf_command(data_file))) {
    read_character(data_file, command_, keyboard, &c);
    if (c != ' ' && c != ',' && c != ';')
      ok = false;
  }
  if (ok)
    return true;
  write_pch(stdout, " Keyword `", 10L);
  write_pch(stdout, word_to_find, length);
  write_pch(stdout, "' expected and assumed", 22L);
  write_line(stdout);
  if (c == ' ' && (d == ' ' || d == '@')) {
    write_pch(stdout, " Unexpected EndOfLine/Keyword", 29L);
    write_line(stdout);
  } else
    skip_word(data_file, c, &skip_count, echo);
  return false;
}  /* seek_word */


Static Void read_integer_separator(fil, command_, keyboard, one_digit, promb,
				   w, i, c)
FILE *fil;
boolean command_, keyboard, one_digit;
Char *promb;
t_integer w;
t_long_integer *i;
Char *c;
{
  seek_non_blank(fil, command_, keyboard, promb, w, c);
  if (*c == '-') {
    *i = STRUCT_ZERO;
    return;
  }
  if (*c == '/' || *c == ';') {
    *i = _UNDEF;
    return;
  }
  if (*c == '.' || *c == '*') {
    *i = MISSING;
    return;
  }
  if (*c == 'n' || *c == 'N') {
    if (seek_word(fil, command_, keyboard, "Null", 2L, 4L, *i,
		  true))
      *i = 0;
    else
      *i = 0;
    return;
  }
  if (*c == 'v' || *c == 'V') {
    if (seek_word(fil, command_, keyboard, "Variating", 2L, 9L, *i,
		  true))
      *i = 0;
    else
      *i = 0;
    return;
  }
  if (*c == 'r' || *c == 'R') {
    if (seek_word(fil, command_, keyboard, "Random", 2L, 6L, *i,
		  true))
      *i = MAXIMAL;
    else
      *i = MAXIMAL;
    return;
  }
  if (!isdigit(*c)) {
    *i = _INVALID;
    return;
  }
  *i = 0;
  while (isdigit(*c)) {
    *i = *i * 10 + *c - '0';
    if (eolnorf_command(fil) || one_digit)
      *c = ' ';
    else
      read_character(fil, command_, keyboard, c);
  }
}  /* read_integer_separator */


Static Void read_integer(f, promb, w, x)
FILE *f;
Char *promb;
t_integer w;
t_long_integer *x;
{
  Char c;

  do {
    read_integer_separator(f, true, true, false, promb, w, x, &c);
    if (*x == STRUCT_ZERO) {
      read_integer_separator(f, true, true, false, promb, w, x, &c);
      if (*x != _INVALID && *x != _UNDEF && *x != MISSING)
	*x = -*x;
    }
    if (echo || *x == _INVALID || *x == _UNDEF || *x == MISSING) {
      write_pch(stdout, promb, w);
      if (*x != _INVALID && *x != _UNDEF && *x != MISSING)
	write_integer(stdout, *x, 10L);
      else
	write_pch(stdout, " Invalid  ", 10L);
      write_line(stdout);
    }
  } while (!((*x != _INVALID && *x != _UNDEF && *x != MISSING) | eof_command(f)));
      /* read_integer */
}


Static Void read_integer_data(fil, command_, keyboard, i)
FILE *fil;
boolean command_, keyboard;
t_long_integer *i;
{
  Char c;

  read_integer_separator(fil, command_, keyboard, false, "1234567890", 0L, i,
			 &c);
}  /* read_integer_data */


Static Void sub_read_list_level(f, one_digit, level, c)
FILE *f;
boolean one_digit;
t_level *level;
Char *c;
{
  t_long_integer i;

  read_integer_separator(f, false, false, one_digit, "1234567890", 0L, &i, c);
  if (i == MISSING) {
    *level = MISSING_LEVEL;
    return;
  }
  if (i == _UNDEF) {
    *level = _UNDEF_LEVEL;
    return;
  }
  if ((unsigned long)i <= MAX_LEVEL)
    *level = i;
  else
    *level = _INVALID_LEVEL;
}  /* sub_read_list_level */


Static Void read_list_level(f, one_digit, level, c)
FILE *f;
boolean one_digit;
t_level *level;
Char *c;
{
  sub_read_list_level(f, one_digit, level, c);
  if (*level != MISSING_LEVEL && *level != _UNDEF_LEVEL &&
      *level != _INVALID_LEVEL)
    *level += FIRST_LEVEL - 1;
}  /* read_list_level */


Static Void read_level(f, level, c)
FILE *f;
t_level *level;
Char *c;
{
  sub_read_list_level(f, false, level, c);
}  /* read_level */


/* Not used:
procedure write_level(var f: text;
                          level: t_level;
                          w: t_long_integer);
begin
   if level = missing_level then
      write_pch(f, ' *        ', w)
   else
      write_integer(f, level, w)
end; */
/* write_level */

Static Void read_real_separator(fil, command_, keyboard, promb, w, x, c)
FILE *fil;
boolean command_, keyboard;
Char *promb;
t_integer w;
t_long_real *x;
Char *c;
{
  boolean found_digit = false, minus = false;
  t_integer i = 0;
  t_long_integer count;

  seek_non_blank(fil, command_, keyboard, promb, w, c);
  if (*c == '/') {
    *x = _UNDEF_REAL;
    return;
  }
  if (*c == '*') {
    *x = MISSING_REAL;
    return;
  }
  if (*c == 'n' || *c == 'N') {
    if (seek_word(fil, command_, keyboard, "Null", 2L, 4L, i,
		  true))
      *x = 0.0;
    else
      *x = 0.0;
    return;
  }
  if (!(*c == '.' || *c == '-' || *c == '+' || isdigit(*c))) {
    *x = _INVALID_REAL;
    return;
  }
  if (*c == '-' || *c == '+') {
    minus = (*c == '-');
    if (!eolnnotf_command(fil))
      read_character(fil, command_, keyboard, c);
    else
      *c = ' ';
  }
  if (!(*c == '.' || isdigit(*c))) {
    *x = _INVALID_REAL;
    return;
  }
  i = 0;
  while (isdigit(*c)) {
    found_digit = true;
    i = i * 10 + *c - '0';
    if (eolnorf_command(fil))
      *c = ' ';
    else
      read_character(fil, command_, keyboard, c);
  }
  *x = i;
  if (*c == '.') {
    if (!eolnnotf_command(fil))
      read_character(fil, command_, keyboard, c);
    else
      *c = ' ';
    i = 0;
    count = 0;
    while (isdigit(*c)) {
      found_digit = true;
      i = i * 10 + *c - '0';
      count++;
      if (eolnorf_command(fil))
	*c = ' ';
      else
	read_character(fil, command_, keyboard, c);
    }
    if (found_digit)
      *x += i / exp(count * log(10.0));
    else
      *x = MISSING_REAL;
  }
  if (minus)
    *x = -*x;
  if (*c != 'e' && *c != 'E')
    return;
  if (!eolnnotf_command(fil))
    read_character(fil, command_, keyboard, c);
  else
    *c = ' ';
  minus = false;
  if (*c == '-' || *c == '+') {
    minus = (*c == '-');
    if (!eolnnotf_command(fil))
      read_character(fil, command_, keyboard, c);
    else
      *c = ' ';
  }
  i = 0;
  while (isdigit(*c)) {
    i = i * 10 + *c - '0';
    if (eolnorf_command(fil))
      *c = ' ';
    else
      read_character(fil, command_, keyboard, c);
  }
  if (minus)
    *x /= exp(i * log(10.0));
  else
    *x *= exp(i * log(10.0));
}  /* read_real_separator */


Static Void read_real(f, promb, w, x)
FILE *f;
Char *promb;
t_integer w;
t_long_real *x;
{
  Char c;

  do {
    read_real_separator(f, true, true, promb, w, x, &c);
    if (echo || *x == _INVALID || *x == _UNDEF || *x == MISSING) {
      write_pch(stdout, promb, w);
      if (*x != _INVALID && *x != _UNDEF && *x != MISSING)
	write_real(stdout, *x, 10L, 5L);
      else
	write_pch(stdout, " Invalid  ", 10L);
      write_line(stdout);
    }
  } while (!((fabs(*x) <= fabs(0.999 * _INVALID_REAL)) | eof_command(f)));
      /* read_real */
}


/* Not used:
procedure read_real_data(var fil      : text;
                             command  : boolean;
                             keyboard : boolean;
                         var x      : t_long_real);
var
   c: char;
begin
   read_real_separator(fil, command, keyboard, '1234567890', 0, x, c)
end; */
/* read_real_data */

/*@-"mat.c"*/
/*@+"dispose.p"*/

/*

  383:    +++  ++
  384:    +++  ++
  385:    ---  -- p/dispose.p         63     221    3642 p/dispose.p
  386: |    4:    procedure dispose_integer_list
  387: |   15:    procedure dispose_real_list
  388: |   26:    procedure revers_vertex_list
  389: |   40:    procedure revers_set_list
    -: |    -:    procedure revers_g_c_list
  390: |   54:    procedure dispose_offset_list
  391: |   65:    procedure dispose_vertex_list
  392: |   76:    procedure dispose_list_of_vertex_lists
  393: |   88:    procedure dispose_set_list
  394: |   99:    procedure dispose_g_c_list
  395: |  111:    procedure dispose_edge_list
  396: |  122:    procedure dispose_cell_list
  397: |  134:    procedure dispose_discrete_generator_list
  398: |  146:    procedure dispose_linear_generator_list
  399: |  158:    procedure dispose_linear_and_quadratic_generator_list
  400: |  170:    procedure dispose_single_quadratic_generator_list
  401: |  182:    procedure dispose_quadratic_pair_generator_list
  402: |  194:    procedure dispose_m_ips_generators
  403: |  210:    procedure dispose_m_ips_element
  404: |  222:    procedure dispose_expression
  405: |  233:    procedure dispose_expression_min_max
  406: |  252:    procedure dispose_ips_set_list
  407: |  263:    procedure dispose_d_ips_element
  408: |  271:    procedure dispose_d_ips_element_min_max
  409: |  285:    procedure dispose_ips_list_min_max
  410: |  299:    procedure dispose_ips_list_blind
  411: |  311:    procedure dispose_cips_set_list
  412: |  322:    procedure dispose_c_ips_element
  413: |  328:    procedure dispose_continuous_ips_list
  414: |  341:    procedure dispose_r_ips_element
  415: |  361:    procedure dispose_radim_list
  416: |  373:    procedure dispose_radim_list_blind
  417: |  379:    procedure move_ps_in_all_models
  418: |  419:    procedure dispose_ips_list
  419: |  437:    procedure dispose_em_expression_and_ips_list
  420: |  466:    procedure dispose_identification
  421: |  496:    procedure dispose_model_link
  422: |  509:    procedure sub_dispose_formula
  423: |  575:    procedure dispose_formula
  424: |  586:    procedure dispose_formula_blind
  425: |  595:    procedure dispose_model
  426: |  616:    procedure dispose_model_and_link
  427: |  630:    procedure dispose_all_expressions
  428: |  642:    procedure dispose_model_but_identification
  429: |  652:    procedure clear_expression_and_set_model_set
  430: |  659:    procedure dispose_model_list
  431: |  684:    procedure dispose_internal_of_model_list
  432: |  708:    procedure dispose_all_models
  433: |  715:    procedure dispose_ps
  434: |  748:    procedure dispose_part_list
  435: |  759:    procedure dispose_sort_list
  436: |  772:    procedure dispose_test_list
  437: |  785:    procedure dispose_r_offset_list
  438: |  796:    procedure dispose_s_offset_list
  439: |  807:    procedure dispose_ss_offset_list
  440: |  818:    procedure dispose_t_offset_list
  441: |  829:    procedure dispose_2_3_tree
  442: |  862:    procedure dispose_internal_models
  443: |  882:    procedure dispose_tests
  444: |  889:    procedure dispose_offsets
  445: |  895:    procedure dispose_r_offsets
  446: |  901:    procedure dispose_s_offsets
  447: |  907:    procedure dispose_ss_offsets
  448: |  913:    procedure dispose_t_offsets
  449:    +++  ++
  450:    +++  ++

*/

Static Void dispose_integer_list(p)
t_integer_list **p;
{
  t_integer_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_integer_list */


Static Void dispose_real_list(p)
t_real_list **p;
{
  t_real_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_real_list */


Static Void revers_vertex_list(p)
t_vertex_list **p;
{
  t_vertex_list *hp1 = NULL;
  t_vertex_list *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_vertex_list */


Static Void revers_set_list(p)
t_set_list **p;
{
  t_set_list *hp1 = NULL;
  t_set_list *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_set_list */


Static Void revers_g_c_list(p)
t_g_c_list **p;
{
  t_g_c_list *hp1 = NULL;
  t_g_c_list *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_g_c_list */


Static Void dispose_offset_list(p)
t_offset_list **p;
{
  t_offset_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_offset_list */


Static Void dispose_vertex_list(p)
t_vertex_list **p;
{
  t_vertex_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_vertex_list */


Static Void dispose_list_of_vertex_lists(p)
t_list_of_vertex_lists **p;
{
  t_list_of_vertex_lists *q;

  while (*p != NULL) {
    dispose_vertex_list(&(*p)->vertex_list);
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_list_of_vertex_lists */


Static Void dispose_set_list(p)
t_set_list **p;
{
  t_set_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_set_list */


Static Void dispose_g_c_list(p)
t_g_c_list **p;
{
  t_g_c_list *q;

  while (*p != NULL) {
    dispose_set_list(&(*p)->g_c);
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_g_c_list */


Static Void dispose_edge_list(p)
t_edge_list **p;
{
  t_edge_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_edge_list */


Static Void dispose_cell_list(p)
t_cell_list **p;
{
  t_cell_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    dispose_vertex_list(&(*p)->vertex_list);
    _Free(*p);
    *p = q;
  }
}  /* dispose_cell_list */


Static Void dispose_discrete_generator_list(p)
t_discrete_generator **p;
{
  t_discrete_generator *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_discrete_generator_list */


Static Void dispose_linear_generator_list(p)
t_linear_generator **p;
{
  t_linear_generator *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_linear_generator_list */


Static Void dispose_linear_and_quadratic_generator_list(p)
t_linear_and_quadratic_generator **p;
{
  t_linear_and_quadratic_generator *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_linear_and_quadratic_generator_list */


Static Void dispose_single_quadratic_generator_list(p)
t_single_quadratic_generator **p;
{
  t_single_quadratic_generator *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_single_quadratic_generator_list */


Static Void dispose_quadratic_pair_generator_list(p)
t_quadratic_pair_generator **p;
{
  t_quadratic_pair_generator *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_quadratic_pair_generator_list */


Static Void dispose_m_ips_generators(generators)
t_mips_generators **generators;
{
  t_mips_generators *WITH;

  if (*generators != NULL) {
    WITH = *generators;
    dispose_discrete_generator_list(&WITH->discrete_generators);
    dispose_linear_generator_list(&WITH->linear_generators);
    dispose_linear_and_quadratic_generator_list(
      &WITH->linear_and_quadratic_generators);
    dispose_single_quadratic_generator_list(&WITH->single_quadratic_generators);
    dispose_quadratic_pair_generator_list(&WITH->quadratic_pair_generators);
  }
  _Free(*generators);
  *generators = NULL;
}  /* dispose_m_ips_generators */


Static Void dispose_m_ips_element(mixed_item)
t_mips_element *mixed_item;
{
  /* dispose_set_list(g_c); */
  dispose_set_list(&mixed_item->discrete_);
  dispose_set_list(&mixed_item->linear);
  dispose_set_list(&mixed_item->quadratic);
  _Free(mixed_item->mixed_characteristics);
  dispose_m_ips_generators(&mixed_item->generators);
}  /* dispose_m_ips_element */


Static Void dispose_expression(p)
t_expression **p;
{
  t_expression *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_expression */


/* Not used:
procedure dispose_expression_min_max
(var p  : t_link_expression;
 var min_p, max_p : t_e_p_cell_index);
var
   q   : t_link_expression;
   max : t_e_p_cell_index;
begin
   while p <> nil do begin
      if min_p > p^.offset then
         min_p := p^.offset;
      max := p^.offset + marginal_dimension(p^.vertex_set);
      if max_p < max then
         max_p := max;
      q := p^.pointer;
      dispose(p);
      p := q
   end
end; */
/* dispose_expression_min_max */

Static Void dispose_ips_set_list(p)
t_ips_set_list **p;
{
  t_ips_set_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_ips_set_list */


Static Void dispose_d_ips_element(ips_element)
t_ips_element *ips_element;
{
  if (!ips_element->radim_part) {
    dispose_offset_list(&ips_element->link_q_tables);
    dispose_ips_set_list(&ips_element->gen_class);
  }
}  /* dispose_d_ips_element */


Static Void dispose_d_ips_element_min_max(ips_element, min_p, max_p)
t_ips_element *ips_element;
t_e_p_cell_index *min_p, *max_p;
{
  t_e_p_cell_index max;

  if (*min_p > ips_element->p_offset)
    *min_p = ips_element->p_offset;
  max = ips_element->p_offset + marginal_dimension(ips_element->a);
  if (*max_p < max)
    *max_p = max;
  dispose_d_ips_element(ips_element);
}  /* dispose_d_ips_element_min_max */


Static Void dispose_ips_list_min_max(ips_list, min_p, max_p)
t_list_ips_elements **ips_list;
t_e_p_cell_index *min_p, *max_p;
{
  t_list_ips_elements *q;

  while (*ips_list != NULL) {
    dispose_d_ips_element_min_max(&(*ips_list)->ips_element, min_p, max_p);
    q = (*ips_list)->pointer;
    _Free(*ips_list);
    *ips_list = q;
  }
}  /* dispose_ips_list_min_max */


Static Void dispose_ips_list_blind(ips_list)
t_list_ips_elements **ips_list;
{
  t_list_ips_elements *q;

  while (*ips_list != NULL) {
    dispose_d_ips_element(&(*ips_list)->ips_element);
    q = (*ips_list)->pointer;
    _Free(*ips_list);
    *ips_list = q;
  }
}  /* dispose_ips_list_blind */


Static Void dispose_cips_set_list(p)
t_cips_set_list **p;
{
  t_cips_set_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_cips_set_list */


Static Void dispose_c_ips_element(cips_item)
t_cips_element *cips_item;
{
  /* dispose_set_list(cips_item.g_c); */
  dispose_cips_set_list(&cips_item->generators);
  /* if cips_item.m_ips_leaf <> nil then begin
       dispose_m_ips_element(cips_item.m_ips_leaf^);
       dispose(cips_item.m_ips_leaf)
    end */
}  /* dispose_c_ips_element */


/* Not used:
procedure dispose_continuous_ips_list
(var continuous_ips_list: t_link_list_cips_elements);
var
   q: t_link_list_cips_elements;
begin
   while continuous_ips_list <> nil do begin
      dispose_c_ips_element(continuous_ips_list^.link_cips_element^);
      q := continuous_ips_list^.pointer;
      dispose(continuous_ips_list);
      continuous_ips_list := q
   end
end; */
/* dispose_continuous_ips_list */

Static Void dispose_r_ips_element(radim_element)
t_radim_element *radim_element;
{
  t_radim_part *p, *radim_part;

  dispose_ips_set_list(&radim_element->gen_class);
  dispose_ips_list_blind(&radim_element->ips_list);   /* ?!?!? */
  dispose_offset_list(&radim_element->link_q_tables);
  dispose_integer_list(&radim_element->lower_n_offsets);
  radim_part = radim_element->radim_parts;
  while (radim_part != NULL) {
    dispose_offset_list(&radim_part->generators);
    dispose_offset_list(&radim_part->upper);
    dispose_offset_list(&radim_part->lower);
    dispose_offset_list(&radim_part->from);
    p = radim_part;
    radim_part = radim_part->pointer;
    _Free(p);
  }
}  /* dispose_r_ips_element */


/* Not used:
procedure dispose_radim_list(var radim_list: t_link_list_radim_elements);
var
   q: t_link_list_radim_elements;
begin
   while radim_list <> nil do begin
      dispose_r_ips_element(radim_list^.radim_element);
      q := radim_list;
      radim_list := radim_list^.pointer;
      dispose(q)
   end
end; */
/* dispose_radim_list */

/* Not used:
procedure dispose_radim_list_blind(var radim_list:
                                       t_link_list_radim_elements);
begin
   dispose_radim_list(radim_list)
end; */
/* dispose_radim_list_blind */

Static Void move_ps_in_all_models(min_p, max_p)
t_e_p_cell_index min_p, max_p;
{
  t_e_p_cell_index index;
  t_model_list *p_model;
  t_formula_node *formula_node;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_e_p_cell_index FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " MovePsInAllModels  ", sizeof(pch20));
  ntr_4(tzt, 20L, 417L, 1L, min_p, max_p, -1L, fpa);
  /*$endif TRACE*/
  if (fpa > max_p) {
    FORLIM = fpa;
    for (index = max_p; index <= FORLIM - 1; index++)
      p[index - max_p + min_p] = p[index];
    p_model = link_model_list;
    while (p_model != NULL) {
      formula_node = p_model->model->formula_node;
      if (formula_node != NULL) {
	switch (formula_node->node_type) {

	case null_node:
	  /* blank case */
	  break;

	case decomposition_node:
	  /* blank case */
	  break;

	case d_complete_node:
	  if (em) {
	    if (formula_node->UU.d_complete_leaf->offset > min_p &&
		formula_node->UU.d_complete_leaf->offset != MAX_OFFSET)
	      formula_node->UU.d_complete_leaf->offset += min_p - max_p;
	  }
	  break;

	case c_complete_node:
	  /* blank case */
	  break;

	case m_complete_node:
	  /* blank case */
	  break;

	case d_ips_node:
	  if (formula_node->UU.d_ips_leaf->p_offset > min_p &&
	      formula_node->UU.d_ips_leaf->p_offset != MAX_OFFSET)
	    formula_node->UU.d_ips_leaf->p_offset += min_p - max_p;
	  break;

	case r_ips_node:
	  /* blank case */
	  break;

	case c_ips_node:
	  /* blank case */
	  break;

	case m_ips_node:
	  /* blank case */
	  break;
	}
      }
      p_model = p_model->pointer;
    }
  }
  fpa += min_p - max_p;
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr(tzt, 20L, 417L, 1L, -8L, fpa);
}  /* move_ps_in_all_models */


Static Void dispose_ips_list(ips_list)
t_list_ips_elements **ips_list;
{
  t_e_p_cell_index min_p, max_p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeIpsList     ", sizeof(pch20));
  ntr(tzt, 20L, 419L, 1L, 1L, fpa);
  /*$endif TRACE*/
  if (em)
    write_pch(stdout, " Ups !!!!!", 10L);
  if (!em) {
    if (*ips_list != NULL) {
      if ((*ips_list)->ips_element.p_offset != MAX_OFFSET) {
	min_p = (*ips_list)->ips_element.p_offset;
	max_p = min_p;
	dispose_ips_list_min_max(ips_list, &min_p, &max_p);
	move_ps_in_all_models(min_p, max_p);
      } else {
	/*$ifdef TRACE*/
	dispose_ips_list_blind(ips_list);
      }
    }
  }
  /* dispose_all_expressions */
  /* !?!?! */
  ntr(tzt, 20L, 419L, 1L, 8L, fpa);
  /*$endif TRACE*/
}  /* dispose_ips_list */


/* Not used:
procedure dispose_em_expression_and_ips_list
(var expression: t_link_expression;
 var ips_list: t_link_list_ips_elements);
var
   min_p, max_p: t_e_p_cell_index;
   do_it: boolean;
begin
   do_it := false;
   if ips_list <> nil then
      if ips_list^.ips_element.p_offset <> max_offset then
         do_it := true;
   if expression <> nil then
      if expression^.offset <> max_offset then
         do_it := true;
   if do_it then begin
      if ips_list <> nil then
         min_p := ips_list^.ips_element.p_offset
      else
         min_p := expression^.offset;
      max_p := min_p;
      dispose_ips_list_min_max(ips_list, min_p, max_p);
      dispose_expression_min_max(expression, min_p, max_p);
      move_ps_in_all_models(min_p, max_p)
   end else begin
      dispose_ips_list_blind(ips_list);
      dispose_expression(expression)
   end
end; */
/* dispose_em_expression_and_ips_list */

Static Void dispose_identification(identification)
t_model_specification **identification;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeIdentificati", sizeof(pch20));
  ntr(tzt, 20L, 420L, 1L, 1L, fpa);
  /*$endif TRACE*/
  if (*identification != NULL) {
    /*$ifdef TRACE*/
    ntr_id(tzt, 20L, 420L, 1L, -1L, (*identification)->paritet,
	   identification);
    /*$endif TRACE*/
    dispose_set_list(&(*identification)->causal_structure);
    if ((*identification)->model_type == pure_discrete)
      dispose_set_list(&(*identification)->UU.g_c_log_linear);
    else if ((*identification)->model_type == pure_continuous)
      dispose_set_list(&(*identification)->UU.g_c_covariance);
    else {
      dispose_set_list(&(*identification)->UU.U1.g_c_discrete);
      dispose_set_list(&(*identification)->UU.U1.g_c_linear);
      dispose_set_list(&(*identification)->UU.U1.g_c_quadratic);
    }
    _Free(*identification);
  }
  *identification = NULL;
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr(tzt, 20L, 420L, 1L, 8L, fpa);
}  /* dispose_identification */


Static Void dispose_model_link(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeModelLink   ", sizeof(pch20));
  ntr(tzt, 20L, 421L, 1L, 0L, 0L);
  /*$endif TRACE*/
  _Free(*model);
}  /* dispose_model_link */


Static Void sub_dispose_formula(model, min_p, max_p, blind)
t_model **model;
t_e_p_cell_index *min_p, *max_p;
boolean blind;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula, *separator;

  formula = (*model)->formula_node;
  if (formula != NULL) {
    if (formula->tmp_m_ips_leaf != NULL) {
      dispose_m_ips_element(formula->tmp_m_ips_leaf);
      _Free(formula->tmp_m_ips_leaf);
      formula->tmp_m_ips_leaf = NULL;
    }
    switch (formula->node_type) {

    case null_node:
      /* blank case */
      break;

    case decomposition_node:
      decomposition_element = formula->UU.decomposition_node_;
      sub_dispose_formula(&decomposition_element->left_model, min_p, max_p,
			  blind);
      dispose_identification(&decomposition_element->left_model->id);
      dispose_model_link(&decomposition_element->left_model);
      sub_dispose_formula(&decomposition_element->right_model, min_p, max_p,
			  blind);
      dispose_identification(&decomposition_element->right_model->id);
      dispose_model_link(&decomposition_element->right_model);
      separator = decomposition_element->separator;
      switch (separator->node_type) {

      case d_complete_node:
	_Free(separator->UU.d_complete_leaf);
	break;

      case c_complete_node:
	_Free(separator->UU.c_complete_leaf);
	break;

      case m_complete_node:
	_Free(separator->UU.m_complete_leaf);
	break;
      }
      _Free(decomposition_element->separator);
      _Free(formula->UU.decomposition_node_);
      break;

    case d_complete_node:   /* EM ?!?!?! */
      _Free(formula->UU.d_complete_leaf);
      break;

    case c_complete_node:
      _Free(formula->UU.c_complete_leaf);
      break;

    case m_complete_node:
      _Free(formula->UU.m_complete_leaf);
      break;

    case d_ips_node:
      if (formula->UU.d_ips_leaf != NULL) {
	if (blind)
	  dispose_d_ips_element(formula->UU.d_ips_leaf);
	else
	  dispose_d_ips_element_min_max(formula->UU.d_ips_leaf, min_p, max_p);
	_Free(formula->UU.d_ips_leaf);
      }
      break;

    case r_ips_node:
      if (formula->UU.r_ips_leaf != NULL) {
	dispose_r_ips_element(formula->UU.r_ips_leaf);
	_Free(formula->UU.r_ips_leaf);
      }
      break;

    case c_ips_node:
      if (formula->UU.c_ips_leaf != NULL) {
	dispose_c_ips_element(formula->UU.c_ips_leaf);
	_Free(formula->UU.c_ips_leaf);
      }
      break;

    case m_ips_node:
      if (formula->UU.m_ips_leaf != NULL) {
	dispose_m_ips_element(formula->UU.m_ips_leaf);
	_Free(formula->UU.m_ips_leaf);
      }
      break;
    }
    _Free(formula);
  }
  (*model)->found_expression = false;
  (*model)->found_ps = false;
  (*model)->formula_node = NULL;
}  /* sub_dispose_formula */


Static Void dispose_formula(model)
t_model **model;
{
  t_e_p_cell_index min_p;
  t_e_p_cell_index max_p = 0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  min_p = max_p_cell_number;   /* max_offset */
  /* range check error */
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeFormula     ", sizeof(pch20));
  ntr_4(tzt, 20L, 423L, 1L, min_p, max_p, -1L, fpa);
  /*$endif TRACE*/
  sub_dispose_formula(model, &min_p, &max_p, false);
  if (min_p < max_p_cell_number) {   /* max_offset */
    /*$ifdef TRACE*/
    move_ps_in_all_models(min_p, max_p);
  }
  /*$endif TRACE*/
  ntr(tzt, 20L, 423L, 1L, -8L, fpa);
}  /* dispose_formula */


Static Void dispose_formula_blind(model)
t_model **model;
{
  t_e_p_cell_index min_p;
  t_e_p_cell_index max_p = 0;

  min_p = max_p_cell_number;   /* max_offset */
  /* range check error */
  sub_dispose_formula(model, &min_p, &max_p, true);
}  /* dispose_formula */


Static Void dispose_model(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeModel       ", sizeof(pch20));
  if ((*model)->id != NULL)
    ntr(tzt, 20L, 425L, 1L, (*model)->model_number, (*model)->id->paritet);
  else
    ntr(tzt, 20L, 425L, 1L, (*model)->model_number, 0L);
  /*$endif TRACE*/
  dispose_identification(&(*model)->id);
  (*model)->id = NULL;
  /*$ifdef TRACE*/
  dispose_formula(model);
  /*$endif TRACE*/
  ntr(tzt, 20L, 425L, 1L, (*model)->model_number, fpa);
}  /* dispose_model */


Static Void dispose_model_and_link(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeModelAndLink", sizeof(pch20));
  ntr(tzt, 20L, 426L, 1L, 0L, 0L);
  /*$endif TRACE*/
  dispose_model(model);
  /*$ifdef TRACE*/
  dispose_model_link(model);
  ntr(tzt, 20L, 426L, 1L, 8L, 0L);
  /*$endif TRACE*/
}  /* dispose_model_and_link */


Static Void dispose_all_expressions()
{
  t_model_list *p_model;

  p_model = link_model_list;
  while (p_model != NULL) {
    dispose_formula(&p_model->model);
    p_model = p_model->pointer;
  }
  fpa = P_START - FIRST_INDEX;
}  /* dispose_all_expressions */


Static Void dispose_model_but_identification(model)
t_model **model;
{
  t_model_specification *tmp_id;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeModelButIden", sizeof(pch20));
  ntr(tzt, 20L, 428L, 1L, 0L, 0L);
  /*$endif TRACE*/
  tmp_id = (*model)->id;
  (*model)->id = NULL;
  dispose_model(model);
  (*model)->id = tmp_id;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 428L, 1L, 8L, 0L);
  /*$endif TRACE*/
}  /* dispose_model_but_identification */


Static Void clear_expression_and_set_model_set(model, g)
t_model **model;
long *g;
{
  (*model)->formula_node = NULL;
  P_setcpy((*model)->id->vertices, g);
}  /* clear_expression_and_set_set */


Static Void dispose_model_list(p, dispose_gcs)
t_model_list **p;
boolean dispose_gcs;
{
  t_model_list *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeModelList   ", sizeof(pch20));
  ntr(tzt, 20L, 430L, 1L, 0L, 0L);
  /*$endif TRACE*/
  while (*p != NULL) {
    q = (*p)->pointer;
    if (dispose_gcs)
      dispose_model(&(*p)->model);
    _Free((*p)->model);
    _Free(*p);
    *p = q;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr(tzt, 20L, 430L, 1L, 0L, 1L);
}  /* dispose_model_list */


Static Void dispose_internal_model_list(p)
t_list_of_model_lists **p;
{
  t_list_of_model_lists *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeInternalMdlL", sizeof(pch20));
  ntr(tzt, 20L, 431L, 1L, 0L, 0L);
  /*$endif TRACE*/
  while (*p != NULL) {
    q = (*p)->pointer;
    if ((*p)->model_list != NULL)   /* Hack!!!! */
      (*p)->model_list->pointer = NULL;
    dispose_model_list(&(*p)->model_list, boolean_option[113]);
    _Free(*p);
    *p = q;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr(tzt, 20L, 431L, 1L, 0L, 1L);
}  /* dispose_internal_model_list */


Static Void dispose_all_models()
{
  dispose_model_list(&link_model_list, true);
  link_base = NULL;
  link_current = NULL;
}  /* dispose_all_models */


Static Void dispose_ps()
{
  t_model_list *p_model;
  t_formula_node *formula_node;

  p_model = link_model_list;
  while (p_model != NULL) {
    p_model->model->found_ps = false;
    formula_node = p_model->model->formula_node;
    if (formula_node != NULL) {
      switch (formula_node->node_type) {

      case null_node:
	/* blank case */
	break;

      case decomposition_node:
	/* blank case */
	break;

      case d_complete_node:
	if (em) {
	  if (formula_node->UU.d_complete_leaf->offset > 0 &&
	      formula_node->UU.d_complete_leaf->offset != MAX_OFFSET)
	    formula_node->UU.d_complete_leaf->offset = -1;
	}
	break;

      case c_complete_node:
	/* blank case */
	break;

      case m_complete_node:
	/* blank case */
	break;

      case d_ips_node:
	if (formula_node->UU.d_ips_leaf->p_offset > 0 &&
	    formula_node->UU.d_ips_leaf->p_offset != MAX_OFFSET)
	  formula_node->UU.d_ips_leaf->p_offset = MAX_OFFSET;
	break;

      case r_ips_node:
	/* blank case */
	break;

      case c_ips_node:
	/* blank case */
	break;

      case m_ips_node:
	/* blank case */
	break;
      }
    }
    p_model = p_model->pointer;
  }
  fpa = P_START - FIRST_INDEX;
}  /* dispose_ps */


Static Void dispose_part_list(link_part_list)
t_part_list **link_part_list;
{
  t_part_list *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposePartList    ", sizeof(pch20));
  ntr(tzt, 20L, 434L, 1L, 0L, 0L);
  /*$endif TRACE*/
  while (*link_part_list != NULL) {
    p = *link_part_list;
    *link_part_list = (*link_part_list)->pointer;
    _Free(p);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 434L, 1L, 8L, 0L);
  /*$endif TRACE*/
}  /* dispose_part_list */


Static Void dispose_sort_list(link_sort_list)
t_sort_list **link_sort_list;
{
  t_sort_list *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeSortList    ", sizeof(pch20));
  ntr(tzt, 20L, 435L, 1L, 0L, 0L);
  /*$endif TRACE*/
  while (*link_sort_list != NULL) {
    p = *link_sort_list;
    *link_sort_list = (*link_sort_list)->pointer;
    dispose_part_list(&p->link_sepa_list);
    dispose_part_list(&p->link_part_list);
    _Free(p);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 435L, 1L, 8L, 0L);
  /*$endif TRACE*/
}  /* dispose_sort_list */


Static Void dispose_test_list(link_test_list)
t_test_list **link_test_list;
{
  t_test_list *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeTestList    ", sizeof(pch20));
  ntr(tzt, 20L, 436L, 1L, 0L, 0L);
  /*$endif TRACE*/
  while (*link_test_list != NULL) {
    q = *link_test_list;
    *link_test_list = (*link_test_list)->pointer;
    /* dispose_set_list(q^.test.g_c_1);
       dispose_set_list(q^.test.g_c_2);
       dispose_set_list(q^.test.cs); */
    dispose_identification(&q->test.id_1);
    dispose_identification(&q->test.id_2);
    _Free(q);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 436L, 1L, 8L, 0L);
  /*$endif TRACE*/
}  /* dispose_test_list */


Static Void dispose_r_offset_list(p)
t_r_offset_list **p;
{
  t_r_offset_list *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeROffsetList ", sizeof(pch20));
  ntr(tzt, 20L, 437L, 1L, 0L, 0L);
  /*$endif TRACE*/
  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 437L, 1L, 8L, 0L);
  /*$endif TRACE*/
}  /* dispose_r_offset_list */


Static Void dispose_s_offset_list(p)
t_s_offset_list **p;
{
  t_s_offset_list *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeSOffsetList ", sizeof(pch20));
  ntr(tzt, 20L, 438L, 1L, 0L, 0L);
  /*$endif TRACE*/
  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 438L, 1L, 8L, 0L);
  /*$endif TRACE*/
}  /* dispose_s_offset_list */


Static Void dispose_ss_offset_list(p)
t_ss_offset_list **p;
{
  t_ss_offset_list *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeSSOffsetList", sizeof(pch20));
  ntr(tzt, 20L, 439L, 1L, 0L, 0L);
  /*$endif TRACE*/
  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 438L, 1L, 8L, 0L);
  /*$endif TRACE*/
}  /* dispose_ss_offset_list */


Static Void dispose_t_offset_list(p)
t_t_offset_list **p;
{
  t_t_offset_list *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeTOffsetList ", sizeof(pch20));
  ntr(tzt, 20L, 440L, 1L, 0L, 0L);
  /*$endif TRACE*/
  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 440L, 1L, 8L, 0L);
  /*$endif TRACE*/
}  /* dispose_t_offset_list */


Static Void dispose_2_3_tree(a)
t_2_3_node **a;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " Dispose-2-3-tree   ", sizeof(pch20));
  ntr(tzt, 20L, 441L, 1L, 0L, 0L);
  /*$endif TRACE*/
  if (*a != NULL) {
    if ((*a)->node_type == interior) {
      dispose_2_3_tree(&(*a)->UU.U1.firstchild);
      dispose_2_3_tree(&(*a)->UU.U1.secondchild);
      dispose_2_3_tree(&(*a)->UU.U1.thirdchild);
    } else {
      switch ((*a)->UU.leaf_->tree_type) {

      case model_tree:
	/* blank case */
	break;

      /* dispose_model_list(a^.leaf^.model_list, false) */
      case test_tree:
	dispose_part_list(&(*a)->UU.leaf_->UU.test_list);
	break;

      case r_offset_tree:
	dispose_r_offset_list(&(*a)->UU.leaf_->UU.r_offset_list);
	break;

      case s_offset_tree:
	dispose_s_offset_list(&(*a)->UU.leaf_->UU.s_offset_list);
	break;

      case ss_offset_tree:
	dispose_ss_offset_list(&(*a)->UU.leaf_->UU.ss_offset_list);
	break;

      case offset_tree:
	dispose_offset_list(&(*a)->UU.leaf_->UU.offset_list);
	break;
      }
      _Free((*a)->UU.leaf_);
    }
    _Free(*a);
  }
  *a = NULL;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 441L, 1L, 0L, 1L);
  /*$endif TRACE*/
}  /* dispose_2_3_tree */


Static Void dispose_internal_models()
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeInternalList", sizeof(pch20));
  ntr(tzt, 20L, 442L, 1L, 0L, 0L);
  /*$endif TRACE*/
  dispose_2_3_tree(&model_2_3_tree);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 442L, 1L, 0L, 1L);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  dispose_internal_model_list(&internal_model_list);
  ntr(tzt, 20L, 442L, 1L, 0L, 2L);
  /*$endif TRACE*/
}  /* dispose_internal_models */


Static Void dispose_tests()
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeTests       ", sizeof(pch20));
  ntr(tzt, 20L, 443L, 1L, 0L, 0L);
  /*$endif TRACE*/
  dispose_internal_models();
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 443L, 1L, 0L, 1L);
  /*$endif TRACE*/
  dispose_2_3_tree(&test_2_3_tree);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 443L, 1L, 0L, 2L);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  dispose_test_list(&link_test_list);
  /*$endif TRACE*/
  ntr(tzt, 20L, 443L, 1L, 0L, 3L);
}  /* dispose_tests */


Static Void dispose_offsets()
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeOffsets     ", sizeof(pch20));
  ntr(tzt, 20L, 444L, 1L, 0L, 0L);
  /*$endif TRACE*/
  dispose_2_3_tree(&offset_2_3_tree);
  dispose_offset_list(&link_offset_list);
}  /* dispose_offsets */


Static Void dispose_r_offsets()
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeROffsets    ", sizeof(pch20));
  ntr(tzt, 20L, 445L, 1L, 0L, 0L);
  /*$endif TRACE*/
  dispose_2_3_tree(&r_offset_2_3_tree);
  dispose_r_offset_list(&link_r_offset_list);
}  /* dispose_r_offsets */


Static Void dispose_s_offsets()
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeSOffsets    ", sizeof(pch20));
  ntr(tzt, 20L, 446L, 1L, 0L, 0L);
  /*$endif TRACE*/
  dispose_2_3_tree(&s_offset_2_3_tree);
  dispose_s_offset_list(&link_s_offset_list);
}  /* dispose_s_offsets */


Static Void dispose_ss_offsets()
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeSsOffsets   ", sizeof(pch20));
  ntr(tzt, 20L, 447L, 1L, 0L, 0L);
  /*$endif TRACE*/
  dispose_2_3_tree(&ss_offset_2_3_tree);
  dispose_ss_offset_list(&link_ss_offset_list);
}  /* dispose_ss_offsets */


Static Void dispose_t_offsets()
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeTOffsets    ", sizeof(pch20));
  ntr(tzt, 20L, 448L, 1L, 0L, 0L);
  /*$endif TRACE*/
  /* dispose_2_3_tree(t_offset_2_3_tree); */
  dispose_t_offset_list(&link_t_offset_list);
}  /* dispose_t_offsets */


/*@+"space.p"*/

/*

  537:    +++  ++
  538:    +++  ++
  539:    ---  -- p/space.p         29     155    1683 p/space.p
  540: |    4:    function space_in_n_array
  541: |   15:    function space_in_p_array
  542: |   26:    function space_in_q_array
  543: |   37:    procedure malloc_ss_array
  544: |   50:    procedure dispose_ss_arrays
  545: |   62:    function space_in_ss_array
  546: |   75:    function return_ss_space
  547: |   98:    function return_tmp_ss_space
  548: |  122:    function free_tmp_ss_space
  549: |  130:    procedure malloc_s_array
  550: |  143:    procedure dispose_s_arrays
  551: |  155:    function space_in_s_array
  552: |  167:    function return_s_space
  553: |  190:    function return_tmp_s_space
  554: |  214:    function free_tmp_s_space
  555: |  222:    procedure clear_r_array
  556: |  232:    procedure malloc_r_array
  557: |  245:    procedure dispose_r_arrays
  558: |  257:    function space_in_r_array
  559: |  269:    function return_r_space
  560: |  292:    function return_tmp_r_space
  561: |  316:    function free_tmp_r_space
  562: |  324:    procedure clear_t_array
  563: |  334:    procedure malloc_t_array
  564: |  347:    procedure dispose_t_arrays
  565: |  359:    function space_in_t_array
  566: |  371:    function return_t_space
  567: |  394:    function return_tmp_t_space
  568: |  418:    function free_tmp_t_space
  569:    +++  ++
  570:    +++  ++

*/

Static Void write_warning_size(f, c, w, size, top, used)
FILE *f;
Char *c;
t_long_integer w, size, top, used;
{
  if (!trace_flag_set(20L, 539L, 1L))
    return;
  /* warning_begin(output, false); */
  w -= 5;
  write_pch(f, c, w);
  /* write_line(f); */
  write_pch(f, " Required:", 10L);
  write_integer(f, size, 12L);
  write_pch(f, " Top:     ", 10L);
  write_integer(f, top, 12L);
  write_pch(f, " Used:    ", 10L);
  write_integer(f, used, 12L);
  write_pch(f, ".", 1L);
  write_line(f);
  /* warning_end(output, false); */
}  /* write_warning */


Static boolean space_in_n_array(increment, current)
t_long_integer increment, current;
{
  boolean ok = true;

  if (increment > max_cell_number - current &&
      increment < MAX_CELL_NUMBER_MAX - current)
    ok = resize_n(&n, current + increment, &max_cell_number);
  return ok;
}  /* space_in_n_array */


Static boolean space_in_p_array(increment, current)
t_long_integer increment, current;
{
  boolean ok = true;

  if (increment > max_p_cell_number - current &&
      increment < MAX_P_CELL_NUMBER_MAX - current)
    ok = resize_p(&p, current + increment, &max_p_cell_number);
  return ok;
}  /* space_in_p_array */


Static boolean space_in_q_array(increment, current)
t_long_integer increment, current;
{
  boolean ok = true;

  if (increment > max_q_cell_number - current &&
      increment < MAX_Q_CELL_NUMBER_MAX - current)
    ok = resize_q(&q_array, current + increment, &max_q_cell_number);
  return ok;
}  /* space_in_q_array */


Static Void dispose_ss_arrays(p)
t_ss_list **p;
{
  t_ss_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free((*p)->ss->z);
    _Free((*p)->ss);
    _Free(*p);
    *p = q;
  }
}  /* dispose_ss_arrays */


Static boolean space_in_ss_array(ss, increment, current)
t_ss_r **ss;
t_long_integer increment, current;
{
  boolean ok = true;

  if (increment > max_ss_cell_number - current &&
      increment < MAX_SS_CELL_NUMBER_MAX - current)
    ok = RESIZE_Ss(&(*ss)->z, increment, current, &max_ss_cell_number);
	/*_array*/
  return ok;
}  /* space_in_ss_array */


Static boolean return_ss_space(ss_size, ss, ss_offset)
t_long_integer *ss_size;
t_ss_r **ss;
t_ss_offset *ss_offset;
{
  boolean ok = true;

  /* p  : t_link_ss_list; */
  write_warning_size(stdout, " Note-1 (ReturnSSspace):    Size.", 33L,
		     *ss_size, max_ss_cell_number, ss_list->fssa);
  if (!TURBO_PC)
    ok = space_in_ss_array(&ss_list->ss, *ss_size, ss_list->fssa);
  if (ok)
    ok = (*ss_size <= max_ss_cell_number - ss_list->fssa);
  else {
    if (note_warnings) {
      write_pch(stdout, " Note-3 (ReturnSSspace): SpaceInSSarray.", 40L);
      write_line(stdout);
    }
  }
  if (!ok) {
    write_warning_size(stdout, " Note-4 (ReturnSSspace):    Size.",
		       33L, *ss_size, max_ss_cell_number, ss_list->fssa);
    return ok;
  }
  if (ss_list->top != 0)
    write_warning(stdout, " Space on top of temporary in SS-array. ", 40L);
  *ss_offset = ss_list->fssa;
  ss_list->fssa += *ss_size;
  *ss = ss_list->ss;
  return ok;
}  /* return_ss_space */


/* Not used:
function return_tmp_ss_space(var ss_size   : t_long_integer;
                             var ss   : t_ss;
                             var ss_offset : t_ss_offset): boolean;
var
   ok : boolean;
begin
   write_warning_size(output,
                      ' Note-1 (ReturnTmpSSspace): Size.@@@@@@@', 33,
                      ss_size, max_ss_cell_number, ss_list^.fssa);
   ok := true;
   if not turbo_pc then
      ok := space_in_ss_array(ss_list^.ss, ss_size,
                              ss_list^.fssa + ss_list^.top);
   if ok then
      ok := ss_size <= max_ss_cell_number - ss_list^.fssa - ss_list^.top
   else begin
      if note_warnings then begin
         write_pch(output,
                     ' Note-3 (ReturnSSspace): SpaceInSSarray.', 40);
         write_line(output)
      end
   end;
   if ok then begin
      if ss_list^.top <> 0 then
         write_warning(output,
                       ' Temporary on top of temp. in SS-array. ', 40);
      ss_offset := ss_list^.fssa + ss_list^.top;
      ss_list^.top := ss_list^.top + ss_size;
      ss := ss_list^.ss
   end else
      write_warning_size(output,
                         ' Note-4 (ReturnTmpSSspace): Size.@@@@@@@', 33,
                         ss_size, max_ss_cell_number, ss_list^.fssa);
   return_tmp_ss_space := ok;
end; */
/* return_tmp_ss_space */

/* Not used:
function free_tmp_ss_space */
/* ( ss_size : t_long_integer;
                           var ss : t_ss;
                           var ss_offset : t_ss_offset) */
/* : boolean;
begin
   ss_list^.top := 0;
   free_tmp_ss_space := true;
end; */
/* free_tmp_ss_space */

Static Void dispose_s_arrays(p)
t_s_list **p;
{
  t_s_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free((*p)->s->z);
    _Free((*p)->s);
    _Free(*p);
    *p = q;
  }
}  /* dispose_s_arrays */


Static boolean space_in_s_array(s, increment, current)
t_s_r **s;
t_long_integer increment, current;
{
  boolean ok = true;

  if (increment > max_s_cell_number - current &&
      increment < MAX_S_CELL_NUMBER_MAX - current)
    ok = RESIZE_S(&(*s)->z, increment, current, &max_s_cell_number);
	/*_array*/
  return ok;
}  /* space_in_s_array */


Static boolean return_s_space(s_size, s, s_offset)
t_long_integer *s_size;
t_s_r **s;
t_s_offset *s_offset;
{
  boolean ok = true;

  /* p  : t_link_s_list; */
  write_warning_size(stdout, " Note-1 (ReturnSspace):     Size.", 33L,
		     *s_size, max_s_cell_number, s_list->fsa);
  if (!TURBO_PC)
    ok = space_in_s_array(&s_list->s, *s_size, s_list->fsa);
  if (ok)
    ok = (*s_size <= max_s_cell_number - s_list->fsa);
  else {
    if (note_warnings) {
      write_pch(stdout, " Note-3 (ReturnSspace): SpaceInSarray.", 38L);
      write_line(stdout);
    }
  }
  if (!ok) {
    write_warning_size(stdout, " Note-4 (ReturnSspace):     Size.",
		       33L, *s_size, max_s_cell_number, s_list->fsa);
    return ok;
  }
  if (s_list->top != 0)
    write_warning(stdout, " Space on top of temporary in S-array.  ", 40L);
  *s_offset = s_list->fsa;
  s_list->fsa += *s_size;
  *s = s_list->s;
  return ok;
}  /* return_s_space */


Static boolean return_tmp_s_space(s_size, s, s_offset)
t_long_integer s_size;
t_s_r **s;
t_s_offset *s_offset;
{
  boolean ok = true;

  /* p  : t_link_s_list; */
  write_warning_size(stdout, " Note-1 (ReturnTmpSspace):  Size.", 33L,
		     s_size, max_s_cell_number, s_list->fsa);
  if (!TURBO_PC)
    ok = space_in_s_array(&s_list->s, s_size, s_list->fsa + s_list->top);
  if (ok)
    ok = (s_size <= max_s_cell_number - s_list->fsa - s_list->top);
  else {
    if (note_warnings) {
      write_pch(stdout, " Note-3 (ReturnSspace): SpaceInSarray.", 38L);
      write_line(stdout);
    }
  }
  if (!ok) {
    write_warning_size(stdout, " Note-4 (ReturnTmpSspace):  Size.",
		       33L, s_size, max_s_cell_number, s_list->fsa);
    return ok;
  }
  if (s_list->top != 0)
    write_warning(stdout, " Temporary on top of temp. in S-array.  ", 40L);
  *s_offset = s_list->fsa + s_list->top;
  s_list->top += s_size;
  *s = s_list->s;
  return ok;
}  /* return_tmp_s_space */


Static boolean free_tmp_s_space()
{
  /* ( s_size   : t_long_integer;
                            var s       : t_s;
                            var s_offset : t_s_offset) */
  s_list->top = 0;
  return true;
}  /* free_tmp_s_space */


/* Not used:
procedure clear_r_array(var r: t_r;
                        var r_offset: t_r_offset;
                        var size: t_r_offset);
var
   index: t_e_cell_index;
begin
   for index := r_offset + first_index to r_offset + first_index + size - 1 do
      r^.z^[index] := 0
end; */
/* clear_r_array */

Static Void dispose_r_arrays(p)
t_r_list **p;
{
  t_r_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free((*p)->r->z);
    _Free((*p)->r);
    _Free(*p);
    *p = q;
  }
}  /* dispose_r_arrays */


Static boolean space_in_r_array(r, increment, current)
t_r_r **r;
t_long_integer increment, current;
{
  boolean ok = true;

  if (increment > max_r_cell_number - current &&
      increment < MAX_R_CELL_NUMBER_MAX - current)
    ok = RESIZE_R(&(*r)->z, increment, current, &max_r_cell_number);
	/*_array*/
  return ok;
}  /* space_in_r_array */


Static boolean return_r_space(r_size, r, r_offset)
t_long_integer *r_size;
t_r_r **r;
t_r_offset *r_offset;
{
  boolean ok = true;

  /* p  : t_link_r_list; */
  write_warning_size(stdout, " Note-1 (ReturnRspace):     Size.", 33L,
		     *r_size, max_r_cell_number, r_list->fra);
  if (!TURBO_PC)
    ok = space_in_r_array(&r_list->r, *r_size, r_list->fra);
  if (ok)
    ok = (*r_size <= max_r_cell_number - r_list->fra);
  else {
    if (note_warnings) {
      write_pch(stdout, " Note-3 (ReturnRspace): SpaceInRarray.", 38L);
      write_line(stdout);
    }
  }
  if (!ok) {
    write_warning_size(stdout, " Note-4 (ReturnRspace):     Size.",
		       33L, *r_size, max_r_cell_number, r_list->fra);
    return ok;
  }
  if (r_list->top != 0)
    write_warning(stdout, " Space on top of temporary in R-array.  ", 40L);
  *r_offset = r_list->fra;
  r_list->fra += *r_size;
  *r = r_list->r;
  return ok;
}  /* return_r_space */


Static boolean return_tmp_r_space(r_size, r, r_offset)
t_long_integer *r_size;
t_r_r **r;
t_r_offset *r_offset;
{
  boolean ok = true;

  /* p  : t_link_r_list; */
  write_warning_size(stdout, " Note-1 (ReturnTmpRspace):  Size.", 33L,
		     *r_size, max_r_cell_number, r_list->fra);
  if (!TURBO_PC)
    ok = space_in_r_array(&r_list->r, *r_size, r_list->fra + r_list->top);
  if (ok)
    ok = (*r_size <= max_r_cell_number - r_list->fra - r_list->top);
  else {
    if (note_warnings) {
      write_pch(stdout, " Note-3 (ReturnRspace): SpaceInRarray.", 38L);
      write_line(stdout);
    }
  }
  if (!ok) {
    write_warning_size(stdout, " Note-4 (ReturnTmpRspace):  Size.",
		       33L, *r_size, max_r_cell_number, r_list->fra);
    return ok;
  }
  if (r_list->top != 0)
    write_warning(stdout, " Temporary on top of temp. in R-array.  ", 40L);
  *r_offset = r_list->fra + r_list->top;
  r_list->top += *r_size;
  *r = r_list->r;
  return ok;
}  /* return_tmp_r_space */


Static boolean free_tmp_r_space()
{
  /* ( r_size   : t_long_integer;
                            var r       : t_r;
                            var r_offset : t_r_offset) */
  r_list->top = 0;
  return true;
}  /* free_tmp_r_space */


Static Void clear_t_array(t, t_offset_, size)
t_t_r **t;
t_t_offset *t_offset_, *size;
{
  t_e_cell_index index, FORLIM;

  FORLIM = *t_offset_ + *size;
  for (index = *t_offset_; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ass(t, t_offset_, index, 0.0, " ClearTArray        ", 20L, 562L, 1L);
    /*$endif TRACE-ARRAY*/
    (*t)->z[index] = 0.0;
  }
}  /* clear_t_array */


Static Void dispose_t_arrays(p)
t_t_list **p;
{
  t_t_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free((*p)->t->z);
    _Free((*p)->t);
    _Free(*p);
    *p = q;
  }
}  /* dispose_t_arrays */


Static boolean space_in_t_array(t, increment, current)
t_t_r **t;
t_long_integer increment, current;
{
  boolean ok = true;

  if (increment > max_t_cell_number - current &&
      increment < MAX_T_CELL_NUMBER_MAX - current)
    ok = RESIZE_T(&(*t)->z, increment, current, &max_t_cell_number);
	/*_array*/
  return ok;
}  /* space_in_t_array */


Static boolean return_t_space(t_size, t, t_offset_)
t_long_integer t_size;
t_t_r **t;
t_t_offset *t_offset_;
{
  boolean ok = true;

  /* p  : t_link_t_list; */
  write_warning_size(stdout, " Note-1 (ReturnTspace):     Size.", 33L,
		     t_size, max_t_cell_number, t_list->fta);
  if (!TURBO_PC)
    ok = space_in_t_array(&t_list->t, t_size, t_list->fta);
  if (ok)
    ok = (t_size <= max_t_cell_number - t_list->fta);
  else {
    if (note_warnings) {
      write_pch(stdout, " Note-3 (ReturnTspace): SpaceInTarray.", 38L);
      write_line(stdout);
    }
  }
  if (!ok) {
    write_warning_size(stdout, " Note-4 (ReturnTspace):     Size.",
		       33L, t_size, max_t_cell_number, t_list->fta);
    return ok;
  }
  if (t_list->top != 0)
    write_warning(stdout, " Space on top of temporary in T-array.  ", 40L);
  *t_offset_ = t_list->fta;
  t_list->fta += t_size;
  *t = t_list->t;
  return ok;
}  /* return_t_space */


Static boolean return_tmp_t_space(t_size, t, t_offset_)
t_long_integer t_size;
t_t_r **t;
t_t_offset *t_offset_;
{
  boolean ok = true;

  /* p  : t_link_t_list; */
  write_warning_size(stdout, " Note-1 (ReturnTmpTspace):  Size.", 33L,
		     t_size, max_t_cell_number, t_list->fta);
  if (!TURBO_PC)
    ok = space_in_t_array(&t_list->t, t_size, t_list->fta + t_list->top);
  if (ok)
    ok = (t_size <= max_t_cell_number - t_list->fta - t_list->top);
  else {
    if (note_warnings) {
      write_pch(stdout, " Note-3 (ReturnTspace): SpaceInTarray.", 38L);
      write_line(stdout);
    }
  }
  if (!ok) {
    write_warning_size(stdout, " Note-4 (ReturnTmpTspace):  Size.",
		       33L, t_size, max_t_cell_number, t_list->fta);
    return ok;
  }
  if (t_list->top != 0)
    write_warning(stdout, " Temporary on top of temp. in T-array.  ", 40L);
  *t_offset_ = t_list->fta + t_list->top;
  t_list->top += t_size;
  *t = t_list->t;
  return ok;
}  /* return_tmp_t_space */


Static boolean free_tmp_t_space()
{
  /* ( t_size   : t_long_integer;
                            var t       : t_t;
                            var t_offset : t_t_offset) */
  t_list->top = 0;
  return true;
}  /* free_tmp_t_space */


/*@+"lists.p"*/


/*


  571:    +++  ++
  572:    +++  ++
  573:    ---  -- p/lists.p         31     126    1858 p/lists.p
  574: |    4:    procedure insert_real_in_real_list
  575: |   15:    procedure insert_integer_in_integer_list
  576: |   26:    procedure insert_vertex_in_vertex_list
  577: |   37:    procedure insert_set_in_set_list
  578: |   48:    - function return_empty_gc
  579: |   57:    procedure copy_set_list
  580: |   67:    procedure copy_ordered_set_list
  581: |   74:    procedure insert_set_minimal
  582: |  103:    procedure insert_clique
  583: |  132:    procedure add_cliques
  584: |  141:    procedure add_delta_gamma_cliques
  585: |  153:    function subset_of_an_edge
  586: |  169:    function contains_an_edge
  587: |  185:    procedure insert_g_c_in_g_c_list
  588: |  196:    procedure insert_edge_in_edge_list
  589: |  209:    procedure dispose_case_list
  590: |  220:    procedure dispose_item_list
  591: |  236:    procedure make_case_list
  592: |  255:    procedure clear_test
  593: |  288:    procedure new_test
  594: |  296:    function new_test_write_options
  595: |  311:    function new_test_write_options_do
  596: |  325:    function new_test_write_options_true
  597: |  338:    function new_test_write_options_false
  598: |  351:    function new_test_labels_empty
  599: |  367:    function new_test_labels_reused
  600: |  384:    - function new_test_labels_string
  601: |  402:    - function new_test_labels_set
  602: |  418:    - function new_test_labels_pair
  603: |  434:    procedure clear_stepwise_options
  604: |  456:    function copy_stepwise_options
  605:    +++  ++
  606:    +++  ++

*/

Static Void insert_real_in_real_list(x, real_list)
t_long_real x;
t_real_list **real_list;
{
  t_real_list *p;

  p = (t_real_list *)Malloc(sizeof(t_real_list));
  if (p == NULL)
    _OutMem();
  p->x = x;
  p->pointer = *real_list;
  *real_list = p;
}  /* insert_real_in_real_list */


Static Void insert_integer_in_integer_list(i, integer_list)
t_long_integer i;
t_integer_list **integer_list;
{
  t_integer_list *p;

  p = (t_integer_list *)Malloc(sizeof(t_integer_list));
  if (p == NULL)
    _OutMem();
  p->x = i;
  p->pointer = *integer_list;
  *integer_list = p;
}  /* insert_integer_in_integer_list */


Static Void insert_vertex_in_vertex_list(v, vertex_list)
t_vertex v;
t_vertex_list **vertex_list;
{
  t_vertex_list *p;

  p = (t_vertex_list *)Malloc(sizeof(t_vertex_list));
  if (p == NULL)
    _OutMem();
  p->vertex = v;
  p->pointer = *vertex_list;
  *vertex_list = p;
}  /* insert_vertex_in_vertex_list */


Static Void insert_set_in_set_list(a, set_list)
long *a;
t_set_list **set_list;
{
  t_set_list *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertSetInSetList ", sizeof(pch20));
  ntr_set_and_g_c(tzt, 20L, 577L, 1L, -1L, -1L, a, set_list);
  /*$endif TRACE*/
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, a);
  p->pointer = *set_list;
  *set_list = p;
  /*$ifdef TRACE*/
  ntr_set_and_g_c(tzt, 20L, 577L, 1L, -9L, -9L, a, set_list);
  /*$endif TRACE*/
}  /* insert_set_in_set_list */


/* Not used:
function return_empty_gc: t_link_set_list;
var
   p: t_link_set_list;
begin
   p := nil;
   insert_set_in_set_list(empty_set, p);
   return_empty_gc := p
end; */
/* return_empty_gc */

Static Void copy_set_list(link_1, link_2)
t_set_list *link_1, **link_2;
{
  *link_2 = NULL;
  while (link_1 != NULL) {
    insert_set_in_set_list(link_1->vertex_set, link_2);
    link_1 = link_1->pointer;
  }
}  /* copy_set_list */


Static Void copy_ordered_set_list(link_1, link_2)
t_set_list *link_1, **link_2;
{
  copy_set_list(link_1, link_2);
  revers_set_list(link_2);
}  /* copy_ordered_set_list */


Static Void insert_set_minimal(a, list_of_sets)
long *a;
t_set_list **list_of_sets;
{
  t_set_list *p, *q;
  boolean b = true;

  p = *list_of_sets;
  while (p != NULL && b) {
    if (P_subset(p->vertex_set, a))
      b = false;
    else
      p = p->pointer;
  }
  if (!b)
    return;
  p = *list_of_sets;
  insert_set_in_set_list(a, list_of_sets);
  q = *list_of_sets;
  while (p != NULL) {
    if (P_subset(a, p->vertex_set)) {
      q->pointer = p->pointer;
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* insert_set_minimal */


Static Void insert_clique(a, list_of_sets)
long *a;
t_set_list **list_of_sets;
{
  t_set_list *p, *q;
  boolean b = true;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertClique       ", sizeof(pch20));
  ntr_set_and_g_c(tzt, 20L, 582L, 1L, -1L, -1L, a, list_of_sets);
  /*$endif TRACE*/
  p = *list_of_sets;
  while (p != NULL && b) {
    if (P_subset(a, p->vertex_set))
      b = false;
    else
      p = p->pointer;
  }
  if (b) {
    p = *list_of_sets;
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 582L, 1L, -2L, -1L, list_of_sets);
    /*$endif TRACE*/
    insert_set_in_set_list(a, list_of_sets);
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 582L, 1L, -2L, -2L, &p);
    ntr_g_c(tzt, 20L, 582L, 1L, -2L, -3L, list_of_sets);
    /*$endif TRACE*/
    q = *list_of_sets;
    while (p != NULL) {
      if (P_subset(p->vertex_set, a)) {
	q->pointer = p->pointer;
	_Free(p);
	p = q->pointer;
      } else {
	q = p;
	p = p->pointer;
      }
    }
  }
  /*$ifdef TRACE*/
  ntr_set_and_g_c(tzt, 20L, 582L, 1L, -9L, -9L, a, list_of_sets);
  /*$endif TRACE*/
}  /* insert_clique */


Static Void add_cliques(add_list, list_of_cliques)
t_set_list *add_list, **list_of_cliques;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " AddCliques         ", sizeof(pch20));
  ntr_double_g_c(tzt, 20L, 583L, 1L, -1L, -1L, &add_list, list_of_cliques,
		 true);
  /*$endif TRACE*/
  while (add_list != NULL) {
    insert_clique(add_list->vertex_set, list_of_cliques);
    add_list = add_list->pointer;
  }
  /*$ifdef TRACE*/
  ntr_double_g_c(tzt, 20L, 583L, 1L, -9L, -9L, &add_list, list_of_cliques,
		 true);
  /*$endif TRACE*/
}  /* add_cliques */


Static Void add_delta_gamma_cliques(add_list, list_of_cliques)
t_set_list *add_list, **list_of_cliques;
{
  t_vertex_set a;

  while (add_list != NULL) {
    P_setint(a, add_list->vertex_set, delta_gamma);
    insert_clique(a, list_of_cliques);
    add_list = add_list->pointer;
  }
}  /* add_delta_gamma_cliques */


Static boolean subset_of_an_edge(a, list_of_cliques)
long *a;
t_set_list **list_of_cliques;
{
  t_set_list *p;
  boolean b = true;

  p = *list_of_cliques;
  while (p != NULL && b) {
    if (P_subset(a, p->vertex_set))
      b = false;
    else
      p = p->pointer;
  }
  return (!b);
}  /* subset_of_an_edge */


Static Void remove_sub_cliques(add_list, list_of_cliques)
t_set_list **add_list, **list_of_cliques;
{
  t_set_list *p, *q;
  boolean b;

  p = *list_of_cliques;
  *list_of_cliques = NULL;
  while (p != NULL) {
    /*
    b := true;
    q := add_list;
    while (q <> nil) and b do
       if p^.vertex_set <= q^.vertex_set then
          b := false
       else
          q := q^.pointer;
    */
    b = !subset_of_an_edge(p->vertex_set, add_list);
    if (b)
      insert_clique(p->vertex_set, list_of_cliques);
    q = p;
    p = p->pointer;
    _Free(q);
  }
}  /* remove_sub_cliques */


Static Void remove_id_sub_cliques(add_list, list_of_cliques)
t_model_specification **add_list;
t_set_list **list_of_cliques;
{
}  /* remove_id_sub_cliques */


Static Void add_not_sub_cliques(add_list, list_of_sets, list_of_cliques)
t_set_list *add_list, **list_of_sets, **list_of_cliques;
{
  while (add_list != NULL) {
    if (!subset_of_an_edge(add_list->vertex_set, list_of_sets))
      insert_clique(add_list->vertex_set, list_of_cliques);
    add_list = add_list->pointer;
  }
}  /* add_not_sub_cliques */


Static boolean contains_an_edge(a, list_of_cliques)
long *a;
t_set_list **list_of_cliques;
{
  t_set_list *p;
  boolean b = true;

  p = *list_of_cliques;
  while (p != NULL && b) {
    if (P_subset(p->vertex_set, a))
      b = false;
    else
      p = p->pointer;
  }
  return (!b);
}  /* contains_an_edge */


Static Void insert_g_c_in_g_c_list(g_c, g_c_list)
t_set_list *g_c;
t_g_c_list **g_c_list;
{
  t_g_c_list *p;

  p = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
  if (p == NULL)
    _OutMem();
  p->g_c = g_c;
  p->pointer = *g_c_list;
  *g_c_list = p;
}  /* insert_g_c_in_g_c_list */


Static Void insert_edge_in_edge_list(v, w, edge_list)
t_vertex v, w;
t_edge_list **edge_list;
{
  t_edge_list *p;

  p = (t_edge_list *)Malloc(sizeof(t_edge_list));
  if (p == NULL)
    _OutMem();
  p->v = v;
  p->w = w;
  p->pointer = *edge_list;
  *edge_list = p;
}  /* insert_edge_in_edge_list */


Static Void dispose_case_list(p)
t_case_list **p;
{
  t_case_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_case_list */


Static Void dispose_item_list(p, dispose_case)
t_item_list **p;
boolean dispose_case;
{
  t_item_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    if (dispose_case) {
      _Free((*p)->item.integer_vector);
      _Free((*p)->item.real_vector);
    }
    _Free(*p);
    *p = q;
  }
}  /* dispose_item_list */


Static Void make_case_list()
{
  t_cell i;
  t_vertex v;
  t_case_list *p_case_list;

  dispose_case_list(&case_list_read);
  rewind(file_read);
  while (!eof_level_file(file_read)) {
    for (v = first_vertex; v <= last_vertex; v++)
      read_level_file(file_read, &i[v - MIN_VERTEX]);
    p_case_list = (t_case_list *)Malloc(sizeof(t_case_list));
    if (p_case_list == NULL)
      _OutMem();
    p_case_list->pointer = case_list_read;
    memcpy(p_case_list->cell, i, sizeof(t_cell));
    case_list_read = p_case_list;
  }
  case_list = case_list_read;
}  /* make_case_list */


Static Void clear_test(test)
t_test *test;
{
  test->test_type = pure_discrete;
  /* test.cs := nil;
     test.g_c_1 := nil;
     test.g_c_2 := nil; */
  test->id_1 = NULL;
  test->id_2 = NULL;
  test->beta = _INVALID_REAL;
  test->x_f_test = _INVALID_REAL;
  test->x_deviance = _INVALID_REAL;
  test->x_pearson = _INVALID_REAL;
  test->x_power = _INVALID_REAL;
  test->gamma = _INVALID_REAL;
  test->s = _INVALID_REAL;
  test->s1 = _INVALID_REAL;
  test->mcep_f_test = -1.0;
  test->mcep_deviance = -1.0;
  test->mcep_pearson = -1.0;
  test->mcep_power = -1.0;
  test->mcep_gamma_1 = -1.0;
  test->mcep_gamma_2 = -1.0;
  test->number_of_tables = -1;
  test->test_ifail = -1;
  test->paritet = -1;
  test->df = _INFINITY;
  test->df_real = _INFINITY;
  test->adj = _INFINITY;
  test->f_test_df = _INFINITY;
  test->beta_df = _INFINITY;
  test->n_count = -1;
  test->ok = false;
  test->in_eh = false;
  test->class_ = 0;
  test->decomposable = false;
  test->graphical = false;
}  /* clear_test */


Static Void new_test(link_test)
t_test_list **link_test;
{
  *link_test = (t_test_list *)Malloc(sizeof(t_test_list));
  if (*link_test == NULL)
    _OutMem();
  (*link_test)->pointer = NULL;
  clear_test(&(*link_test)->test);
}  /* new_test */


/* Not used:
function new_test_write_options(var write_test, line_form,
                                    write_models : boolean):
                                                     t_link_test_write_options;

var
   p: t_link_test_write_options;
begin
   new(p);
   p^.write_test   := write_test;
   p^.line_form    := line_form;
   p^.write_models := write_models;
   p^.examin_terms := false;
   new_test_write_options := p
end; */
/* new_test_write_options */

Static t_test_write_options *new_test_write_options_do(line_form, write_models)
boolean *line_form, *write_models;
{
  t_test_write_options *p;

  p = (t_test_write_options *)Malloc(sizeof(t_test_write_options));
  if (p == NULL)
    _OutMem();
  p->write_test = true;
  p->line_form = *line_form;
  p->write_models = *write_models;
  p->examin_terms = false;
  return p;
}  /* new_test_write_options */


Static t_test_write_options *new_test_write_options_true()
{
  t_test_write_options *p;

  p = (t_test_write_options *)Malloc(sizeof(t_test_write_options));
  if (p == NULL)
    _OutMem();
  p->write_test = true;
  p->line_form = true;
  p->write_models = true;
  p->examin_terms = false;
  return p;
}  /* new_test_write_options_true */


Static t_test_write_options *new_test_write_options_false()
{
  t_test_write_options *p;

  p = (t_test_write_options *)Malloc(sizeof(t_test_write_options));
  if (p == NULL)
    _OutMem();
  p->write_test = true;
  p->line_form = false;
  p->write_models = false;
  p->examin_terms = false;
  return p;
}  /* new_test_write_options_false */


Static t_test_labels *new_test_labels_empty()
{
  t_test_labels *p;

  p = (t_test_labels *)Malloc(sizeof(t_test_labels));
  if (p == NULL)
    _OutMem();
  p->indent = 0;
  p->reused_test = false;
  p->short_report = false;
  p->separators = false;
  p->write_type = _string_label;
  memcpy(p->UU.U0.label_string, "", sizeof(pch20));
  p->UU.U0.width = 0;
  return p;
}  /* new_test_labels_empty */


Static t_test_labels *new_test_labels_reused(indent, reused_test)
t_long_integer *indent;
boolean *reused_test;
{
  t_test_labels *p;

  p = (t_test_labels *)Malloc(sizeof(t_test_labels));
  if (p == NULL)
    _OutMem();
  p->indent = *indent;
  p->reused_test = *reused_test;
  p->short_report = false;
  p->separators = false;
  p->write_type = _string_label;
  memcpy(p->UU.U0.label_string, "", sizeof(pch20));
  p->UU.U0.width = 0;
  return p;
}  /* new_test_labels_reused */


/* Not used:
function new_test_labels_string(var indent : t_long_integer;
                                var reused_test : boolean;
                                var string_label : pch20;
                                var w : t_long_integer):
                                                            t_link_test_labels;

var
   p: t_link_test_labels;
begin
   new(p);
   p^.indent              := indent;
   p^.reused_test         := reused_test;
   p^.write_type          := _string_label;
   p^.label_string        := string_label;
   p^.width               := width;
   new_test_labels_string := p
end; */
/* new_test_labels_string */

/* Not used:
function new_test_labels_set(var indent     : t_long_integer;
                             var reused_test : boolean;
                             var set_label   : t_vertex_set):
                                                            t_link_test_labels;

var
   p: t_link_test_labels;
begin
   new(p);
   p^.indent           := indent;
   p^.reused_test      := reused_test;
   p^.write_type       := _set_label;
   p^.vertex_set       := set_label;
   new_test_labels_set := p
end; */
/* new_test_labels_set */

/* Not used:
function new_test_labels_pair(var indent      : t_long_integer;
                              var reused_test : boolean;
                              var u, v      : t_vertex): t_link_test_labels;

var
   p: t_link_test_labels;
begin
   new(p);
   p^.indent            := indent;
   p^.reused_test       := reused_test;
   p^.write_type        := _pair_label;
   p^.u                 := u;
   p^.v                 := v;
   new_test_labels_pair := p
end; */
/* new_test_labels_pair */

Static Void clear_stepwise_options(p)
t_stepwise_options **p;
{
  (*p)->reversed = false;   /* 2 */
  (*p)->sorted_list = false;   /* 3 */
  (*p)->short_report = false;   /* 5 */

  (*p)->decomposable = false;   /* 7 */
  (*p)->graphical = false;   /* 8 */
  (*p)->hierarchical = false;   /* 9 */

  (*p)->recursive = false;   /* 10 */
  (*p)->coherent = false;   /* 11 */
  (*p)->headlong = false;   /* 12 */
  (*p)->follow = false;   /* 13 */
  (*p)->blockwise = false;   /* 14 */
  (*p)->separators = false;   /* 15 */

  (*p)->partitioning = false;   /* 19 */

  (*p)->alternative = false;   /* 20 / 21 */
}  /* clear_stepwise_options */


Static t_stepwise_options *copy_stepwise_options()
{
  t_stepwise_options *p;

  p = (t_stepwise_options *)Malloc(sizeof(t_stepwise_options));
  if (p == NULL)
    _OutMem();
  p->reversed = global_stepwise_options->reversed;
  p->sorted_list = global_stepwise_options->sorted_list;
  p->short_report = global_stepwise_options->short_report;

  p->decomposable = (decomposable_mode ||
		     global_stepwise_options->decomposable);
      /* ! */
  p->graphical = global_stepwise_options->graphical;   /* ! */
  p->hierarchical = global_stepwise_options->hierarchical;   /* ! */

  p->recursive = global_stepwise_options->recursive;
  p->coherent = global_stepwise_options->coherent;
  p->headlong = global_stepwise_options->headlong;
  p->follow = global_stepwise_options->follow;
  p->blockwise = global_stepwise_options->blockwise;
  p->separators = global_stepwise_options->separators;

  p->partitioning = c_partitioning;
  /* global_stepwise_options^.partitioning */

  p->alternative = global_stepwise_options->alternative;

  clear_stepwise_options(&global_stepwise_options);
  return p;
}  /* copy_stepwise_options */


/*@+"insert.p"*/

/*@+"newmodel^.p"*/


/*

  612:    +++  ++
  613:    +++  ++
  614:    ---  -- p/newmodel.p        37     172    2428 p/newmodel.p
  615: |    3:    procedure erase_model_but_set
  616: |   45:    procedure erase_discrete_model
  617: |   54:    procedure erase_continuous_model
  618: |   63:    procedure erase_mixed_model
  619: |   76:    procedure erase_model
  620: |   91:    procedure new_model
  621: |  105:    procedure new_model_in_list
  622: |  119:    procedure add_union_of_gc
  623: |  128:    function is_empty_g_c
  624: |  138:    function test_sub_g_c
  625: |  172:    function test_list_of_sets_subset_of_list_of_sets
  626: |  207:    function identical_g_c
  627: |  215:    function test_identical_c_s
  628: |  227:    function test_identical_c_s_ifail
  629: |  242:    function test_hierarchical
  630: |  261:    procedure check_generating_class
  631: |  285:    function degenerated_g_c
  632: |  303:    function advance_to_continuous_vertex
  633: |  311:    procedure discrete_of_contains_v
  634: |  328:    function mean_linear_gc
  635: |  364:    procedure check_mixed_model
  636: |  460:    function g_c_intersects_set
  637: |  499:    procedure split_g_c_in_mixed_terms
  638: |  540:    procedure copy_g_c_to_mixed_graphical_model
  639: |  549:    procedure sub_insert_g_c_in_model
  640: |  601:    procedure dispose_g_c_copy_for_mixed_model
  641: |  608:    procedure insert_g_c_in_model
  642: |  619:    procedure insert_mixed_g_c_in_model
  643: |  680:    procedure dispose_model_but_gc
  644: |  689:    procedure insert_g_c_in_new_discrete_model
  645: |  700:    procedure insert_g_c_in_new_continuous_model
  646: |  713:    function homogeneous_g_c
  647: |  727:    procedure insert_g_c_list_in_new_model
  648: |  905:    procedure insert_g_c_in_new_mixed_model
  649: |  929:    procedure insert_g_c_in_new_model
  650: |  961:    procedure cliques_of_mixed_model
  651: |  970:    - procedure g_c_of_mixed_model
  652:    +++  ++
  653:    +++  ++

*/


Static Void erase_identification_but_set(identification)
t_model_specification **identification;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " EraseIdentButSet   ", sizeof(pch20));
  ntr(tzt, 20L, 615L, 1L, 0L, 0L);
  /*$endif TRACE*/
  if (*identification != NULL)
    return;
  *identification = (t_model_specification *)Malloc(sizeof(t_model_specification));
  if (*identification == NULL)
    _OutMem();
  P_setcpy((*identification)->vertices, empty_set);
  (*identification)->paritet = 0;
  (*identification)->causal_structure = NULL;
}  /* erase_identification_but_set */


Static Void erase_discrete_identification(identification)
t_model_specification **identification;
{
  pch20 tzt;
  t_model_specification *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " EraseDiscreteIdent ", sizeof(pch20));
  ntr(tzt, 20L, 615L, 1L, 0L, 1L);
  /*$endif TRACE*/
  erase_identification_but_set(identification);
  WITH = *identification;
  WITH->model_type = pure_discrete;
  WITH->UU.g_c_log_linear = NULL;
}  /* erase_discrete_identification */


Static Void erase_continuous_identification(identification)
t_model_specification **identification;
{
  pch20 tzt;
  t_model_specification *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " EraseCintinIdent   ", sizeof(pch20));
  ntr(tzt, 20L, 615L, 1L, 0L, 2L);
  /*$endif TRACE*/
  erase_identification_but_set(identification);
  WITH = *identification;
  WITH->model_type = pure_continuous;
  WITH->UU.g_c_covariance = NULL;
}  /* erase_continuous_identification */


Static Void erase_mixed_identification(identification)
t_model_specification **identification;
{
  pch20 tzt;
  t_model_specification *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " EraseMixedIdent    ", sizeof(pch20));
  ntr(tzt, 20L, 615L, 1L, 0L, 3L);
  /*$endif TRACE*/
  erase_identification_but_set(identification);
  WITH = *identification;
  WITH->model_type = mixed;
  WITH->UU.U1.decompose = !boolean_option[121];
  WITH->UU.U1.full_specified = false;
  WITH->UU.U1.homogeneous = false;
  WITH->UU.U1.g_c_discrete = NULL;
  WITH->UU.U1.g_c_linear = NULL;
  WITH->UU.U1.g_c_quadratic = NULL;
}  /* erase_mixed_identification */


Static Void erase_identification(identification, model_type, clear_set)
t_model_specification **identification;
t_model_type model_type;
boolean clear_set;
{
  switch (model_type) {

  case pure_discrete:
    erase_discrete_identification(identification);
    break;

  case mixed:
    erase_mixed_identification(identification);
    break;

  case pure_continuous:
    erase_continuous_identification(identification);
    break;
  }
  if (clear_set)
    P_setcpy((*identification)->vertices, empty_set);
}  /* erase_identification */


Static Void copy_identification(old_id, new_id)
t_model_specification **old_id, **new_id;
{
  *new_id = NULL;
  erase_identification(new_id, (*old_id)->model_type, false);
  if ((*old_id)->model_type == pure_discrete)
    copy_set_list((*old_id)->UU.g_c_log_linear, &(*new_id)->UU.g_c_log_linear);
  else if ((*old_id)->model_type == pure_continuous)
    copy_set_list((*old_id)->UU.g_c_covariance, &(*new_id)->UU.g_c_covariance);
  else {
    (*new_id)->UU.U1.full_specified = (*old_id)->UU.U1.full_specified;
    (*new_id)->UU.U1.homogeneous = (*old_id)->UU.U1.homogeneous;
    copy_set_list((*old_id)->UU.U1.g_c_discrete,
		  &(*new_id)->UU.U1.g_c_discrete);
    copy_set_list((*old_id)->UU.U1.g_c_linear, &(*new_id)->UU.U1.g_c_linear);
    copy_set_list((*old_id)->UU.U1.g_c_quadratic,
		  &(*new_id)->UU.U1.g_c_quadratic);
  }
  copy_set_list((*old_id)->causal_structure, &(*new_id)->causal_structure);
  P_setcpy((*new_id)->vertices, (*old_id)->vertices);
  (*new_id)->paritet = (*old_id)->paritet;
}  /* copy_identification */


Static Void erase_model_but_set(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " EraseModelButSet   ", sizeof(pch20));
  ntr(tzt, 20L, 615L, 1L, 0L, 0L);
  /*$endif TRACE*/
  /* new(model); */
  WITH = *model;

  WITH->copy = false;

  WITH->found_log_l = false;
  WITH->found_expression = false;
  WITH->found_ps = false;

  WITH->graphical = false;
  WITH->decomposable = false;

  WITH->constant = 1.0;

  WITH->log_l = _INVALID_REAL;

  WITH->dim = 0;
  WITH->dimdec = -2;
  WITH->model_ifail = 0;

  WITH->formula_node = NULL;

  /* model^.model_number := - first_model_available; */

  if (WITH->id != NULL)
    return;

  WITH->id = (t_model_specification *)Malloc(sizeof(t_model_specification));
  if (WITH->id == NULL)
    _OutMem();
  P_setcpy(WITH->id->vertices, empty_set);
  WITH->id->paritet = 0;
  WITH->id->causal_structure = NULL;
}  /* erase_model_but_set */


Static Void erase_discrete_model(model)
t_model **model;
{
  erase_model_but_set(model);
  erase_discrete_identification(&(*model)->id);
}  /* erase_discrete_model */


Static Void erase_continuous_model(model)
t_model **model;
{
  erase_model_but_set(model);
  erase_continuous_identification(&(*model)->id);
}  /* erase_continuous_model */


Static Void erase_mixed_model(model)
t_model **model;
{
  erase_model_but_set(model);
  erase_mixed_identification(&(*model)->id);
}  /* erase_mixed_model */


Static Void erase_model(model, model_type, clear_set)
t_model **model;
t_model_type model_type;
boolean clear_set;
{
  switch (model_type) {

  case pure_discrete:
    erase_discrete_model(model);
    break;

  case mixed:
    erase_mixed_model(model);
    break;

  case pure_continuous:
    erase_continuous_model(model);
    break;
  }
  if (clear_set) {
    (*model)->model_number = -1;   /* !!! */
    P_setcpy((*model)->id->vertices, empty_set);   /* !!! */
  }
}  /* erase_model */


Static Void new_model(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " NewModel           ", sizeof(pch20));
  ntr(tzt, 20L, 620L, 1L, 0L, 0L);
  /*$endif TRACE*/
  *model = (t_model *)Malloc(sizeof(t_model));
  if (*model == NULL)
    _OutMem();
  (*model)->model_number = -first_model_available;
  (*model)->id = NULL;
}  /* new_model */


Static Void new_model_with_identification(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " NewModel           ", sizeof(pch20));
  ntr(tzt, 20L, 620L, 1L, 0L, 0L);
  /*$endif TRACE*/
  new_model(model);
  (*model)->model_number = -first_model_available;
  (*model)->id = NULL;
  erase_model_but_set(model);
}  /* new_model_with_identification */


Static Void new_model_in_list(link_model_list, model_number)
t_model_list **link_model_list;
t_integer *model_number;
{
  t_model_list *p;

  p = (t_model_list *)Malloc(sizeof(t_model_list));
  if (p == NULL)
    _OutMem();
  p->pointer = *link_model_list;
  *link_model_list = p;
  (*model_number)++;
  new_model(&(*link_model_list)->model);
  erase_model(&(*link_model_list)->model, pure_discrete, true);
  (*link_model_list)->model->model_number = *model_number;
}  /* new_model_in_list */


Static Void add_union_of_gc(p_g_c, vertex_set)
t_set_list *p_g_c;
long *vertex_set;
{
  while (p_g_c != NULL) {
    P_setunion(vertex_set, vertex_set, p_g_c->vertex_set);
    p_g_c = p_g_c->pointer;
  }
}  /* add_union_of_gc */


Static Void add_union_of_id(identification, vertex_set)
t_model_specification **identification;
long *vertex_set;
{
  P_setunion(vertex_set, vertex_set, (*identification)->vertices);
}  /* add_union_of_id */


Static boolean is_empty_g_c(g_c)
t_set_list **g_c;
{
  if (*g_c == NULL)
    return true;
  else if ((*g_c)->pointer == NULL &&
	   P_setequal((*g_c)->vertex_set, empty_set))
    return true;
  else
    return false;
}  /* is_empty_g_c */


Static boolean test_sub_g_c(link_1, link_2)
t_set_list *link_1, *link_2;
{
  t_set_list *p;
  t_set_list *tmp_cs = NULL;
  boolean ok = true;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " TestSubGC          ", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 624L, 1L, 1L, 1L, &link_1, &link_2, &tmp_cs);
  /*$endif TRACE*/
  if (link_2 == NULL) {
    if (link_1 != NULL) {
      P_setcpy(a, link_1->vertex_set);
      if (P_setequal(a, empty_set)) {
	if (true) {   /* trace_flag_set(20, 624, 0) */
	  write_pch(stdout, " (Testing GC with empty set", 27L);
	  write_pch(stdout, " subset of empty GC)", 20L);
	  write_line(stdout);
	}
      } else
	ok = false;
    }
  } else {
    while (link_1 != NULL && ok) {
      P_setcpy(a, link_1->vertex_set);
      ok = false;
      p = link_2;
      while (p != NULL && !ok) {
	if (P_subset(a, p->vertex_set)) {
	  /*  Note: a <= p^.vertex_set */
	  ok = true;
	} else
	  p = p->pointer;
      }
      link_1 = link_1->pointer;
    }
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 624L, 8L, 1L, 1L, ok);
  /*$endif TRACE*/
  return ok;
}  /* test_sub_g_c */


Static boolean test_list_of_sets_subset_of_list_of_sets(link_1, link_2)
t_set_list *link_1, *link_2;
{
  t_set_list *p;
  t_set_list *tmp_cs = NULL;
  boolean ok = true;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " TestLOSsSubsetOfLOS", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 625L, 1L, 1L, 1L, &link_1, &link_2, &tmp_cs);
  /*$endif TRACE*/
  while (link_1 != NULL && ok) {
    P_setcpy(a, link_1->vertex_set);
    ok = false;
    p = link_2;
    while (p != NULL && !ok) {
      if (P_setequal(a, p->vertex_set)) {
	/*  Note: a = p^.vertex_set */
	ok = true;
      } else
	p = p->pointer;
    }
    link_1 = link_1->pointer;
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 625L, 8L, 1L, 1L, ok);
  /*$endif TRACE*/
  return ok;
}  /* test_list_of_sets_subset_of_list_of_sets */


Static boolean identical_g_c(link_1, link_2)
t_set_list *link_1, *link_2;
{
  if (test_sub_g_c(link_1, link_2))
    return (test_sub_g_c(link_2, link_1));
  else
    return false;
}  /* identical_g_c */


Static boolean test_identical_c_s(link_1, link_2)
t_set_list *link_1, *link_2;
{
  if (identical_g_c(link_1, link_2))
    return true;
  else {
    write_pch(stdout, " Causal structures (", 20L);
    print_g_c(link_1, 0L, line_length);
    write_char(stdout, '/');
    print_g_c(link_2, 0L, line_length);
    write_pch(stdout, ") not identical.", 16L);
    write_line(stdout);
    return false;
  }
}  /* identical_g_c */


Static boolean test_identical_c_s_ifail(current_model, base_model, ifail)
t_model *current_model, *base_model;
t_integer *ifail;
{
  if (identical_g_c(current_model->id->causal_structure,
		    base_model->id->causal_structure))
    return true;
  else {
    write_pch(stdout, " Causal structures (", 20L);
    print_g_c(current_model->id->causal_structure, 0L, line_length);
    write_char(stdout, '-');
    print_g_c(base_model->id->causal_structure, 0L, line_length);
    write_pch(stdout, ") not identical.", 16L);
    write_line(stdout);
    *ifail = 28;
    return false;
  }
}  /* test_identical_c_s_ifail */


Static boolean test_hierarchical(p)
t_set_list *p;
{
  t_set_list *q;
  boolean ok = true;

  while (p != NULL && ok) {
    q = p->pointer;
    while (q != NULL && ok) {
      if (P_subset(p->vertex_set, q->vertex_set) ||
	  P_subset(q->vertex_set, p->vertex_set))
	ok = false;
      else
	q = q->pointer;
    }
    p = p->pointer;
  }
  return ok;
}  /* test_hierarchical */


Static Void check_generating_class(g_c, fault, c, w)
t_set_list **g_c;
boolean *fault;
Char *c;
t_integer w;
{
  t_set_list *p;

  if (test_hierarchical(*g_c))
    return;
  *fault = true;
  write_line(stdout);
  write_pch(stdout, c, w);
  write_pch(stdout, " part ", 6L);
  print_g_c(*g_c, 0L, line_length);
  write_pch(stdout, " is not a generating class.", 27L);
  p = *g_c;
  *g_c = NULL;
  while (p != NULL) {
    insert_clique(p->vertex_set, g_c);
    p = p->pointer;
  }
  write_pch(stdout, " Input reduced to ", 18L);
  print_g_c(*g_c, 0L, line_length);
  write_char(stdout, '.');
}  /* check_generating_class */


Static boolean degenerated_g_c(a_, g_c)
long *a_;
t_set_list **g_c;
{
  t_vertex_set a;
  boolean ok = true;
  t_vertex v;
  t_vertex_set b;

  P_setcpy(a, a_);
  P_setint(a, a, gamma_);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (ok & P_inset(v, a)) {
      P_setcpy(b, double_vertex_set);
      P_addset(b, v);
      ok = subset_of_an_edge(b, g_c);
    }
  }
  return (!ok);
}  /* degenerated_g_c */


Static t_vertex advance_to_continuous_vertex(a_, v)
long *a_;
t_vertex v;
{
  t_vertex_set a;

  P_setcpy(a, a_);
  P_setint(a, a, gamma_);
  while (!P_inset(v, a) && v < last_vertex)
    v++;
  return v;
}  /* advance_to_continuous_vertex */


Static Void discrete_of_contains_v(v, p, g_c_out)
t_vertex *v;
t_set_list *p, **g_c_out;
{
  t_vertex_set a;

  *g_c_out = NULL;
  while (p != NULL) {
    P_setcpy(a, p->vertex_set);
    if (P_inset(*v, a)) {
      P_setint(a, a, delta);
      insert_clique(a, g_c_out);
    }
    p = p->pointer;
  }
}  /* discrete_of_contains_v */


Static boolean mean_linear_gc(g_c_l, g_c_q)
t_set_list *g_c_l, *g_c_q;
{
  boolean ok = true;
  t_vertex_set linear_continuous, quadratic_discrete;
  t_vertex v;
  t_set_list *p = NULL;
  t_set_list *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " MeanLinearGC       ", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 634L, 1L, -1L, -1L, &p, &g_c_l, &g_c_q);
  /*$endif TRACE*/
  P_setcpy(linear_continuous, empty_set);
  add_union_of_gc(g_c_l, linear_continuous);
  P_setint(linear_continuous, linear_continuous, gamma_);
  P_setcpy(quadratic_discrete, empty_set);
  add_union_of_gc(g_c_q, quadratic_discrete);
  P_setint(quadratic_discrete, quadratic_discrete, delta);
  if (!P_setequal(quadratic_discrete, empty_set)) {
    p = g_c_l;
    while (ok && p != NULL) {
      ok = P_subset(quadratic_discrete, p->vertex_set);
      p = p->pointer;
    }
  }
  if (ok) {
    v = advance_to_continuous_vertex(linear_continuous, first_vertex);
    discrete_of_contains_v(&v, g_c_l, &p);
    v = advance_to_continuous_vertex(linear_continuous, v + 1);
    while (ok & P_inset(v, linear_continuous)) {
      discrete_of_contains_v(&v, g_c_l, &q);
      ok = identical_g_c(p, q);
      dispose_set_list(&q);
      v = advance_to_continuous_vertex(linear_continuous, v + 1);
    }
    dispose_set_list(&p);
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 634L, 1L, -9L, -9L, ok);
  /*$endif TRACE*/
  return ok;
}  /* mean_linear_gc */


/* Local variables for unfold_linear: */
struct LOC_unfold_linear {
  boolean print_note;
} ;


Static Void unfold_linear(g_c_old, g_c_new, unfold, txt_, w, print_note_)
t_set_list **g_c_old, **g_c_new;
boolean *unfold;
Char *txt_;
t_integer w;
boolean print_note_;
{
  struct LOC_unfold_linear Local_Var;
  pch20 txt;
  t_set_list *p;
  t_vertex_set a, b, c;
  t_vertex v;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  memcpy(txt, txt_, sizeof(pch20));
  Local_Var.print_note = print_note_;
  /*$ifdef TRACE*/
  memcpy(tzt, " UnfoldLinear       ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 629L, 1L, 1L, 1L, g_c_old);
  /*$endif TRACE*/
  *unfold = false;
  p = *g_c_old;
  *g_c_new = NULL;
  while (p != NULL) {
    P_setint(a, p->vertex_set, gamma_);
    P_setint(b, p->vertex_set, delta);
    if (!P_setequal(a, empty_set)) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  P_setcpy(c, b);
	  P_addset(c, v);
	  insert_clique(c, g_c_new);
	}
      }
    }
    p = p->pointer;
  }
  if (test_sub_g_c(*g_c_old, *g_c_new)) {
    dispose_set_list(g_c_new);
    *g_c_new = NULL;
  } else {
    *unfold = true;
    note_replace_gc(stdout, txt, "Linear    ", 6L, &Local_Var.print_note,
		    g_c_old, g_c_new);
    /* dispose_set_list(g_c_old);
    g_c_old := g_c_new */
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_g_c(tzt, 20L, 629L, 1L, 1L, 8L, g_c_new);
}  /* unfold_linear */


/* Local variables for unfold_quadratic: */
struct LOC_unfold_quadratic {
  boolean print_note;
} ;


Static Void unfold_quadratic(g_c_old, g_c_new, unfold, txt_, w, to_full,
			     print_note_)
t_set_list **g_c_old, **g_c_new;
boolean *unfold;
Char *txt_;
t_integer w;
boolean to_full, print_note_;
{
  struct LOC_unfold_quadratic Local_Var;
  pch20 txt;
  t_set_list *p;
  t_vertex_set a, b, c, d;
  t_vertex v, u;
  boolean full_specified;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  memcpy(txt, txt_, sizeof(pch20));
  Local_Var.print_note = print_note_;
  /*$ifdef TRACE*/
  memcpy(tzt, " UnfoldQuadraticF.  ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 630L, 1L, 1L, 1L, g_c_old);
  /*$endif TRACE*/
  *unfold = false;
  full_specified = subset_of_an_edge(double_vertex_set, g_c_old);
  if (true) {
    p = *g_c_old;
    *g_c_new = NULL;
    while (p != NULL) {
      P_setint(a, p->vertex_set, gamma_);
      P_setint(b, p->vertex_set, delta);
      if (!P_setequal(a, empty_set)) {
	for (v = first_vertex; v <= last_vertex; v++) {
	  if (P_inset(v, a)) {
	    P_setcpy(c, b);
	    P_addset(c, v);
	    for (u = v + 1; u <= last_vertex; u++) {
	      if (P_inset(u, a)) {
		P_setcpy(d, c);
		P_addset(d, u);
		insert_clique(d, g_c_new);
	      }
	    }
	    if ((full_specified & P_inset(double_vertex, p->vertex_set)) ||
		!full_specified && to_full)
	      P_addset(c, double_vertex);
	    insert_clique(c, g_c_new);
	  }
	}
      }
      p = p->pointer;
    }
    if (test_sub_g_c(*g_c_old, *g_c_new) && !to_full) {
      dispose_set_list(g_c_new);
      *g_c_new = NULL;
    } else {
      *unfold = true;
      note_replace_gc(stdout, txt, "Quadratic ", 9L, &Local_Var.print_note,
		      g_c_old, g_c_new);
    }
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_g_c(tzt, 20L, 630L, 1L, 1L, 8L, g_c_new);
}  /* unfold_quadratic */


/* Local variables for quadratic_subset_linear: */
struct LOC_quadratic_subset_linear {
  boolean print_note;
} ;


Static Void quadratic_subset_linear(g_c_linear, g_c_quadratic, fault, txt_, w,
				    print_note_)
t_set_list **g_c_linear, **g_c_quadratic;
boolean *fault;
Char *txt_;
t_integer w;
boolean print_note_;
{
  struct LOC_quadratic_subset_linear Local_Var;
  pch20 txt;
  t_set_list *p;
  t_set_list *q = NULL;
  t_vertex_set a, b, c;
  t_vertex v;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  memcpy(txt, txt_, sizeof(pch20));
  Local_Var.print_note = print_note_;
  /*$ifdef TRACE*/
  memcpy(tzt, " QuadraticSubsetL.  ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 631L, 1L, 1L, 1L, g_c_linear);
  ntr_g_c(tzt, 20L, 631L, 1L, 1L, 2L, g_c_quadratic);
  /*$endif TRACE*/
  p = *g_c_quadratic;
  while (p != NULL) {
    P_setint(a, p->vertex_set, gamma_);
    P_setint(b, p->vertex_set, delta);
    if (!P_setequal(a, empty_set)) {
      insert_clique(p->vertex_set, &q);
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  P_setcpy(c, b);
	  P_addset(c, v);
	  if (!subset_of_an_edge(c, g_c_linear)) {
	    if (Local_Var.print_note) {
	      *fault = true;
	      write_line(stdout);
	      write_pch(stdout, " Quadratic generator ", 21L);
	      print_vertex_set(c);
	      write_pch(stdout, " not contained in linear generator.",
			  35L);
	    }
	    insert_set_in_set_list(c, g_c_linear);
	  }
	}
      }
    } else if (Local_Var.print_note) {
      *fault = true;
      write_line(stdout);
      write_pch(stdout, " Quadratic generator @@@@@@@@ ", 21L);
      print_vertex_set(p->vertex_set);
      write_pch(stdout, " is without continuous variables.", 33L);
    }
    p = p->pointer;
  }
  if (test_sub_g_c(*g_c_quadratic, q)) {
    dispose_set_list(&q);
    return;
  }
  *fault = true;
  note_replace_gc(stdout, txt, "Quadratic ", 9L, &Local_Var.print_note,
		  g_c_quadratic, &q);
  dispose_set_list(g_c_quadratic);
  *g_c_quadratic = q;
}  /* quadratic_subset_linear */


/* Local variables for linear_subset_discrete: */
struct LOC_linear_subset_discrete {
  boolean print_note;
} ;


Static Void linear_subset_discrete(g_c_discrete, g_c_linear, fault, txt_, w,
				   print_note_)
t_set_list **g_c_discrete, **g_c_linear;
boolean *fault;
Char *txt_;
t_integer w;
boolean print_note_;
{
  struct LOC_linear_subset_discrete Local_Var;
  pch20 txt;
  t_set_list *p;
  t_set_list *q = NULL;
  t_vertex_set a, b, c;
  t_vertex v;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  memcpy(txt, txt_, sizeof(pch20));
  Local_Var.print_note = print_note_;
  /*$ifdef TRACE*/
  memcpy(tzt, " LinearSubsetDisc.  ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 632L, 1L, 1L, 1L, g_c_discrete);
  ntr_g_c(tzt, 20L, 632L, 1L, 1L, 2L, g_c_linear);
  /*$endif TRACE*/
  p = *g_c_linear;
  while (p != NULL) {
    P_setint(a, p->vertex_set, gamma_);
    P_setint(b, p->vertex_set, delta);
    if (!P_setequal(a, empty_set)) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  P_setcpy(c, b);
	  P_addset(c, v);
	  insert_clique(c, &q);
	}
      }
      if (!subset_of_an_edge(b, g_c_discrete)) {
	if (Local_Var.print_note) {
	  *fault = true;
	  write_line(stdout);
	  write_pch(stdout, " Discrete part ", 15L);
	  print_vertex_set(b);
	  write_pch(stdout, " of linear generator ", 21L);
	  print_vertex_set(p->vertex_set);
	  write_pch(stdout, " not contained in discrete generator.", 37L);
	}
	insert_clique(b, g_c_discrete);
      }
    } else if (Local_Var.print_note) {
      *fault = true;
      write_line(stdout);
      write_pch(stdout, " Linear generator @ ", 19L);
      print_vertex_set(p->vertex_set);
      write_pch(stdout, " is without continuous variables.", 33L);
    }
    p = p->pointer;
  }
  if (test_sub_g_c(*g_c_linear, q)) {
    dispose_set_list(&q);
    return;
  }
  *fault = true;
  note_replace_gc(stdout, txt, "Linear    ", 6L, &Local_Var.print_note,
		  g_c_linear, &q);
  dispose_set_list(g_c_linear);
  *g_c_linear = q;
}  /* linear_subset_discrete */


/* Local variables for tjek_discrete: */
struct LOC_tjek_discrete {
  boolean print_note;
} ;


Static Void tjek_discrete(g_c_discrete, fault, txt_, w, print_note_)
t_set_list **g_c_discrete;
boolean *fault;
Char *txt_;
t_integer w;
boolean print_note_;
{
  struct LOC_tjek_discrete Local_Var;
  pch20 txt;
  t_set_list *p;
  t_set_list *q = NULL;
  t_vertex_set a, b;
  boolean local_fault = false;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  memcpy(txt, txt_, sizeof(pch20));
  Local_Var.print_note = print_note_;
  /*$ifdef TRACE*/
  memcpy(tzt, " TjekDiscrete       ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 633L, 1L, 1L, 1L, g_c_discrete);
  /*$endif TRACE*/
  p = *g_c_discrete;
  while (p != NULL) {
    P_setint(a, p->vertex_set, gamma_);
    P_setint(b, p->vertex_set, delta);
    insert_clique(b, &q);
    if (!P_setequal(a, empty_set)) {
      if (Local_Var.print_note) {
	local_fault = true;
	write_line(stdout);
	write_pch(stdout, " Discrete generator ", 20L);
	print_vertex_set(p->vertex_set);
	write_pch(stdout, " contain continuous ", 20L);
	print_vertex_set(a);
      }
    }
    p = p->pointer;
  }
  if (!local_fault) {
    dispose_set_list(&q);
    return;
  }
  *fault = true;
  note_replace_gc(stdout, txt, "Discrete  ", 8L, &Local_Var.print_note,
		  g_c_discrete, &q);
  dispose_set_list(g_c_discrete);
  *g_c_discrete = q;
}  /* tjek_discrete */


Static Void sub_sub_check_mixed_model(g_c_discrete, g_c_linear, g_c_quadratic,
  unfolded_linear, unfolded_quadratic, g_, model_type, txt, w, print_note)
t_set_list **g_c_discrete, **g_c_linear, **g_c_quadratic, *unfolded_linear,
	   *unfolded_quadratic;
long *g_;
t_model_type model_type;
Char *txt;
t_integer w;
boolean print_note;
{
  t_vertex_set g;
  boolean fault = false;
  boolean unfold, print_unfold;
  Char c = '~';
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /* if print_note then */
  P_setcpy(g, g_);
  /*$ifdef TRACE*/
  memcpy(tzt, " SubSubCheckMixedMdl", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 634L, 1L, 1L, 1L, g_c_discrete, g_c_linear,
		 g_c_quadratic);
      /*ntr*/
  ntr_set(txt, 20L, 634L, 1L, 1L, 1L, g);
  /*$endif TRACE*/
  if (model_type == mixed) {
    check_generating_class(g_c_discrete, &fault, " Discrete", 9L);
    check_generating_class(g_c_linear, &fault, " Linear", 7L);
    check_generating_class(g_c_quadratic, &fault, " Quadratic", 10L);
    print_unfold = (print_note && boolean_option[182]);
    unfold_linear(g_c_linear, &unfolded_linear, &unfold, txt, w, print_unfold);
    if (unfold) {
      fault = true;
      /* dispose_set_list(g_c_linear);
         g_c_linear := unfolded_linear */
    } else {
      copy_set_list(*g_c_linear, &unfolded_linear);
      fault = false;
    }
    if (fault && c == '~')
      c = ':';
    unfold_quadratic(g_c_quadratic, &unfolded_quadratic, &unfold, txt, w,
		     false, print_unfold);
    if (unfold) {
      fault = true;
      /* dispose_set_list(g_c_quadratic);
         g_c_quadratic := unfolded_quadratic */
    } else {
      copy_set_list(*g_c_quadratic, &unfolded_quadratic);
      fault = false;
    }
    if (fault && c == '~')
      c = '.';
    quadratic_subset_linear(&unfolded_linear, &unfolded_quadratic, &fault,
			    txt, w, print_note);
    if (fault && c == '~')
      c = '-';
    linear_subset_discrete(g_c_discrete, &unfolded_linear, &fault, txt, w,
			   print_note);
    if (fault && c == '~')
      c = '+';
    tjek_discrete(g_c_discrete, &fault, txt, w, print_note);
    if (fault && c == '~')
      c = '*';
    if (subset_of_an_edge(double_vertex_set, &unfolded_quadratic)) {
      if (degenerated_g_c(g, &unfolded_quadratic)) {
	write_line(stdout);
	write_pch(stdout, " Model is degenerated!", 22L);
	fault = true;
      }
    }
    if (fault && print_note) {
      write_char(stdout, c);
      write_line(stdout);
    }
    return;
  }
  write_line(stdout);
  write_pch(stdout, " ( CheckMixedModel: ", 20L);
  write_pch(stdout, " Model ", 7L);
  print_triple_g_c(g_c_discrete, g_c_linear, g_c_quadratic, 10L);
  write_pch(stdout, " is not mixed! / ", 17L);
  write_pch(stdout, txt, w);
  write_char(stdout, ' ');
  write_char(stdout, ')');
  write_line(stdout);
}  /* sub_sub_check_mixed_model */


Static Void sub_check_mixed_model(g_c_discrete, g_c_linear, g_c_quadratic, g_,
				  model_type, txt, w, print_note)
t_set_list **g_c_discrete, **g_c_linear, **g_c_quadratic;
long *g_;
t_model_type model_type;
Char *txt;
t_integer w;
boolean print_note;
{
  t_vertex_set g;
  t_set_list *unfolded_linear = NULL, *unfolded_quadratic = NULL;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  P_setcpy(g, g_);
  /*$ifdef TRACE*/
  memcpy(tzt, " SubCheckMixedModel ", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 634L, 1L, 1L, 1L, g_c_discrete, g_c_linear,
		 g_c_quadratic);
      /*ntr*/
  ntr_set(txt, 20L, 634L, 1L, 1L, 1L, g);
  /*$endif TRACE*/
  sub_sub_check_mixed_model(g_c_discrete, g_c_linear, g_c_quadratic,
			    unfolded_linear, unfolded_quadratic, g,
			    model_type, txt, w, print_note);
  dispose_set_list(&unfolded_linear);
  dispose_set_list(&unfolded_quadratic);
}  /* sub_check_mixed_model */


Static Void check_mixed_model(model, txt, w, print_note)
t_model **model;
Char *txt;
t_integer w;
boolean print_note;
{
  t_set_list *unfolded_linear = NULL, *unfolded_quadratic = NULL;

  sub_sub_check_mixed_model(&(*model)->id->UU.U1.g_c_discrete,
    &(*model)->id->UU.U1.g_c_linear, &(*model)->id->UU.U1.g_c_quadratic,
    unfolded_linear, unfolded_quadratic, (*model)->id->vertices,
    (*model)->id->model_type, txt, w, print_note);
  dispose_set_list(&unfolded_linear);
  dispose_set_list(&unfolded_quadratic);
}  /* check_mixed_model */


Static boolean g_c_intersects_set(a, list_of_cliques)
long *a;
t_set_list *list_of_cliques;
{
  t_vertex_set b;
  boolean found = false;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GCIntersectsSet    ", sizeof(pch20));
  ntr_set_and_g_c(tzt, 20L, 636L, 1L, 1L, 1L, a, &list_of_cliques);
  /*$endif TRACE*/
  while (!found && list_of_cliques != NULL) {
    P_setint(b, list_of_cliques->vertex_set, a);
    /*$ifdef TRACE*/
    ntr_3_sets(tzt, 20L, 636L, 2L, 1L, 1L, a, list_of_cliques->vertex_set, b);
    /*$endif TRACE*/
    found = !P_setequal(b, empty_set);
    list_of_cliques = list_of_cliques->pointer;
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 636L, 8L, 1L, 1L, found);
  /*$endif TRACE*/
  return found;
}  /* g_c_intersects_set */


Static Void split_g_c_in_mixed_terms(gc, full_specified, homogeneous,
				     discrete_g_c, linear_g_c, quadratic_g_c)
t_set_list *gc;
boolean full_specified, homogeneous;
t_set_list **discrete_g_c, **linear_g_c, **quadratic_g_c;
{
  t_vertex_set a, b, c, d;
  t_vertex v, u;

  /* full_specified : boolean; */
  /* full_specified := subset_of_an_edge(double_vertex_set, gc); */
  *discrete_g_c = NULL;
  *linear_g_c = NULL;
  *quadratic_g_c = NULL;
  insert_clique(empty_set, discrete_g_c);
  while (gc != NULL) {
    P_setint(a, gc->vertex_set, gamma_);
    P_setint(b, gc->vertex_set, delta);
    if (!P_setequal(a, empty_set)) {
      insert_clique(b, discrete_g_c);
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  P_setcpy(c, b);
	  P_addset(c, v);
	  insert_clique(c, linear_g_c);   /* full_specified */
	  if (true) {
	    if (homogeneous)
	      P_addset(P_expset(c, 0L), v);   /* empty_set + */
	    for (u = v + 1; u <= last_vertex; u++) {
	      if (P_inset(u, a)) {
		P_setcpy(d, c);
		P_addset(d, u);
		insert_clique(d, quadratic_g_c);
	      }
	    }
	    P_setcpy(d, c);
	    if (full_specified)
	      P_addset(d, double_vertex);
	    insert_clique(d, quadratic_g_c);
	  }
	}
      }
      /* if not full_specified then
           if homogeneous then
              insert_clique(a, quadratic_g_c)
           else
              insert_clique(gc^.vertex_set, quadratic_g_c) */
    } else
      insert_clique(gc->vertex_set, discrete_g_c);
    gc = gc->pointer;
  }
}  /* split_g_c_in_mixed_terms */


Static Void copy_g_c_to_mixed_graphical_model(gc, full_specified, homogeneous,
					      model)
t_set_list *gc;
boolean full_specified, homogeneous;
t_model **model;
{
  pch20 txt;

  memcpy(txt, " CopyGCtoMixedGraMo ", sizeof(pch20));
  /*$ifdef TRACE*/
  ntr_g_c(txt, 20L, 639L, 1L, 0L, 0L, &gc);
  /*$endif TRACE*/
  (*model)->id->UU.U1.homogeneous = homogeneous;
  split_g_c_in_mixed_terms(gc, full_specified, homogeneous,
    &(*model)->id->UU.U1.g_c_discrete, &(*model)->id->UU.U1.g_c_linear,
    &(*model)->id->UU.U1.g_c_quadratic);
  /*$ifdef TRACE*/
  ntr_id(txt, 20L, 639L, 1L, 1L, 0L, &(*model)->id);
  /*$endif TRACE*/
  check_mixed_model(model, txt, 20L, true);
}  /* copy_g_c_to_mixed_graphical_model */


Static Void copy_g_c_to_mixed_graphical_id(gc, full_specified, homogeneous, id)
t_set_list *gc;
boolean full_specified, homogeneous;
t_model_specification **id;
{
  pch20 txt;

  memcpy(txt, " CopyGCtoMixedGraId ", sizeof(pch20));
  /*$ifdef TRACE*/
  ntr_g_c(txt, 20L, 639L, 1L, 0L, 0L, &gc);
  /*$endif TRACE*/
  /* new(id); */
  (*id)->UU.U1.homogeneous = homogeneous;
  P_setcpy((*id)->vertices, empty_set);
  (*id)->paritet = 0;
  (*id)->causal_structure = NULL;
  split_g_c_in_mixed_terms(gc, full_specified, homogeneous,
    &(*id)->UU.U1.g_c_discrete, &(*id)->UU.U1.g_c_linear,
    &(*id)->UU.U1.g_c_quadratic);
  /*$ifdef TRACE*/
  ntr_g_c(txt, 20L, 639L, 1L, 1L, 8L, &gc);
  ntr_id(txt, 20L, 639L, 1L, 1L, 9L, id);
  /*$endif TRACE*/
  sub_check_mixed_model(&(*id)->UU.U1.g_c_discrete, &(*id)->UU.U1.g_c_linear,
			&(*id)->UU.U1.g_c_quadratic, (*id)->vertices,
			(*id)->model_type, txt, 20L, true);
}  /* copy_g_c_to_mixed_graphical_id */


Static Void sub_insert_g_c_in_id(g_c, g, causal_structure, copy,
  full_specified, homogeneous, force_continuous, id)
t_set_list **g_c;
long *g;
t_set_list **causal_structure;
boolean copy, full_specified, homogeneous, force_continuous;
t_model_specification **id;
{
  t_vertex_set a;
  pch20 txt;

  memcpy(txt, " SubInsertGCinId    ", sizeof(pch20));
  /*$ifdef TRACE*/
  ntr_set_and_g_c(txt, 20L, 639L, 1L, 0L, 1L, g, g_c);
  ntr_g_c(txt, 20L, 639L, 1L, 0L, 2L, causal_structure);
  /*$endif TRACE*/
  P_setcpy(a, empty_set);
  add_union_of_gc(*g_c, a);
  if (((!P_setequal(a, g)) | P_inset(double_vertex, g)) && *g_c != NULL)
    note_error_g_c(stdout, 639L, 1L, txt, *g_c, g, a, false);
  if (P_subset(g, delta) && !force_continuous) {
    erase_discrete_identification(id);
    if (copy)
      copy_set_list(*g_c, &(*id)->UU.g_c_log_linear);
    else
      (*id)->UU.g_c_log_linear = *g_c;
  } else if (P_subset(g, gamma_) && !boolean_option[104]) {
    erase_continuous_identification(id);
    if (copy)
      copy_set_list(*g_c, &(*id)->UU.g_c_covariance);
    else
      (*id)->UU.g_c_covariance = *g_c;
  } else {
    erase_mixed_identification(id);
    copy_g_c_to_mixed_graphical_id(*g_c, full_specified, homogeneous, id);
  }
  P_setcpy((*id)->vertices, a);
  /*$ifdef TRACE*/
  copy_ordered_set_list(*causal_structure, &(*id)->causal_structure);
  ntr_set_and_g_c(txt, 20L, 639L, 8L, 97L, 0L, g, g_c);
  ntr_id(txt, 20L, 639L, 8L, 98L, 0L, id);
  /*$endif TRACE*/
  ntr_g_c(txt, 20L, 639L, 8L, 99L, 0L, &(*id)->causal_structure);
}  /* sub_insert_g_c_in_id */


Static Void sub_insert_g_c_in_model(g_c, g, causal_structure, full_specified,
				    homogeneous, force_continuous, model)
t_set_list **g_c;
long *g;
t_set_list **causal_structure;
boolean full_specified, homogeneous, force_continuous;
t_model **model;
{
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubInsertGCinModel ", sizeof(pch20));
  ntr_set_and_g_c(tzt, 20L, 639L, 1L, 0L, 1L, g, g_c);
  ntr_g_c(tzt, 20L, 639L, 1L, 0L, 2L, causal_structure);
  /*$endif TRACE*/
  erase_model_but_set(model);
  sub_insert_g_c_in_id(g_c, g, causal_structure, false, full_specified,
		       homogeneous, force_continuous, &(*model)->id);
  P_setcpy(a, (*model)->id->vertices);
  P_setdiff(a, delta_gamma, g);
  P_setint(a, a, delta);
  (*model)->constant = 1 / marginal_dimension_real(a);
  /*$ifdef TRACE*/
  copy_ordered_set_list(*causal_structure, &(*model)->id->causal_structure);
  ntr_real(tzt, 20L, 639L, 8L, 0L, 0L, &(*model)->constant);
  ntr_set_and_g_c(tzt, 20L, 639L, 1L, 0L, 97L, g, g_c);
  ntr_model_g_c(tzt, 20L, 639L, 8L, 98L, 0L, model);
  /*$endif TRACE*/
  ntr_g_c(tzt, 20L, 639L, 8L, 99L, 0L, &(*model)->id->causal_structure);
}  /* sub_insert_g_c_in_model */


Static Void dispose_g_c_copy_for_mixed_id(id, g_c)
t_model_specification **id;
t_set_list **g_c;
{
  if ((*id)->model_type == mixed)
    dispose_set_list(g_c);
}  /* dispose_g_c_copy_for_mixed_model */


Static Void dispose_g_c_copy_for_mixed_model(model, g_c)
t_model **model;
t_set_list **g_c;
{
  if ((*model)->id->model_type == mixed)
    dispose_set_list(g_c);
}  /* dispose_g_c_copy_for_mixed_model */


Static Void insert_g_c_in_model(g_c, g, causal_structure, full_specified,
				homogeneous, model)
t_set_list **g_c;
long *g;
t_set_list **causal_structure;
boolean full_specified, homogeneous;
t_model **model;
{
  sub_insert_g_c_in_model(g_c, g, causal_structure, full_specified,
			  homogeneous, false, model);
  dispose_g_c_copy_for_mixed_model(model, g_c);
  *g_c = NULL;
}  /* insert_g_c_in_model */


Static Void insert_g_c_in_id(g_c, causal_structure, copy, homogeneous, id)
t_set_list **g_c, **causal_structure;
boolean copy, homogeneous;
t_model_specification **id;
{
  /* full_specified: boolean; */
  t_vertex_set g;
  boolean full_specified;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  P_setcpy(g, empty_set);
  add_union_of_gc(*g_c, g);
  full_specified = subset_of_an_edge(double_vertex_set, g_c);
  /*$ifdef TRACE*/
  memcpy(tzt, " SubInsertGCinId    ", sizeof(pch20));
  ntr_set_and_g_c(tzt, 20L, 639L, 1L, 0L, 1L, g, g_c);
  ntr_g_c(tzt, 20L, 639L, 1L, 0L, 2L, causal_structure);
  /*$endif TRACE*/
  *id = (t_model_specification *)Malloc(sizeof(t_model_specification));
  if (*id == NULL)
    _OutMem();
  P_setcpy((*id)->vertices, empty_set);
  (*id)->paritet = 0;
  (*id)->causal_structure = NULL;
  sub_insert_g_c_in_id(g_c, g, causal_structure, copy, full_specified,
		       homogeneous, false, id);
  if (!copy) {
    dispose_g_c_copy_for_mixed_id(id, g_c);
    *g_c = NULL;
  }
  /*$ifdef TRACE*/
  ntr_set_and_g_c(tzt, 20L, 639L, 8L, 97L, 0L, g, g_c);
  ntr_id(tzt, 20L, 639L, 8L, 98L, 0L, id);
  /*$endif TRACE*/
  ntr_g_c(tzt, 20L, 639L, 8L, 99L, 0L, &(*id)->causal_structure);
}  /* insert_g_c_in_id */


Static Void insert_mixed_g_c_in_model(g_c_d, g_c_l, g_c_q, g,
  causal_structure, full_specified, homogeneous, model)
t_set_list **g_c_d, **g_c_l, **g_c_q;
long *g;
t_set_list **causal_structure;
boolean full_specified, homogeneous;
t_model **model;
{
  t_vertex_set a;
  pch20 txt;

  /*$ifdef TRACE*/
  memcpy(txt, " InsertMixedGCinMo. ", sizeof(pch20));
  ntr_triple_g_c(txt, 20L, 642L, 1L, 0L, 0L, g_c_d, g_c_l, g_c_q);
  ntr_set_and_g_c(txt, 20L, 642L, 1L, 0L, 1L, g, causal_structure);
  /*$endif TRACE*/
  P_setcpy(a, empty_set);
  add_union_of_gc(*g_c_d, a);
  add_union_of_gc(*g_c_l, a);
  add_union_of_gc(*g_c_q, a);
  P_remset(a, double_vertex);
  if (!P_setequal(a, g) &&
      (*g_c_d != NULL || *g_c_l != NULL || *g_c_q != NULL))
    note_error_triple_g_c(stdout, 642L, 1L, txt, *g_c_d, *g_c_l, *g_c_q, g, a,
			  false);

  if (P_subset(g, delta)) {
    erase_discrete_model(model);
    dispose_set_list(g_c_l);
    dispose_set_list(g_c_q);
    (*model)->id->UU.g_c_log_linear = *g_c_d;
    /* copy_set_list(g_c, model^.id^.g_c_log_linear) */
  } else if (P_subset(g, gamma_) && !boolean_option[104]) {
    erase_continuous_model(model);
    dispose_set_list(g_c_d);
    dispose_set_list(g_c_l);
    (*model)->id->UU.g_c_covariance = *g_c_q;
    /* copy_set_list(g_c, model^.id^.g_c_covariance) */
  } else {
    erase_mixed_model(model);
    (*model)->id->UU.U1.full_specified = full_specified;
    (*model)->id->UU.U1.homogeneous = homogeneous;
    (*model)->id->UU.U1.g_c_discrete = *g_c_d;
    (*model)->id->UU.U1.g_c_linear = *g_c_l;
    (*model)->id->UU.U1.g_c_quadratic = *g_c_q;
  }
  P_setcpy((*model)->id->vertices, g);
  P_setdiff(a, delta_gamma, g);
  P_setint(a, a, delta);
  (*model)->constant = 1 / marginal_dimension_real(a);
  copy_ordered_set_list(*causal_structure, &(*model)->id->causal_structure);
  if ((*model)->id->model_type == mixed) {
    /*$ifdef TRACE*/
    check_mixed_model(model, " InsertMixedGcInMode", 20L, true);
  }
  ntr_model_g_c(txt, 20L, 642L, 8L, 98L, 0L, model);
  /*$endif TRACE*/
  ntr_g_c(txt, 20L, 642L, 8L, 99L, 0L, &(*model)->id->causal_structure);
}  /* insert_mixed_g_c_in_model */


Static Void dispose_model_but_gc(model)
t_model **model;
{
  if ((*model)->id->model_type == pure_discrete)
    (*model)->id->UU.g_c_log_linear = NULL;
  else if ((*model)->id->model_type == pure_continuous)
    (*model)->id->UU.g_c_covariance = NULL;
  dispose_model(model);
}  /* dispose_model_but_gc */


Static Void insert_g_c_in_new_discrete_model(g_c, causal_structure)
t_set_list **g_c, **causal_structure;
{
  new_model_in_list(&link_model_list, &first_model_available);
  P_setcpy(link_model_list->model->id->vertices, empty_set);
  add_union_of_gc(*g_c, link_model_list->model->id->vertices);
  link_model_list->model->id->model_type = pure_discrete;
  link_model_list->model->id->UU.g_c_log_linear = *g_c;
  copy_set_list(*causal_structure,
		&link_model_list->model->id->causal_structure);
}  /* insert_g_c_in_new_discrete_model */


Static Void insert_g_c_in_new_continuous_model(g_c, causal_structure)
t_set_list **g_c, **causal_structure;
{
  new_model_in_list(&link_model_list, &first_model_available);
  erase_continuous_model(&link_model_list->model);   /* Double `new' !!! */
  P_setcpy(link_model_list->model->id->vertices, empty_set);
  add_union_of_gc(*g_c, link_model_list->model->id->vertices);
  link_model_list->model->id->model_type = pure_continuous;
  link_model_list->model->id->UU.g_c_covariance = *g_c;
  copy_set_list(*causal_structure,
		&link_model_list->model->id->causal_structure);
}  /* insert_g_c_in_new_continuous_model */


Static boolean homogeneous_g_c(g_c_quadratic)
t_set_list **g_c_quadratic;
{
  t_vertex_set a;
  boolean homogeneous = false;

  P_setcpy(a, empty_set);
  add_union_of_gc(*g_c_quadratic, a);
  if (P_subset(a, gamma_)) {
    if (subset_of_an_edge(a, g_c_quadratic))
      homogeneous = true;
  }
  return homogeneous;
}  /* homogeneous_g_c */


Static Void insert_g_c_list_in_new_model(gc_list, causal_structure,
					 heterogenous_set, heterogenous)
t_g_c_list **gc_list;
t_set_list **causal_structure;
boolean heterogenous_set, heterogenous;
{
  t_g_c_list *p;
  boolean continuous_model, discrete_model;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertGClistInNewM.", sizeof(pch20));
  /*$endif TRACE*/
  if (*gc_list != NULL) {
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 647L, 1L, 0L, 1L, heterogenous_set);
    ntr_boolean(tzt, 20L, 647L, 1L, 0L, 1L, heterogenous);
    /*$endif TRACE*/
    new_model_in_list(&link_model_list, &first_model_available);
    WITH = link_model_list->model;
    P_setcpy(WITH->id->vertices, empty_set);
    p = *gc_list;
    while (p != NULL) {
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 647L, 2L, 1L, 0L, &p->g_c);
      /*$endif TRACE*/
      add_union_of_gc(p->g_c, WITH->id->vertices);
      p = p->pointer;
    }
    P_remset(WITH->id->vertices, double_vertex);
    discrete_model = (P_subset(WITH->id->vertices, delta) &&
		      (*gc_list)->pointer == NULL);
    /**/
    /**/
    continuous_model = P_subset(WITH->id->vertices, gamma_);
    /**/
    /* and (gc_list^.pointer = nil) */
    /**/
    if (discrete_model) {
      WITH->id->model_type = pure_discrete;
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 647L, 3L, 2L, 1L, &(*gc_list)->g_c);
      /*$endif TRACE*/
      WITH->id->UU.g_c_log_linear = NULL;
      add_cliques((*gc_list)->g_c, &WITH->id->UU.g_c_log_linear);
      dispose_set_list(&(*gc_list)->g_c);
    } else if (continuous_model && !boolean_option[104]) {
      erase_continuous_model(&link_model_list->model);
      WITH->id->model_type = pure_continuous;
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 647L, 3L, 2L, 2L, &(*gc_list)->g_c);
      /*$endif TRACE*/
      WITH->id->UU.g_c_covariance = NULL;
      p = *gc_list;
      while (p != NULL) {
	add_delta_gamma_cliques(p->g_c, &WITH->id->UU.g_c_covariance);
	p = p->pointer;
      }
      dispose_g_c_list(gc_list);
    } else {   /*ntr*/
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 647L, 3L, 2L, 3L, &(*gc_list)->g_c);
      ntr_set_and_boolean(tzt, 20L, 647L, 3L, 2L, 4L, WITH->id->vertices,
			  heterogenous);
      /*$endif TRACE*/
      erase_mixed_model(&link_model_list->model);
      if ((*gc_list)->pointer == NULL || heterogenous_set && heterogenous) {
	/* Heterogenous */
	if (!heterogenous_set)
	  heterogenous = true;
	/*$ifdef TRACE*/
	ntr_set_and_boolean(tzt, 20L, 647L, 4L, 2L, 1L, WITH->id->vertices,
			    heterogenous);
	    /*ntr*/
	/*$endif TRACE*/
	WITH->graphical = true;
	split_g_c_in_mixed_terms((*gc_list)->g_c, false, !heterogenous,
	  &WITH->id->UU.U1.g_c_discrete, &WITH->id->UU.U1.g_c_linear,
	  &WITH->id->UU.U1.g_c_quadratic);
	WITH->id->UU.U1.homogeneous = !heterogenous;   /* false */
	dispose_set_list(&(*gc_list)->g_c);
	if ((*gc_list)->pointer != NULL)   /* ?!?!? */
	  dispose_set_list(&(*gc_list)->pointer->g_c);
      } else if ((is_empty_g_c(&(*gc_list)->pointer->g_c) &&
		  (*gc_list)->pointer->pointer == NULL &&
		  !heterogenous_set) || heterogenous_set && !heterogenous) {
	/* Homogeneous */
	/*$ifdef TRACE*/
	ntr_set_and_boolean(tzt, 20L, 647L, 4L, 2L, 2L, WITH->id->vertices,
			    heterogenous);
	    /*ntr*/
	/*$endif TRACE*/
	WITH->graphical = true;
	split_g_c_in_mixed_terms((*gc_list)->g_c, false, true,
	  &WITH->id->UU.U1.g_c_discrete, &WITH->id->UU.U1.g_c_linear,
	  &WITH->id->UU.U1.g_c_quadratic);
	WITH->id->UU.U1.homogeneous = true;
	dispose_set_list(&(*gc_list)->g_c);
	if ((*gc_list)->pointer != NULL)   /* ?!?!? */
	  dispose_set_list(&(*gc_list)->pointer->g_c);
      } else {
	/*$ifdef TRACE*/
	ntr_boolean(tzt, 20L, 647L, 4L, 2L, 3L, heterogenous);
	/*$endif TRACE*/
	WITH->id->UU.U1.homogeneous = true;
	WITH->id->UU.U1.g_c_discrete = (*gc_list)->g_c;

	if (is_empty_g_c(&(*gc_list)->pointer->g_c)) {
	  /*$ifdef TRACE*/
	  ntr_boolean(tzt, 20L, 647L, 5L, 3L, 1L, heterogenous);
	  /*$endif TRACE*/
	  WITH->id->UU.U1.g_c_linear = NULL;   /* empty_gc,  ? a */
	} else {
	  /*$ifdef TRACE*/
	  ntr_boolean(tzt, 20L, 647L, 5L, 3L, 2L, heterogenous);
	  /*$endif TRACE*/
	  WITH->id->UU.U1.g_c_linear = (*gc_list)->pointer->g_c;
	}

	if ((*gc_list)->pointer->pointer == NULL) {
	  /*$ifdef TRACE*/
	  ntr_boolean(tzt, 20L, 647L, 5L, 4L, 1L, heterogenous);
	  /*$endif TRACE*/
	  WITH->id->UU.U1.g_c_quadratic = NULL;   /* empty_gc,  ? b */
	} else {
	  /*$ifdef TRACE*/
	  ntr_boolean(tzt, 20L, 647L, 5L, 4L, 2L, heterogenous);
	  /*$endif TRACE*/
	  if (is_empty_g_c(&(*gc_list)->pointer->pointer->g_c)) {
	    /*$ifdef TRACE*/
	    ntr_boolean(tzt, 20L, 647L, 5L, 5L, 1L, heterogenous);
	    /*$endif TRACE*/
	    WITH->id->UU.U1.g_c_quadratic = NULL;   /* empty_gc,  ? c */
	  } else {
	    /*$ifdef TRACE*/
	    ntr_boolean(tzt, 20L, 647L, 5L, 5L, 2L, heterogenous);
	    /*$endif TRACE*/
	    WITH->id->UU.U1.g_c_quadratic = (*gc_list)->pointer->pointer->g_c;
	    WITH->id->UU.U1.homogeneous = homogeneous_g_c(
		&WITH->id->UU.U1.g_c_quadratic);
	  }
	}
	/* ---- */
	WITH->id->UU.U1.full_specified = subset_of_an_edge(double_vertex_set,
	    &WITH->id->UU.U1.g_c_quadratic);
	/*$ifdef TRACE*/
	/*$endif TRACE*/
	ntr_boolean(tzt, 20L, 647L, 6L, 2L, 4L, heterogenous);
      }
      /*$ifdef TRACE*/
      ntr_set_and_boolean(tzt, 20L, 647L, 7L, 0L, 66L, WITH->id->vertices,
			  heterogenous);
	  /*ntr*/
      ntr_g_c(tzt, 20L, 647L, 7L, 1L, 77L, &(*gc_list)->g_c);
      if ((*gc_list)->pointer != NULL) {
	ntr_g_c(tzt, 20L, 647L, 7L, 2L, 88L, &(*gc_list)->pointer->g_c);
	if ((*gc_list)->pointer->pointer != NULL)
	  ntr_g_c(tzt, 20L, 647L, 7L, 3L, 99L,
		  &(*gc_list)->pointer->pointer->g_c);
      }
      /*$endif TRACE*/
      check_mixed_model(&link_model_list->model, " InsertGcListInNewM.", 20L,
			true);
    }
    copy_set_list(*causal_structure,
		  &link_model_list->model->id->causal_structure);
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_model(tzt, 20L, 647L, 8L, 1L, 2L, link_model_list->model);
}  /* insert_g_c_list_in_new_model */


Static Void insert_g_c_in_new_mixed_model(g_c, causal_structure,
					  full_specified, homogeneous)
t_set_list **g_c, **causal_structure;
boolean full_specified, homogeneous;
{
  t_g_c_list *q, *p;
  boolean heterogenous_set, heterogenous;

/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  heterogenous = !homogeneous;   /* _mode */
  if (homogeneous) {   /* _mode */
    q = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (q == NULL)
      _OutMem();
    q->g_c = NULL;
    q->pointer = NULL;
  } else
    q = NULL;
  p = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
  if (p == NULL)
    _OutMem();
  p->g_c = *g_c;
  p->pointer = q;
  insert_g_c_list_in_new_model(&p, causal_structure, false, heterogenous);
  if (q != NULL)
    _Free(q);
  _Free(p);
}  /* insert_g_c_in_new_mixed_model */


Static Void insert_g_c_in_new_model(g_c, g, causal_structure, full_specified,
				    homogeneous)
t_set_list **g_c;
long *g;
t_set_list **causal_structure;
boolean full_specified, homogeneous;
{
  t_vertex_set a;
  pch20 txt;

  memcpy(txt, " InsertGCinNewModel ", sizeof(pch20));
  /*$ifdef TRACE*/
  ntr_set_and_g_c(txt, 20L, 649L, 1L, 0L, 1L, g, g_c);
  ntr_g_c(txt, 20L, 649L, 1L, 0L, 2L, causal_structure);
  /*$endif TRACE*/
  if (full_specified != subset_of_an_edge(double_vertex_set, g_c))
    full_specified = !full_specified;
  P_setcpy(a, empty_set);
  add_union_of_gc(*g_c, a);
  if ((!P_setequal(a, g)) | P_inset(double_vertex, g))
    note_error_g_c(stdout, 649L, 1L, txt, *g_c, g, a, false);
  if (P_subset(g, delta)) {
    insert_g_c_in_new_discrete_model(g_c, causal_structure);
    return;
  }
  if (P_subset(g, gamma_) && !boolean_option[104])
    insert_g_c_in_new_continuous_model(g_c, causal_structure);
  else
    insert_g_c_in_new_mixed_model(g_c, causal_structure, full_specified,
				  homogeneous);
}  /* insert_g_c_in_new_model */


/* Use return_g_c_copy of 'subm.p' !!!

procedure cliques_of_mixed_model(var model   : t_link_model;
                                 var cliques : t_link_set_list);
begin
   cliques := nil;
   add_cliques(model^.id^.g_c_discrete,  cliques);
   add_cliques(model^.id^.g_c_linear,    cliques);
   add_cliques(model^.id^.g_c_quadratic, cliques);
end; */
/* cliques_of_mixed_model */

/* procedure g_c_of_mixed_model(var model : t_link_model;
                             var g_c   : t_link_set_list);
begin
   g_c := nil;
   add_cliques(model^.id^.g_c_discrete,  g_c);
   add_cliques(model^.id^.g_c_linear,    g_c);
   add_cliques(model^.id^.g_c_quadratic, g_c);
end; */
/* g_c_of_mixed_model */

/*@+"messages.p"*/


/*

  654:    +++  ++
  655:    +++  ++
  656:    ---  -- p/messages.p        16      67     950 p/messages.p
  657: |    4:    procedure sub_write_test_head
  658: |   80:    procedure write_test_head
  659: |  108:    procedure write_test_head_stepwise
  660: |  133:    procedure write_file_not_found
  661: |  144:    procedure write_file_not_opened
  662: |  155:    procedure no_convergence
  663: |  213:    procedure no_ips_convergence
  664: |  230:    procedure report_convergence
  665: |  268:    procedure report_ips
  666: |  285:    procedure warning_cips
  667: |  293:    procedure warning_mips
  668: |  301:    procedure warning_ips
  669: |  315:    procedure write_model_out_of_space
  670: |  352:    procedure write_out_of_space
  671: |  389:    procedure write_used_time
  672: |  398:    procedure sub_print_invers_order
  673:    +++  ++
  674:    +++  ++

*/


Static Void sub_write_test_head(f, write_options, test_labels)
FILE *f;
t_test_write_options *write_options;
t_test_labels *test_labels;
{
  if (exclude_missing && partitioning_output) {
    if (write_options->write_models) {
      write_space(f, 2L);
      if (dimension > 5) {
	write_pch(f, "Test on", 7L);
	write_space(f, dimension - 5L);
      } else
	write_pch(f, "On        ", dimension + 2L);
    }
    write_char(f, ' ');
    write_pch(f, "    N[]", 7L);
    if (long_names && write_options->write_models) {
      write_line(stdout);
      if (test_labels->short_report)
	write_space(stdout, 3L);
      write_space(stdout, 7L);
    }
  }
  write_char(f, ' ');
  if (true)
    write_space(f, labs(x_width) - 4);
  write_pch(f, "  DF", 4L);
  write_char(f, ' ');
  if (adj_df) {
    write_pch(f, "  #0", 4L);
    write_char(f, ' ');
  }
  if (mixed_data) {
    write_pch(f, "F df", 4L);
    write_char(f, ' ');
  }
  write_space(f, labs(x_width) - 8);
  write_pch(f, "-2log(Q)", 8L);
  write_char(f, ' ');
  write_space(f, labs(prob_width) - 1);
  write_pch(f, "P", 1L);
  write_char(f, ' ');
  if (lambda != 1) {
    write_space(f, labs(x_width) - 8);
    write_pch(f, "PowerDiv", 8L);
    write_char(f, ' ');
    write_space(f, labs(prob_width) - 1);
    write_pch(f, "P", 1L);
    write_char(f, ' ');
  }
  if (mixed_data) {
    write_space(f, labs(x_width) - 8);
    write_pch(f, "F or X^2", 8L);
  } else {
    write_space(f, labs(x_width) - 3);
    write_pch(f, "X^2", 3L);
  }
  write_char(f, ' ');
  write_space(f, labs(prob_width) - 1);
  write_pch(f, "P", 1L);
  write_char(f, ' ');
  if (ordinal_tests) {
    write_space(f, labs(x_width) - 5);
    write_pch(f, "Gamma", 5L);
    write_char(f, ' ');
    write_space(f, labs(prob_width) - 1);
    write_pch(f, "P", 1L);
    write_char(f, ' ');
  }
  if (ic) {
    write_space(f, labs(x_width) - 9);
    write_pch(f, "Delta(IC)", 9L);
    write_char(f, ' ');
  }
  write_space(f, labs(x_width) - 6);
}  /* sub_write_test_head */


Static Void write_test_head(f, c1, w1, s, c2, w2, write_options, test_labels)
FILE *f;
Char *c1;
t_integer w1, s;
Char *c2;
t_integer w2;
t_test_write_options *write_options;
t_test_labels *test_labels;
{
  write_line(f);
  if (s >= 0)
    write_char(f, ' ');
  write_pch(f, c1, w1);
  write_space(f, s);
  sub_write_test_head(f, write_options, test_labels);
  write_pch(f, c2, w2);
  if (em) {
    write_line(f);
    if (s >= 0)
      write_char(f, ' ');
    write_space(f, w1 + s + 8);
    write_pch(f, "(Warning: ", 10L);
    write_pch(f, "DF. not correct for latent variables!)", 38L);
  }
  write_line(f);
  write_line(f);
}  /* write_test_head */


Static Void write_test_head_stepwise(f, c, offset, write_options, test_labels,
				     short_report)
FILE *f;
Char *c;
t_integer offset;
t_test_write_options *write_options;
t_test_labels *test_labels;
boolean short_report;
{
  if (!write_options->line_form)
    return;
  if (write_options->write_models) {
    if (short_report)
      write_test_head(f, c, 9L, offset, "Models", 6L, write_options,
		      test_labels);
    else if (write_options->write_test)
      write_test_head(f, "  Edge    ", 6L, offset, "Models", 6L,
		      write_options, test_labels);
    return;
  }
  if (short_report)
    write_test_head(f, "", 0L, offset - 1, c, 9L, write_options,
		    test_labels);
  else if (write_options->write_test)
    write_test_head(f, "", 0L, offset - 1, "Edge", 4L,
		    write_options, test_labels);
}  /* write_test_head_stepwise */


Static Void write_file_not_found(f, name)
FILE *f;
Char *name;
{
  if (!echo)
    write_line_diary();
  write_pch(f, " *** WARNING ***  File '", 24L);
  write_pch_to_blank(f, name, (long)PCH_END);
  write_pch(f, "' not found.  *** WARNING *** ", 30L);
  write_line(f);
}  /* write_file_not_found */


Static Void write_file_not_opened(f, name)
FILE *f;
Char *name;
{
  if (!echo)
    write_line_diary();
  write_pch(f, " *** WARNING ***  Unable to REWRITE '", 37L);
  write_pch_to_blank(f, name, (long)PCH_END);
  write_pch(f, "'.  *** WARNING *** ", 20L);
  write_line(f);
}  /* write_file_not_opened */


Static Void no_convergence(set_list, c, w, ifail, cycle_number, d)
t_set_list *set_list;
Char *c;
t_integer w, *ifail, *cycle_number;
t_long_real *d;
{
  t_integer cc;

  if (!note_warnings)
    return;
  cc = char_count;
  write_pch(stdout, "/*", 2L);
  if (cc > 30)
    write_line(stdout);
  else
    write_space(stdout, 2L);
  write_pch(stdout, " *** WARNING *** ", 17L);
  if (interrupt_1) {
    write_pch(stdout, "  Interrupt in ", 15L);
    interrupt_1 = false;
  } else {
    if (*ifail > 0)
      write_pch(stdout, " Iteration aborted, ", 20L);
    else
      write_pch(stdout, " Max Cycles in ", 15L);
  }
  write_pch(stdout, c, w);
  write_char(stdout, ':');
  write_char(stdout, ' ');
  while (set_list != NULL) {
    print_vertex_set(set_list->vertex_set);
    set_list = set_list->pointer;
  }
  write_line(stdout);
  write_space(stdout, 2L);
  write_space(stdout, 19L);
  write_pch(stdout, " It Nr.:", 8L);
  write_integer(stdout, *cycle_number, 5L);
  write_space(stdout, 2L);
  if (*ifail > 0) {
    write_pch(stdout, " Ifail:", 7L);
    write_integer(stdout, *ifail, 5L);
    write_space(stdout, 2L);
  }
  write_pch(stdout, " Delta:", 7L);
  write_real(stdout, *d, print_width, print_dec);
  write_space(stdout, 2L);
  write_pch(stdout, " *** WARNING *** ", 17L);
  if (cc > 2) {
    write_line(stdout);
    write_space(stdout, cc - 2);
    write_pch(stdout, "*/", 2L);
    return;
  }
  write_space(stdout, 2L);
  write_pch(stdout, "*/", 2L);
  write_line(stdout);
}  /* no_convergence */


Static Void no_ips_convergence(link_clique, cycle_number, d)
t_ips_set_list *link_clique;
t_integer *cycle_number;
t_long_real *d;
{
  t_integer ifail = 0;
  t_set_list *set_list = NULL;

  while (link_clique != NULL) {
    insert_set_in_set_list(link_clique->vertex_set, &set_list);
    link_clique = link_clique->pointer;
  }
  no_convergence(set_list, "IPS", 3L, &ifail, cycle_number, d);
  dispose_set_list(&set_list);
}  /* no_ips_convergence */


Static Void report_convergence_mips(mixed_item, link_clique, c, w, a,
				    cycle_number, start_clock, d, epsilon)
t_mips_element **mixed_item;
t_set_list *link_clique;
Char *c;
t_integer w;
long *a;
t_integer *cycle_number;
t_long_real *start_clock, *d, *epsilon;
{
  write_pch_10_text(report_file, " :: ", 4L);
  write_pch_10_text(report_file, c, 4L);
  write_pch_20_text(report_file, " -  Nr.Cycles: ", 15L);
  write_integer_text(report_file, *cycle_number, 5L);
  write_pch_10_text(report_file, ",  Delta: ", 10L);
  write_real_text(report_file, *d, 13L, 10L);
  write_time_text(report_file, ",  Time: ", 9L, (double)my_clock()/1,
		  *start_clock, 8L, 3L);
  write_pch_10_text(report_file, ",  A: ", 6L);
  write_integer_text(report_file, cardinality(a), 4L);
  write_pch_10_text(report_file, ",  ", 3L);
  print_vertex_set_on_report(report_file, a);
  write_line_text(report_file);
  write_pch_10_text(report_file, " :: ", 4L);
  write_pch_10_text(report_file, c, 4L);
  write_pch_10_text(report_file, " - ", 3L);
  if (fabs(*d) > *epsilon)
    write_pch_30_text(report_file, " !!!!! No convergence !!!!!", 27L);
  write_pch_10_text(report_file, " GC: ", 5L);
  while (link_clique != NULL) {
    print_vertex_set_x_on_report(report_file, link_clique->vertex_set);
    link_clique = link_clique->pointer;
    if (link_clique != NULL)
      write_char_text(report_file, ',');
  }
  write_char_text(report_file, '.');
  if (*mixed_item != NULL) {
    write_pch_30_text(report_file, " :: MIPS -  #  Model: @@@@@@@ ", 23L);
    print_set_list_on_report(report_file, (*mixed_item)->discrete_);
    write_pch_10_text(report_file, " / ", 3L);
    print_set_list_on_report(report_file, (*mixed_item)->linear);
    write_pch_10_text(report_file, " / ", 3L);
    print_set_list_on_report(report_file, (*mixed_item)->quadratic);
  }
  write_line_text(report_file);
  fflush(report_file);
  P_ioresult = 0;
}  /* report_convergence_mips */


Static Void report_convergence(link_clique, c, w, a, cycle_number,
			       start_clock, d, epsilon)
t_set_list *link_clique;
Char *c;
t_integer w;
long *a;
t_integer *cycle_number;
t_long_real *start_clock, *d, *epsilon;
{
  t_mips_element *mixed_item = NULL;

  report_convergence_mips(&mixed_item, link_clique, c, w, a, cycle_number,
			  start_clock, d, epsilon);
}  /* report_convergnce */


Static Void report_ips(link_clique, a, cycle_number, start_clock, d,
		       ips_epsilon)
t_ips_set_list *link_clique;
long *a;
t_integer *cycle_number;
t_long_real *start_clock, *d, *ips_epsilon;
{
  t_set_list *set_list = NULL;

  while (link_clique != NULL) {
    insert_set_in_set_list(link_clique->vertex_set, &set_list);
    link_clique = link_clique->pointer;
  }
  report_convergence(set_list, "IPS", 3L, a, cycle_number, start_clock,
		     d, ips_epsilon);
  dispose_set_list(&set_list);
}  /* report_ips */


Static Void warning_cips(g_c)
t_set_list *g_c;
{
  warning_begin(stdout, true);
  write_pch(stdout, " Cycles in (C)IPS:  ", 20L);
  print_g_c(g_c, 10L, line_length);
  warning_end(stdout, true);
}  /* warning_cips */


Static Void warning_mips(g_c)
t_set_list *g_c;
{
  warning_begin(stdout, true);
  write_pch(stdout, " Cycles in (M)IPS:  ", 20L);
  print_g_c(g_c, 10L, line_length);
  warning_end(stdout, true);
}  /* warning_mips */


Static Void warning_ips(link_clique)
t_ips_set_list *link_clique;
{
  t_set_list *set_list = NULL;

  while (link_clique != NULL) {
    insert_set_in_set_list(link_clique->vertex_set, &set_list);
    link_clique = link_clique->pointer;
  }
  warning_mips(set_list);
  dispose_set_list(&set_list);
}  /* warning_ips */


Static Void write_model_out_of_space(current_model, base_g_c, c,
				     write_options, test_labels, off)
t_model *current_model;
t_set_list *base_g_c;
Char *c;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_long_integer off;
{
  if ((*write_options)->line_form) {
    write_pch(stdout, " Out of space in test of ", 25L);
    print_model_g_c(&current_model, off + 8);
    write_line(stdout);
    write_space(stdout, 7L);
    write_pch(stdout, " against ", 9L);
    if (base_g_c == NULL)
      write_pch(stdout, c, 10L);
    else
      print_g_c_from(base_g_c, off + 17, off + 8, line_length);
    write_line(stdout);
    return;
  }
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "Out of space", 12L);
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "in test of ", 11L);
  print_model_g_c(&current_model, (*test_labels)->indent + 1);
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "against ", 8L);
  if (base_g_c == NULL)
    write_pch(stdout, c, 10L);
  else
    print_g_c_from(base_g_c, (*test_labels)->indent + 9,
		   (*test_labels)->indent + 1, line_length);
  write_line(stdout);
}  /* write_model_out_of_space */


Static Void write_out_of_space(current_g_c, base_g_c, c, write_options,
			       test_labels, off)
t_set_list *current_g_c, *base_g_c;
Char *c;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_long_integer off;
{
  if ((*write_options)->line_form) {
    write_pch(stdout, " Out of space in test of ", 25L);
    print_g_c_from(current_g_c, off + 33, off + 8, line_length);
    write_line(stdout);
    write_space(stdout, 7L);
    write_pch(stdout, " against ", 9L);
    if (base_g_c == NULL)
      write_pch(stdout, c, 10L);
    else
      print_g_c_from(base_g_c, off + 17, off + 8, line_length);
    write_line(stdout);
    return;
  }
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "Out of space", 12L);
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "in test of ", 11L);
  print_g_c_from(current_g_c, (*test_labels)->indent + 12,
		 (*test_labels)->indent + 1, line_length);
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "against ", 8L);
  if (base_g_c == NULL)
    write_pch(stdout, c, 10L);
  else
    print_g_c_from(base_g_c, (*test_labels)->indent + 9,
		   (*test_labels)->indent + 1, line_length);
  write_line(stdout);
}  /* write_out_of_space */


Static Void write_used_time(f, start_clock)
FILE *f;
t_long_real start_clock;
{
  write_pch(f, " Time:       ", 13L);
  write_real(f, (my_clock()/1 - start_clock) / 1000, 14L, 3L);
  write_pch(f, "secs.", 5L);
  write_line(f);
}  /* write_used_time */


Static Void sub_print_invers_order(invers_order, c, complete)
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
{
  t_integer i;
  t_vertex v;

  write_space(stdout, 2L);
  write_char(stdout, 'V');
  write_pch(stdout, "  ", 2L);
  write_pch(stdout, " Order(V) ", 10L);
  write_space(stdout, 2L);
  write_pch(stdout, "C(V)", 4L);
  write_space(stdout, dimension - 2L);
  write_pch(stdout, "Complete(V)  ", 13L);
  write_line(stdout);
  for (i = 1; i <= dimension; i++) {
    v = invers_order[i-1];
    write_space(stdout, 2L);
    print_vertex_on_file(stdout, v, 10L);
    write_pch(stdout, ": ", 2L);
    write_integer(stdout, i, 10L);
    write_space(stdout, 3L);
    print_vertex_set_table_full(c[v - MIN_VERTEX]);
    write_boolean(stdout, P_getbits_UB(complete, v - MIN_VERTEX, 0, 3));
    write_line(stdout);
  }
}  /* sub_print_invers_order */


/*@+"reav.p"*/


/*

  675:    +++  ++
  676:    +++  ++
  677:    ---  -- p/readv.p         35     165    1985 p/readv.p
  678: |    4:    function begin_set_char
  679: |    9:    function end_set_char
  680: |   14:    function end_gc_char
  681: |   19:    function end_gc_list_char
  682: |   24:    function end_mark_char
  683: |   31:    function end_list_char
  684: |   36:    function order_mark_char
  685: |   41:    function end_mark_plus_char
  686: |   47:    function name_char
  687: |   53:    function white_space
  688: |   58:    procedure return_saturated_in_vertex_list
  689: |   71:    procedure return_main_effects_in_set_list
  690: |   89:    procedure list_of_vertices_to_set
  691: |   99:    procedure note_invalid_vertex_name
  692: |  110:    procedure skip_one_end_mark
  693: |  131:    function vertex_name_to_vertex
  694: |  156:    procedure read_long_vertex_name
  695: |  189:    function long_vertex_name_to_vertex
  696: |  251:    procedure read_sep_vertex
  697: |  297:    procedure read_vertex
  698: |  311:    procedure read_promb_vertex
  699: |  347:    procedure read_sep_vertex_list
  700: |  372:    procedure read_vertex_list
  701: |  382:    procedure read_promb_vertex_list_sep
  702: |  406:    procedure read_promb_vertex_list
  703: |  418:    procedure read_sep_list_of_vertex_lists
  704: |  456:    procedure read_list_of_vertex_lists
  705: |  469:    procedure read_sep_set_of_vertexes
  706: |  486:    procedure read_set_of_vertexes
  707: |  496:    procedure read_promb_set_of_vertexes
  708: |  515:    procedure read_sep_set_list
  709: |  536:    procedure read_promb_set_list
  710: |  555:    procedure set_order
  711: |  574:    procedure read_sep_ordered_set_list
  712: |  620:    procedure read_g_c_list
  713:    +++  ++
  714:    +++  ++

*/

/* Not used:
function begin_set_char(var c : char): boolean;
begin
   begin_set_char := (c = ':') or (c = '[')
end; */
/* begin_set_char */

/* Not used:
function end_set_char(var c : char): boolean;
begin
   end_set_char := (c = ',') or (c = ']')
end; */
/* end_set_char */

/* Not used:
function end_gc_char(var c : char): boolean;
begin
   end_gc_char := (c = '.') or (c = ']') or (c = '/')
end; */
/* end_gc_char */

/* Not used:
function end_gc_list_char(var c : char): boolean;
begin
   end_gc_list_char := (c = ']') or (c = ';') or (c = '/')
end; */
/* end_gc_list_char */

/* Not used:
function end_mark_char(var c : char): boolean;
begin
   end_mark_char := (c = ',') or (c = '.') or
    (c = '<') or (c = '|') or (c = '>') or
    (c = ']') or (c = ';') or (c = '/')
end; */
/* end_mark_char */

/* Not used:
function end_list_char(var c : char): boolean;
begin
   end_list_char := (c = ';') or (c = '/')
end; */
/* end_list_char */

/* Not used:
function order_mark_char(var c : char): boolean;
begin
   order_mark_char := (c = '<') or (c = '|') or (c = '>')
end; */
/* order_mark_char */

/* Not used:
function end_mark_plus_char(var c : char): boolean;
begin
   end_mark_plus_char := end_mark_char(c) or (c = '*')
end; */
/* end_mark_plus_char */


Static boolean name_char(full, c)
boolean *full;
Char *c;
{
  return ((*c == '^') | ((!*full) & P_inset(*c, names)) |
	  ((*full) & P_inset(*c, full_names)));
}  /* name_char */


Static boolean white_space(c)
Char *c;
{
  return (*c == ' ' || *c == '\t' || *c == '\n');
}  /* white_space */


Static Void return_saturated_in_vertex_list(full, p)
boolean *full;
t_vertex_list **p;
{
  t_vertex v, u;

  if (*full)
    u = full_last_vertex;
  else
    u = last_vertex;
  for (v = first_vertex; v <= u; v++)
    insert_vertex_in_vertex_list(v, p);
}  /* return_saturated_in_vertex_list */


Static Void return_main_effects_in_set_list(full, p)
boolean *full;
t_set_list **p;
{
  t_vertex_set a;
  t_vertex v, u;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnMainEffects. ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 689L, 1L, 0L, 1L, p);
  /*$endif TRACE*/
  P_addset(P_expset(a, 0L), first_vertex);   /* empty_set + */
  insert_set_in_set_list(a, p);
  if (*full)
    u = full_last_vertex;
  else
    u = last_vertex;
  for (v = first_vertex + 1; v <= u; v++) {
    P_addset(P_expset(a, 0L), v);   /* empty_set + */
    insert_set_in_set_list(a, p);
  }
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 689L, 1L, 0L, 2L, p);
  /*$endif TRACE*/
}  /* return_main_effects_in_set_list */


Static Void list_of_vertices_to_set(p, a)
t_vertex_list *p;
long *a;
{

  P_setcpy(a, empty_set);
  while (p != NULL) {
    P_addset(a, p->vertex);
    p = p->pointer;
  }
}  /* list_of_vertices_to_set */


/* Local variables for note_invalid_vertex_name: */
struct LOC_note_invalid_vertex_name {
  Char c;
} ;


Static Void note_invalid_vertex_name(c_)
Char c_;
{
  struct LOC_note_invalid_vertex_name Local_Var;

  Local_Var.c = c_;
  if (((P_inset(Local_Var.c, begin_set) | P_inset(Local_Var.c, end_mark_plus)) ||
       Local_Var.c == '&') | white_space(&Local_Var.c))
    return;
  write_pch(stdout, " Invalid factor name: `", 23L);
  write_char(stdout, Local_Var.c);
  write_char(stdout, '\'');
  write_line(stdout);
}  /* note_invalid_vertex_name */


/* Local variables for skip_one_end_mark: */
struct LOC_skip_one_end_mark {
  boolean full;
} ;


Static Void skip_one_end_mark(input_file, command_, keyboard, full_, c)
FILE *input_file;
boolean command_, keyboard, full_;
Char *c;
{
  struct LOC_skip_one_end_mark Local_Var;

  Local_Var.full = full_;
  *c = '&';
  while (!(P_inset(*c, begin_set) | P_inset(*c, end_mark_plus) |
	   name_char(&Local_Var.full, c)))
  {   /* (c = ':') or */
    if (eof_command(input_file)) {
      *c = ']';
      continue;
    }
    if (eoln_command(input_file)) {
      if (*c == '&')
	read_line_end(input_file, command_, keyboard);
      else
	*c = ';';
    } else {
      read_character(input_file, command_, keyboard, c);
      if (!name_char(&Local_Var.full, c))
	note_invalid_vertex_name(*c);
    }
  }
}  /* skip_one_end_mark */


Static boolean vertex_name_to_vertex(vertex_name, full, v)
Char *vertex_name;
boolean *full;
t_vertex *v;
{
  *v = first_vertex;
  if (*vertex_name == '\0') {
    write_pch(stdout, " Unexpeced end of string", 24L);
    write_pch(stdout, " when reading variable name.", 28L);
    write_line(stdout);
    /* note_invalid_vertex_name('?'); */
    *v = NULL_VERTEX;
    return false;
  } else if (*vertex_name == '^') {
    *v = double_vertex;
    return true;
  } else if (*full) {
    if (P_inset(*vertex_name, full_names)) {
      *v = full_name_to_vertex[*vertex_name - MIN_NAME];
      return true;
    } else {
      note_invalid_vertex_name(*vertex_name);
      return false;
    }
  } else if (P_inset(*vertex_name, names)) {
    *v = name_to_vertex[*vertex_name - MIN_NAME];
    return true;
  } else {
    note_invalid_vertex_name(*vertex_name);
    return false;
  }
}  /* vertex_name_to_vertex */


Static Void read_long_vertex_name(input_file, command_, keyboard, vertex_name,
				  length, c)
FILE *input_file;
boolean *command_, *keyboard;
Char *vertex_name;
t_integer *length;
Char *c;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadLongVertexName ", sizeof(pch20));
  /*$endif TRACE*/
  while (((white_space(c) || *c == ':') | P_inset(*c, begin_set)) || *c == '&')
    seek_non_blank(input_file, *command_, *keyboard, "1234567890", 0L, c);
  *length = 0;
  while (!((((white_space(c) || *c == ':') | P_inset(*c, end_mark_plus)) ||
	    *c == '^') | eolnorf_command(input_file))) {
    (*length)++;
    vertex_name[*length - PCH_START] = *c;
    read_character(input_file, *command_, *keyboard, c);
  }
  if ((!((white_space(c) || *c == ':') | P_inset(*c, end_mark_plus))) &
      ((*length == 0 && *c == '^') | eolnorf_command(input_file))) {
    (*length)++;
    vertex_name[*length - PCH_START] = *c;
    *c = ' ';
  }
  /*$ifdef TRACE*/
  ntr_char(tzt, 20L, 694L, 1L, 0L, 0L, *c);
  ntr_long_txt(tzt, 20L, 694L, 1L, 0L, *length, vertex_name);
  /*$endif TRACE*/
}  /* read_long_vertex_name */


Static boolean long_vertex_name_to_vertex(vertex_name, length, full, v)
Char *vertex_name;
t_integer *length;
boolean *full;
t_vertex *v;
{
  t_vertex_name_list *p_name_list;
  t_integer i = 1, count = 0;
  boolean match_length = false;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " LongVertexNameToVe ", sizeof(pch20));
  ntr_long_txt(tzt, 20L, 695L, 1L, 0L, *length, vertex_name);
  /*$endif TRACE*/
  *v = first_vertex;
  if (*length <= 0)
    return false;
  if (vertex_name[i - PCH_START] == '^') {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 695L, 1L, 1L, 0L);
    /*$endif TRACE*/
    count = 1;
    *v = double_vertex;
  } else {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 695L, 1L, 1L, 1L);
    /*$endif TRACE*/
    if (*full)
      p_name_list = full_name_list;
    else
      p_name_list = name_list;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 695L, 1L, 1L, 2L);
    /*$endif TRACE*/
    while (p_name_list != NULL && !match_length) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 695L, 1L, 2L, 1L);
      /*$endif TRACE*/
      i = 1;
      while (vertex_name[i - PCH_START] == p_name_list->name[i - PCH_START] &&
	     i < p_name_list->length && i < *length)
	i++;
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 695L, 1L, 2L, i);
      /*$endif TRACE*/
      if (vertex_name[i - PCH_START] == p_name_list->name[i - PCH_START] &&
	  i == *length) {
	count++;
	*v = p_name_list->vertex;
	if (i == p_name_list->length && i == *length)
	  match_length = true;
      }
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 695L, 1L, 2L, 888L);
      /*$endif TRACE*/
      p_name_list = p_name_list->pointer;
    }
  }
  if (count == 0) {
    write_pch(stdout, " Invalid factor name: `", 23L);
    write_pch(stdout, vertex_name, *length);
    write_char(stdout, '\'');
    write_line(stdout);
    return match_length;
  }
  if (count <= 1 || match_length)
    return (count == 1 || match_length);
  write_pch(stdout, " Not unique factor name: `", 26L);
  write_pch(stdout, vertex_name, *length);
  write_char(stdout, '\'');
  write_char(stdout, ':');
  write_integer(stdout, count, 3L);
  write_pch(stdout, " matching factors", 17L);
  write_line(stdout);
  return (count == 1);
}  /* long_vertex_name_to_vertex */


Static Void read_sep_vertex(input_file, command_, keyboard, full, v, ok, c)
FILE *input_file;
boolean *command_, *keyboard, *full;
t_vertex *v;
boolean *ok;
Char *c;
{
  pch_long vertex_name;
  t_integer length;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadSepVertex      ", sizeof(pch20));
  ntr_char(tzt, 20L, 696L, 1L, 0L, 1L, *c);
  /*$endif TRACE*/
  *ok = false;
  if (!long_names)
    *ok = vertex_name_to_vertex(c, full, v);
  else if (!(white_space(c) & eoln_command(input_file))) {
    read_long_vertex_name(input_file, command_, keyboard, vertex_name,
			  &length, c);
    /*$ifdef TRACE*/
    ntr_char(tzt, 20L, 696L, 1L, 0L, length, *c);
    /*$endif TRACE*/
    if (*c != '*' && *c != '.' || length != 0)
      *ok = long_vertex_name_to_vertex(vertex_name, &length, full, v);
  }
  /*$ifdef TRACE*/
  ntr_char(tzt, 20L, 696L, 1L, 0L, 2L, *c);
  /*$endif TRACE*/
  while (!(((*ok) | P_inset(*c, end_mark_plus)) || *c == '@')) {
    /*$ifdef TRACE*/
    ntr_char(tzt, 20L, 696L, 1L, 0L, 3L, *c);
    /*$endif TRACE*/
    if (eof_command(input_file)) {
      *c = '@';
      continue;
    }
    if (eoln_command(input_file)) {
      if (*c == '&')
	read_line_end(input_file, *command_, *keyboard);
      else
	*c = ';';
      continue;
    }
    if (!long_names) {
      read_character(input_file, *command_, *keyboard, c);
      *ok = vertex_name_to_vertex(c, full, v);
    } else {
      read_long_vertex_name(input_file, command_, keyboard, vertex_name,
			    &length, c);
      if (*c != '*' && *c != '.' || length != 0)
	*ok = long_vertex_name_to_vertex(vertex_name, &length, full, v);
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 696L, 1L, -1L, 8L);
  /*$endif TRACE*/
}  /* read_sep_vertex */


Static Void read_vertex(input_file, arg_command, arg_keyboard, arg_full, v)
FILE *input_file;
boolean arg_command, arg_keyboard, arg_full;
t_vertex *v;
{
  boolean command_ = arg_command, keyboard = arg_keyboard, full = arg_full;
  boolean ok;
  Char c = '&';

  read_sep_vertex(input_file, &command_, &keyboard, &full, v, &ok, &c);
}  /* read_vertex */


Static Void read_promb_vertex(input_file, command_, keyboard, full, promb, w,
			      v)
FILE *input_file;
boolean *command_, *keyboard, *full;
Char *promb;
t_long_integer *w;
t_vertex *v;
{
  Char c = '&';
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  if (echo)
    write_pch(stdout, promb, *w);
  read_sep_vertex(input_file, command_, keyboard, full, v, &ok, &c);
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadPrombVertex    ", sizeof(pch20));
  ntr_char(tzt, 20L, 698L, 1L, 0L, 0L, c);
  /*$endif TRACE*/
  if ((ok && c != ';' && c != '/' && !(long_names && c == ' ')) &
      (!eolnorf_command(input_file)))
    read_char(input_file, &c);
  /*$ifdef TRACE*/
  ntr_char(tzt, 20L, 698L, 8L, 0L, 0L, c);
  /*$endif TRACE*/
  if (echo)
    write_line(stdout);
}  /* read_promb_vertex */


/* Local variables for read_sep_vertex_list: */
struct LOC_read_sep_vertex_list {
  boolean arg_full;
} ;


Static Void read_sep_vertex_list(input_file, arg_command, arg_keyboard,
				 arg_full_, p, c)
FILE *input_file;
boolean arg_command, arg_keyboard, arg_full_;
t_vertex_list **p;
Char *c;
{
  struct LOC_read_sep_vertex_list Local_Var;
  t_vertex v;
  boolean command_, keyboard, full, ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.arg_full = arg_full_;
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadSepVertexList  ", sizeof(pch20));
  ntr(tzt, 20L, 699L, 1L, -1L, 1L);
  /*$endif TRACE*/
  command_ = arg_command;
  keyboard = arg_keyboard;
  full = Local_Var.arg_full;
  *p = NULL;
  do {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 699L, 1L, -1L, 2L);
    /*$endif TRACE*/
    read_sep_vertex(input_file, &command_, &keyboard, &full, &v, &ok, c);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 699L, 1L, -1L, 3L);
    /*$endif TRACE*/
    if (*c == '*') {
      return_saturated_in_vertex_list(&Local_Var.arg_full, p);
      *c = '.';
    } else if (ok)
      insert_vertex_in_vertex_list(v, p);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 699L, 1L, -1L, 6L);
    /*$endif TRACE*/
    if (!P_inset(*c, end_mark))   /* and not (c = '^') */
      *c = ' ';
    /*$ifdef TRACE*/
  } while (!P_inset(*c, end_mark));
  ntr(tzt, 20L, 699L, 1L, -1L, 8L);
  /*$endif TRACE*/
}  /* read_sep_vertex_list */


Static Void read_vertex_list(input_file, command_, keyboard, full, p)
FILE *input_file;
boolean command_, keyboard, full;
t_vertex_list **p;
{
  Char c = ' ';

  read_sep_vertex_list(input_file, command_, keyboard, full, p, &c);
}  /* read_vertex_list */


Static Void read_promb_vertex_list_sep(input_file, arg_command, arg_keyboard,
				       arg_full, promb, w, c, p)
FILE *input_file;
boolean arg_command, arg_keyboard, arg_full;
Char *promb;
t_long_integer *w;
Char *c;
t_vertex_list **p;
{
  boolean command_ = arg_command, keyboard = arg_keyboard, full = arg_full;

  if (echo)
    write_pch(stdout, promb, *w);
  *c = ' ';
  read_sep_vertex_list(input_file, command_, keyboard, full, p, c);
  if ((P_inset(*c, end_mark_plus) && *c != ';' && *c != '/') &
      (!eolnorf_command(input_file)))
    read_char(input_file, c);
  if (echo)
    write_line(stdout);
}  /* read_promb_vertex_list_sep */


Static Void read_promb_vertex_list(input_file, command_, keyboard, full,
				   promb_, w, p)
FILE *input_file;
boolean command_, keyboard, full;
Char *promb_;
t_long_integer w;
t_vertex_list **p;
{
  pch10 promb;
  Char c;

  memcpy(promb, promb_, sizeof(pch10));
  read_promb_vertex_list_sep(input_file, command_, keyboard, full, promb, &w,
			     &c, p);
}  /* read_promb_vertex_list */


Static Void read_sep_list_of_vertex_lists(input_file, command_, keyboard,
					  full, p, c)
FILE *input_file;
boolean command_, keyboard, full;
t_list_of_vertex_lists **p;
Char *c;
{
  t_vertex v, u;
  t_list_of_vertex_lists *q;

  *p = NULL;
  do {
    q = (t_list_of_vertex_lists *)Malloc(sizeof(t_list_of_vertex_lists));
    if (q == NULL)
      _OutMem();
    q->vertex_list = NULL;
    q->pointer = *p;
    *p = q;
    read_sep_vertex_list(input_file, command_, keyboard, full,
			 &(*p)->vertex_list, c);
    if (P_inset(*c, end_set) & P_inset(*c, end_gc))
      skip_one_end_mark(input_file, command_, keyboard, full, c);
    else if (P_inset(*c, end_set))
      *c = ' ';
  } while (!P_inset(*c, end_mark));
  if (*c != '.' || (*p)->pointer != NULL || (*p)->vertex_list != NULL)
    return;
  insert_vertex_in_vertex_list(first_vertex, &(*p)->vertex_list);
  if (full)
    u = full_last_vertex;
  else
    u = last_vertex;
  for (v = first_vertex + 1; v <= u; v++) {
    q = (t_list_of_vertex_lists *)Malloc(sizeof(t_list_of_vertex_lists));
    if (q == NULL)
      _OutMem();
    q->vertex_list = NULL;
    q->pointer = *p;
    *p = q;
    insert_vertex_in_vertex_list(v, &(*p)->vertex_list);
  }
}  /* read_sep_list_of_vertex_lists */


Static Void read_list_of_vertex_lists(input_file, command_, keyboard, full, p)
FILE *input_file;
boolean command_, keyboard, full;
t_list_of_vertex_lists **p;
{
  Char c = ' ';

  read_sep_list_of_vertex_lists(input_file, command_, keyboard, full, p, &c);
  if ((P_inset(c, end_mark_plus) && c != ';' && c != '/') &
      (!eolnorf_command(input_file)))
    read_character(input_file, command_, keyboard, &c);
}  /* read_list_of_vertex_lists */


Static Void read_sep_set_of_vertexes(input_file, command_, keyboard, full, a,
				     c)
FILE *input_file;
boolean command_, keyboard, full;
long *a;
Char *c;
{
  t_vertex_list *p, *q;

  read_sep_vertex_list(input_file, command_, keyboard, full, &q, c);
  P_setcpy(a, empty_set);
  p = q;
  while (q != NULL) {
    P_addset(a, q->vertex);
    q = q->pointer;
  }
  dispose_vertex_list(&p);
}  /* read_sep_set_of_vertexes */


/* Not used:
procedure read_set_of_vertexes(var input_file: text;
                                   command, keyboard, full: boolean;
                               var a: t_vertex_set);
var
   c: char;
begin
   c := ' ';
   read_sep_set_of_vertexes(input_file, command, keyboard, full, a, c)
end; */
/* read_set_of_vertexes */

Static Void read_promb_set_of_vertexes(input_file, command_, keyboard, full,
				       promb, w, a)
FILE *input_file;
boolean *command_, *keyboard, *full;
Char *promb;
t_long_integer *w;
long *a;
{
  Char c = ' ';

  if (echo)
    write_pch(stdout, promb, *w);
  read_sep_set_of_vertexes(input_file, *command_, *keyboard, *full, a, &c);
  if ((P_inset(c, end_mark_plus) && c != ';' && c != '/') &
      (!eolnorf_command(input_file)))
    read_char(input_file, &c);
  if (echo)
    write_line(stdout);
}  /* read_promb_set_of_vertexes */


/* Local variables for read_sep_set_list: */
struct LOC_read_sep_set_list {
  boolean full;
} ;


Static Void read_sep_set_list(input_file, command_, keyboard, full_, p, c)
FILE *input_file;
boolean command_, keyboard, full_;
t_set_list **p;
Char *c;
{
  struct LOC_read_sep_set_list Local_Var;
  t_vertex_set a;

  Local_Var.full = full_;
  *p = NULL;
  do {
    read_sep_set_of_vertexes(input_file, command_, keyboard, Local_Var.full,
			     a, c);
    if (*c == '.' && *p == NULL && P_setequal(a, empty_set))
      return_main_effects_in_set_list(&Local_Var.full, p);
    else
      insert_set_in_set_list(a, p);
    if (P_inset(*c, end_set) & P_inset(*c, end_gc))
      skip_one_end_mark(input_file, command_, keyboard, Local_Var.full, c);
    else if (P_inset(*c, end_set))
      *c = ' ';
  } while (!P_inset(*c, end_mark));   /* read_sep_set_list */
}


Static Void read_promb_set_list(input_file, command_, keyboard, full, promb,
				w, p)
FILE *input_file;
boolean *command_, *keyboard, *full;
Char *promb;
t_long_integer *w;
t_set_list **p;
{
  Char c = ' ';

  if (echo)
    write_pch(stdout, promb, *w);
  read_sep_set_list(input_file, *command_, *keyboard, *full, p, &c);
  if ((P_inset(c, end_mark_plus) && c != ';' && c != '/') &
      (!eolnorf_command(input_file)))
    read_char(input_file, &c);
  if (echo)
    write_line(stdout);
}  /* read_promb_set_list */


Static Void set_order(ordered, order, c)
boolean *ordered, *order;
Char *c;
{
  boolean new_order;

  if (*c == '|' || *c == '>')
    new_order = true;
  else if (*c == '<')
    new_order = false;
  if (*ordered && new_order != *order) {
    write_line(stdout);
    write_pch(stdout, " Invalid causal structure !!! ", 30L);
    write_line(stdout);
  } else
    *order = new_order;
  *ordered = true;
}  /* set_order */


/* Local variables for read_sep_ordered_set_list: */
struct LOC_read_sep_ordered_set_list {
  boolean full;
} ;


Static Void read_sep_ordered_set_list(input_file, command_, keyboard, full_,
				      p, c)
FILE *input_file;
boolean command_, keyboard, full_;
t_set_list **p;
Char *c;
{
  struct LOC_read_sep_ordered_set_list Local_Var;
  t_vertex_set a;
  boolean ordered = false, reverse = false;

  Local_Var.full = full_;
  *p = NULL;
  if (*c == ' ') {
    if (!eolnorf_command(input_file))
      read_character(input_file, command_, keyboard, c);
    else
      *c = ';';
    while ((white_space(c) || *c == ',') & (!eolnorf_command(input_file)))
      read_character(input_file, command_, keyboard, c);
  }
  if (P_inset(*c, order_mark)) {
    if (*c != '|')
      set_order(&ordered, &reverse, c);
    skip_one_end_mark(input_file, command_, keyboard, Local_Var.full, c);
  }
  if (!eolnorf_command(input_file) && *c != ';' && *c != '/') {
    do {
      read_sep_set_of_vertexes(input_file, command_, keyboard, Local_Var.full,
			       a, c);
      if (*c == '.' && *p == NULL && P_setequal(a, empty_set))
	return_main_effects_in_set_list(&Local_Var.full, p);
      else
	insert_set_in_set_list(a, p);
      if ((*c != '>') & P_inset(*c, end_set) & P_inset(*c, end_gc))
	skip_one_end_mark(input_file, command_, keyboard, Local_Var.full, c);
      else if ((*c != '>') & P_inset(*c, end_set)) {   /* c = '.' */
	/* c := ' ' */
	skip_one_end_mark(input_file, command_, keyboard, Local_Var.full, c);
      }
      if (P_inset(*c, order_mark)) {
	set_order(&ordered, &reverse, c);
	skip_one_end_mark(input_file, command_, keyboard, Local_Var.full, c);
      }
    } while (!(P_inset(*c, end_mark) | eof_command(input_file)));
  }
  if (reverse)
    revers_set_list(p);
}  /* read_sep_ordered_set_list */


Static Void read_g_c_list(input_file, command_, keyboard, full, skip_eoln, p,
			  end_of_command, options)
FILE *input_file;
boolean *command_, *keyboard, *full, *skip_eoln;
t_g_c_list **p;
boolean *end_of_command, *options;
{
  t_set_list *set_list;
  Char c = ' ';
  Char d;

  *p = NULL;
  do {
    read_sep_set_list(input_file, *command_, *keyboard, *full, &set_list, &c);
    insert_g_c_in_g_c_list(set_list, p);
    if (eoln_command(input_file) && *skip_eoln)
      read_line(input_file);
    *end_of_command = (c == ';');
    if (P_inset(c, end_gc) & P_inset(c, end_gc_list)) {
      d = c;
      skip_one_end_mark(input_file, *command_, *keyboard, *full, &c);
      if (!*end_of_command)
	*end_of_command = (c == ';');
      if (d != '/' && c == '/')
	skip_one_end_mark(input_file, *command_, *keyboard, *full, &c);
    } else if (P_inset(c, end_gc))
      c = ' ';
  } while (!P_inset(c, end_mark));
  *options = (c == '/');
}  /* read_g_c_list */


/*@+"pchint.p"*/


/*

  715:    +++  ++
  716:    +++  ++
  717:    ---  -- p/pchint.p         20      81    1112 p/pchint.p
  718: |    4:    procedure int_vector_to_pch
  719: |   27:    procedure pch_to_int_vector
  720: |   41:    procedure vertex_to_long_vertex_name
  721: |   59:    procedure insert_chr_in_pch
  722: |   69:    procedure insert_long_vertex_name_in_pch
  723: |   87:    procedure return_vertex_set_in_pch
  724: |  116:    procedure return_vertex_list_in_pch
  725: |  142:    procedure return_g_c_in_pch
  726: |  159:    procedure return_g_c_list_in_pch
  727: |  173:    procedure skip_one_end_mark_in_pch
  728: |  189:    procedure get_long_vertex_name
  729: |  214:    procedure pch_to_vertex
  730: |  243:    procedure pch_to_vertex_list
  731: |  265:    procedure pch_to_vertex_set_sep
  732: |  282:    procedure pch_to_vertex_set
  733: |  292:    procedure pch_to_set_list_sep
  734: |  315:    procedure pch_to_set_list
  735: |  325:    procedure pch_to_ordered_set_list_sep
  736: |  371:    procedure pch_to_ordered_set_list
  737: |  382:    procedure pch_to_gc_list
  738:    +++  ++
  739:    +++  ++

*/

Static Void int_vector_to_pch(int_vector, length, s)
long *int_vector;
t_integer length;
Char *s;
{
  t_integer i = 1;

  while (int_vector[i-1] != 0 && i <= length) {
    s[i - PCH_START] = (Char)int_vector[i-1];
    /*$ifdef TRACE*/
    ntr_char(" IntVectorToPch     ", 20L, 718L, 1L, 0L, int_vector[i-1],
	     s[i - PCH_START]);
    /*$endif TRACE*/
    i++;
  }
  s[i - PCH_START] = '\0';
}  /* int_vector_to_pch */


Static Void pch_to_int_vector(int_vector, length, s)
long *int_vector;
t_integer length;
Char *s;
{
  t_integer i = 1;

  while (s[i - PCH_START] != '\0' && i <= length) {
    int_vector[i-1] = s[i - PCH_START];
    i++;
  }
  int_vector[i-1] = 0;
}  /* pch_to_int_vector */


Static Void vertex_to_long_vertex_name(v, full, vertex_name, length)
t_vertex *v;
boolean *full;
Char *vertex_name;
t_integer *length;
{
  t_vertex_name_list *p_name_list;
  t_vertex u;

  if (*full)
    p_name_list = full_name_list;
  else
    p_name_list = name_list;
  for (u = first_vertex + 1; u <= *v; u++)
    p_name_list = p_name_list->pointer;
  memcpy(vertex_name, p_name_list->name, sizeof(pch_long));
  *length = p_name_list->length;
}  /* vertex_to_long_vertex_name */


Static Void insert_chr_in_pch(c, s, j, stop)
Char c;
Char *s;
t_integer *j, *stop;
{
  if (*j <= *stop)
    s[*j - PCH_START] = c;
  (*j)++;
}  /* insert_chr_in_pch */


Static Void insert_long_vertex_name_in_pch(v, full, s, j, stop)
t_vertex *v;
boolean *full;
Char *s;
t_integer *j, *stop;
{
  pch_long vertex_name;
  t_integer i, length;

  vertex_to_long_vertex_name(v, full, vertex_name, &length);
  if (*j + length <= *stop) {
    s[*j - PCH_START] = ':';
    for (i = 1; i <= length; i++)
      s[*j + i - PCH_START] = vertex_name[i - PCH_START];
  }
  *j += length + 1;
}  /* insert_long_vertex_name_in_pch */


Static Void return_vertex_set_in_pch(a, full, s, j, stop)
long *a;
boolean *full;
Char *s;
t_integer *j, *stop;
{
  t_vertex u, v, w;

  insert_chr_in_pch('[', s, j, stop);
  if (*full)
    u = full_last_vertex;
  else
    u = last_vertex;
  for (v = first_vertex; v <= u; v++) {
    if (P_inset(v, a)) {
      if (long_names) {
	w = v;
	insert_long_vertex_name_in_pch(&w, full, s, j, stop);
      } else {
	if (*j <= *stop) {
	  if (*full)
	    s[*j - PCH_START] = full_variable_description[v - MIN_VERTEX]->name;
	  else
	    s[*j - PCH_START] = variable_description[v - MIN_VERTEX]->name;
	}
	(*j)++;
      }
    }
  }
  insert_chr_in_pch(']', s, j, stop);
}  /* return_vertex_set_in_pch */


Static Void return_vertex_list_in_pch(p, full, s, j, stop)
t_vertex_list *p;
boolean *full;
Char *s;
t_integer *j, *stop;
{
  t_vertex v;

  insert_chr_in_pch('[', s, j, stop);
  while (p != NULL) {
    if (long_names) {
      v = p->vertex;
      insert_long_vertex_name_in_pch(&v, full, s, j, stop);
    } else {
      if (*j <= *stop) {
	if (*full)
	  s[*j - PCH_START] =
	    full_variable_description[p->vertex - MIN_VERTEX]->name;
	else
	  s[*j - PCH_START] = variable_description[p->vertex - MIN_VERTEX]->name;
      }
      (*j)++;
    }
    p = p->pointer;
  }
  insert_chr_in_pch(']', s, j, stop);
}  /* return_vertex_list_in_pch */


Static Void return_g_c_in_pch(p, full, s, j, stop)
t_set_list *p;
boolean *full;
Char *s;
t_integer *j, *stop;
{
  insert_chr_in_pch('[', s, j, stop);
  while (p != NULL) {
    if (*j > *stop && !long_names)
      *j += cardinality(p->vertex_set) + 2;
    else
      return_vertex_set_in_pch(p->vertex_set, full, s, j, stop);
    p = p->pointer;
  }
  insert_chr_in_pch(']', s, j, stop);
}  /* return_g_c_in_pch */


Static Void return_g_c_list_in_pch(p, full, s, j, stop)
t_g_c_list *p;
boolean *full;
Char *s;
t_integer *j, *stop;
{
  insert_chr_in_pch('[', s, j, stop);
  while (p != NULL) {
    return_g_c_in_pch(p->g_c, full, s, j, stop);
    p = p->pointer;
  }
  insert_chr_in_pch(']', s, j, stop);
}  /* return_g_c_list_in_pch */


Static Void skip_one_end_mark_in_pch(s, full, i)
Char *s;
boolean *full;
t_integer *i;
{
  (*i)++;
  while (!(((P_inset(s[*i - PCH_START], begin_set) | P_inset(s[*i - PCH_START],
							     end_mark)) ||
	    s[*i - PCH_START] == '\0') | name_char(full, &s[*i - PCH_START]))) {
    /*$ifdef TRACE*/
    ntr_char(" SkipOneEndMarkInPch", 13L, 727L, 1L, 1L, *i, s[*i - PCH_START]);
    /*$endif TRACE*/
    if (!(name_char(full, &s[*i - PCH_START]) | white_space(&s[*i - PCH_START])))
      note_invalid_vertex_name(s[*i - PCH_START]);
    (*i)++;
  }
}  /* skip_one_end_mark_in_pch */


Static Void get_long_vertex_name(s, vertex_name, length, i)
Char *s, *vertex_name;
t_integer *length, *i;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GetLongVertexName  ", sizeof(pch20));
  ntr_char(tzt, 20L, 728L, 1L, -1L, *i, s[*i - PCH_START]);
  /*$endif TRACE*/
  while ((white_space(&s[*i - PCH_START]) || s[*i - PCH_START] == ':') |
	 P_inset(s[*i - PCH_START], begin_set))
    (*i)++;
  *length = 0;
  while (!(((white_space(&s[*i - PCH_START]) || s[*i - PCH_START] == ':') |
	    P_inset(s[*i - PCH_START], end_mark_plus)) ||
	   s[*i - PCH_START] == '^' || s[*i - PCH_START] == '\0')) {
    (*length)++;
    vertex_name[*length - PCH_START] = s[*i - PCH_START];
    (*i)++;
  }
  if (*length == 0 && s[*i - PCH_START] == '^') {
    (*length)++;
    vertex_name[*length - PCH_START] = s[*i - PCH_START];
    (*i)++;
  }
  /*$ifdef TRACE*/
  ntr_long_txt(tzt, 20L, 728L, 1L, *i, *length, vertex_name);
  /*$endif TRACE*/
}  /* get_long_vertex_name */


Static Void pch_to_vertex(s, full, i, v, ok)
Char *s;
boolean *full;
t_integer *i;
t_vertex *v;
boolean *ok;
{
  pch_long vertex_name;
  t_integer length;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PchToVertex        ", sizeof(pch20));
  ntr_char(tzt, 20L, 729L, 1L, -1L, *i, s[*i - PCH_START]);
  /*$endif TRACE*/
  *ok = false;
  if (long_names) {
    get_long_vertex_name(s, vertex_name, &length, i);
    if (s[*i - PCH_START] != '*' && s[*i - PCH_START] != '.' || length != 0)
      *ok = long_vertex_name_to_vertex(vertex_name, &length, full, v);
  } else if (!white_space(&s[*i - PCH_START]))
    *ok = vertex_name_to_vertex(&s[*i - PCH_START], full, v);
  while (!(((*ok) | P_inset(s[*i - PCH_START], end_mark_plus)) ||
	   s[*i - PCH_START] == '\0' || s[*i - PCH_START] == '\\')) {
    if (long_names) {
      get_long_vertex_name(s, vertex_name, &length, i);
      if (s[*i - PCH_START] != '*' && s[*i - PCH_START] != '.' || length != 0)
	*ok = long_vertex_name_to_vertex(vertex_name, &length, full, v);
    } else {
      (*i)++;
      if (!white_space(&s[*i - PCH_START]))
	*ok = vertex_name_to_vertex(&s[*i - PCH_START], full, v);
    }
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_vertex(tzt, 20L, 729L, 1L, -1L, *i, v);
}  /* pch_to_vertex */


Static Void pch_to_vertex_list(s, full, i, p)
Char *s;
boolean *full;
t_integer *i;
t_vertex_list **p;
{
  t_vertex v;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PchToVertexList    ", sizeof(pch20));
  ntr_char(tzt, 20L, 730L, 1L, -1L, *i, s[*i - PCH_START]);
  /*$endif TRACE*/
  *p = NULL;
  do {
    pch_to_vertex(s, full, i, &v, &ok);
    if (s[*i - PCH_START] == '*')
      return_saturated_in_vertex_list(full, p);
    else if (ok)
      insert_vertex_in_vertex_list(v, p);
    if (!(P_inset(s[*i - PCH_START], end_mark_plus) ||
	  s[*i - PCH_START] == '\0' || s[*i - PCH_START] == '.' ||
	  s[*i - PCH_START] == ':' || s[*i - PCH_START] == '\\')) {
      /* or
      (s[i] = '^') */
      (*i)++;
    }
    /* or
    (s[i] = '^') */
    /*$ifdef TRACE*/
  } while (!(P_inset(s[*i - PCH_START], end_mark_plus) ||
	     s[*i - PCH_START] == '\0' || s[*i - PCH_START] == '.' ||
	     s[*i - PCH_START] == '\\'));
  ntr(tzt, 20L, 730L, 1L, -9L, *i);
  /*$endif TRACE*/
}  /* pch_to_vertex_list */


Static Void pch_to_vertex_set_sep(s, full, i, a)
Char *s;
boolean *full;
t_integer *i;
long *a;
{
  t_vertex_list *p, *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PchToVertexSetSep  ", sizeof(pch20));
  ntr_char(tzt, 20L, 731L, 1L, -1L, *i, s[*i - PCH_START]);
  /*$endif TRACE*/
  pch_to_vertex_list(s, full, i, &q);
  P_setcpy(a, empty_set);
  p = q;
  while (q != NULL) {
    P_addset(a, q->vertex);
    q = q->pointer;
  }
  /*$ifdef TRACE*/
  dispose_vertex_list(&p);
  /*$endif TRACE*/
  ntr_set(tzt, 20L, 731L, 1L, -1L, *i, a);
}  /* pch_to_vertex_set_sep */


Static Void pch_to_vertex_set(s, full, a)
Char *s;
boolean *full;
long *a;
{
  t_integer i = PCH_START;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /**/
  /**/
  /*$ifdef TRACE*/
  memcpy(tzt, " PchToVertexSet     ", sizeof(pch20));
  ntr_char(tzt, 20L, 732L, 1L, -1L, -1L, s[i - PCH_START]);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  pch_to_vertex_set_sep(s, full, &i, a);
  /*$endif TRACE*/
  ntr_set(tzt, 20L, 732L, 1L, -1L, i, a);
}  /* pch_to_vertex_set */


Static Void pch_to_set_list_sep(s, full, i, p)
Char *s;
boolean *full;
t_integer *i;
t_set_list **p;
{
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PchToVertexListSep ", sizeof(pch20));
  ntr_char(tzt, 20L, 733L, 1L, -1L, *i, s[*i - PCH_START]);
  /*$endif TRACE*/
  *p = NULL;
  do {
    pch_to_vertex_set_sep(s, full, i, a);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 733L, 1L, -2L, *i, a);
    ntr_char(tzt, 20L, 733L, 1L, -2L, *i, s[*i - PCH_START]);
    /*$endif TRACE*/
    insert_set_in_set_list(a, p);
    if (P_inset(s[*i - PCH_START], end_set) & P_inset(s[*i - PCH_START], end_gc))
      skip_one_end_mark_in_pch(s, full, i);
    else if (P_inset(s[*i - PCH_START], end_set))
      (*i)++;
  } while (!(P_inset(s[*i - PCH_START], end_mark_plus) ||
	     s[*i - PCH_START] == '\0'));
  /* or
         (s[i] = '^') */
  if (s[*i - PCH_START] == '.' && (*p)->pointer == NULL &&
      P_setequal((*p)->vertex_set, empty_set)) {
    dispose_set_list(p);
    return_main_effects_in_set_list(full, p);
  }
  if (s[*i - PCH_START] == '*' || s[*i - PCH_START] == '.') {
    (*i)++;
    /*$ifdef TRACE*/
  }
  ntr(tzt, 20L, 733L, 1L, -9L, *i);
  /*$endif TRACE*/
}  /* pch_to_set_list_sep */


/* Not used:
procedure pch_to_set_list(var s   : pch_long;
                          var full : boolean;
                          var p   : t_link_set_list);
var
   i : t_integer;
begin
   i := 1;
   pch_to_set_list_sep(s, full, i, p)
end; */
/* pch_to_set_list */

Static Void pch_to_ordered_set_list_sep(s, full, i, p)
Char *s;
boolean *full;
t_integer *i;
t_set_list **p;
{
  t_vertex_set a;
  boolean ordered = false, reverse = false;

  *p = NULL;
  if (s[*i - PCH_START] == ' ') {
    if (s[*i - PCH_START] != '\0')
      (*i)++;
    else
      s[*i - PCH_START] = ';';
    while ((white_space(&s[*i - PCH_START]) || s[*i - PCH_START] == ',') &&
	   s[*i - PCH_START] != '\0')
      (*i)++;
  }
  if (P_inset(s[*i - PCH_START], order_mark)) {
    if (s[*i - PCH_START] != '|')
      set_order(&ordered, &reverse, &s[*i - PCH_START]);
    skip_one_end_mark_in_pch(s, full, i);
  }
  if (s[*i - PCH_START] != '\0' && s[*i - PCH_START] != ';' &&
      s[*i - PCH_START] != '/') {
    do {
      pch_to_vertex_set_sep(s, full, i, a);
      if (s[*i - PCH_START] == '.' && *p == NULL && P_setequal(a, empty_set))
	return_main_effects_in_set_list(full, p);
      else
	insert_set_in_set_list(a, p);
      if ((s[*i - PCH_START] != '>') & P_inset(s[*i - PCH_START], end_set) &
	  P_inset(s[*i - PCH_START], end_gc))
	skip_one_end_mark_in_pch(s, full, i);
      else if ((s[*i - PCH_START] != '>') & P_inset(s[*i - PCH_START], end_set))
      {   /* s[i] = '.' */
	/* i := i + 1 */
	skip_one_end_mark_in_pch(s, full, i);
      }
      if (P_inset(s[*i - PCH_START], order_mark)) {
	set_order(&ordered, &reverse, &s[*i - PCH_START]);
	skip_one_end_mark_in_pch(s, full, i);
      }
    } while (!(P_inset(s[*i - PCH_START], end_mark_plus) ||
	       s[*i - PCH_START] == '\0'));
  }
  if (reverse)
    revers_set_list(p);
}  /* pch_to_ordered_set_list_sep */


Static Void pch_to_ordered_set_list(s, i, full, p)
Char *s;
t_integer *i;
boolean *full;
t_set_list **p;
{
  /*$ifdef TRACE*/
  ntr(" PchOrderedToSetList", 20L, 736L, 1L, 1L, *i);
  /*$endif TRACE*/
  pch_to_ordered_set_list_sep(s, full, i, p);
}  /* pch_ordered_to_set_list */


Static Void pch_to_gc_list(s, i, full, p, end_of_command, options)
Char *s;
t_integer *i;
boolean *full;
t_g_c_list **p;
boolean *end_of_command, *options;
{
  t_set_list *set_list;
  Char d;

  *p = NULL;
  do {
    pch_to_set_list_sep(s, full, i, &set_list);
    insert_g_c_in_g_c_list(set_list, p);
    *end_of_command = (s[*i - PCH_START] == ';' || s[*i - PCH_START] == '\0');
    if (P_inset(s[*i - PCH_START], end_gc) & P_inset(s[*i - PCH_START],
						     end_gc_list)) {
      d = s[*i - PCH_START];
      skip_one_end_mark_in_pch(s, full, i);
      if (!*end_of_command)
	*end_of_command = (s[*i - PCH_START] == ';' ||
			   s[*i - PCH_START] == '\0');
      if (d != '/' && s[*i - PCH_START] == '/')
	skip_one_end_mark_in_pch(s, full, i);
    } else if (P_inset(s[*i - PCH_START], end_gc))
      (*i)++;
  } while (!(P_inset(s[*i - PCH_START], end_mark) ||
	     s[*i - PCH_START] == '\0'));
  *options = (s[*i - PCH_START] == '/');
}  /* pch_to_gc_list */


/*@+"get.p"*/


/*

  740:    +++  ++
  741:    +++  ++
  742:    ---  -- p/get.p         31     135    1745 p/get.p
  743: |    4:    procedure set_ifail
  744: |   10:    function ok_arg
  745: |   33:    function ok_int_arg
  746: |   48:    function ok_double_arg
  747: |   63:    function ok_char_arg
  748: |   78:    procedure get_option_list
  749: |   96:    procedure get_one_integer
  750: |  118:    procedure get_next_integer
  751: |  143:    procedure get_next_level
  752: |  201:    procedure get_one_long_real
  753: |  223:    procedure get_next_long_real
  754: |  248:    procedure put_one_integer
  755: |  257:    procedure put_one_long_real
  756: |  266:    function get_file_name
  757: |  287:    procedure set_string_end
  758: |  301:    procedure set_long_end
  759: |  315:    procedure set_real_end
  760: |  329:    function get_vertex
  761: |  377:    function get_vertex_list_sep
  762: |  421:    function get_vertex_list
  763: |  461:    function get_vertex_set
  764: |  502:    function get_vertex_set_list
  765: |  544:    procedure list_of_lists_to_list_of_sets
  766: |  563:    function gc_ok
  767: |  579:    function sub_get_gc
  768: |  630:    function get_gc
  769: |  648:    function get_ordered_gc
  770: |  717:    function sub_get_gc_list
  771: |  779:    function get_gc_list
  772: |  799:    procedure get_two_vertices_and_set_list
  773: |  861:    procedure sub_code_to_model
  774:    +++  ++
  775:    +++  ++

*/

Static Void set_ifail(ifail, error)
t_integer *ifail, error;
{
  *ifail = error;
}  /* set_ifail */


Static boolean ok_arg(ifail, size, request)
t_integer *ifail, size, request;
{
  boolean ok;

/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  if (size < request) {
    /*$ifdef TRACE*/
    ntr(" OkArg, size < rqst.", 20L, 744L, 1L, size, request);
    /*$endif TRACE*/
    set_ifail(ifail, 70L);
    return false;
  }
  if (size > request) {
    /*$ifdef TRACE*/
    ntr(" OkArg, size > rqst.", 20L, 744L, 1L, size, request);
    /*$endif TRACE*/
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  }
  return true;
}  /* ok_arg */


Static boolean ok_int_arg(ifail, arg_pos, request, nargs, arg_int)
t_integer *ifail, arg_pos, request;
long **nargs, **arg_int;
{
  boolean ok = false;

  if (*nargs == NULL || *arg_int == NULL)
    set_ifail(ifail, 60L);
  else
    ok = ok_arg(ifail, (*nargs)[arg_pos], request);
  return ok;
}  /* ok_int_arg */


Static boolean ok_double_arg(ifail, arg_pos, request, nargs, arg_double)
t_integer *ifail, arg_pos, request;
long **nargs;
double **arg_double;
{
  boolean ok = false;

  if (*nargs == NULL || *arg_double == NULL)
    set_ifail(ifail, 60L);
  else
    ok = ok_arg(ifail, (*nargs)[arg_pos], request);
  return ok;
}  /* ok_double_arg */


Static boolean ok_char_arg(ifail, arg_pos, request, nargs, arg_char)
t_integer *ifail, arg_pos, request;
long **nargs;
Char **arg_char;
{
  boolean ok = false;

  if (*nargs == NULL || *arg_char == NULL)
    set_ifail(ifail, 60L);
  else
    ok = ok_arg(ifail, (*nargs)[arg_pos], request);
  return ok;
}  /* ok_char_arg */


Static Void get_option_list(command_file, as_argument, sep)
FILE *command_file;
boolean as_argument;
Char *sep;
{
  if (as_argument)
    return;
  *sep = '@';
  if (eoln_command(command_file)) {
    *sep = ' ';
    return;
  }
  read_char(command_file, sep);
  if (*sep != '-')
    return;
  while ((*sep != '/' && *sep != ';') & (!eoln_command(command_file)))
    read_char(command_file, sep);
  *sep = ' ';
}  /* get_option_list */


Static Void get_one_integer(command_file, as_argument, ifail, sub_code,
			    arg_pos, nargs, arg_int, promb, w, x)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
Char *promb;
t_integer w;
t_long_integer *x;
{
  if (!as_argument) {
    read_integer(command_file, promb, w, x);
    return;
  }
  if (!ok_int_arg(ifail, arg_pos, 1L, nargs, arg_int))
    return;
  if (*sub_code == -1)
    (*arg_int)[0] = *x;
  else
    *x = (*arg_int)[0];
}  /* get_one_integer */


Static Void get_next_integer(command_file, as_argument, i, ifail, sub_code,
			     arg_pos, nargs, arg_int, promb, w, x)
FILE *command_file;
boolean as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
Char *promb;
t_integer w;
t_long_integer *x;
{
  if (as_argument) {
    if (ok_int_arg(ifail, arg_pos, *i + 1, nargs, arg_int)) {
      if (*sub_code == -1)
	(*arg_int)[*i] = *x;
      else
	*x = (*arg_int)[*i];
    } else if (*sub_code == -1)
      (*arg_int)[(*nargs)[arg_pos] - 1] = _INFINITY_SHORT;   /* range check */
  } else
    read_integer(command_file, promb, w, x);
  (*i)++;
}  /* get_next_integer */


Static Void get_next_level(command_file, f, command_, keyboard, full,
			   as_argument, i, ifail, sub_code, arg_pos, nargs,
			   arg_int, promb, w, x, sep, max_level, v)
FILE *command_file, *f;
boolean command_, keyboard, full, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
Char *promb;
t_integer w;
t_long_integer *x;
Char *sep;
t_level max_level;
t_vertex v;
{
  boolean eod = false;

  do {
    if (as_argument) {
      if (ok_int_arg(ifail, arg_pos, *i + 1, nargs, arg_int)) {
	if (*sub_code == -1)
	  (*arg_int)[*i] = *x;
	else
	  *x = (*arg_int)[*i];
      } else if (*sub_code == -1)
	(*arg_int)[(*nargs)[arg_pos]] = _INFINITY_SHORT;   /* range check */
    } else {
      read_integer_separator(command_file, command_, keyboard, false, promb,
			     w, x, sep);
      if (*x == MISSING)
	*x = MISSING_LEVEL;
      else if (*x == _UNDEF)
	*x = _UNDEF_LEVEL;
      else if ((unsigned long)(*x) > max_level)
	*x = _INVALID_LEVEL;
    }
    (*i)++;
    if (*x == _UNDEF_LEVEL || *x == _INVALID_LEVEL ||
	*x != MISSING_LEVEL && *x > max_level) {
      write_pch(f, promb, w - 2);
      write_char(f, '(');
      if (full)
	print_full_vertex_on_file(f, v, 0L);
      else
	print_vertex_on_file(f, v, 0L);
      write_pch(f, ")-> ", 4L);
      write_pch(f, " Invalid  ", 10L);
      write_line(f);
    }
    if (!as_argument)
      eod = eof_command(command_file);
  } while (!((*x != _UNDEF_LEVEL && *x != _INVALID_LEVEL &&
	      (*x == MISSING_LEVEL || *x <= max_level)) || eod ||
	     *ifail != 0));
      /* get_next_level */
}


Static Void get_one_long_real(command_file, as_argument, ifail, sub_code,
			      arg_pos, nargs, arg_double, promb, w, x)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
Char *promb;
t_integer w;
t_long_real *x;
{
  if (!as_argument) {
    read_real(command_file, promb, w, x);
    return;
  }
  if (!ok_double_arg(ifail, arg_pos, 1L, nargs, arg_double))
    return;
  if (*sub_code == -1)
    (*arg_double)[0] = *x;
  else
    *x = (*arg_double)[0];
}  /* get_one_long_real */


Static Void get_next_long_real(command_file, as_argument, i, ifail, sub_code,
			       arg_pos, nargs, arg_double, promb, w, x)
FILE *command_file;
boolean as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
Char *promb;
t_integer w;
t_long_real *x;
{
  if (as_argument) {
    if (ok_double_arg(ifail, arg_pos, *i + 1, nargs, arg_double)) {
      if (*sub_code == -1)
	(*arg_double)[*i] = *x;
      else
	*x = (*arg_double)[*i];
    } else if (*sub_code == -1)
      (*arg_double)[(*nargs)[arg_pos] - 1] = _INVALID_REAL;
  } else
    read_real(command_file, promb, w, x);
  (*i)++;
}  /* get_next_long_real */


Static Void put_one_integer(arg_int, j, stop, x)
long **arg_int;
t_integer *j, *stop;
t_long_integer *x;
{
  if (*j < *stop - 1)
    (*arg_int)[*j] = *x;
  (*j)++;
}  /* put_one_integer */


Static Void put_one_long_real(arg_double, j, stop, x)
double **arg_double;
t_integer *j, *stop;
t_long_real *x;
{
  if (*j < *stop - 1)
    (*arg_double)[*j] = *x;
  (*j)++;
}  /* put_one_long_real */


Static boolean get_file_name(command_file, as_argument, ifail, sub_code,
			     arg_pos, nargs, arg_char, old_name, new_name)
FILE *command_file;
boolean as_argument;
t_integer *ifail, sub_code, arg_pos;
long **nargs;
Char **arg_char, *old_name, *new_name;
{
  if (as_argument) {
    if (!ok_char_arg(ifail, arg_pos, 0L, nargs, arg_char))
      return (sub_code != -1 && *ifail == 0);
    if (sub_code == -1)
      copy_string(old_name, *arg_char, (*nargs)[arg_pos], ifail);
    else
      copy_string(*arg_char, new_name, (*nargs)[arg_pos], ifail);
    return (sub_code != -1 && *ifail == 0);
  } else {
    read_file_name(command_file, new_name);
    return true;
  }
}  /* get_file_name */


Static Void set_string_end(i, ifail, arg_pos, nargs, arg_char)
t_integer *i, *ifail, arg_pos;
long **nargs;
Char **arg_char;
{
  /* 'i' is the next position to set, nargs^[arg_pos] is
     one more than the number of characters to return. */
  if (*i < PCH_START + (*nargs)[arg_pos])
    (*arg_char)[*i - 1] = '\0';
  else {
    set_ifail(ifail, 70L);
    (*arg_char)[(*nargs)[arg_pos] - 1] = '\0';
  }
  (*nargs)[arg_pos] = *i - PCH_START + 1;
}  /* set_string_end */


Static Void set_long_end(i, ifail, arg_pos, nargs, arg_int)
t_integer *i, *ifail, arg_pos;
long **nargs, **arg_int;
{
  /* 'i' is the next position to set, nargs^[arg_pos] is
     one more than the number of integers to return. */
  if (*i < (*nargs)[arg_pos])
    (*arg_int)[*i] = _INFINITY_SHORT;   /* range check */
  else {
    set_ifail(ifail, 70L);
    if ((*nargs)[arg_pos] > 1)
      (*arg_int)[(*nargs)[arg_pos] - 1] = _INFINITY_SHORT;   /* range check */
  }
  (*nargs)[arg_pos] = *i + 1;
}  /* set_long_end */


Static Void set_real_end(i, ifail, arg_pos, nargs, arg_double)
t_integer *i, *ifail, arg_pos;
long **nargs;
double **arg_double;
{
  if (*i < (*nargs)[arg_pos])
    (*arg_double)[*i] = _INVALID_REAL;
  else {
    set_ifail(ifail, 70L);
    if ((*nargs)[arg_pos] > 1)
      (*arg_double)[(*nargs)[arg_pos] - 1] = _INVALID_REAL;
  }
  (*nargs)[arg_pos] = *i + 1;
}  /* set_real_end */


Static boolean get_vertex(command_file, arg_command, arg_keyboard, arg_full,
			  as_argument, i, ifail, sub_code, arg_pos, nargs,
			  arg_char, promb_, w, old_vertex, new_vertex)
FILE *command_file;
boolean arg_command, arg_keyboard, arg_full, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
Char *promb_;
t_integer w;
t_vertex *old_vertex, *new_vertex;
{
  boolean Result;
  pch10 promb;
  boolean command_, keyboard, full, ok;

  memcpy(promb, promb_, sizeof(pch10));
  command_ = arg_command;
  keyboard = arg_keyboard;
  full = arg_full;
  if (as_argument) {
    if (ok_char_arg(ifail, arg_pos, 0L, nargs, arg_char)) {
      if (*sub_code == -1) {
	if (long_names) {
	  insert_long_vertex_name_in_pch(old_vertex, &full, *arg_char, i,
					 &(*nargs)[arg_pos]);
	  set_string_end(i, ifail, arg_pos, nargs, arg_char);
	} else {
	  if (*i <= (*nargs)[arg_pos])
	    (*arg_char)[*i - PCH_START] =
	      variable_description[*old_vertex - MIN_VERTEX]->name;
	  (*i)++;
	}
	(*nargs)[arg_pos] = *i - 1;
      } else
	pch_to_vertex(*arg_char, &full, i, new_vertex, &ok);
    }
    Result = (*sub_code != -1 && *ifail == 0);
  } else {
    read_promb_vertex(command_file, &command_, &keyboard, &full, promb, &w,
		      new_vertex);
    Result = true;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_vertex(" GetVertex          ", 20L, 760L, 8L, 0L, *ifail, new_vertex);
  return Result;
}  /* get_vertex */


Static boolean get_vertex_list_sep(command_file, command_, keyboard, arg_full,
  as_argument, sep, i, ifail, sub_code, arg_pos, nargs, arg_char,
  old_vertex_list, new_vertex_list)
FILE *command_file;
boolean command_, keyboard, arg_full, as_argument;
Char *sep;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
t_vertex_list **old_vertex_list, **new_vertex_list;
{
  /* promb: pch10;
     w: t_integer; */
  boolean Result, full;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GetVertexListSep   ", sizeof(pch20));
  ntr(tzt, 20L, 761L, 1L, 0L, *ifail);
  /*$endif TRACE*/
  full = arg_full;
  if (as_argument) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 761L, 1L, *i, (*nargs)[arg_pos]);
    /*$endif TRACE*/
    if (ok_char_arg(ifail, arg_pos, 0L, nargs, arg_char)) {
      if (*sub_code == -1) {
	return_vertex_list_in_pch(*old_vertex_list, &full, *arg_char, i,
				  &(*nargs)[arg_pos]);
	set_string_end(i, ifail, arg_pos, nargs, arg_char);
      } else
	pch_to_vertex_list(*arg_char, &full, i, new_vertex_list);
    }
    *sep = (*arg_char)[*i - PCH_START];
    Result = (*sub_code != -1 && *ifail == 0);
  } else {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 761L, 1L, -1L, 2L);
    /*$endif TRACE*/
    read_sep_vertex_list(command_file, command_, keyboard, full,
			 new_vertex_list, sep);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 761L, 1L, -1L, 3L);
    /*$endif TRACE*/
    Result = true;
  }
  /*$ifdef TRACE*/
  ntr_vertex_list(tzt, 20L, 761L, 8L, 0L, *ifail, new_vertex_list);
  /*$endif TRACE*/
  ntr_char(tzt, 20L, 761L, 8L, 0L, *ifail, *sep);
  return Result;
}  /* get_vertex_list_sep */


Static boolean get_vertex_list(command_file, command_, keyboard, arg_full,
  as_argument, i, ifail, sub_code, arg_pos, nargs, arg_char, promb, w,
  old_vertex_list, new_vertex_list)
FILE *command_file;
boolean command_, keyboard, arg_full, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
Char *promb;
t_integer w;
t_vertex_list **old_vertex_list, **new_vertex_list;
{
  boolean Result, full = arg_full;

  if (as_argument) {
    if (ok_char_arg(ifail, arg_pos, 0L, nargs, arg_char)) {
      if (*sub_code == -1) {
	return_vertex_list_in_pch(*old_vertex_list, &full, *arg_char, i,
				  &(*nargs)[arg_pos]);
	set_string_end(i, ifail, arg_pos, nargs, arg_char);
      } else
	pch_to_vertex_list(*arg_char, &full, i, new_vertex_list);
    }
    Result = (*sub_code != -1 && *ifail == 0);
  } else {
    read_promb_vertex_list(command_file, command_, keyboard, full, promb, w,
			   new_vertex_list);
    Result = true;
  }
  /*$ifdef TRACE*/
  ntr_vertex_list(" GetVertexList      ", 20L, 762L, 8L, 0L, *ifail,
		  new_vertex_list);
  /*$endif TRACE*/
  return Result;
}  /* get_vertex_list */


Static boolean get_vertex_set(command_file, arg_command, arg_keyboard,
  arg_full, as_argument, i, ifail, sub_code, arg_pos, nargs, arg_char, promb_,
  w, old_set, new_set)
FILE *command_file;
boolean arg_command, arg_keyboard, arg_full, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
Char *promb_;
t_integer w;
long *old_set, *new_set;
{
  boolean Result;
  pch10 promb;
  boolean command_, keyboard, full;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  memcpy(promb, promb_, sizeof(pch10));
  /*$ifdef TRACE*/
  memcpy(tzt, " GetVertexSet       ", sizeof(pch20));
  ntr(tzt, 20L, 763L, 1L, *i, *ifail);
  ntr(tzt, 20L, 763L, 1L, *sub_code, arg_pos);
  /*$endif TRACE*/
  command_ = arg_command;
  keyboard = arg_keyboard;
  full = arg_full;
  if (as_argument) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 763L, 1L, -1L, -1L);
    /*$endif TRACE*/
    if (ok_char_arg(ifail, arg_pos, 0L, nargs, arg_char)) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 763L, 1L, -2L, -1L);
      /*$endif TRACE*/
      if (*sub_code == -1) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 763L, 1L, -3L, -1L);
	/*$endif TRACE*/
	return_vertex_set_in_pch(old_set, &full, *arg_char, i,
				 &(*nargs)[arg_pos]);
	set_string_end(i, ifail, arg_pos, nargs, arg_char);
      } else
	pch_to_vertex_set(*arg_char, &full, new_set);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 763L, 1L, -2L, -2L);
      /*$endif TRACE*/
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 763L, 1L, -3L, -3L);
    /*$endif TRACE*/
    Result = (*sub_code != -1 && *ifail == 0);
  } else {
    read_promb_set_of_vertexes(command_file, &command_, &keyboard, &full,
			       promb, &w, new_set);
    Result = true;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_set(tzt, 20L, 763L, 8L, 0L, *ifail, new_set);
  return Result;
}  /* get_vertex_set */


Static boolean get_vertex_set_list(command_file, arg_command, arg_keyboard,
  arg_full, as_argument, i, ifail, sub_code, arg_pos, nargs, arg_char, promb_,
  w, old_set_list, new_set_list)
FILE *command_file;
boolean arg_command, arg_keyboard, arg_full, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
Char *promb_;
t_integer w;
t_set_list **old_set_list, **new_set_list;
{
  boolean Result;
  pch10 promb;
  boolean command_, keyboard, full;

  memcpy(promb, promb_, sizeof(pch10));
  command_ = arg_command;
  keyboard = arg_keyboard;
  full = arg_full;
  if (as_argument) {
    if (ok_char_arg(ifail, arg_pos, 0L, nargs, arg_char)) {
      if (*sub_code == -1) {
	return_g_c_in_pch(*old_set_list, &full, *arg_char, i,
			  &(*nargs)[arg_pos]);
	set_string_end(i, ifail, arg_pos, nargs, arg_char);
      } else
	pch_to_set_list_sep(*arg_char, &full, i, new_set_list);
    }
    Result = (*sub_code != -1 && *ifail == 0);
  } else {
    read_promb_set_list(command_file, &command_, &keyboard, &full, promb, &w,
			new_set_list);
    Result = true;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_g_c(" GetVertexSetList   ", 20L, 764L, 8L, 0L, *ifail, new_set_list);
  return Result;
}  /* get_vertex_set_list */


Static Void list_of_lists_to_list_of_sets(link_list_of_lists, link_set_list)
t_list_of_vertex_lists *link_list_of_lists;
t_set_list **link_set_list;
{
  t_vertex_list *p_vertex;

  *link_set_list = NULL;
  while (link_list_of_lists != NULL) {
    insert_set_in_set_list(empty_set, link_set_list);
    p_vertex = link_list_of_lists->vertex_list;
    while (p_vertex != NULL) {
      P_addset((*link_set_list)->vertex_set, p_vertex->vertex);
      p_vertex = p_vertex->pointer;
    }
    link_list_of_lists = link_list_of_lists->pointer;
  }
}  /* list_of_lists_to_list_of_sets */


Static boolean gc_ok(set_list)
t_set_list **set_list;
{
  if (echo)
    write_line(stdout);
  if (!test_hierarchical(*set_list)) {
    write_pch(stdout, " Read: ", 7L);
    print_g_c(*set_list, 1L, line_length);
    dispose_set_list(set_list);
    write_line(stdout);
    write_pch(stdout, " Set of sets is not a generating class.", 39L);
    write_line(stdout);
    return false;
  } else
    return true;
}  /* gc_ok */


Static boolean sub_get_gc(command_file, command_, keyboard, arg_full,
			  as_argument, i, ifail, sub_code, arg_pos, nargs,
			  arg_char, old_set_list, new_set_list,
			  end_of_command)
FILE *command_file;
boolean command_, keyboard, arg_full, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
t_set_list **old_set_list, **new_set_list;
boolean *end_of_command;
{
  /* promb    : pch10;
     w    : t_integer; */
  boolean Result, ok, full = arg_full;
  t_list_of_vertex_lists *p;
  Char c;

  if (as_argument) {
    if (ok_char_arg(ifail, arg_pos, 0L, nargs, arg_char)) {
      if (*sub_code == -1) {
	return_g_c_in_pch(*old_set_list, &full, *arg_char, i,
			  &(*nargs)[arg_pos]);
	set_string_end(i, ifail, arg_pos, nargs, arg_char);
      } else
	pch_to_set_list_sep(*arg_char, &full, i, new_set_list);
    }
    ok = (*sub_code != -1 && *ifail == 0);
  } else {
    c = ' ';
    read_sep_list_of_vertex_lists(command_file, command_, keyboard, full, &p,
				  &c);
    *end_of_command = (c == ';');
    if ((P_inset(c, end_mark_plus) && c != ';' && c != '/') &
	(!eolnorf(command_file)))
      read_character(command_file, command_, keyboard, &c);
    list_of_lists_to_list_of_sets(p, new_set_list);
    dispose_list_of_vertex_lists(&p);
    ok = true;
  }
  if (ok)
    Result = gc_ok(new_set_list);
  else {
    Result = false;
    /*$ifdef TRACE*/
  }
  /*$endif TRACE*/
  ntr_g_c(" SubGetGC           ", 20L, 767L, 8L, 0L, *ifail, new_set_list);
  return Result;
}  /* sub_get_gc */


Static boolean get_gc(command_file, command_, keyboard, arg_full, as_argument,
		      i, ifail, sub_code, arg_pos, nargs, arg_char,
		      old_set_list, new_set_list)
FILE *command_file;
boolean command_, keyboard, arg_full, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
t_set_list **old_set_list, **new_set_list;
{
  /* promb: pch10;
     w: t_integer; */
  boolean eoc;

  return (sub_get_gc(command_file, command_, keyboard, arg_full, as_argument,
		     i, ifail, sub_code, arg_pos, nargs, arg_char,
		     old_set_list, new_set_list, &eoc));
  /* promb, w, */
}  /* get_gc */


Static boolean get_ordered_gc(command_file, command_, keyboard, arg_full,
			      as_argument, i, ifail, sub_code, arg_pos, nargs,
			      arg_char, options, old_set_list, new_set_list)
FILE *command_file;
boolean command_, keyboard, arg_full, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
boolean *options;
t_set_list **old_set_list, **new_set_list;
{
  /* promb: pch10;
     w: t_integer; */
  boolean Result, ok, full;
  Char c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GetOrderedGc - A   ", sizeof(pch20));
  ntr(tzt, 20L, 769L, 1L, *i, *ifail);
  /*$endif TRACE*/
  full = arg_full;
  if (as_argument) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 769L, 2L, *i, *ifail);
    /*$endif TRACE*/
    if (ok_char_arg(ifail, arg_pos, 0L, nargs, arg_char)) {
      if (*sub_code == -1) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 769L, 3L, *i, *ifail);
	/*$endif TRACE*/
	return_g_c_in_pch(*old_set_list, &full, *arg_char, i,
			  &(*nargs)[arg_pos]);
	    /* Note order !!!! */
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 769L, 4L, *i, *ifail);
	/*$endif TRACE*/
	/*$ifdef TRACE*/
	set_string_end(i, ifail, arg_pos, nargs, arg_char);
	ntr(tzt, 20L, 769L, 5L, *i, *ifail);
	/*$endif TRACE*/
      } else {
	pch_to_ordered_set_list(*arg_char, i, &full, new_set_list);
	*options = false;
      }
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 769L, 6L, 1L, *ifail);
    /*$endif TRACE*/
    ok = (*sub_code != -1 && *ifail == 0);
  } else {
    c = ' ';
    read_sep_ordered_set_list(command_file, command_, keyboard, full,
			      new_set_list, &c);
    *options = (c == '/');
    ok = true;
  }
  if (ok)
    Result = gc_ok(new_set_list);
  else
    Result = false;
  /*$ifdef TRACE*/
  if (*options)
    ntr_g_c(tzt, 20L, 769L, 8L, 1L, *ifail, new_set_list);
  else
    ntr_g_c(tzt, 20L, 769L, 8L, 0L, *ifail, new_set_list);
  /*$endif TRACE*/
  return Result;
}  /* get_ordered_gc */


/* Local variables for sub_get_gc_list: */
struct LOC_sub_get_gc_list {
  boolean skip_eoln;
} ;


Static boolean sub_get_gc_list(command_file, arg_command, arg_keyboard,
  arg_full, skip_eoln_, as_argument, i, ifail, sub_code, arg_pos, nargs,
  arg_char, old_gc_list, new_gc_list, end_of_command, options)
FILE *command_file;
boolean arg_command, arg_keyboard, arg_full, skip_eoln_, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
t_g_c_list **old_gc_list, **new_gc_list;
boolean *end_of_command, *options;
{
  /* promb      : pch10;
     w      : t_integer; */
  struct LOC_sub_get_gc_list Local_Var;
  boolean Result, command_, keyboard, full;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.skip_eoln = skip_eoln_;
  /*$ifdef TRACE*/
  memcpy(tzt, " SubGetGcList       ", sizeof(pch20));
  ntr(tzt, 20L, 770L, 1L, *i, *ifail);
  /*$endif TRACE*/
  command_ = arg_command;
  keyboard = arg_keyboard;
  full = arg_full;
  if (as_argument) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 770L, 2L, *i, *ifail);
    /*$endif TRACE*/
    if (ok_char_arg(ifail, arg_pos, 0L, nargs, arg_char)) {
      if (*sub_code == -1) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 770L, 3L, *i, *ifail);
	/*$endif TRACE*/
	return_g_c_list_in_pch(*old_gc_list, &full, *arg_char, i,
			       &(*nargs)[arg_pos]);
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 770L, 4L, *i, *ifail);
	/*$endif TRACE*/
	/*$ifdef TRACE*/
	set_string_end(i, ifail, arg_pos, nargs, arg_char);
	ntr(tzt, 20L, 770L, 5L, *i, *ifail);
	/*$endif TRACE*/
      } else
	pch_to_gc_list(*arg_char, i, &full, new_gc_list, end_of_command,
		       options);
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 770L, 1L, 6L, *ifail);
    /*$endif TRACE*/
    Result = (*sub_code != -1 && *ifail == 0);
  } else {
    read_g_c_list(command_file, &command_, &keyboard, &full,
		  &Local_Var.skip_eoln, new_gc_list, end_of_command, options);
    Result = true;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_g_c_list(tzt, 20L, 770L, 8L, 1L, *ifail, *new_gc_list);
  return Result;
}  /* sub_get_gc_list */


Static boolean get_gc_list(command_file, arg_command, arg_keyboard, arg_full,
			   as_argument, i, ifail, sub_code, arg_pos, nargs,
			   arg_char, old_gc_list, new_gc_list)
FILE *command_file;
boolean arg_command, arg_keyboard, arg_full, as_argument;
t_integer *i, *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
t_g_c_list **old_gc_list, **new_gc_list;
{
  /* promb  : pch10;
     w  : t_integer; */
  boolean eoc;

  return (sub_get_gc_list(command_file, arg_command, arg_keyboard, arg_full,
			  true, as_argument, i, ifail, sub_code, arg_pos,
			  nargs, arg_char, old_gc_list, new_gc_list, &eoc,
			  &eoc));
      /* promb, w, */
}  /* get_gc_list */


Static Void get_two_vertices_and_set_list(command_file, as_argument,
  separated, ifail, sub_code, arg_pos_char, nargs, arg_char, v, w, gc)
FILE *command_file;
boolean as_argument, separated;
t_integer *ifail, *sub_code, arg_pos_char;
long **nargs;
Char **arg_char;
t_vertex *v, *w;
t_set_list **gc;
{
  t_integer i = PCH_START;
  Char sep;
  t_vertex_list *p;
  t_vertex_list *q = NULL;

  get_option_list(command_file, as_argument, &sep);
  i = PCH_START;
  get_vertex_list_sep(command_file, true, true, false, as_argument, &sep, &i,
		      ifail, sub_code, arg_pos_char, nargs, arg_char, &q, &q);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  /* ' Vertex->@', 9, */
  revers_vertex_list(&q);
  if (q == NULL || *ifail != 0) {
    set_ifail(ifail, 71L);
    return;
  }
  p = q;
  q = q->pointer;
  *v = p->vertex;
  _Free(p);
  if (q == NULL) {
    i++;
    sep = ' ';
    get_vertex_list_sep(command_file, true, true, false, as_argument, &sep,
			&i, ifail, sub_code, arg_pos_char, nargs, arg_char,
			&q, &q);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    /* ' Vertex->@', 9, */
    revers_vertex_list(&q);
  }
  if (q == NULL || *ifail != 0) {
    set_ifail(ifail, 71L);
    return;
  }
  p = q;
  q = q->pointer;
  *w = p->vertex;
  _Free(p);
  if (separated)
    dispose_vertex_list(&q);
  if (q == NULL) {
    *gc = NULL;
    i++;
    sep = ' ';
    get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			ifail, sub_code, arg_pos_char, nargs, arg_char,
			" GC->", 5L, gc, gc);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    return;
  }
  *gc = (t_set_list *)Malloc(sizeof(t_set_list));
  if (*gc == NULL)
    _OutMem();
  (*gc)->pointer = NULL;
  list_of_vertices_to_set(q, (*gc)->vertex_set);
}  /* get_two_vertices_and_set_list */


Static Void sub_code_to_model(ifail, sub_code, p)
t_integer *ifail, *sub_code;
t_model_list **p;
{
  *p = NULL;
  switch (*sub_code) {

  case -1:
    if (base_ifail(ifail))
      *p = link_base;
    break;

  case -2:
    if (current_ifail(ifail))
      *p = link_current;
    break;

  case -3:
    if (link_model_list != NULL)
      *p = link_model_list;
    break;
  }
}  /* sub_code_to_model */


/*@-"marginal.c"*/
/*@+"next.p"*/


Static Void fast_next_offset(offset_pack, offset, i)
t_fast_next_offset_pack *offset_pack;
t_long_integer *offset;
t_level *i;
{
  t_vertex v;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FastNextOffset     ", sizeof(pch20));
  /*$endif TRACE*/
  v = first_vertex;
  while (i[v - MIN_VERTEX] == offset_pack->levels[v - MIN_VERTEX]) {
    if (offset_pack->c_in_a[v - MIN_VERTEX])
      *offset -= offset_pack->decrements[v - MIN_VERTEX];
    i[v - MIN_VERTEX] = FIRST_LEVEL;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 779L, 1L, (long)i[v - MIN_VERTEX],
	offset_pack->levels[v - MIN_VERTEX]);
    ntr_vertex(tzt, 20L, 779L, 1L, (long)i[v - MIN_VERTEX], *offset, &v);
    /*$endif TRACE*/
    v++;
  }
  if (v > offset_pack->l)
    return;
  if (offset_pack->c_in_a[v - MIN_VERTEX])
    *offset += offset_pack->increments[v - MIN_VERTEX];
  i[v - MIN_VERTEX]++;
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_vertex(tzt, 20L, 779L, 1L, (long)i[v - MIN_VERTEX], *offset, &v);
}  /* fast_next_offset */


Static Void fast_find_products(a, c, offset_pack)
long *a, *c;
t_fast_next_offset_pack *offset_pack;
{
  t_cell_index product = 1;
  t_vertex v, w;

  w = first_vertex;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      if (P_inset(v, c)) {
	offset_pack->c_in_a[w - MIN_VERTEX] = true;
	offset_pack->increments[w - MIN_VERTEX] = product;
	product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
	offset_pack->decrements[w - MIN_VERTEX] =
	  product - offset_pack->increments[w - MIN_VERTEX];
      } else
	offset_pack->c_in_a[w - MIN_VERTEX] = false;
      offset_pack->levels[w - MIN_VERTEX] =
	FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1;
      w++;
    }
  }
  offset_pack->levels[w - MIN_VERTEX] = _INVALID_LEVEL;
  offset_pack->l = w - 1;
}  /* fast_find_products */


Static Void next_c_offset_in_a(c_in_a, offset, prod_1, prod_2, levels,
			       l_a_vertex, i)
long *c_in_a;
t_cell_index *offset;
long *prod_1, *prod_2, *levels;
t_vertex *l_a_vertex;
t_level *i;
{
  t_vertex v;

  v = first_vertex;
  while (i[v - MIN_VERTEX] == levels[v - MIN_VERTEX]) {
    if (P_inset(v, c_in_a))
      *offset -= prod_2[v - MIN_VERTEX];
    i[v - MIN_VERTEX] = FIRST_LEVEL;
    v++;
  }
  if (v > *l_a_vertex)
    return;
  if (P_inset(v, c_in_a))
    *offset += prod_1[v - MIN_VERTEX];
  i[v - MIN_VERTEX]++;
}  /* next_c_offset_in_a */


Static Void find_products(a, c, c_in_a, prod_1, prod_2, levels, l)
long *a, *c, *c_in_a;
long *prod_1, *prod_2, *levels;
t_vertex *l;
{
  t_cell_index product = 1;
  t_vertex v, w;

  w = first_vertex;
  P_setcpy(c_in_a, empty_set);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      if (P_inset(v, c)) {
	P_addset(c_in_a, w);
	prod_1[w - MIN_VERTEX] = product;
	product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
	prod_2[w - MIN_VERTEX] = product - prod_1[w - MIN_VERTEX];
      }
      levels[w - MIN_VERTEX] =
	FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1;
      w++;
    }
  }
  levels[w - MIN_VERTEX] = _INVALID_LEVEL;
  *l = w - 1;
}  /* find_products */


Static Void add_to_offsets(link_expression, link_ips_list, x)
t_expression *link_expression;
t_list_ips_elements *link_ips_list;
t_long_integer x;
{
  if (x == 0)
    return;
  while (link_expression != NULL) {
    link_expression->offset += x;
    link_expression = link_expression->pointer;
  }
  while (link_ips_list != NULL) {
    link_ips_list->ips_element.p_offset += x;
    link_ips_list = link_ips_list->pointer;
  }
}  /* add_to_offsets */


Static Void dispose_product_list(p)
t_product_list **p;
{
  t_product_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_product_list */


Static t_cell_index find_product(a, l)
long *a;
t_vertex *l;
{
  t_cell_index product = 1;
  t_vertex v;

  if (*l <= first_vertex)
    return product;
  for (v = first_vertex; v <= *l - 1; v++) {
    if (P_inset(v, a))
      product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
  }
  return product;
}  /* find_product */


Static Void find_slice_products(c, vc, wc, vwc, v, w, slice_pack)
long *c, *vc, *wc, *vwc;
t_vertex *v, *w;
t_slice_pack *slice_pack;
{
  t_cell_index product_v = 1, product_w = 1, product_vw = 1;
  t_vertex a, b;

  b = first_vertex;
  slice_pack->marginal_dimension_c = marginal_dimension(c);
  slice_pack->p_vc_v = find_product(vc, v);
  slice_pack->p_wc_w = find_product(wc, w);
  slice_pack->p_vwc_v = find_product(vwc, v);
  slice_pack->p_vwc_w = find_product(vwc, w);
  for (a = first_vertex; a <= last_vertex; a++) {
    if (P_inset(a, vwc)) {
      if (a != *w) {
	slice_pack->product_a_v[b - MIN_VERTEX] = product_v;
	product_v *= variable_description[a - MIN_VERTEX]->UU.U0.levels;
	slice_pack->product_b_v[b - MIN_VERTEX] =
	  product_v - slice_pack->product_a_v[b - MIN_VERTEX];
      }
      if (a != *v) {
	slice_pack->product_a_w[b - MIN_VERTEX] = product_w;
	product_w *= variable_description[a - MIN_VERTEX]->UU.U0.levels;
	slice_pack->product_b_w[b - MIN_VERTEX] =
	  product_w - slice_pack->product_a_w[b - MIN_VERTEX];
      }
      slice_pack->product_a_vw[b - MIN_VERTEX] = product_vw;
      product_vw *= variable_description[a - MIN_VERTEX]->UU.U0.levels;
      slice_pack->product_b_vw[b - MIN_VERTEX] =
	product_vw - slice_pack->product_a_vw[b - MIN_VERTEX];
      if (a != *v && a != *w) {
	slice_pack->levels[b - MIN_VERTEX] = FIRST_LEVEL +
	    variable_description[a - MIN_VERTEX]->UU.U0.levels - 1;
	b++;
      }
    }
  }
  slice_pack->levels[b - MIN_VERTEX] = _INVALID_LEVEL;
  slice_pack->l = b;
}  /* find_slice_products */


Static Void next_offset_in_slice(slice_pack, offset_v, offset_w, offset_vw, i)
t_slice_pack *slice_pack;
t_cell_index *offset_v, *offset_w, *offset_vw;
t_level *i;
{
  t_vertex v;

  v = first_vertex;
  while (i[v - MIN_VERTEX] == slice_pack->levels[v - MIN_VERTEX]) {
    *offset_v -= slice_pack->product_b_v[v - MIN_VERTEX];
    *offset_w -= slice_pack->product_b_w[v - MIN_VERTEX];
    *offset_vw -= slice_pack->product_b_vw[v - MIN_VERTEX];
    i[v - MIN_VERTEX] = FIRST_LEVEL;
    v++;
  }
  if (v >= slice_pack->l)
    return;
  *offset_v += slice_pack->product_a_v[v - MIN_VERTEX];
  *offset_w += slice_pack->product_a_w[v - MIN_VERTEX];
  *offset_vw += slice_pack->product_a_vw[v - MIN_VERTEX];
  i[v - MIN_VERTEX]++;
}  /* next_offset_in_slice */


/*@+"next1.p"*/


Static Void offset_down_in_expression_list(v, link_expression, p)
t_vertex *v;
t_expression *link_expression;
t_product_list **p;
{
  while (link_expression != NULL) {
    if (P_inset(*v, (*p)->c_in_a))
      link_expression->offset -= (*p)->prod_2[*v - MIN_VERTEX];
    *p = (*p)->pointer;
    link_expression = link_expression->pointer;
  }
}  /* offset_down_in_expression_list */


Static Void offset_down_in_ips_list(v, link_ips_list, p)
t_vertex *v;
t_list_ips_elements *link_ips_list;
t_product_list **p;
{
  while (link_ips_list != NULL) {
    if (P_inset(*v, (*p)->c_in_a))
      link_ips_list->ips_element.p_offset -= (*p)->prod_2[*v - MIN_VERTEX];
    *p = (*p)->pointer;
    link_ips_list = link_ips_list->pointer;
  }
}  /* offset_down_in_ips_list */


Static Void offset_up_in_expression_list(v, link_expression, p)
t_vertex *v;
t_expression *link_expression;
t_product_list **p;
{
  while (link_expression != NULL) {
    if (P_inset(*v, (*p)->c_in_a))
      link_expression->offset += (*p)->prod_1[*v - MIN_VERTEX];
    *p = (*p)->pointer;
    link_expression = link_expression->pointer;
  }
}  /* offset_up_in_expression_list */


Static Void offset_up_in_ips_list(v, link_ips_list, p)
t_vertex *v;
t_list_ips_elements *link_ips_list;
t_product_list **p;
{
  while (link_ips_list != NULL) {
    if (P_inset(*v, (*p)->c_in_a))
      link_ips_list->ips_element.p_offset += (*p)->prod_1[*v - MIN_VERTEX];
    *p = (*p)->pointer;
    link_ips_list = link_ips_list->pointer;
  }
}  /* offset_up_in_ips_list */


Static Void next_offset_in_exp_list(link_expression, link_ips_list,
				    link_prod_list, levels, l_a_vertex, i)
t_expression **link_expression;
t_list_ips_elements **link_ips_list;
t_product_list **link_prod_list;
long *levels;
t_vertex *l_a_vertex;
t_level *i;
{
  t_vertex v;
  t_product_list *p;

  v = first_vertex;
  while (i[v - MIN_VERTEX] == levels[v - MIN_VERTEX]) {
    p = *link_prod_list;
    offset_down_in_expression_list(&v, *link_expression, &p);
    offset_down_in_ips_list(&v, *link_ips_list, &p);
    i[v - MIN_VERTEX] = FIRST_LEVEL;
    v++;
  }
  if (v > *l_a_vertex)
    return;
  p = *link_prod_list;
  offset_up_in_expression_list(&v, *link_expression, &p);
  offset_up_in_ips_list(&v, *link_ips_list, &p);
  i[v - MIN_VERTEX]++;
}  /* next_offset_in_exp_list */


Static Void next_offset_in_exp_list_2(link_expression_1, link_ips_list_1,
  link_expression_2, link_ips_list_2, link_prod_list, levels, l_a_vertex, i)
t_expression **link_expression_1;
t_list_ips_elements **link_ips_list_1;
t_expression **link_expression_2;
t_list_ips_elements **link_ips_list_2;
t_product_list **link_prod_list;
long *levels;
t_vertex *l_a_vertex;
t_level *i;
{
  t_vertex v;
  t_product_list *p;

  v = first_vertex;
  while (i[v - MIN_VERTEX] == levels[v - MIN_VERTEX]) {
    p = *link_prod_list;
    offset_down_in_expression_list(&v, *link_expression_1, &p);
    offset_down_in_ips_list(&v, *link_ips_list_1, &p);
    offset_down_in_expression_list(&v, *link_expression_2, &p);
    offset_down_in_ips_list(&v, *link_ips_list_2, &p);
    i[v - MIN_VERTEX] = FIRST_LEVEL;
    v++;
  }
  if (v > *l_a_vertex)
    return;
  p = *link_prod_list;
  offset_up_in_expression_list(&v, *link_expression_1, &p);
  offset_up_in_ips_list(&v, *link_ips_list_1, &p);
  offset_up_in_expression_list(&v, *link_expression_2, &p);
  offset_up_in_ips_list(&v, *link_ips_list_2, &p);
  i[v - MIN_VERTEX]++;
}  /* next_offset_in_exp_list_2 */


Static Void insert_empty_product_element(link_prod_list)
t_product_list **link_prod_list;
{
  t_product_list *p;

  p = (t_product_list *)Malloc(sizeof(t_product_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->c_in_a, empty_set);
  p->product = 1;
  p->pointer = *link_prod_list;
  *link_prod_list = p;
}  /* insert_empty_product_element */


Static Void insert_empty_expression_product_element(link_expression,
						    link_prod_list)
t_expression *link_expression;
t_product_list **link_prod_list;
{
  while (link_expression != NULL) {
    insert_empty_product_element(link_prod_list);
    link_expression = link_expression->pointer;
  }
}  /* insert_empty_expression_product_element */


Static Void insert_empty_ips_product_element(link_ips_list, link_prod_list)
t_list_ips_elements *link_ips_list;
t_product_list **link_prod_list;
{
  while (link_ips_list != NULL) {
    insert_empty_product_element(link_prod_list);
    link_ips_list = link_ips_list->pointer;
  }
}  /* insert_empty_ips_product_element */


Static Void find_products_for_expression_list(v, w, link_expression,
					      link_prod_list)
t_vertex v, w;
t_expression *link_expression;
t_product_list **link_prod_list;
{
  t_product_list *WITH;

  while (link_expression != NULL) {
    if (P_inset(v, link_expression->vertex_set)) {
      WITH = *link_prod_list;
      P_addset(WITH->c_in_a, w);
      WITH->prod_1[w - MIN_VERTEX] = WITH->product;
      WITH->product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
      WITH->prod_2[w - MIN_VERTEX] = WITH->product - WITH->prod_1[w - MIN_VERTEX];
    }
    *link_prod_list = (*link_prod_list)->pointer;
    link_expression = link_expression->pointer;
  }
}  /* find_products_for_expression_list */


Static Void find_products_for_ips_list(v, w, link_ips_list, link_prod_list)
t_vertex v, w;
t_list_ips_elements *link_ips_list;
t_product_list **link_prod_list;
{
  t_product_list *WITH;

  while (link_ips_list != NULL) {
    if (P_inset(v, link_ips_list->ips_element.a)) {
      WITH = *link_prod_list;
      P_addset(WITH->c_in_a, w);
      WITH->prod_1[w - MIN_VERTEX] = WITH->product;
      WITH->product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
      WITH->prod_2[w - MIN_VERTEX] = WITH->product - WITH->prod_1[w - MIN_VERTEX];
    }
    *link_prod_list = (*link_prod_list)->pointer;
    link_ips_list = link_ips_list->pointer;
  }
}  /* find_products_for_ips_list */


Static Void find_product_list(a, link_expression, link_ips_list,
			      link_prod_list, levels, l)
long *a;
t_expression **link_expression;
t_list_ips_elements **link_ips_list;
t_product_list **link_prod_list;
long *levels;
t_vertex *l;
{
  t_vertex v, w;
  t_product_list *p;

  *link_prod_list = NULL;
  insert_empty_expression_product_element(*link_expression, link_prod_list);
  insert_empty_ips_product_element(*link_ips_list, link_prod_list);
  w = first_vertex;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      p = *link_prod_list;
      find_products_for_expression_list(v, w, *link_expression, &p);
      find_products_for_ips_list(v, w, *link_ips_list, &p);
      levels[w - MIN_VERTEX] =
	FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1;
      w++;
    }
  }
  levels[w - MIN_VERTEX] = _INVALID_LEVEL;
  *l = w - 1;
}  /* find_product_list */


Static Void find_product_list_2(a, link_1_expression, link_1_ips_list,
  link_2_expression, link_2_ips_list, link_prod_list, levels, l)
long *a;
t_expression **link_1_expression;
t_list_ips_elements **link_1_ips_list;
t_expression **link_2_expression;
t_list_ips_elements **link_2_ips_list;
t_product_list **link_prod_list;
long *levels;
t_vertex *l;
{
  t_vertex v, w;
  t_product_list *p;

  *link_prod_list = NULL;
  insert_empty_expression_product_element(*link_1_expression, link_prod_list);
  insert_empty_ips_product_element(*link_1_ips_list, link_prod_list);
  insert_empty_expression_product_element(*link_2_expression, link_prod_list);
  insert_empty_ips_product_element(*link_2_ips_list, link_prod_list);
  w = first_vertex;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      p = *link_prod_list;
      find_products_for_expression_list(v, w, *link_1_expression, &p);
      find_products_for_ips_list(v, w, *link_1_ips_list, &p);
      find_products_for_expression_list(v, w, *link_2_expression, &p);
      find_products_for_ips_list(v, w, *link_2_ips_list, &p);
      levels[w - MIN_VERTEX] =
	FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1;
      w++;
    }
  }
  levels[w - MIN_VERTEX] = _INVALID_LEVEL;
  *l = w - 1;
}  /* find_product_list_2 */


/*@+"tree23.p"*/


/*

  808:    +++  ++
  809:    +++  ++
  810:    ---  -- p/tree23.p         18      67    1063 p/tree23.p
  811: |    4:    procedure find_in_2_3_tree
  812: |   21:    procedure insert_leaf_in_2_3_tree
  813: |   70:    procedure sub_insert_in_2_3_tree
  814: |  181:    procedure insert_in_2_3_tree
  815: |  233:    procedure print_offset_list
  816: |  245:    procedure print_s_offset_list
  817: |  257:    procedure print_ss_offset_list
  818: |  269:    procedure print_t_offset_list
  819: |  281:    procedure print_r_offset_list
  820: |  293:    procedure visit_2_3_tree_preorder
  821: |  343:    procedure insert_test_in_2_3_tree
  822: |  361:    procedure insert_test
  823: |  372:    procedure find_test_in_2_3_tree
  824: |  403:    function offset_key
  825: |  426:    procedure insert_offset
  826: |  439:    procedure insert_offset_in_2_3_tree
  827: |  459:    procedure insert_offset_in_both
  828: |  468:    procedure find_offset_in_2_3_tree
  829:    +++  ++
  830:    +++  ++

*/


Static Void find_in_2_3_tree(node, x_key, result)
t_2_3_node **node;
t_2_3_key x_key;
t_2_3_leaf **result;
{
  if ((*node)->node_type == leaf) {
    if ((*node)->UU.leaf_->key == x_key)
      *result = (*node)->UU.leaf_;
    else
      *result = NULL;
    return;
  }
  if (x_key < (*node)->UU.U1.lowofsecond) {
    find_in_2_3_tree(&(*node)->UU.U1.firstchild, x_key, result);
    return;
  }
  if ((*node)->UU.U1.thirdchild == NULL || x_key < (*node)->UU.U1.lowofthird)
    find_in_2_3_tree(&(*node)->UU.U1.secondchild, x_key, result);
  else
    find_in_2_3_tree(&(*node)->UU.U1.thirdchild, x_key, result);
}  /* find_in_2_3_tree */


Static Void insert_leaf_in_2_3_tree(x, a)
t_2_3_element *x;
t_2_3_leaf **a;
{
  t_part_list *link_part;
  t_model_list *link_model;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertLeafIn-2-3-Tr", sizeof(pch20));
  /*$endif TRACE*/
  (*a)->count++;
  switch (x->tree_type) {

  case model_tree:
    /*$ifdef TRACE*/
    ntr_model_numbers(tzt, 20L, 812L, 1L, -1L, -1L,
		      &x->UU.model_element->model);
    ntr_model_g_c(tzt, 20L, 812L, 1L, -1L, -2L, &x->UU.model_element->model);
    /*$endif TRACE*/
    if (!boolean_option[70]) {
      link_model = (t_model_list *)Malloc(sizeof(t_model_list));
      if (link_model == NULL)
	_OutMem();
      link_model->model = x->UU.model_element->model;
      ntr(tzt, 20L, 812L, 1L, 1L, link_model->model->model_number);
      link_model->pointer = (*a)->UU.model_list;
      (*a)->UU.model_list = link_model;
    } else {
      x->UU.model_element->pointer = (*a)->UU.model_list;
      ntr(tzt, 20L, 812L, 1L, 1L, x->UU.model_element->model->model_number);
      (*a)->UU.model_list = x->UU.model_element;
    }
    break;

  case test_tree:
    link_part = (t_part_list *)Malloc(sizeof(t_part_list));
    if (link_part == NULL)
      _OutMem();
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 812L, 1L, 0L, 2L);
    /*$endif TRACE*/
    link_part->pointer = (*a)->UU.test_list;
    (*a)->UU.test_list = link_part;
    (*a)->UU.test_list->link_test_list = x->UU.test_element;
    break;

  case r_offset_tree:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 812L, 1L, 0L, 3L);
    /*$endif TRACE*/
    x->UU.r_offset_element->pointer = (*a)->UU.r_offset_list;
    (*a)->UU.r_offset_list = x->UU.r_offset_element;
    break;

  case s_offset_tree:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 812L, 1L, 0L, 4L);
    /*$endif TRACE*/
    x->UU.s_offset_element->pointer = (*a)->UU.s_offset_list;
    (*a)->UU.s_offset_list = x->UU.s_offset_element;
    break;

  case ss_offset_tree:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 812L, 1L, 0L, 5L);
    /*$endif TRACE*/
    x->UU.ss_offset_element->pointer = (*a)->UU.ss_offset_list;
    (*a)->UU.ss_offset_list = x->UU.ss_offset_element;
    break;

  case t_offset_tree:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 812L, 1L, 0L, 6L);
    /*$endif TRACE*/
    x->UU.t_offset_element->pointer = (*a)->UU.t_offset_list_;
    (*a)->UU.t_offset_list_ = x->UU.t_offset_element;
    break;

  case offset_tree:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 812L, 1L, 0L, 7L);
    /*$endif TRACE*/
    x->UU.offset_element->pointer = (*a)->UU.offset_list;
    (*a)->UU.offset_list = x->UU.offset_element;
    break;
  }
}  /* insert_leaf_in_2_3_tree */


Static Void sub_insert_in_2_3_tree(node, x_element, min, pnew, low)
t_2_3_node **node;
t_2_3_element *x_element;
boolean *min;
t_2_3_node **pnew;
t_2_3_key *low;
{
  t_2_3_node *pback, *w;
  char child;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubInsertIn-2-3Tree", sizeof(pch20));
  ntr(tzt, 20L, 813L, 1L, 0L, x_element->key);
  /*$endif TRACE*/
  *pnew = NULL;
  if ((*node)->node_type == leaf) {
    if ((*node)->UU.leaf_->key != x_element->key) {
      *pnew = (t_2_3_node *)Malloc(sizeof(t_2_3_node));
      if (*pnew == NULL)
	_OutMem();
      (*pnew)->node_type = leaf;
      (*pnew)->count = -10;
      (*pnew)->UU.leaf_ = (t_2_3_leaf *)Malloc(sizeof(t_2_3_leaf));
      if ((*pnew)->UU.leaf_ == NULL)
	_OutMem();
      (*pnew)->UU.leaf_->count = 0;
      (*pnew)->UU.leaf_->tree_type = x_element->tree_type;
      switch (x_element->tree_type) {

      case model_tree:
	(*pnew)->UU.leaf_->UU.model_list = NULL;
	break;

      case test_tree:
	(*pnew)->UU.leaf_->UU.test_list = NULL;
	break;

      case r_offset_tree:
	(*pnew)->UU.leaf_->UU.r_offset_list = NULL;
	break;

      case s_offset_tree:
	(*pnew)->UU.leaf_->UU.s_offset_list = NULL;
	break;

      case ss_offset_tree:
	(*pnew)->UU.leaf_->UU.ss_offset_list = NULL;
	break;

      case t_offset_tree:
	(*pnew)->UU.leaf_->UU.t_offset_list_ = NULL;
	break;

      case offset_tree:
	(*pnew)->UU.leaf_->UU.offset_list = NULL;
	break;
      }
      (*pnew)->UU.leaf_->key = x_element->key;
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 813L, 1L, 1L, (*pnew)->UU.leaf_->key);
      /*$endif TRACE*/
      insert_leaf_in_2_3_tree(x_element, &(*pnew)->UU.leaf_);
      *low = x_element->key;
      return;
    }
    (*node)->count--;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 813L, 1L, 2L, x_element->key);
    /*$endif TRACE*/
    insert_leaf_in_2_3_tree(x_element, &(*node)->UU.leaf_);
    return;
  }
  if (x_element->key < (*node)->UU.U1.lowofsecond) {
    child = 1;
    w = (*node)->UU.U1.firstchild;
  } else if ((*node)->UU.U1.thirdchild == NULL ||
	     x_element->key < (*node)->UU.U1.lowofthird) {
    *min = false;
    child = 2;
    w = (*node)->UU.U1.secondchild;
  } else {
    *min = false;
    child = 3;
    w = (*node)->UU.U1.thirdchild;
  }
  sub_insert_in_2_3_tree(&w, x_element, min, &pback, low);
  if (pback == NULL)
    return;
  if ((*node)->UU.U1.thirdchild == NULL) {
    if (child == 2) {
      (*node)->UU.U1.thirdchild = pback;
      (*node)->UU.U1.lowofthird = *low;
      return;
    }
    (*node)->UU.U1.thirdchild = (*node)->UU.U1.secondchild;
    (*node)->UU.U1.lowofthird = (*node)->UU.U1.lowofsecond;
    if (*min)
      *min = (pback->UU.leaf_->key < (*node)->UU.U1.firstchild->UU.leaf_->key);
    if (!*min) {
      (*node)->UU.U1.secondchild = pback;
      (*node)->UU.U1.lowofsecond = *low;
      return;
    }
    (*node)->UU.U1.secondchild = (*node)->UU.U1.firstchild;
    (*node)->UU.U1.lowofsecond = (*node)->UU.U1.firstchild->UU.leaf_->key;
    (*node)->UU.U1.firstchild = pback;
    *min = false;
    return;
  }
  *pnew = (t_2_3_node *)Malloc(sizeof(t_2_3_node));
  if (*pnew == NULL)
    _OutMem();
  (*pnew)->UU.U1.lowofsecond = -99;
  (*pnew)->UU.U1.lowofthird = -99;
  (*pnew)->node_type = interior;
  (*pnew)->count = -3;
  if (child == 3) {
    (*pnew)->UU.U1.firstchild = (*node)->UU.U1.thirdchild;
    (*pnew)->UU.U1.secondchild = pback;
    (*pnew)->UU.U1.thirdchild = NULL;
    (*pnew)->UU.U1.lowofsecond = *low;
    *low = (*node)->UU.U1.lowofthird;
    (*node)->UU.U1.thirdchild = NULL;
    return;
  }
  (*pnew)->UU.U1.secondchild = (*node)->UU.U1.thirdchild;
  (*pnew)->UU.U1.lowofsecond = (*node)->UU.U1.lowofthird;
  (*pnew)->UU.U1.thirdchild = NULL;
  (*node)->UU.U1.thirdchild = NULL;
  if (child == 2) {
    (*pnew)->UU.U1.firstchild = pback;
    return;
  }
  (*pnew)->UU.U1.firstchild = (*node)->UU.U1.secondchild;
  (*node)->UU.U1.lowofthird = *low;
  *low = (*node)->UU.U1.lowofsecond;
  if (*min)
    *min = (pback->UU.leaf_->key < (*node)->UU.U1.firstchild->UU.leaf_->key);
  if (!*min) {
    (*node)->UU.U1.secondchild = pback;
    (*node)->UU.U1.lowofsecond = (*node)->UU.U1.lowofthird;
    return;
  }
  (*node)->UU.U1.secondchild = (*node)->UU.U1.firstchild;
  (*node)->UU.U1.lowofsecond = (*node)->UU.U1.firstchild->UU.leaf_->key;
  (*node)->UU.U1.firstchild = pback;
  *min = false;
}  /* sub_insert_in_2_3_tree */


Static Void insert_in_2_3_tree(x_element, s)
t_2_3_element *x_element;
t_2_3_node **s;
{
  t_2_3_node *pback, *saves;
  t_2_3_key lowback;
  boolean min = true;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertIn-2-3-Tree  ", sizeof(pch20));
  ntr(tzt, 20L, 814L, 1L, 0L, x_element->key);
  /*$endif TRACE*/
  if (*s == NULL) {
    *s = (t_2_3_node *)Malloc(sizeof(t_2_3_node));
    if (*s == NULL)
      _OutMem();
    (*s)->node_type = leaf;
    (*s)->count = -2;
    (*s)->UU.leaf_ = (t_2_3_leaf *)Malloc(sizeof(t_2_3_leaf));
    if ((*s)->UU.leaf_ == NULL)
      _OutMem();
    (*s)->UU.leaf_->count = 0;
    (*s)->UU.leaf_->tree_type = x_element->tree_type;
    switch (x_element->tree_type) {

    case model_tree:
      (*s)->UU.leaf_->UU.model_list = NULL;
      break;

    case test_tree:
      (*s)->UU.leaf_->UU.test_list = NULL;
      break;

    case r_offset_tree:
      (*s)->UU.leaf_->UU.r_offset_list = NULL;
      break;

    case s_offset_tree:
      (*s)->UU.leaf_->UU.s_offset_list = NULL;
      break;

    case ss_offset_tree:
      (*s)->UU.leaf_->UU.ss_offset_list = NULL;
      break;

    case t_offset_tree:
      (*s)->UU.leaf_->UU.t_offset_list_ = NULL;
      break;

    case offset_tree:
      (*s)->UU.leaf_->UU.offset_list = NULL;
      break;
    }
    (*s)->UU.leaf_->key = x_element->key;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 814L, 1L, 1L, (*s)->UU.leaf_->key);
    /*$endif TRACE*/
    insert_leaf_in_2_3_tree(x_element, &(*s)->UU.leaf_);
    return;
  }
  sub_insert_in_2_3_tree(s, x_element, &min, &pback, &lowback);
  if (pback == NULL)
    return;
  saves = *s;
  *s = (t_2_3_node *)Malloc(sizeof(t_2_3_node));
  if (*s == NULL)
    _OutMem();
  (*s)->UU.U1.lowofsecond = -88;
  (*s)->UU.U1.lowofthird = -88;
  (*s)->node_type = interior;
  (*s)->count = -1;
  if (min)
    min = (pback->UU.leaf_->key < saves->UU.leaf_->key);
  if (min) {
    (*s)->UU.U1.firstchild = pback;
    (*s)->UU.U1.secondchild = saves;
    (*s)->UU.U1.lowofsecond = saves->UU.leaf_->key;
  } else {
    (*s)->UU.U1.firstchild = saves;
    (*s)->UU.U1.secondchild = pback;
    (*s)->UU.U1.lowofsecond = lowback;
  }
  (*s)->UU.U1.thirdchild = NULL;
}  /* insert_in_2_3_tree */


Static Void print_offset_list(p)
t_offset_list *p;
{
  write_char(stdout, '[');
  while (p != NULL) {
    print_vertex_set(p->vertex_set);
    write_char(stdout, ':');
    write_integer(stdout, p->offset, 4L);
    p = p->pointer;
  }
  write_char(stdout, ']');
}  /* print_offset_list */


Static Void print_s_offset_list(p)
t_s_offset_list *p;
{
  write_char(stdout, '[');
  while (p != NULL) {
    print_vertex_set(p->vertex_set);
    write_char(stdout, ':');
    write_integer(stdout, p->s_offset, 4L);
    p = p->pointer;
  }
  write_char(stdout, ']');
}  /* print_s_offset_list */


Static Void print_ss_offset_list(p)
t_ss_offset_list *p;
{
  write_char(stdout, '[');
  while (p != NULL) {
    print_vertex_set(p->vertex_set);
    write_char(stdout, ':');
    write_integer(stdout, p->ss_offset, 4L);
    p = p->pointer;
  }
  write_char(stdout, ']');
}  /* print_ss_offset_list */


Static Void print_t_offset_list(p)
t_t_offset_list *p;
{
  write_char(stdout, '[');
  while (p != NULL) {
    print_vertex_set(p->vertex_set);
    write_char(stdout, ':');
    write_integer(stdout, p->t_offset_, 4L);
    p = p->pointer;
  }
  write_char(stdout, ']');
}  /* print_t_offset_list */


Static Void print_r_offset_list(p)
t_r_offset_list *p;
{
  write_char(stdout, '[');
  while (p != NULL) {
    print_vertex_set(p->vertex_set);
    write_char(stdout, ':');
    write_integer(stdout, p->r_offset, 4L);
    p = p->pointer;
  }
  write_char(stdout, ']');
}  /* print_r_offset_list */


Static Void print_model_list(indent, q)
t_integer indent;
t_model_list *q;
{
  t_model_list *p;
  t_long_integer i = 0;
  t_long_integer j;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PrintModelList     ", sizeof(pch20));
  ntr(tzt, 20L, 819L, 1L, 0L, 0L);
  /*$endif TRACE*/
  p = q;
  while (p != NULL) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 819L, 1L, 1L, i);
    i++;
    /*$endif TRACE*/
    if (p->model != NULL) {
      /*$ifdef TRACE*/
      ntr_model_numbers(tzt, 20L, 819L, 1L, -1L, -1L, &p->model);
      ntr_model_g_c(tzt, 20L, 819L, 1L, -1L, -2L, &p->model);
      /*$endif TRACE*/
      print_model_g_c(&p->model, 0L);
      write_line(stdout);
      for (i = 1; i <= indent; i++)
	write_char_stdout(' ');
    }
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr(tzt, 20L, 819L, 1L, 999L, 999L);
}  /* print_model_list */


Static Void visit_2_3_tree_preorder(count, a)
t_integer count;
t_2_3_node **a;
{
  t_integer i;

  if (*a == NULL) {
    write_char_text(stdout, '-');
    write_line_stdout();
    return;
  }
  if ((*a)->node_type == interior) {
    write_char_text(stdout, '[');
    write_integer_text(stdout, (*a)->count, 3L);
    write_char_text(stdout, ',');
    write_integer_text(stdout, (*a)->UU.U1.lowofsecond, 5L);
    write_char_text(stdout, ',');
    write_integer_text(stdout, (*a)->UU.U1.lowofthird, 5L);
    write_char_text(stdout, ']');
    visit_2_3_tree_preorder(count + 1, &(*a)->UU.U1.firstchild);
    for (i = 1; i <= (count + 1) * 17; i++)
      write_char_stdout(' ');
    visit_2_3_tree_preorder(count + 1, &(*a)->UU.U1.secondchild);
    for (i = 1; i <= (count + 1) * 17; i++)
      write_char_stdout(' ');
    visit_2_3_tree_preorder(count + 1, &(*a)->UU.U1.thirdchild);
    return;
  }
  write_char_text(stdout, '[');
  write_integer_text(stdout, (*a)->count, 3L);
  write_char_text(stdout, ',');
  write_integer_text(stdout, -1L, 3L);
  write_char_text(stdout, ',');
  write_integer_text(stdout, -1L, 3L);
  write_char_text(stdout, ']');
  write_pch_10_text(stdout, ": ", 2L);
  write_integer_text(stdout, (*a)->UU.leaf_->key, 5L);
  write_pch_10_text(stdout, ": ", 2L);
  write_integer_text(stdout, (*a)->UU.leaf_->count, 5L);
  switch ((*a)->UU.leaf_->tree_type) {

  case model_tree:
    print_model_list((count + 1) * 17, (*a)->UU.leaf_->UU.model_list);
    break;

  case test_tree:
    /* blank case */
    break;

  case r_offset_tree:
    print_r_offset_list((*a)->UU.leaf_->UU.r_offset_list);
    break;

  case s_offset_tree:
    print_s_offset_list((*a)->UU.leaf_->UU.s_offset_list);
    break;

  case ss_offset_tree:
    print_ss_offset_list((*a)->UU.leaf_->UU.ss_offset_list);
    break;

  case t_offset_tree:
    print_t_offset_list((*a)->UU.leaf_->UU.t_offset_list_);
    break;

  case offset_tree:
    print_offset_list((*a)->UU.leaf_->UU.offset_list);
    break;
  }
  write_line_stdout();
}  /* visit_2_3_tree_preorder */


Static Void insert_test_in_2_3_tree(x, key)
t_test_list **x;
t_long_integer *key;
{
  t_2_3_element element;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertTestIn2-3Tree", sizeof(pch20));
  ntr(tzt, 20L, 821L, 1L, 1L, *key);
  /*$endif TRACE*/
  element.tree_type = test_tree;
  element.UU.test_element = *x;
  element.key = *key;
  insert_in_2_3_tree(&element, &test_2_3_tree);
}  /* insert_test_in_2_3_tree */


Static Void insert_test(p, test)
t_test_list **p;
t_test *test;
{
  *p = (t_test_list *)Malloc(sizeof(t_test_list));
  if (*p == NULL)
    _OutMem();
  (*p)->test = *test;
  (*p)->pointer = link_test_list;
  link_test_list = *p;
  if (!boolean_option[113])
    insert_test_in_2_3_tree(p, &test->paritet);
}  /* insert_test */


Static Void find_test_in_2_3_tree(key, p)
t_2_3_key *key;
t_part_list **p;
{
  t_2_3_leaf *result;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " Findtestin2-3Tree  ", sizeof(pch20));
  ntr(tzt, 20L, 823L, 1L, 1L, *key);
  if (trace_flag[TRACE_FLAG_FACTOR * 823])
    visit_2_3_tree_preorder(0L, &test_2_3_tree);
  /*$endif TRACE*/
  *p = NULL;
  if (test_2_3_tree != NULL) {
    find_in_2_3_tree(&test_2_3_tree, *key, &result);
    if (result != NULL)
      *p = result->UU.test_list;
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 823L, 8L, 1L, *key, *p == NULL);
  /*$endif TRACE*/
}  /* find_test_in_2_3_tree */


/* 65536 */

#define max_par         _INFINITY_SHORT


Static t_long_integer offset_key(a)
long *a;
{
  t_long_integer sum, product;
  t_vertex v;

  if (dimension != 0) {
    sum = 1;
    product = 1;
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, a))
	sum = (sum + product) % (max_par / dimension);
      if (product * 2 >= max_par / dimension)
	product = 1;
      else
	product *= 2;
    }
    return (cardinality(a) * (max_par / dimension) + sum);
  } else
    return 0;
}  /* offset_key */

#undef max_par


Static Void insert_offset(a, a_offset, local_offset_list)
long *a;
t_offset a_offset;
t_offset_list **local_offset_list;
{
  t_offset_list *p;

  p = (t_offset_list *)Malloc(sizeof(t_offset_list));
  if (p == NULL)
    _OutMem();
  p->offset = a_offset;
  P_setcpy(p->vertex_set, a);
  p->pointer = *local_offset_list;
  *local_offset_list = p;
}  /* insert_offset */


Static Void insert_offset_in_2_3_tree(a, x)
long *a;
t_offset *x;
{
  t_2_3_element element;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertOffsetIn2-3Tr", sizeof(pch20));
  ntr_set(tzt, 20L, 826L, 1L, 1L, offset_key(a), a);
  /*$endif TRACE*/
  element.tree_type = offset_tree;
  element.UU.offset_element = NULL;
  insert_offset(a, *x, &element.UU.offset_element);
  element.key = offset_key(a);
  insert_in_2_3_tree(&element, &offset_2_3_tree);
}  /* insert_offset_in_2_3_tree */


Static Void insert_offset_in_both(a, a_offset)
long *a;
t_offset a_offset;
{
  if (!boolean_option[112])
    insert_offset_in_2_3_tree(a, &a_offset);
  else
    insert_offset(a, a_offset, &link_offset_list);
}  /* insert_offset_in_both */


Static Void find_offset_in_2_3_tree(a, p)
long *a;
t_offset_list **p;
{
  t_2_3_leaf *result;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " findOffsetIn2-3Tree", sizeof(pch20));
  ntr_set(tzt, 20L, 826L, 1L, 1L, offset_key(a), a);
  if (trace_flag[TRACE_FLAG_FACTOR * 826])
    visit_2_3_tree_preorder(0L, &offset_2_3_tree);
  /*$endif TRACE*/
  *p = NULL;
  if (offset_2_3_tree != NULL) {
    find_in_2_3_tree(&offset_2_3_tree, offset_key(a), &result);
    if (result != NULL)
      *p = result->UU.offset_list;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_boolean(tzt, 20L, 826L, 8L, 1L, offset_key(a), *p == NULL);
}  /* find_offset_in_2_3_tree */


/*@+"margall.p"*/


Static Void invers_offset_hash(offset_index, v_set)
t_offset_index offset_index;
long *v_set;
{
  short sum;
  t_vertex v;

  P_setcpy(v_set, empty_set);
  sum = offset_index - 1;
  for (v = last_vertex; v >= first_vertex; v--) {
    if (sum >= (long)floor(exp(log(2.0) * (v - first_vertex)) + 0.5)) {
      P_addset(v_set, v);
      sum -= (long)floor(exp(log(2.0) * (v - first_vertex)) + 0.5);
    }
  }
}  /* invers_offset_hash */


Static Void find_all_marginals(ok)
boolean *ok;
{
  t_cell i;
  t_vertex_set vertex_set[MAX_OFFSET_CELL_NUMBER];
  t_offset_index g_set_nr, set_nr_1, set_nr_2, card;
  t_cell_index number_of_tables, offset_index, index, m_index, a, g_size,
	       g_size_2;
  t_vertex_set g_set, set_1, set_2, c_in_a;
  t_long_integer marg_dim_delta;
  t_vertex l_a_vertex;
  t_v_arr_of_integer prod_1, prod_2, levels;
  t_cell_index FORLIM2;

  a = fna;
  number_of_tables = (long)floor(exp(log(2.0) * dimension) + 0.5);
  for (g_set_nr = 2; g_set_nr <= number_of_tables - 1; g_set_nr++) {
    invers_offset_hash(g_set_nr, vertex_set[g_set_nr-1]);
    offset[g_set_nr-1] = a;
    a += marginal_dimension(vertex_set[g_set_nr-1]);
  }
  P_setcpy(vertex_set[number_of_tables-1], delta);
  if (!TURBO_PC)
    *ok = space_in_n_array(a, 0L);
  if (a > max_cell_number) {
    *ok = false;
    return;
  }
  if (!sorted) {
    *ok = true;
    for (index = FIRST_INDEX + fna; index <= FIRST_INDEX + a; index++)
      n[index] = 0;
    memcpy(i, first_cell, sizeof(t_cell));
    fna = a;
    marg_dim_delta = marginal_dimension(delta);
    for (offset_index = 1; offset_index <= number_of_tables - 2; offset_index++) {
      find_products(delta, vertex_set[offset_index], c_in_a, prod_1, prod_2,
		    levels, &l_a_vertex);
      m_index = offset[offset_index];
      for (index = N_START; index <= N_START + marg_dim_delta - 1; index++) {
	n[m_index] += n[index];
	next_c_offset_in_a(c_in_a, &m_index, prod_1, prod_2, levels,
			   &l_a_vertex, i);
      }
    }
    return;
  }
  *ok = true;
  for (index = FIRST_INDEX + fna; index <= FIRST_INDEX + a; index++)
    n[index] = 0;
  memcpy(i, first_cell, sizeof(t_cell));
  fna = a;
  for (card = cardinality(delta) - 1; card >= 1; card--) {
    for (set_nr_1 = 2; set_nr_1 <= number_of_tables - 1; set_nr_1++) {
      P_setcpy(set_1, vertex_set[set_nr_1-1]);
      if (card == cardinality(set_1)) {
	P_setcpy(g_set, delta);
	g_set_nr = number_of_tables;
	g_size = marginal_dimension(delta);
	for (set_nr_2 = 2; set_nr_2 <= number_of_tables - 1; set_nr_2++) {
	  P_setcpy(set_2, vertex_set[set_nr_2-1]);
	  g_size_2 = marginal_dimension(set_2);
	  if (P_subset(set_1, set_2) && g_size_2 < g_size &&
	      set_nr_1 != set_nr_2) {
	    P_setcpy(g_set, set_2);
	    g_set_nr = set_nr_2;
	    g_size = g_size_2;
	  }
	}
	find_products(g_set, set_1, c_in_a, prod_1, prod_2, levels,
		      &l_a_vertex);
	m_index = offset[set_nr_1-1];
	FORLIM2 = offset[g_set_nr-1] + g_size;
	for (index = offset[g_set_nr-1]; index <= FORLIM2 - 1; index++) {
	  n[m_index] += n[index];
	  next_c_offset_in_a(c_in_a, &m_index, prod_1, prod_2, levels,
			     &l_a_vertex, i);
	}
      }
    }
  }
}  /* find_all_marginals */


/*@+"margnec.p"*/


/*

  838:    +++  ++
  839:    +++  ++
  840:    ---  -- p/margnec.p          9      37     514 p/margnec.p
  841: |    4:    procedure visit_marginals
  842: |   31:    function found_marginal
  843: |   40:    procedure visit_marginals_in_2_3_tree
  844: |   86:    procedure find_the_marginal
  845: |  175:    function sub_find_marginal
  846: |  222:    function find_marginal
  847: |  231:    procedure insert_set_in_list_of_marginals_to_find
  848: |  270:    procedure find_list_of_marginals
  849: |  287:    procedure find_covariance
  850:    +++  ++
  851:    +++  ++

*/

Static Void visit_marginals(a, p, b, g, size_of_a, size_of_g, g_offset)
long *a;
t_offset_list *p;
boolean *b;
long *g;
t_cell_index *size_of_a, *size_of_g;
t_offset *g_offset;
{
  t_cell_index size_of_g0;
  t_vertex_set g0;

  while (p != NULL && *b && *size_of_a * 2 < *size_of_g) {
    P_setcpy(g0, p->vertex_set);
    if (P_setequal(a, g0)) {
      *g_offset = p->offset;
      *b = false;
      continue;
    }
    size_of_g0 = marginal_dimension(g0);
    if (P_subset(a, g0) && size_of_g0 < *size_of_g) {
      P_setcpy(g, g0);
      *g_offset = p->offset;
      *size_of_g = size_of_g0;
    }
    p = p->pointer;
  }
}  /* visit_marginals */


/* Local variables for found_marginal: */
struct LOC_found_marginal {
  long *a, *g0;
  t_offset *g_offset;
  boolean b;
  t_cell_index size_of_a, size_of_g;
} ;

Local Void visit_marginals_in_2_3_tree(x_key, tree, LINK)
t_2_3_key x_key;
t_2_3_node **tree;
struct LOC_found_marginal *LINK;
{
  if (*tree == NULL)
    return;
  if ((*tree)->node_type != interior) {
    visit_marginals(LINK->a, (*tree)->UU.leaf_->UU.offset_list, &LINK->b,
		    LINK->g0, &LINK->size_of_a, &LINK->size_of_g,
		    LINK->g_offset);
    return;
  }
  if (x_key < (*tree)->UU.U1.lowofsecond)
    visit_marginals_in_2_3_tree(x_key, &(*tree)->UU.U1.firstchild, LINK);
  if ((*tree)->UU.U1.thirdchild == NULL || x_key < (*tree)->UU.U1.lowofthird)
    visit_marginals_in_2_3_tree(x_key, &(*tree)->UU.U1.secondchild, LINK);
  visit_marginals_in_2_3_tree(x_key, &(*tree)->UU.U1.thirdchild, LINK);
}  /* visit_marginals_in_2_3_tree */


Static boolean found_marginal(a_, tmp_marginals, g0_, g_offset_)
long *a_;
t_offset_list **tmp_marginals;
long *g0_;
t_offset *g_offset_;
{
  struct LOC_found_marginal Local_Var;
  t_offset_list *p;

  Local_Var.a = a_;
  Local_Var.g0 = g0_;
  Local_Var.g_offset = g_offset_;
  Local_Var.b = true;
  if (!boolean_option[112]) {
    find_offset_in_2_3_tree(Local_Var.a, &p);
    while (p != NULL && Local_Var.b) {
      if (P_setequal(Local_Var.a, p->vertex_set)) {
	*Local_Var.g_offset = p->offset;
	Local_Var.b = false;
      } else
	p = p->pointer;
    }
  }
  if (!Local_Var.b)
    return (!Local_Var.b);
  P_setcpy(Local_Var.g0, delta);
  *Local_Var.g_offset = N_START - FIRST_INDEX;
  if (datastructure == necessary)
    Local_Var.size_of_g = number_of_cells;
  else
    Local_Var.size_of_g = max_cell_number;
  Local_Var.size_of_a = marginal_dimension(Local_Var.a);
  visit_marginals(Local_Var.a, *tmp_marginals, &Local_Var.b, Local_Var.g0,
		  &Local_Var.size_of_a, &Local_Var.size_of_g,
		  Local_Var.g_offset);
  if (!Local_Var.b)
    return (!Local_Var.b);
  if (!boolean_option[112])
    visit_marginals_in_2_3_tree(offset_key(Local_Var.a), &offset_2_3_tree,
				&Local_Var);
  else
    visit_marginals(Local_Var.a, link_offset_list, &Local_Var.b, Local_Var.g0,
		    &Local_Var.size_of_a, &Local_Var.size_of_g,
		    Local_Var.g_offset);
  return (!Local_Var.b);
}  /* found_marginal */


Static Void find_the_marginal(a, g, g_offset)
long *a, *g;
t_offset *g_offset;
{
  t_cell_index index, m_index;
  t_long_integer case_number;
  t_cell i;
  t_vertex v;
  t_vertex_set c_in_a;
  t_discrete_vertex_set b;
  t_vertex l_a_vertex;
  t_v_arr_of_integer prod_1, prod_2, levels;
  t_case_list *p_case_list;
  t_item_list *p_item_list;
  /*$ifdef TRACE*/
  t_continuous_vertex_set a_continuous;
  pch20 tzt;
  t_cell_index FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindTheMarginal    ", sizeof(pch20));
  ntr_set(tzt, 20L, 844L, 2L, 0L, 0L, g);
  ntr_set(tzt, 20L, 844L, 2L, 0L, 0L, a);
  /*$endif TRACE*/
  P_setint(c_in_a, a, gamma_);
  if (!P_setequal(c_in_a, empty_set)) {
    note_error_sets(stdout, 844L, 1L, " FindTheMarginal    ", a, c_in_a,
		    false);
    write_warning(stdout, "2: Continuous variables in FindMarginal.", 40L);
    P_setint(a, a, delta);
  }
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 844L, 2L, 0L, 0L, a);
  /*$endif TRACE*/
  memcpy(i, first_cell, sizeof(t_cell));
  FORLIM = fna + last_index(a);
  for (m_index = fna; m_index <= FORLIM; m_index++)
    n[m_index] = 0;
  if (mixed_data && P_setequal(g, delta) && item_list != NULL) {
    p_item_list = item_list;
    to_discrete_set(a, b);
    /*$ifdef TRACE*/
    P_setcpy(a_continuous, empty_set);
    ntr_split_set(tzt, 20L, 844L, 2L, 0L, 0L, a, b, a_continuous);
    /*$endif TRACE*/
    for (case_number = 1; case_number <= n[0]; case_number++) {
      m_index = fna + discrete_marginal_hash(b, p_item_list->item.integer_vector);
      p_item_list = p_item_list->pointer;
      n[m_index]++;
    }
    return;
  }
  if (datastructure == list_file && P_setequal(g, delta) && case_list != NULL) {
    p_case_list = case_list;
    for (case_number = 1; case_number <= n[0]; case_number++) {
      m_index = fna + marginal_hash(a, p_case_list->cell);
      p_case_list = p_case_list->pointer;
      n[m_index]++;
    }
    return;
  }
  if (datastructure == list_file && P_setequal(g, delta) && !exclude_missing) {
    reset_level_file(file_read);
    for (case_number = 1; case_number <= n[0]; case_number++) {
      for (v = first_vertex; v <= last_vertex; v++)
	read_level_file(file_read, &i[v - MIN_VERTEX]);
      m_index = fna + marginal_hash(a, i);
      n[m_index]++;
    }
    return;
  }
  if (datastructure == list_file && P_setequal(g, delta) && exclude_missing) {
    reset_level_file(file_excluded);
    for (case_number = 1; case_number <= n[0]; case_number++) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, delta_missing_excluded))
	  read_level_file(file_excluded, &i[v - MIN_VERTEX]);
      }
      m_index = fna + marginal_hash(a, i);
      n[m_index]++;
    }
    return;
  }
  find_products(g, a, c_in_a, prod_1, prod_2, levels, &l_a_vertex);
  m_index = fna;
  FORLIM = *g_offset + last_index(g);
  for (index = *g_offset; index <= FORLIM; index++) {
    n[m_index] += n[index];
    next_c_offset_in_a(c_in_a, &m_index, prod_1, prod_2, levels, &l_a_vertex,
		       i);
  }
}  /* find_the_marginal */


Static t_offset sub_find_marginal(a, tmp_marginals, use_temporary, ok)
long *a;
t_offset_list **tmp_marginals;
boolean use_temporary, *ok;
{
  t_offset Result, g_offset;
  t_long_integer off;
  t_vertex_set g;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubFindMarginal    ", sizeof(pch20));
  ntr_set(tzt, 20L, 845L, 1L, 0L, 0L, a);
  /*$endif TRACE*/
  if (em)
    write_warning_em(stdout, 845L, " SubFindMarginal    ");
  if ((!TURBO_PC) & (marginal_dimension(a) < _INFINITY))
    *ok = space_in_n_array(marginal_dimension(a), 0L);
  if (marginal_dimension(a) > max_cell_number) {
    *ok = false;
    return 0;
  }
  *ok = true;
  if (found_marginal(a, tmp_marginals, g, &g_offset))
    return g_offset;
  Result = fna;
  off = fna + marginal_dimension(a);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 845L, 2L, 0L, off);
  /*$endif TRACE*/
  if (!TURBO_PC)
    *ok = space_in_n_array(off, 0L);
  if (off > max_cell_number) {
    *ok = false;
    return Result;
  }
  if (use_temporary)
    insert_offset(a, fna, tmp_marginals);
  else
    insert_offset_in_both(a, fna);
  find_the_marginal(a, g, &g_offset);
  fna = off;
  return Result;
}  /* sub_find_marginal */


Static t_offset find_marginal(a, ok)
long *a;
boolean *ok;
{
  t_offset_list *p = NULL;

  return (sub_find_marginal(a, &p, false, ok));
}  /* find_marginal */


Static Void insert_set_in_list_of_marginals_to_find(a, set_list)
long *a;
t_set_list **set_list;
{
  t_set_list *p, *q;
  t_long_integer card_a;
  boolean b = true;

  if (*set_list == NULL) {
    insert_set_in_set_list(a, set_list);
    return;
  }
  card_a = cardinality(a);
  p = *set_list;
  q = p;
  if (P_setequal(a, p->vertex_set))
    b = false;
  else if (cardinality(p->vertex_set) <= card_a) {
    insert_set_in_set_list(a, set_list);
    b = false;
  } else
    p = p->pointer;
  while (p != NULL && b) {
    if (P_setequal(a, p->vertex_set)) {
      b = false;
      break;
    }
    if (cardinality(p->vertex_set) <= card_a) {
      insert_set_in_set_list(a, &p);
      q->pointer = p;
      b = false;
    } else {
      q = p;
      p = p->pointer;
    }
  }
  if (p == NULL) {
    insert_set_in_set_list(a, &p);
    q->pointer = p;
  }
}  /* insert_set_in_list_of_marginals_to_find */


Static Void find_list_of_marginals(p, ok)
t_set_list **p;
boolean *ok;
{
  t_set_list *q;
  t_long_integer dummy;

  *ok = true;
  while (*p != NULL && *ok) {
    q = (*p)->pointer;
    dummy = find_marginal((*p)->vertex_set, ok);
    _Free(*p);
    *p = q;
  }
  if (!*ok)
    dispose_set_list(p);
}  /* find_list_of_marginals */


Static Void find_covariance(a, n_offset, p_offset, m1, m2, ok)
long *a;
t_offset *n_offset, *p_offset;
t_integer *m1, *m2;
boolean *ok;
{

  /* Only used in "find_and_print_covariance" at:

       15: begin
              find_covariance(a, n_offset, p_offset, m1, m2, ok);
              if ok then
                 print_covariance(a, n_offset, p_offset, m1, m2, p_a, permuted)
           end
  */
  t_cell_index index;
  t_long_integer count, case_number, i, j, j1, j2;
  t_vertex w;
  t_continuous_vertex v1, v2;
  t_vertex_set b;
  t_discrete_vertex_set a_discrete;
  t_continuous_vertex_set a_continuous;
  t_item_list *p_item_list;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindCovariance     ", sizeof(pch20));
  ntr_set(tzt, 20L, 849L, 1L, 0L, 0L, a);
  /*$endif TRACE*/
  P_setint(b, a, delta);
  to_discrete_set(a, a_discrete);
  to_continuous_set(a, a_continuous);
  /* m := cardinality_continuous(a_continuous); */
  *m1 = 0;
  for (w = first_vertex; w <= last_vertex; w++) {
    if (P_inset(w, a) & P_inset(w, gamma_))
      (*m1)++;
  }
  *m2 = *m1 + *m1 * (*m1 + 1) / 2;
  /*$ifdef TRACE*/
  ntr_split_set(tzt, 20L, 849L, 2L, *m1, *m2, a, a_discrete, a_continuous);
  ntr_set(tzt, 20L, 849L, 2L, 0L, last_index(b), b);
  ntr_4(tzt, 20L, 849L, 2L, fpa, (long)FIRST_INDEX, fpa,
	fpa + *m2 * (last_index(b) - FIRST_INDEX + 1) - 1);
      /*ntr*/
  /*$endif TRACE*/
  *n_offset = find_marginal(b, ok);
  *p_offset = fpa;
  j = FIRST_INDEX + *m2 * (last_index(b) - FIRST_INDEX + 1) - 1;
  if (*ok && !TURBO_PC)
    *ok = space_in_p_array(j, fpa);
  if (*ok)
    *ok = (j <= max_p_cell_number - fpa);
  if (!(*ok && item_list != NULL))
    return;
  for (index = *p_offset; index <=
	 *p_offset + *m2 * (last_index(b) - FIRST_INDEX + 1) - 1; index++)
    p[index] = 0.0;
  p_item_list = item_list;
  for (case_number = 1; case_number <= n[0]; case_number++) {
    index = discrete_marginal_hash(a_discrete,
				   p_item_list->item.integer_vector);
    index = *p_offset + index * *m2;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 849L, 3L, 0L, index);
    /*$endif TRACE*/
    for (v1 = first_continuous_vertex; v1 <= last_continuous_vertex; v1++) {
      if (P_inset(v1, a_continuous)) {
	/*$ifdef TRACE*/
	ntr_short_real(tzt, 20L, 849L, 3L, 0L, index, &p[index]);
	/*$endif TRACE*/
	p[index] += p_item_list->item.real_vector[v1 - MIN_VERTEX];   /*ntr*/
	/*$ifdef TRACE*/
	ntr_double_short_real(tzt, 20L, 849L, 3L, 0L, index,
			      &p_item_list->item.real_vector[v1 - MIN_VERTEX],
			      &p[index]);
	    /*ntr*/
	/*$endif TRACE*/
	index++;
      }
    }
    p_item_list = p_item_list->pointer;
  }
  for (i = 0; i < marginal_dimension(b); i++) {
    index = i;
    count = n[*n_offset + index];
    index = *p_offset + index * *m2;
    for (j = index; j < index + *m1; j++) {
      if (count != 0)
	p[j] /= count;
      else
	p[j] = _INVALID_REAL;
    }
  }
  p_item_list = item_list;
  for (case_number = 1; case_number <= n[0]; case_number++) {
    index = discrete_marginal_hash(a_discrete,
				   p_item_list->item.integer_vector);
    index = *p_offset + index * *m2;
    j = index + *m1;
    j1 = index;
    for (v1 = first_continuous_vertex; v1 <= last_continuous_vertex; v1++) {
      if (P_inset(v1, a_continuous)) {
	/* j2 := j1; */
	/* sm_index !!! */
	j2 = index;
	for (v2 = first_continuous_vertex; v2 <= v1; v2++) {
	  /* to last_continuous_vertex */
	  /* sm_index !!! */
	  if (P_inset(v2, a_continuous)) {
	    p[j] += (p_item_list->item.real_vector[v1 - MIN_VERTEX] - p[j1]) *
		    (p_item_list->item.real_vector[v2 - MIN_VERTEX] - p[j2]);
	    j2++;
	    j++;
	  }
	}
	j1++;
      }
    }
    p_item_list = p_item_list->pointer;
  }
  for (i = 0; i < marginal_dimension(b); i++) {
    index = i;
    count = n[*n_offset + index];
    index = *p_offset + index * *m2;
    for (j = index + *m1; j < index + *m2; j++) {
      if (count > 1) {
	/* if boolean_option[110] then */
	p[j] /= count - 1;
	/* else
               p[j] := p[j] / (count-1)
	*/
      } else
	p[j] = _INVALID_REAL;
    }
  }
}  /* find_covariance */


/*@+"margdis.p"*/


Static Void dispose_marginals()
{
  t_model_list *link_model;

  link_model = link_model_list;
  while (link_model != NULL) {
    link_model->model->found_ps = false;
    link_model = link_model->pointer;
  }
  dispose_offsets();
  dispose_r_offsets();
  dispose_s_offsets();
  dispose_ss_offsets();
  dispose_t_offsets();
  if (datastructure == necessary) {
    if (exclude_missing) {
      insert_offset_in_both(delta_missing_excluded,
			    N_START - FIRST_INDEX + number_of_cells);
      fna = N_START - FIRST_INDEX + number_of_cells +
	    marginal_dimension(delta_missing_excluded);
    } else {
      insert_offset_in_both(delta, (long)(N_START - FIRST_INDEX));
      fna = N_START - FIRST_INDEX + number_of_cells;
    }
  } else if (datastructure == list_file)
    fna = N_START - FIRST_INDEX;
  insert_offset_in_both(empty_set, (long)(-FIRST_INDEX));
}  /* dispose_marginals */


Static Void dispose_tmp_marginals(tmp_marginals, tmp_fna)
t_offset_list **tmp_marginals;
t_cell_index *tmp_fna;
{
  t_offset_list *q;

  if (datastructure != all &&
      (fna * 2 > max_cell_number || (fna - *tmp_fna) * 4 > max_cell_number)) {
    dispose_offset_list(tmp_marginals);
    if (link_offset_list == NULL && offset_2_3_tree == NULL)
      dispose_marginals();
    else
      fna = *tmp_fna;
    return;
  }
  q = *tmp_marginals;
  while (q != NULL) {
    insert_offset_in_both(q->vertex_set, q->offset);
    q = q->pointer;
  }
  dispose_offset_list(tmp_marginals);
}  /* dispose_tmp_marginals */


Static Void dispose_marginals_cond()
{
  if (datastructure != all && fna * 2 > max_cell_number)
    dispose_marginals();
}  /* dispose_marginals_cond */


Static Void conditional_dispose_both_marginals(tmp_marginals)
t_offset_list **tmp_marginals;
{
  if (datastructure != all && fna * 2 > max_cell_number) {
    dispose_marginals();
    dispose_offset_list(tmp_marginals);
  }
}  /* conditional_dispose_both_marginals */


/*@+"exclude.p"*/

/*

  861:    +++  ++
  862:    +++  ++
  863:    ---  -- p/exclude.p          6      29     341 p/exclude.p
  864: |    4:    function hash_total
  865: |   18:    procedure do_exclude
  866: |  166:    procedure print_n_total_exclude
  867: |  193:    procedure print_do_exclude
  868: |  205:    procedure short_print_do_exclude
  869: |  217:    procedure new_print_do_exclude
  870:    +++  ++
  871:    +++  ++

*/


Static Void clear_model_list(q)
t_model_list *q;
{
  t_model_list *p;
  t_long_integer i = 0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ClearModelList     ", sizeof(pch20));
  ntr(tzt, 20L, 462L, 1L, 0L, 0L);
  /*$endif TRACE*/
  p = q;
  while (p != NULL) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 462L, 1L, 1L, i);
    i++;
    /*$endif TRACE*/
    if (p->model != NULL) {
      /*$ifdef TRACE*/
      ntr_model_numbers(tzt, 20L, 462L, 1L, -1L, -1L, &p->model);
      ntr_model_g_c(tzt, 20L, 462L, 1L, -1L, -2L, &p->model);
      /*$endif TRACE*/
      if (exclude_missing) {
	if (!boolean_option[73])
	  p->model->found_log_l = false;
	if (boolean_option[74]) {
	  if (p->model->found_expression)
	    dispose_formula(&p->model);
	}
	if (boolean_option[75])
	  p->model->found_ps = false;
      }
    }
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr(tzt, 20L, 462L, 1L, 999L, 999L);
}  /* clear_model_list */


Static Void clear_2_3_tree(a)
t_2_3_node **a;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " Clear-2-3-tree     ", sizeof(pch20));
  ntr(tzt, 20L, 463L, 1L, 0L, 0L);
  /*$endif TRACE*/
  if (*a != NULL) {
    if ((*a)->node_type == interior) {
      clear_2_3_tree(&(*a)->UU.U1.firstchild);
      clear_2_3_tree(&(*a)->UU.U1.secondchild);
      clear_2_3_tree(&(*a)->UU.U1.thirdchild);
    } else {
      switch ((*a)->UU.leaf_->tree_type) {

      case model_tree:
	clear_model_list((*a)->UU.leaf_->UU.model_list);
	break;
	/* test_tree  : clear_part_list(a^.leaf^.test_list);
	   r_offset_tree  : clear_r_offset_list(a^.leaf^.r_offset_list);
	   s_offset_tree  : clear_s_offset_list(a^.leaf^.s_offset_list);
	   ss_offset_tree : clear_ss_offset_list(a^.leaf^.ss_offset_list);
	   offset_tree  : clear_offset_list(a^.leaf^.offset_list); */
      }
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 463L, 1L, 0L, 1L);
  /*$endif TRACE*/
}  /* clear_2_3_tree */


Static t_cell_index hash_total(i)
t_level *i;
{
  t_cell_index sum = FIRST_INDEX, product = 1;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    sum += (i[v - MIN_VERTEX] - FIRST_LEVEL) * product;
    product *= variable_description[v - MIN_VERTEX]->UU.U0.levels_total;
  }
  return sum;
}  /* hash_total */


Static Void do_exclude(a)
long *a;
{
  t_cell_index index, m_index, off;
  t_cell_count n_cell;
  t_cell i;
  t_vertex v;
  t_long_integer number_of_cases;
  boolean ok;
  t_case_list *p_case_list;
  t_item_list *p_item_list;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_cell_index FORLIM;
  t_variable_description_node *WITH;
  t_vertex FORLIM1;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DoExclude          ", sizeof(pch20));
  ntr_set(tzt, 20L, 865L, 1L, -1L, -1L, a);
  /*$endif TRACE*/
  /* if mixed_data then
     note_mixed(output, ' DoExclude@@@@@@@@@@', 10); */
  for (v = first_vertex; v <= last_vertex; v++) {
    if (variable_description[v - MIN_VERTEX]->variable_type == discrete) {
      WITH = variable_description[v - MIN_VERTEX];
      if (P_inset(v, a))
	WITH->UU.U0.levels = WITH->UU.U0.levels_total - WITH->UU.U0.levels_missing;
      else
	WITH->UU.U0.levels = WITH->UU.U0.levels_total;
      last_cell[v - MIN_VERTEX] =
	FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1;
    } else
      last_cell[v - MIN_VERTEX] = FIRST_LEVEL;
  }
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 865])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  if (!boolean_option[71])
    clear_model_list(link_model_list);
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 865])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  clear_2_3_tree(&model_2_3_tree);
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 865])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  off = N_START - FIRST_INDEX + number_of_cells;
  P_setcpy(delta_missing_excluded, a);
  dispose_offsets();
  dispose_r_offsets();
  dispose_s_offsets();
  dispose_ss_offsets();
  /* dispose_t_offsets; */
  if (datastructure == necessary)
    insert_offset_in_both(delta_missing_excluded, off);
  insert_offset_in_both(empty_set, (long)(-FIRST_INDEX));
  if (datastructure == necessary) {
    fna = N_START - FIRST_INDEX + number_of_cells +
	  marginal_dimension(delta_missing_excluded);
    FORLIM = off + last_index(a);
    for (index = off; index <= FORLIM; index++)
      n[index] = 0;
    n[0] = 0;
    memcpy(i, first_cell, sizeof(t_cell));
    FORLIM = marginal_dimension(delta);
    for (index = 1; index <= FORLIM; index++) {
      m_index = off + marginal_hash(a, i);
      n_cell = n[N_START - FIRST_INDEX + hash_total(i)];
      n[0] += n_cell;
      n[m_index] += n_cell;
      next_cell(i);
    }
  } else if (item_list_read != NULL) {
    fna = N_START - FIRST_INDEX;
    number_of_cases = 0;
    dispose_item_list(&item_list_excluded, false);
    item_list = item_list_read;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 865L, 6L)) {
      FORLIM1 = last_vertex;
      for (v = first_vertex; v <= FORLIM1; v++) {
	write_char(stdout, variable_description[v - MIN_VERTEX]->name);
	if (P_inset(v, delta_missing_excluded)) {
	  if (P_inset(v, full_delta)) {
	    write_char(stdout, '<');
	    print_discrete_vertex_on_file(stdout, to_discrete[v - MIN_VERTEX],
					  0L);
	    write_char(stdout, '>');
	  } else {
	    write_char(stdout, '[');
	    print_continuous_vertex_on_file(stdout,
	      to_continuous[v - MIN_VERTEX], 0L);
	    write_char(stdout, ']');
	  }
	}
      }
    }
    /*$endif TRACE*/
    while (item_list != NULL) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 865L, 6L))
	trace_mixed_case(item_list->item.integer_vector,
			 item_list->item.real_vector);
      /*$endif TRACE*/
      ok = true;
      for (v = first_vertex; v <= last_vertex; v++) {
	if (ok & P_inset(v, delta_missing_excluded)) {
	  if (P_inset(v, full_delta))
	    ok = (item_list->item.integer_vector[to_discrete[v - MIN_VERTEX] -
						 MIN_VERTEX] <=
		  FIRST_LEVEL + variable_description[v - MIN_VERTEX]->
				UU.U0.levels - 1);
	  else
	    ok = !is_invalid_short_real(
		item_list->item.real_vector[to_continuous[v - MIN_VERTEX] -
					    MIN_VERTEX]);
	}
      }
      if (ok) {
	p_item_list = (t_item_list *)Malloc(sizeof(t_item_list));
	if (p_item_list == NULL)
	  _OutMem();
	p_item_list->pointer = item_list_excluded;
	p_item_list->item.integer_vector = item_list->item.integer_vector;
	p_item_list->item.real_vector = item_list->item.real_vector;
	item_list_excluded = p_item_list;
	number_of_cases++;
      }
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 865L, 6L)) {
	if (ok)
	  write_char(stdout, '+');
	else
	  write_char(stdout, '%');
	write_char(stdout, '(');
	write_integer(stdout, number_of_cases, 6L);
	write_char(stdout, ')');
	write_line(stdout);
      }
      /*$endif TRACE*/
      item_list = item_list->pointer;
    }
    n[0] = number_of_cases;
    item_list = item_list_excluded;
  } else if (case_list_read != NULL) {
    fna = N_START - FIRST_INDEX;
    number_of_cases = 0;
    dispose_case_list(&case_list_excluded);
    case_list = case_list_read;
    while (case_list != NULL) {
      ok = true;
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, delta_missing_excluded))
	  ok = (ok && case_list->cell[v - MIN_VERTEX] <=
		      FIRST_LEVEL + variable_description[v - MIN_VERTEX]->
				    UU.U0.levels - 1);
      }
      if (ok) {
	p_case_list = (t_case_list *)Malloc(sizeof(t_case_list));
	if (p_case_list == NULL)
	  _OutMem();
	p_case_list->pointer = case_list_excluded;
	memcpy(p_case_list->cell, case_list->cell, sizeof(t_cell));
	case_list_excluded = p_case_list;
	number_of_cases++;
      }
      case_list = case_list->pointer;
    }
    n[0] = number_of_cases;
    case_list = case_list_excluded;
  } else {
    fna = N_START - FIRST_INDEX;
    number_of_cases = 0;
    reset_level_file(file_read);
    reassign_tmp_level_file_write(&file_excluded, file_name_excluded);
    rewrite_level_file(file_excluded);
    while (!eof_level_file(file_read)) {
      for (v = first_vertex; v <= last_vertex; v++)
	read_level_file(file_read, &i[v - MIN_VERTEX]);
      ok = true;
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, delta_missing_excluded))
	  ok = (ok && i[v - MIN_VERTEX] <=
		      FIRST_LEVEL + variable_description[v - MIN_VERTEX]->
				    UU.U0.levels - 1);
      }
      if (ok) {
	for (v = first_vertex; v <= last_vertex; v++) {
	  if (P_inset(v, delta_missing_excluded))
	    write_level_file(file_excluded, i[v - MIN_VERTEX]);
	}
	number_of_cases++;
      }
    }
    n[0] = number_of_cases;
    /*$ifdef TRACE*/
  }
  ntr(tzt, 20L, 865L, 1L, -1L, n[0]);
  /*$endif TRACE*/
}  /* do_exclude */


Static Void print_n_total_exclude(g, write_options, test_labels, n_total)
long *g;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_long_integer n_total;
{
  if ((*write_options)->line_form) {
    /* write_char(output, '<');  PrintExclude */
    if ((*write_options)->write_models) {
      write_space(stdout, 2L);
      print_vertex_set(g);
      if (!long_names)
	write_space(stdout, dimension - cardinality(g));
    }
    write_space(stdout, 1L);
    write_integer(stdout, n_total, 7L);
    /* write_char(output, '>');  PrintExclude */
    return;
  }
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "Number of complete observations in marginal table ",
	      50L);
  print_vertex_set(g);
  if (!long_names)
    write_space(stdout, (dimension - cardinality(g)) % 10);
  write_pch(stdout, ": ", 2L);
  write_integer(stdout, n_total, width);
  write_line(stdout);
}  /* print_n_total_exclude */


Static Void print_do_exclude(g, write_options, test_labels)
long *g;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  /* write_char(output, '(');  PrintExclude */
  /* if write_options^.write_test then   PrintExclude */
  /*    write_char(output, '*');  PrintExclude */
  if (graph_mode || !exclude_missing)
    return;
  /* ; write_char(output, ')') PrintExclude */
  if (!P_setequal(g, delta_missing_excluded))
    do_exclude(g);
  if ((*write_options)->write_test)
    print_n_total_exclude(g, write_options, test_labels, n[0]);
}  /* print_do_exclude */


Static Void short_print_do_exclude(g)
long *g;
{
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_false();
  local_test_labels = new_test_labels_empty();
  print_do_exclude(g, &local_write_options, &local_test_labels);
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* short_print_do_exclude */


Static Void new_print_do_exclude(g, line_form)
long *g;
boolean *line_form;
{
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_false();
  local_write_options->line_form = *line_form;
  local_test_labels = new_test_labels_empty();
  print_do_exclude(g, &local_write_options, &local_test_labels);
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* short_print_do_exclude */


/*@+"retoff.p"*/


/*

  872:    +++  ++
  873:    +++  ++
  874:    ---  -- p/retoff.p         15      63     955 p/retoff.p
  875: |    3:    function limited_offset_hash
  876: |   21:    function add_parity_terms
  877: |   34:    function return_triple_gc_parity
  878: |   61:    function offset_hash
  879: |   76:    function return_offset
  880: |   95:    procedure insert_factor_in_expression
  881: |  108:    procedure put_factor
  882: |  163:    procedure sub_return_expression
  883: |  246:    procedure describe_expression
  884: |  271:    procedure describe_ips_list
  885: |  314:    procedure find_expression_marginals_and_insert_offsets
  886: |  326:    procedure return_expression
  887: |  351:    procedure dismiss_expression
  888: |  373:    procedure return_expression_and_ips_list
  889: |  388:    procedure dismiss_expression_and_ips_list
  890:    +++  ++
  891:    +++  ++

*/

Static t_long_integer limited_offset_hash(a, max_par_var)
long *a;
t_long_integer max_par_var;
{
  t_long_integer sum = 1, product = 1;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      sum = (sum + product) % max_par_var;
    product *= 2;
    if (product >= max_par_var)
      product = 1;
  }
  return sum;
}  /* limited_offset_hash */


Static t_long_integer add_parity_terms(p, max_par_var)
t_set_list *p;
t_long_integer max_par_var;
{
  t_long_integer sum = 0;

  while (p != NULL) {
    sum = (sum + limited_offset_hash(p->vertex_set, max_par_var)) % max_par_var;
    p = p->pointer;
  }
  return sum;
}  /* add_parity_terms */


/* 65536 */

#define max_par         _INFINITY_SHORT


Static t_long_integer return_triple_gc_parity(g_c_1, g_c_2, g_c_3)
t_set_list **g_c_1, **g_c_2, **g_c_3;
{
  t_long_integer sum;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  sum = add_parity_terms(*g_c_1, (long)max_par);
  sum = (sum + add_parity_terms(*g_c_2, (long)max_par)) % max_par;
  sum = (sum + add_parity_terms(*g_c_3, (long)max_par)) % max_par;
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnParitet      ", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 877L, 1L, 0L, sum, g_c_1, g_c_2, g_c_3);
  /*$endif TRACE*/
  return sum;
}  /* return_triple_gc_parity */

#undef max_par


Static t_offset_index offset_hash(a)
long *a;
{
  t_offset_index sum = 1, product = 1;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      sum += product;
    product *= 2;
  }
  return sum;
}  /* offset_hash */


Static t_offset return_offset(a, ok)
long *a;
boolean *ok;
{
  if (em)
    write_warning_em(stdout, 879L, " ReturnOffset       ");
  if (datastructure == all) {
    *ok = true;
    /*$ifdef TRACE*/
    ntr(" ReturnOffset       ", 20L, 879L, 1L, -1L,
	offset[offset_hash(a) - 1]);
    /*$endif TRACE*/
    return (offset[offset_hash(a) - 1]);
  } else
    return (find_marginal(a, ok));
}  /* return_offset */


Static Void insert_factor_in_expression(a, offset, factor, expression)
long *a;
t_offset offset;
t_long_integer *factor;
t_expression **expression;
{
  t_expression *p;

  p = (t_expression *)Malloc(sizeof(t_expression));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, a);
  p->offset = offset;
  p->factor = *factor;
  p->pointer = *expression;
  *expression = p;
}  /* insert_factor_in_expression */


Static Void put_factor(link_expression, a, offset, factor)
t_expression **link_expression;
long *a;
t_offset offset;
t_long_integer factor;
{
  t_expression *p, *q;
  t_expression *r = NULL;
  boolean b = true;
  t_long_integer card_a;

  card_a = cardinality(a);
  if (*link_expression == NULL) {
    insert_factor_in_expression(a, offset, &factor, link_expression);
    (*link_expression)->card = card_a;
    return;
  }
  if (card_a < (*link_expression)->card) {
    insert_factor_in_expression(a, offset, &factor, link_expression);
    (*link_expression)->card = card_a;
    return;
  }
  p = *link_expression;
  q = p;
  while (p != NULL && b) {
    if (P_setequal(a, p->vertex_set) || card_a < p->card)
      b = false;
    else {
      q = p;
      p = p->pointer;
    }
  }
  if (b) {
    insert_factor_in_expression(a, offset, &factor, &p);
    p->card = card_a;
    q->pointer = p;
    return;
  }
  if (P_setequal(a, p->vertex_set)) {
    p->factor += factor;
    if (p->factor != 0)
      return;
    if (q == p) {
      *link_expression = p->pointer;
      _Free(p);
    } else {
      q->pointer = p->pointer;
      _Free(p);
    }
    return;
  }
  insert_factor_in_expression(a, offset, &factor, &r);
  r->card = card_a;
  if (p == q)
    r->pointer = NULL;
  else
    r->pointer = p;
  q->pointer = r;
}  /* put_factor */


Static Void sub_return_expression(link_model, expression, ips_list, radim_list)
t_model **link_model;
t_expression **expression;
t_list_ips_elements **ips_list;
t_list_radim_elements **radim_list;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula, *separator;
  t_list_ips_elements *p, *q;
  t_list_radim_elements *r;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubReturnExpressio ", sizeof(pch20));
  ntr(tzt, 20L, 883L, 1L, 0L, 0L);
  /*$endif TRACE*/
  formula = (*link_model)->formula_node;
  if (formula == NULL)
    return;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    sub_return_expression(&decomposition_element->left_model, expression,
			  ips_list, radim_list);
    sub_return_expression(&decomposition_element->right_model, expression,
			  ips_list, radim_list);
    separator = decomposition_element->separator;
    if (separator->node_type != d_complete_node)
      return;
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 883L, 1L, 2L, -1L, separator->UU.d_complete_leaf->a);
    /*$endif TRACE*/
    put_factor(expression, separator->UU.d_complete_leaf->a,
	       separator->UU.d_complete_leaf->offset, -1L);
    put_factor(expression, empty_set, (long)(-FIRST_INDEX), 1L);
    return;
  }
  /* halt */
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 883L, 1L, 2L, 1L, formula->UU.d_complete_leaf->a);
    ntr(tzt, 20L, 883L, 1L, -2L, formula->UU.d_complete_leaf->offset);
    /*$endif TRACE*/
    put_factor(expression, formula->UU.d_complete_leaf->a,
	       formula->UU.d_complete_leaf->offset, 1L);
    put_factor(expression, empty_set, (long)(-FIRST_INDEX), -1L);
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 883L, 1L, 4L, 2L, formula->UU.d_ips_leaf->a);
    /*$endif TRACE*/
    q = (t_list_ips_elements *)Malloc(sizeof(t_list_ips_elements));
    if (q == NULL)
      _OutMem();
    q->pointer = *ips_list;
    q->ips_element = *formula->UU.d_ips_leaf;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 883L, 1L, -4L, formula->UU.d_ips_leaf->p_offset);
    /*$endif TRACE*/
    *ips_list = q;
    break;

  case r_ips_node:
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 883L, 1L, 5L, 3L, formula->UU.r_ips_leaf->a);
    /*$endif TRACE*/
    r = (t_list_radim_elements *)Malloc(sizeof(t_list_radim_elements));
    if (r == NULL)
      _OutMem();
    r->pointer = *radim_list;
    r->radim_element = *formula->UU.r_ips_leaf;
    *radim_list = r;
    p = r->radim_element.ips_list;
    while (p != NULL) {
      q = (t_list_ips_elements *)Malloc(sizeof(t_list_ips_elements));
      if (q == NULL)
	_OutMem();
      q->pointer = *ips_list;
      q->ips_element = p->ips_element;
      *ips_list = q;
      p = p->pointer;
    }
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    /* blank case */
    break;
  }
}  /* sub_return_expression */


Static Void describe_expression(link_expression, discrete_, full)
t_expression *link_expression;
boolean discrete_, full;
{
  while (link_expression != NULL) {
    if (full) {
      write_integer(stdout, link_expression->offset, 8L);
      write_pch(stdout, " ~ ", 3L);
      write_integer(stdout, marginal_dimension(link_expression->vertex_set),
		    12L);
      write_pch(stdout, " / ", 3L);
    }
    if (discrete_) {
      if (em)
	write_pch(stdout, "   p ( I ", 9L);
      else
	write_pch(stdout, "   N ( I ", 9L);
    } else
      write_pch(stdout, "   Cov ( ", 9L);
    print_vertex_set_table(link_expression->vertex_set);
    write_pch(stdout, " ) ^ ", 5L);
    write_integer(stdout, link_expression->factor, 3L);
    write_pch(stdout, " * ", 3L);
    write_line(stdout);
    link_expression = link_expression->pointer;
  }
}  /* describe_expression */


Static Void describe_ips_list(ips_list, full)
t_list_ips_elements *ips_list;
boolean full;
{
  t_ips_set_list *q;
  t_set_list *cliques;
  t_long_integer stop;

  while (ips_list != NULL) {
    if (full) {
      write_integer(stdout, ips_list->ips_element.n_offset, 8L);
      write_pch(stdout, " | ", 3L);
      write_integer(stdout, ips_list->ips_element.p_offset, 8L);
      write_pch(stdout, " ~ ", 3L);
      write_integer(stdout, marginal_dimension(ips_list->ips_element.a), 12L);
      if (ips_list->ips_element.radim_part)
	write_pch(stdout, " /    R ", 8L);
      else
	write_pch(stdout, " /    P ", 8L);
    } else if (ips_list->ips_element.radim_part)
      write_pch(stdout, "   R ", 5L);
    else
      write_pch(stdout, "   P ", 5L);
    q = ips_list->ips_element.gen_class;
    cliques = NULL;
    while (q != NULL) {
      insert_set_in_set_list(q->vertex_set, &cliques);
      q = q->pointer;
    }
    if (full)
      print_g_c_stop(cliques, 21L, line_length, &stop);
    else
      print_g_c_stop(cliques, 6L, line_length, &stop);
    if (stop > line_length - cardinality(ips_list->ips_element.a) &&
	line_length < MAX_LINE_LENGTH) {
      write_line(stdout);
      write_space(stdout, 19L);
    }
    dispose_set_list(&cliques);
    write_pch(stdout, " ( I ", 5L);
    print_vertex_set(ips_list->ips_element.a);
    write_pch(stdout, " ) * ", 5L);
    write_line(stdout);
    ips_list = ips_list->pointer;
  }
}  /* describe_ips_list */


Static Void find_expression_marginals_and_insert_offsets(link_expression, ok)
t_expression *link_expression;
boolean *ok;
{
  if (em)
    write_warning_em(stdout, 885L, " FindExpressionMarg.");
  *ok = true;
  while (*ok && link_expression != NULL) {
    link_expression->offset = return_offset(link_expression->vertex_set, ok);
    link_expression = link_expression->pointer;
  }
}  /* find_expression_marginals_and_insert_offsets */


Static Void return_expression(link_model, expression, ips_list, radim_list,
			      do_return_offsets)
t_model **link_model;
t_expression **expression;
t_list_ips_elements **ips_list;
t_list_radim_elements **radim_list;
boolean do_return_offsets;
{
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnExpression   ", sizeof(pch20));
  ntr(tzt, 20L, 886L, 1L, 0L, 0L);
  /*$endif TRACE*/
  *expression = NULL;
  *ips_list = NULL;
  *radim_list = NULL;
  sub_return_expression(link_model, expression, ips_list, radim_list);
  if (do_return_offsets) {
    /*$ifdef TRACE*/
    find_expression_marginals_and_insert_offsets(*expression, &ok);
  }
  if (trace_flag[TRACE_FLAG_FACTOR * 886]) {
    describe_expression(*expression, true, true);
    describe_ips_list(*ips_list, true);
  }
  /*$endif TRACE*/
}  /* return_expression */


Static Void dismiss_expression(expression, ips_list, radim_list)
t_expression **expression;
t_list_ips_elements **ips_list;
t_list_radim_elements **radim_list;
{
  t_list_ips_elements *q;
  t_list_radim_elements *r;

  dispose_expression(expression);
  while (*ips_list != NULL) {
    /* dispose_d_ips_element(ips_list^.ips_element); */
    q = (*ips_list)->pointer;
    _Free(*ips_list);
    *ips_list = q;
  }
  while (*radim_list != NULL) {
    /* dispose_r_ips_element(radim_list^.radim_element); */
    r = *radim_list;
    *radim_list = (*radim_list)->pointer;
    _Free(r);
  }
}  /* dismiss_expression */


Static Void return_expression_and_ips_list(link_model, expression, ips_list,
					   do_return_offsets)
t_model **link_model;
t_expression **expression;
t_list_ips_elements **ips_list;
boolean do_return_offsets;
{
  t_list_radim_elements *radim_list, *r;

  return_expression(link_model, expression, ips_list, &radim_list,
		    do_return_offsets);
  while (radim_list != NULL) {
    /* dispose_r_ips_element(radim_list^.radim_element); */
    r = radim_list;
    radim_list = radim_list->pointer;
    _Free(r);
  }
}  /* return_expression_and_ips_list */


Static Void dismiss_expression_and_ips_list(expression, ips_list)
t_expression **expression;
t_list_ips_elements **ips_list;
{
  t_list_radim_elements *radim_list = NULL;

  dismiss_expression(expression, ips_list, &radim_list);
}  /* dismiss_expression_and_ips_list */


/*@-"graph.c"*/
/*@+"compute.p"*/

/*

  892:    +++  ++
  893:    +++  ++
  894:    ---  -- p/compute.p         13      65     680 p/compute.p
  895: |    4:    function return_q_cell
  896: |   18:    function return_marginal_q_cell
  897: |   46:    function zero_cell
  898: |   61:    function marginal_zero_cell
  899: |   92:    function compute_p_fast
  900: |  134:    function compute_p
  901: |  183:    function compute_m_p
  902: |  216:    function compute_m_p_fast
  903: |  279:    function compute_p_em
  904: |  328:    function sub_compute_m_p_em
  905: |  357:    function compute_m_p_em
  906: |  373:    function compute_c
  907: |  414:    function return_table_value
  908:    +++  ++
  909:    +++  ++

*/

Static t_long_integer return_q_cell(i, link_q_tables)
t_level *i;
t_offset_list *link_q_tables;
{
  t_long_integer ii = 1;

  while (link_q_tables != NULL && ii != 0) {
    ii *= q_array[marginal_hash(link_q_tables->vertex_set, i) +
		  link_q_tables->offset];
    link_q_tables = link_q_tables->pointer;
  }
  return ii;
}  /* return_q_cell */


Static t_long_integer return_marginal_q_cell(a, i_, link_q_tables)
long *a;
t_level *i_;
t_offset_list *link_q_tables;
{
  t_cell i;
  t_long_integer q_cell = 0;
  t_vertex v;
  t_vertex_set b, aa;
  t_cell_count index;
  t_offset_list *link_q;
  t_cell_count FORLIM;

  memcpy(i, i_, sizeof(t_cell));
  P_setcpy(b, empty_set);
  link_q = link_q_tables;
  while (link_q != NULL) {
    P_setunion(b, b, link_q->vertex_set);
    link_q = link_q->pointer;
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    if (!P_inset(v, a))
      i[v - MIN_VERTEX] = FIRST_LEVEL;
  }
  P_setdiff(aa, b, a);
  FORLIM = marginal_dimension(aa);
  for (index = 1; index <= FORLIM; index++) {
    next_marginal_cell(aa, i);
    q_cell += return_q_cell(i, link_q_tables);
  }
  return q_cell;
}  /* return_marginal_q_cell */


Static boolean zero_cell(i, link_q_tables)
t_level *i;
t_offset_list *link_q_tables;
{
  boolean b = true;

  while (link_q_tables != NULL && b) {
    if (q_array[marginal_hash(link_q_tables->vertex_set, i) + link_q_tables->
							      offset] == 0)
      b = false;
    link_q_tables = link_q_tables->pointer;
  }
  return (!b);
}  /* zero_cell */


Static boolean marginal_zero_cell(a, i_, link_q_tables)
long *a;
t_level *i_;
t_offset_list *link_q_tables;
{
  t_cell i;
  boolean zero;
  t_vertex v;
  t_vertex_set b, aa;
  t_cell_count index = 1;
  t_cell_count index_stop;
  t_offset_list *link_q;

  memcpy(i, i_, sizeof(t_cell));
  P_setcpy(b, empty_set);
  link_q = link_q_tables;
  while (link_q != NULL) {
    P_setunion(b, b, link_q->vertex_set);
    link_q = link_q->pointer;
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    if (!P_inset(v, a))
      i[v - MIN_VERTEX] = FIRST_LEVEL;
  }
  zero = zero_cell(i, link_q_tables);
  P_setdiff(aa, b, a);
  index_stop = marginal_dimension(aa);
  while (index < index_stop && zero) {
    index++;
    next_marginal_cell(aa, i);
    zero = zero_cell(i, link_q_tables);
  }
  return zero;
}  /* marginal_zero_cell */


Static t_long_real compute_p_fast(constant, link_expression, link_ips_list)
t_long_real *constant;
t_expression *link_expression;
t_list_ips_elements *link_ips_list;
{
  double Result = LONG_MAX;
  t_long_integer count_zero = 0;
  t_long_real p_cell, prob;
  t_long_integer term;

  p_cell = *constant;
  while (link_expression != NULL) {
    term = n[link_expression->offset];
    if (term == 0)
      count_zero += link_expression->factor;
    else
      p_cell *= exp(log((double)term) * link_expression->factor);
    link_expression = link_expression->pointer;
  }
  while (link_ips_list != NULL) {
    prob = p[link_ips_list->ips_element.p_offset];
    if (prob == 0)
      count_zero++;
    else
      p_cell *= prob;
    link_ips_list = link_ips_list->pointer;
  }
  /*$ifdef TRACE*/
  ntr_real(" ComputePFast       ", 20L, 899L, 1L, -1L, -1L, &p_cell);
  /*$endif TRACE*/
  if (count_zero == 0)
    return p_cell;
  if (count_zero > 0)
    return 0.0;
  write_pch_40_text(report_file, " :: Compute(P(i)):  CountZero = ",
		    32L);
  write_integer_text(report_file, count_zero, 5L);
  write_line_text(report_file);
  return Result;
}  /* compute_p_fast */


Static t_long_real compute_p(i, constant, link_expression, link_ips_list)
t_level *i;
t_long_real *constant;
t_expression *link_expression;
t_list_ips_elements *link_ips_list;
{
  double Result = LONG_MAX;
  t_long_integer count_zero = 0;
  t_long_real p_cell, prob;
  t_long_integer term;
  t_vertex v;

  p_cell = *constant;
  while (link_expression != NULL) {
    term = n[marginal_hash(link_expression->vertex_set, i) + link_expression->
							     offset];
    if (term == 0)
      count_zero += link_expression->factor;
    else
      p_cell *= exp(log((double)term) * link_expression->factor);
    link_expression = link_expression->pointer;
  }
  while (link_ips_list != NULL) {
    prob = p[link_ips_list->ips_element.p_offset +
	     marginal_hash(link_ips_list->ips_element.a, i)];
    if (prob == 0)
      count_zero++;
    else
      p_cell *= prob;
    link_ips_list = link_ips_list->pointer;
  }
  /*$ifdef TRACE*/
  ntr_real(" ComputeP           ", 20L, 900L, 1L, -1L, -1L, &p_cell);
  /*$endif TRACE*/
  if (count_zero == 0)
    return p_cell;
  if (count_zero > 0)
    return 0.0;
  write_pch_40_text(report_file, " :: Compute(P(i)):  CountZero = ",
		    42L);
  write_integer_text(report_file, count_zero, 5L);
  write_pch_10_text(report_file, ", i: ", 5L);
  for (v = first_vertex; v <= last_vertex; v++)
    write_level_text(report_file, &i[v - MIN_VERTEX], 3L);
  write_line_text(report_file);
  return Result;
}  /* compute_p */


Static t_long_real compute_m_p(a, i, model)
long *a;
t_level *i;
t_model **model;
{
  /* ;
  var model_set     : t_vertex_set;
  var constant     : t_long_real;
  var link_expression : t_link_expression;
  var link_ips_list   : t_link_list_ips_elements */
  t_vertex_set b, c;
  t_vertex v;
  t_cell_count index;
  t_long_real p_a = 0.0;
  t_expression *link_expression;
  t_list_ips_elements *link_ips_list;
  t_cell_count FORLIM;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (!P_inset(v, a))
      i[v - MIN_VERTEX] = FIRST_LEVEL;
  }
  P_setdiff(b, delta, a);
  P_setint(c, b, (*model)->id->vertices);
  return_expression_and_ips_list(model, &link_expression, &link_ips_list, !em);
  FORLIM = marginal_dimension(c);
  for (index = 1; index <= FORLIM; index++) {
    p_a += compute_p(i, &(*model)->constant, link_expression, link_ips_list);
    next_marginal_cell(c, i);
  }
  dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
  P_setdiff(c, delta, (*model)->id->vertices);
  P_setint(c, b, c);
  return (p_a * marginal_dimension_real(c));
}  /* compute_m_p */


Static t_long_real compute_m_p_fast(a, i, model)
long *a;
t_level *i;
t_model **model;
{
  t_vertex_set b, c;
  t_vertex v;
  t_cell_count index;
  t_long_real p_a = 0.0;
  t_expression *link_expression;
  t_list_ips_elements *link_ips_list;
  t_product_list *link_prod_list;
  t_v_arr_of_integer levels;
  t_vertex l_a_vertex;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_cell_count FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeMPFast      ", sizeof(pch20));
  /*$endif TRACE*/
  for (v = first_vertex; v <= last_vertex; v++) {
    if (!P_inset(v, a))
      i[v - MIN_VERTEX] = FIRST_LEVEL;
  }
  P_setdiff(b, delta, a);
  P_setint(c, b, (*model)->id->vertices);
  if (false) {
    return_expression_and_ips_list(model, &link_expression, &link_ips_list,
				   !em);
    find_product_list(c, &link_expression, &link_ips_list, &link_prod_list,
		      levels, &l_a_vertex);
    add_to_offsets(link_expression, link_ips_list, (long)FIRST_INDEX);
    FORLIM = marginal_dimension(c);
    for (index = 1; index <= FORLIM; index++) {
      p_a += compute_p_fast(&(*model)->constant, link_expression,
			    link_ips_list);
      next_offset_in_exp_list(&link_expression, &link_ips_list,
			      &link_prod_list, levels, &l_a_vertex, i);
    }
    add_to_offsets(link_expression, link_ips_list, (long)(-FIRST_INDEX));
    dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
    dispose_product_list(&link_prod_list);
  } else {
    return_expression_and_ips_list(model, &link_expression, &link_ips_list,
				   !em);
    FORLIM = marginal_dimension(c);
    for (index = 1; index <= FORLIM; index++) {
      p_a += compute_p(i, &(*model)->constant, link_expression, link_ips_list);
      next_marginal_cell(c, i);
    }
    dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
  }
  P_setdiff(c, delta, (*model)->id->vertices);
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 900L, 1L, -1L, -1L, &p_a);
  ntr_4_sets(tzt, 20L, 900L, 1L, -1L, -1L, delta, (*model)->id->vertices, b,
	     c);
  /*$endif TRACE*/
  P_setint(c, b, c);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 900L, 1L, -1L, -1L, c);
  /*$endif TRACE*/
  return (p_a * marginal_dimension_real(c));
}  /* compute_m_p_fast */


Static t_long_real compute_p_em(i, constant, link_expression, link_ips_list)
t_level *i;
t_long_real *constant;
t_expression *link_expression;
t_list_ips_elements *link_ips_list;
{
  double Result = LONG_MAX;
  t_long_integer count_zero = 0;
  t_long_real p_cell, prob, term;
  t_vertex v;

  p_cell = *constant;
  while (link_expression != NULL) {
    if (em)
      term = p[marginal_hash(link_expression->vertex_set, i) +
	       link_expression->offset];
    else
      term = n[marginal_hash(link_expression->vertex_set, i) +
	       link_expression->offset];
    if (term == 0)
      count_zero += link_expression->factor;
    else
      p_cell *= exp(log(term) * link_expression->factor);
    link_expression = link_expression->pointer;
  }
  while (link_ips_list != NULL) {
    prob = p[link_ips_list->ips_element.p_offset +
	     marginal_hash(link_ips_list->ips_element.a, i)];
    if (prob == 0)
      count_zero++;
    else
      p_cell *= prob;
    link_ips_list = link_ips_list->pointer;
  }
  if (count_zero == 0)
    return p_cell;
  if (count_zero > 0)
    return 0.0;
  write_pch_40_text(report_file, " :: Compute(P(i)):  CountZero = ",
		    42L);
  write_integer_text(report_file, count_zero, 5L);
  write_pch_10_text(report_file, ", i: ", 5L);
  for (v = first_vertex; v <= last_vertex; v++)
    write_level_text(report_file, &i[v - MIN_VERTEX], 3L);
  write_line_text(report_file);
  return Result;
}  /* compute_p_em */


Static t_long_real sub_compute_m_p_em(a, i, model_set, constant,
				      link_expression, link_ips_list)
long *a;
t_level *i;
long *model_set;
t_long_real *constant;
t_expression **link_expression;
t_list_ips_elements **link_ips_list;
{
  t_vertex_set b, c;
  t_vertex v;
  t_cell_count index, FORLIM;
  t_long_real p_a = 0.0;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (!P_inset(v, a))
      i[v - MIN_VERTEX] = FIRST_LEVEL;
  }
  P_setdiff(b, delta, a);
  P_setint(c, b, model_set);
  FORLIM = marginal_dimension(c);
  for (index = 1; index <= FORLIM; index++) {
    p_a += compute_p_em(i, constant, *link_expression, *link_ips_list);
    next_marginal_cell(c, i);
  }
  P_setdiff(c, delta, model_set);
  P_setint(c, b, c);
  return (p_a * marginal_dimension_real(c));
}  /* sub_compute_m_p_em */


Static t_long_real compute_m_p_em(a, i, model)
long *a;
t_level *i;
t_model **model;
{
  double Result;
  t_expression *link_expression;
  t_list_ips_elements *link_ips_list;

  return_expression_and_ips_list(model, &link_expression, &link_ips_list,
				 false);
  Result = sub_compute_m_p_em(a, i, (*model)->id->vertices,
			      &(*model)->constant, &link_expression,
			      &link_ips_list);
  dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
  return Result;
}  /* compute_m_p_em */


Static t_long_real compute_c(i, model)
t_level *i;
t_model **model;
{
  /* ;
  var constant       : t_long_real;
  var link_expression : t_link_expression;
  var link_ips_list   : t_link_list_ips_elements */
  double Result;
  t_long_integer count_zero;
  t_long_real m, sum, term;
  t_expression *link_expression;
  t_list_ips_elements *link_ips_list;

  return_expression_and_ips_list(model, &link_expression, &link_ips_list, !em);
  if (link_ips_list == NULL && !em) {
    count_zero = 0;
    sum = -1.0 / n[0];
    while (link_expression != NULL) {
      if (em)
	term = p[marginal_hash(link_expression->vertex_set, i) +
		 link_expression->offset];
      else
	term = n[marginal_hash(link_expression->vertex_set, i) +
		 link_expression->offset];
      if (term == 0)
	count_zero += link_expression->factor;
      else
	sum -= link_expression->factor / term;
      link_expression = link_expression->pointer;
    }
    if (count_zero == 0) {
      m = n[0] * compute_p_em(i, &(*model)->constant, link_expression,
			      link_ips_list) / (*model)->constant;
      Result = m * (1 - m * sum);
    } else
      Result = _INFINITY_REAL;
  } else
    Result = _INFINITY_REAL;
  dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
  return Result;
}  /* compute_c */


Static t_long_real return_table_value(a, table_type, a_offset, n_total,
				      a_index, i, model_set_offset, model)
long *a;
t_long_integer table_type;
t_offset *a_offset;
t_long_real *n_total;
t_long_integer a_index;
t_level *i;
t_offset *model_set_offset;
t_model **model;
{
  t_vertex v;
  t_vertex_set a_unio, a_comp, b, c;
  t_cell_count index, m_index;
  t_long_real f, n_hat, p_hat, q, q_hat, x = _INFINITY_REAL;
  t_long_real y, c_hat, m_hat;
  boolean zero;
  t_long_integer new_table_type;
  t_expression *link_expression;
  t_list_ips_elements *link_ips_list;
  t_cell_count FORLIM;

  if (mixed_data && table_type != 0) {
    if ((*model)->id->model_type != pure_discrete)
      note_mixed(stdout, " ReturnTableValue", 17L);
  }
  new_table_type = table_type & (MAX_NUMBER_OF_TABLE_VALUES - 1);
  if (incomplete_table && MAX_NUMBER_OF_TABLE_VALUES <= table_type &&
      table_type <= MAX_NUMBER_OF_TABLE_VALUES * 2 - 2)
    zero = marginal_zero_cell(a, i, q_tables_offsets);
  else
    zero = false;
  if (zero)
    x = _INFINITY_REAL;
  else if (new_table_type < 4) {
    switch (new_table_type) {

    case 0:
      if (em)
	x = p[a_index + *a_offset];
      else
	x = n[a_index + *a_offset];
      break;

    case 1:
      if (em)
	x = compute_m_p_em(a, i, model);
      else
	x = compute_m_p_fast(a, i, model);
      break;

    case 2:
      if (em)
	x = compute_m_p_em(a, i, model) * *n_total;
      else
	x = compute_m_p_fast(a, i, model) * *n_total;
      break;

    case 3:
      if (em)
	x = compute_m_p_em(a, i, model) * *n_total - p[a_index + *a_offset];
      else
	x = compute_m_p_fast(a, i, model) * *n_total - n[a_index + *a_offset];
      break;
    }
  } else if (new_table_type == 14)
    x = a_index;
  else if (table_type == 15) {
    if (boolean_option[126])
      x = return_marginal_q_cell(a, i, q_tables_offsets);
    else if (marginal_zero_cell(a, i, q_tables_offsets))
      x = 0.0;
    else
      x = 1.0;
  } else if (table_type == MAX_NUMBER_OF_TABLE_VALUES * 2 - 1) {
    if (marginal_zero_cell(a, i, q_tables_offsets)) {
      if (em)
	x = p[a_index + *a_offset];
      else
	x = n[a_index + *a_offset];
    } else
      x = _INFINITY_REAL;
  } else {
    for (v = first_vertex; v <= last_vertex; v++) {
      if (!P_inset(v, a))
	i[v - MIN_VERTEX] = FIRST_LEVEL;
    }
    x = 0.0;
    P_setdiff(b, delta, a);
    P_setdiff(c, delta, (*model)->id->vertices);
    P_setint(c, b, c);
    P_setunion(a_unio, (*model)->id->vertices, a);
    P_setint(a_comp, b, (*model)->id->vertices);
    f = marginal_dimension_real(c);
    q = 1 / marginal_dimension_real(a_unio);
    FORLIM = marginal_dimension(a_comp);
    for (index = 1; index <= FORLIM; index++) {
      m_index = marginal_hash(a_unio, i);
      return_expression_and_ips_list(model, &link_expression, &link_ips_list,
				     !em);
      if (em)
	q_hat = f * compute_p_em(i, &(*model)->constant, link_expression,
				 link_ips_list);
      else
	q_hat = f * compute_p(i, &(*model)->constant, link_expression,
			      link_ips_list);
      dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
      if (em)
	n_hat = p[m_index + *model_set_offset];
      else
	n_hat = n[m_index + *model_set_offset];
      switch (new_table_type) {

      case 4:
	p_hat = n_hat / *n_total;
	if (p_hat == 0 || p_hat == 1)
	  y = _INFINITY_REAL;
	else
	  y = sqrt(*n_total) * (p_hat - q_hat) / sqrt(p_hat * (1 - p_hat));
	break;

      case 5:
	p_hat = n_hat / *n_total;
	if (q_hat == 0 || q_hat == 1)
	  y = _INFINITY_REAL;
	else
	  y = sqrt(*n_total) * (p_hat - q_hat) / sqrt(q_hat * (1 - q_hat));
	break;

      case 6:
	if (q_hat == 0 || q_hat == 1)
	  y = _INFINITY_REAL;
	else
	  y = sqrt(*n_total) * (q_hat - q) / sqrt(q_hat * (1 - q_hat));
	break;

      case 7:
	if (q == 0 || q == 1)
	  y = _INFINITY_REAL;
	else
	  y = sqrt(*n_total) * (q_hat - q) / sqrt(q * (1 - q));
	break;

      case 8:
	m_hat = q_hat * *n_total;
	c_hat = compute_c(i, model);
	/*
	                   link_expression,
	                   link_ips_list */
	if ((c_hat == 0) | is_infinity_real(c_hat))
	  y = _INFINITY_REAL;
	else
	  y = (n_hat - m_hat) / sqrt(c_hat);
	break;

      case 16:
	c_hat = compute_c(i, model);
	/*
	                   link_expression,
	                   link_ips_list */
	if (is_infinity_real(c_hat))
	  y = _INFINITY_REAL;
	else
	  y = c_hat;
	break;

      case 9:
	m_hat = q_hat * *n_total;
	if (m_hat == 0)
	  y = _INFINITY_REAL;
	else
	  y = (n_hat - m_hat) / sqrt(m_hat);
	break;

      case 10:
	m_hat = q_hat * *n_total;
	if (n_hat == 0)
	  y = 0.0;
	else if (m_hat == 0)
	  y = _INFINITY_REAL;
	else
	  y = 2 * n_hat * log(n_hat / m_hat);
	break;

      case 11:
	y = sqrt(n_hat) + sqrt(n_hat + 1) - sqrt(4 * q_hat * *n_total + 1);
	break;

      case 12:
	y = 2 * (sqrt(n_hat) - sqrt(q_hat * *n_total));
	break;

      case 13:
	m_hat = q_hat * *n_total;
	if (n_hat == 0)
	  y = 0.0;
	else if (m_hat == 0)
	  y = _INFINITY_REAL;
	else
	  y = 2 / (lambda * (lambda + 1)) * n_hat *
	      (exp(log(n_hat / m_hat) * lambda) - 1);
	break;
      }
      next_marginal_cell(a_comp, i);
      if (is_infinity_real(y))
	x = _INFINITY_REAL;
      else if (!is_infinity_real(x))
	x += y;
    }
  }
  if (fabs(x) < ROUND_ERROR * *n_total && new_table_type >= 3)
    x = 0.0;
  return x;
}  /* return_table_value */


/*@+"table.p"*/

/*

  910:    +++  ++
  911:    +++  ++
  912:    ---  -- p/table.p          1       4      46 p/table.p
  913: |    3:    procedure print_table
  914:    +++  ++
  915:    +++  ++

*/

Static Void print_table(a, p, table_type, log_trans, percent, permuted,
			a_set_offset, n_total, model_set_offset, model)
long *a;
t_vertex_list *p;
t_long_integer table_type;
boolean log_trans, percent, permuted;
t_offset *a_set_offset;
t_long_real n_total;
t_offset *model_set_offset;
t_model **model;
{
  t_vertex v;
  t_vertex_set b;
  t_cell_index l[MAX_DIMENSION + 1];
  t_vertex_name vn[MAX_DIMENSION + 1];
  t_long_integer a1 = 0, a2 = 0;
  t_long_integer ww, i, ii, j, k, card;
  t_cell cell;
  t_long_real x;
  t_vertex_list *q;
  long FORLIM1;

  if (mixed_data && table_type != 0) {
    if ((*model)->id->model_type != pure_discrete)
      note_mixed(stdout, " PrintTable", 11L);
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 913L, 0L)) {
    write_integer(stdout, *a_set_offset, width);
    write_integer(stdout, *model_set_offset, width);
    write_line(stdout);
  }
  /*$endif TRACE*/
  card = cardinality(a);
  l[0] = 1;
  ww = labs(width);
  v = first_vertex;
  if (permuted) {
    P_setcpy(b, empty_set);
    q = NULL;
    while (p != NULL) {
      if (!P_inset(p->vertex, b)) {
	P_addset(b, p->vertex);
	insert_vertex_in_vertex_list(p->vertex, &q);
      }
      p = p->pointer;
    }
    revers_vertex_list(&q);
    p = q;
    while (q != NULL && a1 + a2 != card) {
      if (a1 < (card + 1) / 2 &&
	  (ww + 1) * variable_description[q->vertex - MIN_VERTEX]->
		     UU.U0.levels < line_length - (card - a1) * 3) {
	a1++;
	ww = (ww + 1) * variable_description[q->vertex - MIN_VERTEX]->UU.U0.levels;
      } else
	a2++;
      l[a1 + a2] = l[a1 + a2 - 1] *
		   variable_description[q->vertex - MIN_VERTEX]->UU.U0.levels;
      vn[a1 + a2] = variable_description[q->vertex - MIN_VERTEX]->name;
      q = q->pointer;
    }
  } else {
    while (v <= last_vertex && a1 + a2 != card) {
      if (P_inset(v, a)) {
	if (a1 < (card + 1) / 2 &&
	    (ww + 1) * variable_description[v - MIN_VERTEX]->UU.U0.levels <
	    line_length - (card - a1) * 3) {
	  a1++;
	  ww = (ww + 1) * variable_description[v - MIN_VERTEX]->UU.U0.levels;
	} else
	  a2++;
	l[a1 + a2] = l[a1 + a2 - 1] * variable_description[v - MIN_VERTEX]->
				      UU.U0.levels;
	vn[a1 + a2] = variable_description[v - MIN_VERTEX]->name;
      }
      if (v != last_vertex)
	v++;
    }
  }
  l[a1 + a2 + 1] = l[a1 + a2] * 2;
  write_space(stdout, 1L);
  if (permuted)
    print_vertex_list(p);
  else
    print_vertex_set(a);
  write_line(stdout);
  write_line(stdout);
  if (card != 0) {
    for (j = a1; j >= 1; j--) {
      for (k = 1; k <= a2; k++)
	write_space(stdout, 3L);
      write_char(stdout, ' ');
      write_char(stdout, vn[j]);
      write_char(stdout, ' ');
      FORLIM1 = l[a1];
      for (i = 1; i <= FORLIM1; i++) {
	if (i % l[j-1] == 0)
	  write_integer(stdout, (i - l[j-1]) % l[j] / l[j-1] + 1, width);
	else
	  write_space(stdout, width);
	for (k = 1; k <= a1; k++) {
	  if (i % l[k] == 0)
	    write_char(stdout, ' ');
	}
      }
      write_line(stdout);
    }
  }
  for (j = a2; j >= 1; j--) {
    write_space(stdout, 2L);
    write_char(stdout, vn[a1 + j]);
  }
  write_line(stdout);
  write_line(stdout);
  memcpy(cell, first_cell, sizeof(t_cell));
  FORLIM1 = marginal_dimension(a);
  for (i = 1; i <= FORLIM1; i++) {
    if ((i - 1) % l[a1] == 0) {
      for (j = a2; j >= 1; j--) {
	if ((i - 1) % l[a1 + j - 1] == 0)
	  write_integer(stdout, (i - 1) % l[a1 + j] / l[a1 + j - 1] + 1, 3L);
	else
	  write_space(stdout, 3L);
      }
      write_space(stdout, 3L);
    }
    if (permuted)
      ii = marginal_hash(a, cell);
    else
      ii = i - 1;
    x = return_table_value(a, table_type, a_set_offset, &n_total, ii, cell,
			   model_set_offset, model);
    if (permuted)
      next_marginal_cell_list(p, cell);
    else if (table_type != 0)
      next_marginal_cell(a, cell);
    if (is_infinity_real(x) || x <= 0 && log_trans) {
      write_space(stdout, labs(width) - 1);
      write_char(stdout, '-');
    } else {
      if (log_trans)
	x = log_10(x);
      if (percent) {
	if (n[ii + *a_set_offset] == 0)
	  write_integer(stdout, 0L, width);
	else
	  write_real(stdout, x, width, decexpt);
      } else if ((table_type & (MAX_NUMBER_OF_TABLE_VALUES - 1)) < 3) {
	switch (table_type & (MAX_NUMBER_OF_TABLE_VALUES - 1)) {

	case 0:
	  if (log_trans || em)
	    write_real(stdout, x, width, decdiff);
	  else
	    write_integer(stdout, (long)floor(x + 0.5), width);
	  break;

	case 1:
	  write_real(stdout, x, width, decprob);
	  break;

	case 2:
	  write_real(stdout, x, width, decexpt);
	  break;
	}
      } else if (table_type == MAX_NUMBER_OF_TABLE_VALUES * 2 - 1 && !em)
	write_integer(stdout, (long)floor(x + 0.5), width);
      else
	write_real(stdout, x, width, decdiff);
    }
    for (j = 1; j <= a1; j++) {
      if (i % l[j] == 0)
	write_char(stdout, ' ');
    }
    if (i != marginal_dimension(a)) {
      for (j = 0; j < a2; j++) {
	if (i % l[a1 + j] == 0)
	  write_line(stdout);
      }
    }
  }
  write_line(stdout);
  write_line(stdout);
  if (permuted)
    dispose_vertex_list(&p);
}  /* print_table */


/*@+"covariance.p"*/


/*

  916:    +++  ++
  917:    +++  ++
  918:    ---  -- p/covariance.p      16      88     841 p/covariance.p
  919: |    4:    - procedure init_sm_index
  920: |   13:    procedure init_half_sqr_array
  921: |   21:    function sm_index_new
  922: |   51:    function sm_index_old
  923: |   70:    function sm_index
  924: |   75:    procedure get_p_discrete
  925: |   98:    procedure print_covariance
  926: |  236:    procedure print_ssd_list
  927: |  451:    procedure move_to_table
  928: |  505:    procedure print_ssd_table
  929: |  571:    procedure return_ssd
  930: |  638:    procedure print_ssd
  931: |  680:    procedure write_headed_ssd
  932: |  708:    procedure sub_find_the_covariance
  933: |  840:    procedure trace_covariance
  934: |  896:    procedure trace_1
  935:    +++  ++
  936:    +++  ++

*/

/* Not used:
procedure init_sm_index(mm : t_integer);
var
   i, n: t_integer;
begin
   for n := 1 to mm do
      for i := 0 to n-1 do
         sm_index[n, i] := i * (n - (i + 1) / 2)
end; */
/* init_sm_index */

Static Void init_half_sqr_array(n)
t_integer n;
{
  t_integer j;

  for (j = 0; j < n; j++)
    half_sqr_array[j] = j * (j + 1) / 2;
}  /* init_sm_index */


Static t_integer sm_index_new(i, j, n)
t_integer i, j, n;
{

  /*
> matrix(f(4)[,3],ncol=4)
       [,1] [,2] [,3] [,4]
[1,]    0    1    3    6
[2,]   -1    2    4    7
[3,]   -1   -1    5    8
[4,]   -1   -1   -1    9
>
  */
  if (n < 3) {
    if (n == 1)
      return 0;
    else
      return (i + j);
  } else if (j < i)
    return (sm_index_new(j, i, n));
  else {
    /* sm_index := round(i * (n - (i + 1) / 2) + j) */
    /* 16.483secs. 16.533secs. 16.550secs. 16.600secs. */
    /* sm_index := round(j * (j + 1) / 2 + i) */
    /* 16.200secs. 16.200secs. 16.200secs. 16.300secs. */
    return (half_sqr_array[j] + i);
    /* 12.300secs. 12.250secs. 12.284secs. 12.250secs. */
    /* 11.983secs. 11.933secs. 12.016secs. 11.984secs. */
  }
}  /* sm_index_new */


Static t_integer sm_index_old(i, j, n)
t_integer i, j, n;
{

  /*
> matrix(g(4)[,3],ncol=4)
       [,1] [,2] [,3] [,4]
[1,]    0    1    2    3
[2,]   -1    4    5    6
[3,]   -1   -1    7    8
[4,]   -1   -1   -1    9
  */
  if (j < i)
    return (sm_index_old(j, i, n));
  else
    return ((long)floor(i * (n - (i + 1.0) / 2) + j + 0.5));
}  /* sm_index_old */


Static t_integer sm_index(i, j, n)
t_integer i, j, n;
{
  return (sm_index_new(i, j, n));
}  /* sm_index */


Static Void get_p_discrete(a, b, p_a, p_b)
long *a, *b;
t_vertex_list **p_a, **p_b;
{
  t_vertex w;
  t_vertex_list *q;

  if (*p_a == NULL) {
    for (w = first_vertex; w <= last_vertex; w++)
      insert_vertex_in_vertex_list(w, p_a);
  }
  q = *p_a;
  *p_b = NULL;
  P_setint(b, a, delta);
  while (q != NULL) {
    if (P_inset(q->vertex, delta)) {
      if (P_inset(q->vertex, b)) {
	insert_vertex_in_vertex_list(q->vertex, p_b);
	P_remset(b, q->vertex);
      }
    }
    q = q->pointer;
  }
  P_setint(b, a, delta);
}  /* get_p_discrete */


Static Void print_covariance(a, n_offset, p_offset, m1, m2, p_a, output_type,
			     permuted)
long *a;
t_offset n_offset, p_offset;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean permuted;
{

  /* Only used in "find_and_print_covariance" at:

       15: begin
              find_covariance(a, n_offset, p_offset, m1, m2, ok);
              if ok then
                 print_covariance(a, n_offset, p_offset, m1, m2, p_a, permuted)
           end

   To be deleted or 'merged' into "print_ssd"

   */

  /* Output_type: 0) All, line; 1) Means; 2) All, Matrix; 3) Only Matrix */
  t_cell_index index;
  t_integer i, j, j_1, j_2;
  t_vertex w1, w2, w;
  t_continuous_vertex v;
  t_vertex_set b;
  t_cell cell;
  t_long_real x;
  t_vertex_list *p_b = NULL;
  /* , r*/
  t_vertex_list *q;
  t_continuous_vertex_set a_continuous;
  long FORLIM;

  if (p_a == NULL) {
    for (w = first_vertex; w <= last_vertex; w++)
      insert_vertex_in_vertex_list(w, &p_a);
  }
  P_setint(b, a, delta);
  if (output_type > 1)
    to_continuous_set(a, a_continuous);
  q = p_a;
  while (q != NULL) {
    if (P_inset(q->vertex, delta))
      insert_vertex_in_vertex_list(q->vertex, &p_b);
    q = q->pointer;
  }
  write_line(stdout);
  for (w = first_vertex; w <= last_vertex; w++) {
    if (P_inset(w, a) & P_inset(w, delta)) {
      write_space(stdout, 2L);
      print_vertex(w);
    }
  }
  write_pch(stdout, " Count", 6L);
  for (w = first_vertex; w <= last_vertex; w++) {
    if (P_inset(w, a) & P_inset(w, gamma_)) {
      write_space(stdout, 1L);
      if (!long_names)
	write_space(stdout, labs(width) - 1);
      print_vertex(w);
    }
  }
  if (output_type == 0) {
    for (w1 = first_vertex; w1 <= last_vertex; w1++) {
      if (P_inset(w1, a) & P_inset(w1, gamma_)) {
	for (w2 = w1; w2 <= last_vertex; w2++) {
	  if (P_inset(w2, a) & P_inset(w2, gamma_)) {
	    if (!long_names)
	      write_space(stdout, labs(width) - 5);
	    write_char(stdout, '<');
	    print_vertex(w1);
	    write_char(stdout, ',');
	    print_vertex(w2);
	    write_char(stdout, '>');
	  }
	}
      }
    }
  }
  write_line(stdout);
  memcpy(cell, first_cell, sizeof(t_cell));
  FORLIM = marginal_dimension(b);
  for (i = 1; i <= FORLIM; i++) {
    for (w = first_vertex; w <= last_vertex; w++) {
      if (P_inset(w, a) & P_inset(w, delta))
	write_integer(stdout, cell[w - MIN_VERTEX] + 1L, 3L);
    }
    if (permuted)
      index = marginal_hash(b, cell);
    else
      index = i - 1;
    if (permuted)
      next_marginal_cell_list(p_b, cell);
    else
      next_marginal_cell(b, cell);
    write_integer(stdout, n[n_offset + index], 6L);
    index = p_offset + index * m2;
    if (output_type == 0)
      j_2 = m2 - 1;
    else
      j_2 = m1 - 1;
    for (j = 0; j <= j_2; j++) {
      x = p[index + j];
      write_space(stdout, 1L);
      if (is_infinity_real(x)) {
	write_space(stdout, labs(width) - 1);
	write_char(stdout, '-');
      } else
	write_real(stdout, x, width, decdiff);
    }
    write_line(stdout);
    if (output_type > 1) {
      j = m1;
      v = first_continuous_vertex;
      while (!P_inset(v, a_continuous) && v <= last_continuous_vertex)
	v++;
      for (j_1 = 0; j_1 < m1; j_1++) {
	for (w = first_vertex; w <= last_vertex; w++) {
	  if (P_inset(w, a) & P_inset(w, delta))
	    write_space(stdout, 3L);
	}
	write_space(stdout, 5L);
	print_continuous_vertex(v, width);
	v++;
	while (!P_inset(v, a_continuous) && v <= last_continuous_vertex)
	  v++;
	for (j_2 = 0; j_2 < j_1; j_2++)
	  write_space(stdout, labs(width) + 1);
	for (j_2 = j_1; j_2 < m1; j_2++) {
	  x = p[index + j];
	  j++;
	  write_space(stdout, 1L);
	  if (is_infinity_real(x)) {
	    write_space(stdout, labs(width) - 1);
	    write_char(stdout, '-');
	  } else
	    write_real(stdout, x, width, decdiff);
	}
	write_line(stdout);
      }
    }
  }
  write_line(stdout);
  write_line(stdout);
  dispose_vertex_list(&p_a);
  dispose_vertex_list(&p_b);
}  /* print_covariance */


Static Void print_ssd_list(a, n_offset, s_offset, s, m1, m2, p_a, output_type,
			   permuted, ssd_type, sigma)
long *a;
t_offset n_offset;
t_s_offset s_offset;
t_s_r *s;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean permuted;
t_integer ssd_type;
boolean sigma;
{
  t_integer count, i, j, j_1, j_2;
  t_cell_index index;
  t_vertex w1, w2, w;
  t_continuous_vertex v;
  t_vertex_set b;
  t_cell cell;
  t_long_real x;
  t_vertex_list *p_b;
  t_continuous_vertex_set a_continuous;
  t_discrete_vertex_set a_discrete;
  /*$ifdef TRACE*/
  pch20 tzt;
  long FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PrintSsdList", sizeof(pch20));
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 926L, 1L, 0L, 1L);
  /*$endif TRACE*/
  get_p_discrete(a, b, &p_a, &p_b);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 926L, 1L, 0L, 2L);
  /*$endif TRACE*/
  to_discrete_set(a, a_discrete);
  to_continuous_set(a, a_continuous);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 926L, 1L, 0L, 3L);
  /*$endif TRACE*/
  write_line(stdout);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 926L, 1L, 1L, -1L);
  /*$endif TRACE*/
  for (w = first_discrete_vertex; w <= last_discrete_vertex; w++) {
    /*$ifdef TRACE*/
    ntr(tzt, 13L, 926L, 1L, 1L, (long)w);
    /*$endif TRACE*/
    if (P_inset(w, a_discrete)) {
      write_space(stdout, 2L);
      print_discrete_vertex(w, width);
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 926L, 1L, 0L, 4L);
  /*$endif TRACE*/
  if (long_names)
    write_space(stdout, labs(width) - 1);
  if (output_type < 3)
    write_pch(stdout, " Count", 6L);
  else
    write_pch(stdout, "     \\", 6L);
  for (w = first_continuous_vertex; w <= last_continuous_vertex; w++) {
    if (P_inset(w, a_continuous)) {
      write_space(stdout, 1L);
      if (!long_names)
	write_space(stdout, labs(width) - 1);
      print_continuous_vertex(w, -width);
    }
  }
  if (output_type == 0) {
    for (w1 = first_continuous_vertex; w1 <= last_continuous_vertex; w1++) {
      if (P_inset(w1, a_continuous)) {
	for (w2 = first_continuous_vertex; w2 <= w1; w2++) {
	  /* to last_continuous_vertex */
	  /* sm_index !!! */
	  if (P_inset(w2, a_continuous)) {
	    write_space(stdout, labs(width) - 5);
	    write_char(stdout, '<');
	    print_continuous_vertex(w1, -width);
	    write_char(stdout, ',');
	    print_continuous_vertex(w2, -width);
	    write_char(stdout, '>');
	  }
	}
      }
    }
  }
  if (output_type < 3) {
    write_space(stdout, labs(width) - 4);
    switch (ssd_type) {

    case 1:
      write_pch(stdout, " Det", 4L);
      break;

    case 2:
      write_pch(stdout, "   G", 4L);
      break;

    case 3:
      write_pch(stdout, "   N", 4L);
      break;
    }
  }
  write_line(stdout);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 926L, 1L, 0L, 5L);
  /*$endif TRACE*/
  memcpy(cell, first_cell, sizeof(t_cell));
  FORLIM = marginal_dimension(b);
  for (i = 1; i <= FORLIM; i++) {
    /*$ifdef TRACE*/
    ntr(tzt, 13L, 926L, 4L, i, 1L);
    /*$endif TRACE*/
    for (w = first_vertex; w <= last_vertex; w++) {
      if (P_inset(w, a) & P_inset(w, delta)) {
	write_integer(stdout, cell[w - MIN_VERTEX] + 1L, 3L);
	if (long_names)
	  write_space(stdout, labs(width) - 1);
      }
    }
    if (permuted)
      index = marginal_hash(b, cell);
    else
      index = i - 1;
    if (permuted)
      next_marginal_cell_list(p_b, cell);
    else
      next_marginal_cell(b, cell);
    /*$ifdef TRACE*/
    ntr(tzt, 13L, 926L, 4L, i, 2L);
    /*$endif TRACE*/
    count = n[n_offset + index];
    index = s_offset + index * m2;
    /*$ifdef TRACE*/
    ntr(tzt, 13L, 926L, 4L, i, 3L);
    /*$endif TRACE*/
    if (output_type < 3) {
      /*$ifdef TRACE*/
      ntr(tzt, 13L, 926L, 4L, i, 4L);
      /*$endif TRACE*/
      if (long_names)
	write_space(stdout, labs(width) - 1);
      write_integer(stdout, count, 6L);
      /*$ifdef TRACE*/
      ntr(tzt, 13L, 926L, 4L, i, 5L);
      /*$endif TRACE*/
      if (output_type == 0)
	j_2 = m2 - 2;
      else
	j_2 = m1 - 1;
      /*$ifdef TRACE*/
      ntr(tzt, 13L, 926L, 4L, i, 6L);
      /*$endif TRACE*/
      for (j = 0; j <= j_2; j++) {
	/*$ifdef TRACE*/
	ntr(tzt, 13L, 926L, 6L, index, j);
	/*$endif TRACE*/
	/*$ifdef TRACE-ARRAY*/
	ntr_s_ref(&s, &s_offset, index + j, " PrintSsdList       ", 20L, 926L,
		  1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	x = s->z[index + j];
	/*$ifdef TRACE*/
	ntr(tzt, 13L, 926L, 6L, index, j);
	/*$endif TRACE*/
	if (sigma && j >= m1) {
	  if (count > 0)
	    x /= count;
	  else
	    x = _INVALID_REAL;
	}
	/*$ifdef TRACE*/
	ntr(tzt, 13L, 926L, 6L, index, j);
	/*$endif TRACE*/
	write_space(stdout, 1L);
	if (is_infinity_real(x)) {
	  write_space(stdout, labs(width) - 1);
	  write_char(stdout, '-');
	} else
	  write_real(stdout, x, width, decdiff);
      }
      /*$ifdef TRACE*/
      ntr(tzt, 13L, 926L, 4L, i, 7L);
      /*$endif TRACE*/
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(&s, &s_offset, index + m2 - 1, " PrintSsdList       ", 20L,
		926L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      write_real(stdout, s->z[index + m2 - 1], width, decexpt);
      /*$ifdef TRACE*/
      ntr(tzt, 13L, 926L, 4L, i, 8L);
      /*$endif TRACE*/
      write_line(stdout);
    }
    /*$ifdef TRACE*/
    ntr(tzt, 13L, 926L, 4L, i, 9L);
    /*$endif TRACE*/
    if (output_type > 1) {
      j = m1;
      v = first_continuous_vertex;
      while (!P_inset(v, a_continuous) && v <= last_continuous_vertex)
	v++;
      for (j_1 = 0; j_1 < m1; j_1++) {
	if (j_1 > 0 || output_type < 3) {
	  for (w = first_discrete_vertex; w <= last_discrete_vertex; w++) {
	    if (P_inset(w, a_discrete)) {
	      write_space(stdout, 3L);
	      if (long_names)
		write_space(stdout, labs(width) - 1);
	    }
	  }
	}
	if (output_type == 2)
	  write_space(stdout, 1L);
	else
	  write_space(stdout, 5L);
	print_continuous_vertex(v, width);
	if (output_type == 2)
	  write_space(stdout, 4L);
	for (j_2 = 0; j_2 < j_1; j_2++)
	  write_space(stdout, labs(width) + 1);
	for (j_2 = j_1; j_2 < m1; j_2++) {
	  j = m1 + sm_index(j_1, j_2, m1);   /* sm_index !!! */
	  /*$ifdef TRACE-ARRAY*/
	  ntr_s_ref(&s, &s_offset, index + j, " PrintSsdList       ", 20L,
		    926L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  x = s->z[index + j];
	  if (sigma) {
	    if (count > 0)
	      x /= count;
	    else
	      x = _INVALID_REAL;
	  }
	  j++;
	  write_space(stdout, 1L);
	  if (is_infinity_real(x)) {
	    write_space(stdout, labs(width) - 1);
	    write_char(stdout, '-');
	  } else
	    write_real(stdout, x, width, decdiff);
	}
	write_space(stdout, 1L);
	print_continuous_vertex(v, width);
	write_line(stdout);
	v++;
	while (!P_inset(v, a_continuous) && v <= last_continuous_vertex)
	  v++;
      }
      /*$ifdef TRACE*/
      ntr(tzt, 13L, 926L, 4L, i, 19L);
      /*$endif TRACE*/
    }
  }
  dispose_vertex_list(&p_a);
  dispose_vertex_list(&p_b);
}  /* print_ssd_list */


Static Void move_to_table(b, n_offset, s_offset, s, m1, m2, p_b, permuted,
			  sigma, j)
long *b;
t_offset n_offset;
t_s_offset s_offset;
t_s_r *s;
t_integer m1, m2;
t_vertex_list *p_b;
boolean permuted, sigma;
t_integer *j;
{
  /* a, */
  /* p_a, */
  /* output_type : t_integer; */
  /* ssd_type  : t_integer; */
  t_cell cell;
  t_cell_index index;
  t_integer table_type = 0;
  t_integer count, i;
  t_long_real x;
  boolean tmp_em;
  t_offset k, model_offset;
  t_model *dummy_model;
  long FORLIM;

  memcpy(cell, first_cell, sizeof(t_cell));
  k = fpa;
  FORLIM = marginal_dimension(b);
  for (i = 1; i <= FORLIM; i++) {
    if (permuted)
      index = marginal_hash(b, cell);
    else
      index = i - 1;
    if (permuted)
      next_marginal_cell_list(p_b, cell);
    else
      next_marginal_cell(b, cell);
    count = n[n_offset + index];
    index = s_offset + index * m2;
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(&s, &s_offset, index + *j, " MoveToTable        ", 20L, 927L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    x = s->z[index + *j];
    if (sigma && *j >= m1) {
      if (count > 0)
	x /= count;
      else
	x = _INVALID_REAL;
    }
    p[k] = x;
    k++;
  }
  tmp_em = em;
  em = true;
  k = fpa;
  new_model(&dummy_model);   /* permuted */
  print_table(b, p_b, table_type, false, false, false, &k, (double)n[0],
	      &model_offset, &dummy_model);
  dispose_model_link(&dummy_model);
  em = tmp_em;
  (*j)++;
}  /* move_to_table */


Static Void print_ssd_table(a, n_offset, s_offset, s, m1, m2, p_a,
			    output_type, permuted, ssd_type, sigma)
long *a;
t_offset n_offset;
t_s_offset s_offset;
t_s_r *s;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean permuted;
t_integer ssd_type;
boolean sigma;
{
  t_integer j;
  t_vertex w1, w2, w;
  /* v: t_continuous_vertex; */
  t_vertex_set b;
  /* , q */
  t_vertex_list *p_b;
  t_continuous_vertex_set a_continuous;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PrintSsdTable", sizeof(pch20));
  ntr(tzt, 20L, 928L, 1L, -1L, -1L);
  /*$endif TRACE*/
  get_p_discrete(a, b, &p_a, &p_b);
  to_continuous_set(a, a_continuous);
  j = marginal_dimension(b);
  if (space_in_p_array(j, fpa)) {
    j = 0;
    write_line(stdout);
    for (w = first_continuous_vertex; w <= last_continuous_vertex; w++) {
      if (P_inset(w, a_continuous)) {
	write_char(stdout, ' ');
	write_char(stdout, '<');
	print_continuous_vertex(w, -width);
	write_char(stdout, '>');   /* a, */
	/* p_a, */
	/* output_type, */
	/* ssd_type, */
	move_to_table(b, n_offset, s_offset, s, m1, m2, p_b, permuted, sigma,
		      &j);
      }
    }
    for (w1 = first_continuous_vertex; w1 <= last_continuous_vertex; w1++) {
      if (P_inset(w1, a_continuous)) {
	for (w2 = first_continuous_vertex; w2 <= w1; w2++) {
	  /* to last_continuous_vertex */
	  /* sm_index !!! */
	  if (P_inset(w2, a_continuous)) {
	    write_char(stdout, ' ');
	    write_char(stdout, '<');
	    print_continuous_vertex(w1, -width);
	    write_char(stdout, ',');
	    print_continuous_vertex(w2, -width);
	    write_char(stdout, '>');   /* a, */
	    /* p_a, */
	    /* output_type, */
	    /* ssd_type, */
	    move_to_table(b, n_offset, s_offset, s, m1, m2, p_b, permuted,
			  sigma, &j);
	  }
	}
      }
    }
    if (output_type < 3) {
      switch (ssd_type) {   /* a, */

      case 1:
	write_pch(stdout, " Det", 4L);
	break;

      case 2:
	write_pch(stdout, "   G", 4L);
	break;

      case 3:
	write_pch(stdout, "   N", 4L);
	break;
      }
      /* p_a, */
      /* output_type, */
      /* ssd_type, */
      move_to_table(b, n_offset, s_offset, s, m1, m2, p_b, permuted, sigma,
		    &j);
    }
  }
  dispose_vertex_list(&p_a);
  dispose_vertex_list(&p_b);
}  /* print_ssd_table */


Static Void return_ssd(a, n_offset, s_offset, s, m1, m2, p_a, permuted, sigma,
		       ifail, arg_pos_double, nargs, arg_double)
long *a;
t_offset n_offset;
t_s_offset s_offset;
t_s_r *s;
t_integer m1, m2;
t_vertex_list *p_a;
boolean permuted, sigma;
t_integer *ifail, arg_pos_double;
long **nargs;
double **arg_double;
{
  /* output_type: t_integer; */
  /* ssd_type: t_integer; */
  t_vertex_set b;
  t_vertex_list *p_b;
  t_integer i, j, index, count;
  t_cell cell;
  t_long_real x;
  /*$ifdef TRACE*/
  pch20 tzt;
  long FORLIM;

  /*$endif TRACE*/
  get_p_discrete(a, b, &p_a, &p_b);
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnSsd", sizeof(pch20));
  ntr(tzt, 10L, 929L, 1L, m2, marginal_dimension(b));
  ntr(tzt, 10L, 929L, 2L, -1L, m2 * marginal_dimension(b));
  /*$endif TRACE*/
  if (ok_double_arg(ifail, arg_pos_double, 0L, nargs, arg_double))
    count = (*nargs)[arg_pos_double];
  /*$ifdef TRACE*/
  ntr(tzt, 10L, 929L, 3L, 0L, count);
  /*$endif TRACE*/
  if (count < m2 * marginal_dimension(b))
    return;
  memcpy(cell, first_cell, sizeof(t_cell));
  FORLIM = marginal_dimension(b);
  for (i = 1; i <= FORLIM; i++) {
    if (permuted)
      index = marginal_hash(b, cell);
    else
      index = i - 1;
    if (permuted)
      next_marginal_cell_list(p_b, cell);
    else
      next_marginal_cell(b, cell);
    count = n[n_offset + index];
    index = s_offset + index * m2;
    for (j = 0; j < m2; j++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(&s, &s_offset, index + j, " ReturnSsd          ", 20L, 929L,
		1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      x = s->z[index + j];
      if (sigma && j > m1) {
	if (count > 0)
	  x /= count;
	else
	  x = _INVALID_REAL;
      }
      if (is_infinity_real(x))
	x = my_var_na_float;
      /*$ifdef TRACE*/
      ntr_real(tzt, 10L, 929L, 7L, i, (i - 1) * m2 - FIRST_INDEX + j, &x);
      /*$endif TRACE*/
      (*arg_double)[(i - 1) * m2 - FIRST_INDEX + j] = x;
    }
  }
}  /* return_ssd */


Static Void print_ssd(a, n_offset, s_offset, s, m1, m2, p_a, output_type,
		      table, permuted, ssd_type, sigma)
long *a;
t_offset n_offset;
t_s_offset s_offset;
t_s_r *s;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean table, permuted;
t_integer ssd_type;
boolean sigma;
{

  /* Output_type:

          A 0) All, line;
          B 1) ``Means'', G;
          C 2) All, Matrix (probit, matrix);
          D 3) Only Matrix

               | 2 Canonical    |  6 Moments       |  9 Raw Moments         |
     Discrete  | 3 Gs           |    Probabilities |    Counts,             |
     Linear    | 4 Hs           |  7 Means         | 10 Totals,             | 1) ``Means''
     Quadratic | 5 Ks           |  8 Covariance,   | 11 SS, 12 Sigma = Ssd, | 3) Only matrix
     Extra     |                | 13 Determinants, | 13 Determinants,       |

   SS =  uncorrected sums of squares and products
   Ssd = sums of square differences
   Cov = Variance / Covariance, sums of square differences divided by count

   */

  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PrintSsd ", sizeof(pch20));
  ntr(tzt, 10L, 930L, 1L, -1L, -1L);
  ntr_set(tzt, 20L, 930L, 1L, -1L, -2L, a);
  /*$endif TRACE*/
  if (table)
    print_ssd_table(a, n_offset, s_offset, s, m1, m2, p_a, output_type,
		    permuted, ssd_type, sigma);
  else
    print_ssd_list(a, n_offset, s_offset, s, m1, m2, p_a, output_type,
		   permuted, ssd_type, sigma);
}  /*print_ssd*/


Static Void write_empty_ssd(a, n_offset, s_offset, s, m1, m2, p_a,
			    output_type, table, permuted, ssd_type, sigma)
long *a;
t_offset n_offset;
t_s_offset s_offset;
t_s_r **s;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean table, permuted;
t_integer ssd_type;
boolean sigma;
{
  write_pch(stdout, " Empty SSD!", 11L);
}  /* write_empty_ssd */


Static Void print_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a, output_type,
			table, permuted, ssd_type, sigma)
long *a;
t_offset n_offset;
t_s_offset s_offset;
t_s_r *s;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean table, permuted;
t_integer ssd_type;
boolean sigma;
{
  if (s != NULL)
    print_ssd(a, n_offset, s_offset, s, m1, m2, p_a, output_type, table,
	      permuted, ssd_type, sigma);
  else
    write_empty_ssd(a, n_offset, s_offset, &s, m1, m2, p_a, output_type,
		    table, permuted, ssd_type, sigma);
}  /* print_ssd_s */


Static Void print_ssd_ss(a, n_offset, ss_offset, ss, m1, m2, p_a, output_type,
			 table, permuted, ssd_type, sigma)
long *a;
t_offset n_offset;
t_ss_offset ss_offset;
t_ss_r **ss;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean table, permuted;
t_integer ssd_type;
boolean sigma;
{
  t_s_offset s_offset = ss_offset;
  t_s_r *s = NULL;

  if (*ss == NULL) {
    write_empty_ssd(a, n_offset, s_offset, &s, m1, m2, p_a, output_type,
		    table, permuted, ssd_type, sigma);
    return;
  }
  s = (t_s_r *)Malloc(sizeof(t_s_r));
  if (s == NULL)
    _OutMem();
  /*$ifdef CAST*/
  s->z = (*ss)->z;   /* Cast of T_SS to T_S. */
  /*$endif CAST*/
  print_ssd(a, n_offset, s_offset, s, m1, m2, p_a, output_type, table,
	    permuted, ssd_type, sigma);
  _Free(s);
}  /* print_ssd_ss */


Static Void print_ssd_r(a, n_offset, r_offset, r, m1, m2, p_a, output_type,
			table, permuted, ssd_type, sigma)
long *a;
t_offset n_offset;
t_r_offset r_offset;
t_r_r *r;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean table, permuted;
t_integer ssd_type;
boolean sigma;
{
  t_s_offset s_offset = r_offset;
  t_s_r *s = NULL;

  if (r == NULL) {
    write_empty_ssd(a, n_offset, s_offset, &s, m1, m2, p_a, output_type,
		    table, permuted, ssd_type, sigma);
    return;
  }
  s = (t_s_r *)Malloc(sizeof(t_s_r));
  if (s == NULL)
    _OutMem();
  /*$ifdef CAST*/
  s->z = r->z;   /* Cast of T_R to T_S. */
  /*$endif CAST*/
  print_ssd(a, n_offset, s_offset, s, m1, m2, p_a, output_type, table,
	    permuted, ssd_type, sigma);
  _Free(s);
}  /* print_ssd_r */


Static Void print_ssd_t(a, n_offset, t_offset_, t, m1, m2, p_a, output_type,
			table, permuted, ssd_type, sigma)
long *a;
t_offset n_offset;
t_t_offset t_offset_;
t_t_r *t;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean table, permuted;
t_integer ssd_type;
boolean sigma;
{
  t_s_offset s_offset = t_offset_;
  t_s_r *s = NULL;

  if (t == NULL) {
    write_empty_ssd(a, n_offset, s_offset, &s, m1, m2, p_a, output_type,
		    table, permuted, ssd_type, sigma);
    return;
  }
  s = (t_s_r *)Malloc(sizeof(t_s_r));
  if (s == NULL)
    _OutMem();
  /*$ifdef CAST*/
  s->z = t->z;   /* Cast of T_T to T_S. */
  /*$endif CAST*/
  print_ssd(a, n_offset, s_offset, s, m1, m2, p_a, output_type, table,
	    permuted, ssd_type, sigma);
  _Free(s);
}  /* print_ssd_t */


Static Void write_headed_ssd_s(text, w, a, n_offset, s_offset, s, m1, m2, p_a,
			       permuted, ssd_type, sigma)
Char *text;
t_integer w;
long *a;
t_offset n_offset;
t_s_offset s_offset;
t_s_r **s;
t_integer m1, m2;
t_vertex_list *p_a;
boolean permuted;
t_integer ssd_type;
boolean sigma;
{
  boolean ok;
  t_vertex_set b;

  write_pch(stdout, text, w);
  write_space(stdout, 20 - w);
  write_integer(stdout, n_offset, 4L);
  if (n_offset == -1) {
    P_setint(b, a, delta);
    n_offset = return_offset(b, &ok);
  }
  write_integer(stdout, n_offset, 4L);
  write_integer(stdout, s_offset, 4L);
  print_ssd_s(a, n_offset, s_offset, *s, m1, m2, p_a, 2L, false, permuted,
	      ssd_type, sigma);
}  /* write_headed_ssd_s */


Static Void write_headed_ssd_ss(text, w, a, n_offset, s_offset, s, m1, m2,
				p_a, permuted, ssd_type, sigma)
Char *text;
t_integer w;
long *a;
t_offset n_offset;
t_ss_offset s_offset;
t_ss_r **s;
t_integer m1, m2;
t_vertex_list *p_a;
boolean permuted;
t_integer ssd_type;
boolean sigma;
{
  boolean ok;
  t_vertex_set b;

  write_pch(stdout, text, w);
  write_space(stdout, 20 - w);
  write_integer(stdout, n_offset, 4L);
  if (n_offset == -1) {
    P_setint(b, a, delta);
    n_offset = return_offset(b, &ok);
  }
  write_integer(stdout, n_offset, 4L);
  write_integer(stdout, s_offset, 4L);
  print_ssd_ss(a, n_offset, s_offset, s, m1, m2, p_a, 2L, false, permuted,
	       ssd_type, sigma);
}  /* write_headed_ssd_ss */


/* Not used:
procedure write_headed_ssd_r( text  : pch40;
                                 w  : t_integer;
                             var a  : t_vertex_set;
                                 n_offset : t_offset;
                                 s_offset : t_r_offset ;
                             var s  : t_r ;
                                 m1, m2  : t_integer;
                                 p_a  : t_link_vertex_list;
                                 permuted : boolean;
                                 ssd_type : t_integer;
                                 sigma  : boolean);
var
   ok: boolean;
   b: t_vertex_set;
begin
   write_pch(output, text, w);
   write_space(output, 20 - w);
   write_integer(output, n_offset, 4);
   if n_offset = -1 then begin
      b := a * delta;
      n_offset := return_offset(b, ok)
   end;
   write_integer(output, n_offset, 4);
   write_integer(output, s_offset, 4);
   print_ssd_r(a, n_offset, s_offset, s, m1, m2, p_a,
               2, false, permuted, ssd_type, sigma)
end; */
/* write_headed_ssd_r */

Static Void write_headed_ssd_t(text, w, a, n_offset, s_offset, s, m1, m2, p_a,
			       permuted, ssd_type, sigma)
Char *text;
t_integer w;
long *a;
t_offset n_offset;
t_t_offset s_offset;
t_t_r **s;
t_integer m1, m2;
t_vertex_list *p_a;
boolean permuted;
t_integer ssd_type;
boolean sigma;
{
  boolean ok;
  t_vertex_set b;

  write_pch(stdout, text, w);
  write_space(stdout, 20 - w);
  write_integer(stdout, n_offset, 4L);
  if (n_offset == -1) {
    P_setint(b, a, delta);
    n_offset = return_offset(b, &ok);
  }
  write_integer(stdout, n_offset, 4L);
  write_integer(stdout, s_offset, 4L);
  print_ssd_t(a, n_offset, s_offset, *s, m1, m2, p_a, 2L, false, permuted,
	      ssd_type, sigma);
}  /* write_headed_ssd_t */


Static Void sub_find_the_covariance_s(a, n_offset, s_offset, s, m1, m2,
				      find_ssd)
long *a;
t_offset *n_offset, *s_offset;
t_s_r **s;
t_integer *m1, *m2;
boolean find_ssd;
{
  t_cell_index index;
  t_integer count, case_number, i, j, j1, j2;
  /* w    : t_vertex; */
  t_continuous_vertex v1, v2;
  t_vertex_set b;
  t_discrete_vertex_set a_discrete;
  t_continuous_vertex_set a_continuous;
  t_item_list *p_item_list;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubFindTheCovarian ", sizeof(pch20));
  /*$endif TRACE*/
  P_setint(b, a, delta);
  to_discrete_set(a, a_discrete);
  to_continuous_set(a, a_continuous);
  if (item_list == NULL)
    return;
  for (index = *s_offset; index <=
	 *s_offset + *m2 * (last_index(b) - FIRST_INDEX + 1) - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ass(s, s_offset, index, 0.0, tzt, 20L, 932L, 0L);
    /*$endif TRACE-ARRAY*/
    (*s)->z[index] = 0.0;
  }
  p_item_list = item_list;
  for (case_number = 1; case_number <= n[0]; case_number++) {
    index = discrete_marginal_hash(a_discrete,
				   p_item_list->item.integer_vector);
    index = *s_offset + index * *m2;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 883L, 1L, -1L, index);
    /*$endif TRACE*/
    for (v1 = first_continuous_vertex; v1 <= last_continuous_vertex; v1++) {
      if (P_inset(v1, a_continuous)) {
	/*$ifdef TRACE*/
	ntr_real(tzt, 20L, 883L, 1L, -1L, index, &(*s)->z[index]);   /* ntr */
	/*$endif TRACE*/
	/*$ifdef TRACE-ARRAY*/
	ntr_s_upd(s, s_offset, index,
		  p_item_list->item.real_vector[v1 - MIN_VERTEX], 1L, tzt,
		  20L, 932L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*s)->z[index] += p_item_list->item.real_vector[v1 - MIN_VERTEX];
	/*$ifdef TRACE*/
	ntr_short_real(tzt, 20L, 883L, 1L, -1L, index,
		       &p_item_list->item.real_vector[v1 - MIN_VERTEX]);
	    /*ntr*/
	ntr_real(tzt, 20L, 883L, 1L, -1L, index, &(*s)->z[index]);
	/*$endif TRACE*/
	index++;
      }
    }
    if (!find_ssd) {
      for (v1 = first_continuous_vertex; v1 <= last_continuous_vertex; v1++) {
	if (P_inset(v1, a_continuous)) {
	  for (v2 = first_continuous_vertex; v2 <= v1; v2++) {
	    /* to last_continuous_vertex */
	    /* sm_index !!! */
	    if (P_inset(v2, a_continuous)) {   /* ntr */
	      ntr_s_upd(s, s_offset, index,
			p_item_list->item.real_vector[v1 - MIN_VERTEX] *
			p_item_list->item.real_vector[v2 - MIN_VERTEX], 1L,
			tzt, 20L, 932L, 1L);
		  /* ntr */
	      /*$endif TRACE-ARRAY*/
	      (*s)->z[index] += p_item_list->item.real_vector[v1 - MIN_VERTEX] *
		  p_item_list->item.real_vector[v2 - MIN_VERTEX];
	      index++;
	    }
	    /*$ifdef TRACE-ARRAY*/
	    /* ntr */
	  }
	}
      }
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ass(s, s_offset, index, _INVALID_REAL, tzt, 20L, 932L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*s)->z[index] = _INVALID_REAL;
    }
    p_item_list = p_item_list->pointer;
  }
  if (!find_ssd)
    return;
  for (i = 0; i < marginal_dimension(b); i++) {
    index = i;
    count = n[*n_offset + index];
    index = *s_offset + index * *m2;
    for (j = index; j < index + *m1; j++) {
      /*$ifdef TRACE-ARRAY*/
      if (count != 0)   /* ntr */
	ntr_s_upd(s, s_offset, index, (double)count, -3L, tzt, 20L, 932L, 1L);
      else
	ntr_s_ass(s, s_offset, j, _INVALID_REAL, tzt, 20L, 932L, 1L);
      /* ntr */
      /*$endif TRACE-ARRAY*/
      if (count != 0)
	(*s)->z[j] /= count;
      else
	(*s)->z[j] = _INVALID_REAL;
    }
  }
  p_item_list = item_list;
  for (case_number = 1; case_number <= n[0]; case_number++) {
    index = discrete_marginal_hash(a_discrete,
				   p_item_list->item.integer_vector);
    index = *s_offset + index * *m2;
    j = index + *m1;
    j1 = index;
    for (v1 = first_continuous_vertex; v1 <= last_continuous_vertex; v1++) {
      if (P_inset(v1, a_continuous)) {
	/* j2 := j1; */
	/* sm_index !!! */
	j2 = index;
	for (v2 = first_continuous_vertex; v2 <= v1; v2++) {
	  /* to last_continuous_vertex */
	  /* sm_index !!! */
	  if (P_inset(v2, a_continuous)) {
	    /*$ifdef TRACE-ARRAY*/
	    ntr_s_ref(s, s_offset, j1, tzt, 20L, 932L, 1L);
	    ntr_s_ref(s, s_offset, j2, tzt, 20L, 932L, 1L);   /* ntr */
	    /* ntr */
	    ntr_s_upd(s, s_offset, j,
	      (p_item_list->item.real_vector[v1 - MIN_VERTEX] - (*s)->z[j1]) *
	      (p_item_list->item.real_vector[v2 - MIN_VERTEX] - (*s)->z[j2]),
	      1L, tzt, 20L, 932L, 1L);
		/* ntr */
	    /*$endif TRACE-ARRAY*/
	    (*s)->z[j] +=
	      (p_item_list->item.real_vector[v1 - MIN_VERTEX] - (*s)->z[j1]) *
	      (p_item_list->item.real_vector[v2 - MIN_VERTEX] - (*s)->z[j2]);
	    j2++;
	    j++;
	  }
	}
	j1++;
      }
    }
    p_item_list = p_item_list->pointer;
  }
  for (i = 0; i < marginal_dimension(b); i++) {
    index = i;
    count = n[*n_offset + index];
    index = *s_offset + index * *m2;
    for (j = index + *m1; j <= index + *m2 - 2; j++) {
      /*$ifdef TRACE-ARRAY*/
      if (count > 1)   /* ntr */
	ntr_s_upd(s, s_offset, index, 1.0, 3L, tzt, 20L, 932L, 1L);
      else
	ntr_s_ass(s, s_offset, j, _INVALID_REAL, tzt, 20L, 932L, 1L);
      /* ntr */
      /*$endif TRACE-ARRAY*/
      if (count <= 1) {
	/* if boolean_option[110] then */
	/* else
	     s^.z^[j] := s^.z^[j]  / (count-1) */
	(*s)->z[j] = _INVALID_REAL;
      }
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ass(s, s_offset, index + *m2 - 1, _INVALID_REAL, tzt, 20L, 932L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*s)->z[index + *m2 - 1] = _INVALID_REAL;
  }
}  /* sub_find_the_covariance_s */


Static Void sub_find_the_covariance_ss(a, n_offset, s_offset, s, m1, m2,
				       find_ssd)
long *a;
t_offset *n_offset, *s_offset;
t_ss_r **s;
t_integer *m1, *m2;
boolean find_ssd;
{
  t_cell_index index;
  t_integer count, case_number, i, j, j1, j2;
  /* w    : t_vertex; */
  t_continuous_vertex v1, v2;
  t_vertex_set b;
  t_discrete_vertex_set a_discrete;
  t_continuous_vertex_set a_continuous;
  t_item_list *p_item_list;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubFindTheCovariSS ", sizeof(pch20));
  /*$endif TRACE*/
  P_setint(b, a, delta);
  to_discrete_set(a, a_discrete);
  to_continuous_set(a, a_continuous);
  if (item_list == NULL)
    return;
  for (index = *s_offset; index <=
	 *s_offset + *m2 * (last_index(b) - FIRST_INDEX + 1) - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_ss_ref(s, s_offset, index, tzt, 20L, 933L, 1L);
    /*$endif TRACE-ARRAY*/
    (*s)->z[index] = 0.0;
  }
  p_item_list = item_list;
  for (case_number = 1; case_number <= n[0]; case_number++) {
    index = discrete_marginal_hash(a_discrete,
				   p_item_list->item.integer_vector);
    index = *s_offset + index * *m2;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 883L, 1L, -1L, index);
    /*$endif TRACE*/
    for (v1 = first_continuous_vertex; v1 <= last_continuous_vertex; v1++) {
      if (P_inset(v1, a_continuous)) {
	/*$ifdef TRACE*/
	ntr_real(tzt, 20L, 883L, 1L, -1L, index, &(*s)->z[index]);   /* ntr */
	/*$endif TRACE*/
	/*$ifdef TRACE-ARRAY*/
	ntr_ss_upd(s, s_offset, index,
		   p_item_list->item.real_vector[v1 - MIN_VERTEX], 1L, tzt,
		   20L, 933L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*s)->z[index] += p_item_list->item.real_vector[v1 - MIN_VERTEX];
	/*$ifdef TRACE*/
	ntr_short_real(tzt, 20L, 883L, 1L, -1L, index,
		       &p_item_list->item.real_vector[v1 - MIN_VERTEX]);
	    /*ntr*/
	ntr_real(tzt, 20L, 883L, 1L, -1L, index, &(*s)->z[index]);
	/*$endif TRACE*/
	index++;
      }
    }
    if (!find_ssd) {
      for (v1 = first_continuous_vertex; v1 <= last_continuous_vertex; v1++) {
	if (P_inset(v1, a_continuous)) {
	  for (v2 = first_continuous_vertex; v2 <= v1; v2++) {
	    /* to last_continuous_vertex */
	    /* sm_index !!! */
	    if (P_inset(v2, a_continuous)) {   /* ntr */
	      ntr_ss_upd(s, s_offset, index,
			 p_item_list->item.real_vector[v1 - MIN_VERTEX] *
			 p_item_list->item.real_vector[v2 - MIN_VERTEX], 1L,
			 tzt, 20L, 933L, 1L);
		  /* ntr */
	      /*$endif TRACE-ARRAY*/
	      (*s)->z[index] += p_item_list->item.real_vector[v1 - MIN_VERTEX] *
		  p_item_list->item.real_vector[v2 - MIN_VERTEX];
	      index++;
	    }
	    /*$ifdef TRACE-ARRAY*/
	    /* ntr */
	  }
	}
      }
      /*$ifdef TRACE-ARRAY*/
      ntr_ss_ass(s, s_offset, index, _INVALID_REAL, tzt, 20L, 933L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*s)->z[index] = _INVALID_REAL;
    }
    p_item_list = p_item_list->pointer;
  }
  if (!find_ssd)
    return;
  for (i = 0; i < marginal_dimension(b); i++) {
    index = i;
    count = n[*n_offset + index];
    index = *s_offset + index * *m2;
    for (j = index; j < index + *m1; j++) {
      /*$ifdef TRACE-ARRAY*/
      if (count != 0)   /* ntr */
	ntr_ss_upd(s, s_offset, index, (double)count, -3L, tzt, 20L, 933L, 1L);
      else
	ntr_ss_ass(s, s_offset, j, _INVALID_REAL, tzt, 20L, 933L, 1L);
      /* ntr */
      /*$endif TRACE-ARRAY*/
      if (count != 0)
	(*s)->z[j] /= count;
      else
	(*s)->z[j] = _INVALID_REAL;
    }
  }
  p_item_list = item_list;
  for (case_number = 1; case_number <= n[0]; case_number++) {
    index = discrete_marginal_hash(a_discrete,
				   p_item_list->item.integer_vector);
    index = *s_offset + index * *m2;
    j = index + *m1;
    j1 = index;
    for (v1 = first_continuous_vertex; v1 <= last_continuous_vertex; v1++) {
      if (P_inset(v1, a_continuous)) {
	/* j2 := j1; */
	/* sm_index !!! */
	j2 = index;
	for (v2 = first_continuous_vertex; v2 <= v1; v2++) {
	  /* to last_continuous_vertex */
	  /* sm_index !!! */
	  if (P_inset(v2, a_continuous)) {
	    /*$ifdef TRACE-ARRAY*/
	    ntr_ss_ref(s, s_offset, j1, tzt, 20L, 933L, 1L);
	    ntr_ss_ref(s, s_offset, j2, tzt, 20L, 933L, 1L);   /* ntr */
	    /* ntr */
	    ntr_ss_upd(s, s_offset, j,
	      (p_item_list->item.real_vector[v1 - MIN_VERTEX] - (*s)->z[j1]) *
	      (p_item_list->item.real_vector[v2 - MIN_VERTEX] - (*s)->z[j2]),
	      1L, tzt, 20L, 933L, 1L);
		/* ntr */
	    /*$endif TRACE-ARRAY*/
	    (*s)->z[j] +=
	      (p_item_list->item.real_vector[v1 - MIN_VERTEX] - (*s)->z[j1]) *
	      (p_item_list->item.real_vector[v2 - MIN_VERTEX] - (*s)->z[j2]);
	    j2++;
	    j++;
	  }
	}
	j1++;
      }
    }
    p_item_list = p_item_list->pointer;
  }
  for (i = 0; i < marginal_dimension(b); i++) {
    index = i;
    count = n[*n_offset + index];
    index = *s_offset + index * *m2;
    for (j = index + *m1; j <= index + *m2 - 2; j++) {
      /*$ifdef TRACE-ARRAY*/
      if (count > 1)   /* ntr */
	ntr_ss_upd(s, s_offset, index, 1.0, 3L, tzt, 20L, 933L, 1L);
      else
	ntr_ss_ass(s, s_offset, j, _INVALID_REAL, tzt, 20L, 933L, 1L);
      /* ntr */
      /*$endif TRACE-ARRAY*/
      if (count <= 1) {
	/* if boolean_option[110] then */
	/* else
	     s^.z^[j] := s^.z^[j]  / (count-1) */
	(*s)->z[j] = _INVALID_REAL;
      }
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_ss_ass(s, s_offset, index + *m2 - 1, _INVALID_REAL, tzt, 20L, 933L,
	       1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*s)->z[index + *m2 - 1] = _INVALID_REAL;
  }
}  /* sub_find_the_covariance_ss */


Static Void trace_covariance(a, b, m1, m2, n_offset, s_offset, s_size, ok)
long *a, *b;
t_integer *m1, *m2;
t_offset *n_offset;
t_s_offset s_offset;
t_integer s_size;
boolean ok;
{
  /**/
  t_discrete_vertex_set a_discrete;
  t_continuous_vertex_set a_continuous;

  /*$ifdef TRACE*/
  if (!trace_flag[TRACE_FLAG_FACTOR * 933])
    return;
  /*$endif TRACE*/
  /* write_line(output); */
  write_pch(stdout, " FindCovariance:", 16L);
  if (!ok)
    write_pch(stdout, " Not Ok!!!", 10L);
  if (long_names)
    write_line(stdout);
  print_vertex_set(a);
  print_vertex_set(b);
  if (long_names)
    write_line(stdout);
  to_discrete_set(a, a_discrete);
  print_discrete_vertex_set(a_discrete);
  to_continuous_set(a, a_continuous);
  print_continuous_vertex_set(a_continuous);
  if (long_names)
    write_line(stdout);
  write_char(stdout, ' ');
  write_integer(stdout, *m1, 3L);
  write_char(stdout, ' ');
  write_integer(stdout, *m2, 3L);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_char(stdout, ' ');
  write_integer(stdout, *n_offset, 5L);
  write_char(stdout, ' ');
  write_integer(stdout, s_offset, 5L);
  write_char(stdout, ' ');
  write_integer(stdout, (long)FIRST_INDEX, 5L);
  write_char(stdout, ' ');
  write_integer(stdout, s_size, 5L);
  write_char(stdout, ' ');
  write_integer(stdout, last_index(b), 5L);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_char(stdout, ' ');
  write_integer(stdout, s_offset, 5L);
  write_char(stdout, ' ');
  write_integer(stdout, s_offset + s_size, 5L);
  write_line(stdout);
}  /* trace_covariance */


Static Void trace_1(text, w, i, n, a, b, c, d, x, y, z)
Char *text;
t_long_integer w, i, n, a, b, c, d;
t_long_real x, y, z;
{
  /*$ifdef TRACE*/
  if (!trace_flag[TRACE_FLAG_FACTOR * 934])
    return;
  /*$endif TRACE*/
  write_pch(stdout, text, w);
  write_space(stdout, 20 - w);
  write_integer(stdout, i, 3L);
  write_char(stdout, '/');
  write_integer(stdout, n, 3L);
  write_char(stdout, '/');
  write_integer(stdout, a, 3L);
  write_char(stdout, '/');
  write_integer(stdout, b, 3L);
  write_char(stdout, '/');
  write_integer(stdout, c, 3L);
  write_char(stdout, '/');
  write_integer(stdout, d, 3L);
  write_char(stdout, '/');
  write_real(stdout, x, print_width, print_dec);
  write_real(stdout, y, print_width, print_dec);
  write_real(stdout, z, print_width, print_dec);
  write_line(stdout);
}  /* trace_1 */


/*@+"ssdnec.p"*/


/*

  937:    +++  ++
  938:    +++  ++
  939:    ---  -- p/ssdnec.p         11      52     638 p/ssdnec.p
  940: |    4:    procedure insert_s_offset
  941: |   19:    procedure insert_s_offset_in_2_3_tree
  942: |   40:    procedure insert_s_offset_in_both
  943: |   50:    procedure find_s_offset_in_2_3_tree
  944: |   82:    procedure visit_ssds
  945: |  113:    function found_ssd
  946: |  123:    procedure visit_ssds_in_2_3_tree
  947: |  169:    function sub_find_ssd
  948: |  212:    function find_ssd
  949: |  225:    procedure insert_set_in_list_of_ssds_to_find
  950: |  264:    procedure find_list_of_ssds
  951:    +++  ++
  952:    +++  ++

*/

Static Void insert_s_offset(a, s, s_offset, local_s_offset_list)
long *a;
t_s_r **s;
t_s_offset *s_offset;
t_s_offset_list **local_s_offset_list;
{
  t_s_offset_list *p;

  p = (t_s_offset_list *)Malloc(sizeof(t_s_offset_list));
  if (p == NULL)
    _OutMem();
  p->s = *s;
  p->s_offset = *s_offset;
  P_setcpy(p->vertex_set, a);
  p->pointer = *local_s_offset_list;
  *local_s_offset_list = p;
}  /* insert_s_offset */


Static Void insert_s_offset_in_2_3_tree(a, s, s_offset)
long *a;
t_s_r **s;
t_s_offset *s_offset;
{
  t_2_3_element element;

  /*$ifdef TRACE*/
  ntr_set(" InsertSOffsetIn2-3 ", 20L, 941L, 1L, 1L, offset_key(a), a);
  /*$endif TRACE*/
  element.tree_type = s_offset_tree;
  element.UU.s_offset_element = NULL;
  insert_s_offset(a, s, s_offset, &element.UU.s_offset_element);
  element.key = offset_key(a);
  insert_in_2_3_tree(&element, &s_offset_2_3_tree);
}  /* insert_s_offset_in_2_3_tree */


Static Void insert_s_offset_in_both(a, s, s_offset)
long *a;
t_s_r **s;
t_s_offset *s_offset;
{
  if (!boolean_option[111])
    insert_s_offset_in_2_3_tree(a, s, s_offset);
  else
    insert_s_offset(a, s, s_offset, &link_s_offset_list);
}  /* insert_s_offset_in_both */


Static Void find_s_offset_in_2_3_tree(a, p)
long *a;
t_s_offset_list **p;
{
  t_2_3_leaf *result;

  /*$ifdef TRACE*/
  ntr_set(" FindSOffsetIn2-3tr ", 20L, 943L, 1L, -1L, offset_key(a), a);
  if (trace_flag[TRACE_FLAG_FACTOR * 943])
    visit_2_3_tree_preorder(0L, &s_offset_2_3_tree);
  /*$endif TRACE*/
  *p = NULL;
  if (s_offset_2_3_tree != NULL) {
    find_in_2_3_tree(&s_offset_2_3_tree, offset_key(a), &result);
    if (result != NULL)
      *p = result->UU.s_offset_list;
  }
  /*$ifdef TRACE*/
  ntr_boolean(" FindSOffsetIn2-3tr ", 20L, 943L, 8L, -1L, -1L, *p == NULL);
  if (!trace_flag[TRACE_FLAG_FACTOR * 943])
    return;
  /*$endif TRACE*/
  if (*p != NULL) {
    print_s_offset_list(*p);
    write_line_stdout();
  }
}  /* find_s_offset_in_2_3_tree */


Static Void visit_ssds(a, p, b, g, size_of_a, size_of_g, s, s_offset)
long *a;
t_s_offset_list *p;
boolean *b;
long *g;
t_cell_index *size_of_a, *size_of_g;
t_s_r **s;
t_s_offset *s_offset;
{
  t_cell_index size_of_g0;
  t_vertex_set g0, g1;

  while (p != NULL && *b && *size_of_a * 2 < *size_of_g) {
    P_setcpy(g0, p->vertex_set);
    if (P_setequal(a, g0)) {
      *s_offset = p->s_offset;
      *s = p->s;
      *b = false;
      continue;
    }
    P_setint(g1, delta, g0);
    size_of_g0 = marginal_dimension(g1);
    if (false) {
      P_setcpy(g, g0);
      *s_offset = p->s_offset;
      *s = p->s;
      *size_of_g = size_of_g0;
    }
    p = p->pointer;
  }
}  /* visit_ssds */


/* Local variables for found_ssd: */
struct LOC_found_ssd {
  long *a, *g0;
  t_s_r **s;
  t_offset *g_offset;
  boolean b;
  t_cell_index size_of_a, size_of_g;
} ;

Local Void visit_ssds_in_2_3_tree(x_key, tree, LINK)
t_2_3_key x_key;
t_2_3_node **tree;
struct LOC_found_ssd *LINK;
{
  if (*tree == NULL)
    return;
  if ((*tree)->node_type != interior) {
    visit_ssds(LINK->a, (*tree)->UU.leaf_->UU.s_offset_list, &LINK->b,
	       LINK->g0, &LINK->size_of_a, &LINK->size_of_g, LINK->s,
	       LINK->g_offset);
    return;
  }
  if (x_key < (*tree)->UU.U1.lowofsecond)
    visit_ssds_in_2_3_tree(x_key, &(*tree)->UU.U1.firstchild, LINK);
  if ((*tree)->UU.U1.thirdchild == NULL || x_key < (*tree)->UU.U1.lowofthird)
    visit_ssds_in_2_3_tree(x_key, &(*tree)->UU.U1.secondchild, LINK);
  visit_ssds_in_2_3_tree(x_key, &(*tree)->UU.U1.thirdchild, LINK);
}  /* visit_ssds_in_2_3_tree */


Static boolean found_ssd(a_, tmp_ssds, g0_, s_, g_offset_)
long *a_;
t_s_offset_list **tmp_ssds;
long *g0_;
t_s_r **s_;
t_s_offset *g_offset_;
{
  struct LOC_found_ssd Local_Var;
  t_s_offset_list *p;

  Local_Var.a = a_;
  Local_Var.g0 = g0_;
  Local_Var.s = s_;
  Local_Var.g_offset = g_offset_;
  Local_Var.b = true;
  if (!boolean_option[111]) {
    find_s_offset_in_2_3_tree(Local_Var.a, &p);
    while (p != NULL && Local_Var.b) {
      if (P_setequal(Local_Var.a, p->vertex_set)) {
	*Local_Var.g_offset = p->s_offset;
	*Local_Var.s = p->s;
	Local_Var.b = false;
      } else
	p = p->pointer;
    }
  }
  if (!Local_Var.b)
    return (!Local_Var.b);
  P_setcpy(Local_Var.g0, delta);
  *Local_Var.g_offset = N_START - FIRST_INDEX;   /* ??? */
  if (datastructure == necessary)
    Local_Var.size_of_g = number_of_cells;
  else
    Local_Var.size_of_g = max_cell_number;
  Local_Var.size_of_a = marginal_dimension(Local_Var.a);
  visit_ssds(Local_Var.a, *tmp_ssds, &Local_Var.b, Local_Var.g0,
	     &Local_Var.size_of_a, &Local_Var.size_of_g, Local_Var.s,
	     Local_Var.g_offset);
  if (!Local_Var.b)
    return (!Local_Var.b);
  if (!boolean_option[111])
    visit_ssds_in_2_3_tree(offset_key(Local_Var.a), &s_offset_2_3_tree,
			   &Local_Var);
  else
    visit_ssds(Local_Var.a, link_s_offset_list, &Local_Var.b, Local_Var.g0,
	       &Local_Var.size_of_a, &Local_Var.size_of_g, Local_Var.s,
	       Local_Var.g_offset);
  return (!Local_Var.b);
}  /* found_ssd */


Static boolean sub_find_ssd(a, tmp_ssds, use_temporary, m1, m2, n_offset,
			    s_offset, s)
long *a;
t_s_offset_list **tmp_ssds;
boolean use_temporary;
t_integer *m1, *m2;
t_offset *n_offset;
t_s_offset *s_offset;
t_s_r **s;
{
  boolean Result = false;
  boolean ok;
  t_vertex_set b, g;
  t_long_integer s_size;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubFindSsd         ", sizeof(pch20));
  ntr_set(tzt, 20L, 947L, 1L, -1L, -1L, a);
  /*$endif TRACE*/
  if (em)
    write_warning_em(stdout, 947L, " SubFindSsd         ");
  *s = NULL;
  *s_offset = -1;
  if (marginal_dimension(a) <= max_cell_number) {
    return_ghk_size(a, m1, m2);
    P_setint(b, a, delta);
    *n_offset = find_marginal(b, &ok);
    if (found_ssd(a, tmp_ssds, g, s, s_offset))
      Result = true;   /* ok */
    else {   /* ok */
      s_size = *m2 * (last_index(b) - FIRST_INDEX + 1);
      if (true)
	ok = return_s_space(&s_size, s, s_offset);
      trace_covariance(a, b, m1, m2, n_offset, *s_offset, s_size, ok);
      if (ok) {
	Result = true;
	sub_find_the_covariance_s(a, n_offset, s_offset, s, m1, m2, true);
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 947L, 1L)) {
	  write_pch(stdout, tzt, 20L);
	  print_ssd_s(a, *n_offset, *s_offset, *s, *m1, *m2, NULL, 3L, false,
		      false, 2L, false);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	if (use_temporary)
	  insert_s_offset(a, s, s_offset, tmp_ssds);
	else
	  insert_s_offset_in_both(a, s, s_offset);
      } else {
	/* sub_find_ssd := false */
	if (note_warnings) {
	  write_pch(stdout, " Note-3 (SubFindSsd): ReturnSspace.", 35L);
	  write_line(stdout);
	}
      }
    }
  } else {
    if (note_warnings) {
      write_pch(stdout, " Note-4 (SubFindSsd): MarginalDimension.", 40L);
      write_line(stdout);
    }
  }
  /*$ifdef TRACE*/
  ntr_4(tzt, 20L, 947L, 1L, -2L, -1L, *m1, *m2);
  ntr_4(tzt, 20L, 947L, 1L, -2L, -2L, *n_offset, *s_offset);
  ntr_boolean(tzt, 20L, 947L, 1L, -2L, -3L, ok);
  /*$endif TRACE*/
  return Result;
}  /* sub_find_ssd */


Static boolean find_ssd(a, m1, m2, n_offset, s_offset, s)
long *a;
t_integer *m1, *m2;
t_offset *n_offset;
t_s_offset *s_offset;
t_s_r **s;
{
  t_s_offset_list *p = NULL;

  return (sub_find_ssd(a, &p, false, m1, m2, n_offset, s_offset, s));
}  /* find_ssd */


/* Not used:
procedure insert_set_in_list_of_ssds_to_find(var a  : t_vertex_set;
                                             var set_list :
                                                 t_link_set_list);
var
   p, q  : t_link_set_list;
   card_a : t_long_integer;
   b  : boolean;
begin
   if set_list <> nil then begin
      card_a := cardinality(a);
      b := true;
      p := set_list;
      q := p;
      if a = p^.vertex_set then
         b := false
      else if cardinality(p^.vertex_set) <= card_a then begin
         insert_set_in_set_list(a, set_list);
         b := false
      end else
         p := p^.pointer;
      while (p <> nil) and b do
         if a = p^.vertex_set then
            b := false
         else if cardinality(p^.vertex_set) <= card_a then begin
            insert_set_in_set_list(a, p);
            q^.pointer := p;
            b := false
         end else begin
            q := p;
            p := p^.pointer
         end;
      if p = nil then begin
         insert_set_in_set_list(a, p);
         q^.pointer := p
      end
   end else
      insert_set_in_set_list(a, set_list)
end; */
/* insert_set_in_list_of_ssds_to_find */

/* Not used:
procedure find_list_of_ssds(var p  : t_link_set_list;
                            var ok : boolean);
var
   q    : t_link_set_list;
   m1, m2   : t_integer;
   n_offset : t_offset;
   s_offset : t_s_offset;
   s    : t_s;
begin
   ok := true;
   while (p <> nil) and ok do begin
      q := p^.pointer;
      ok := find_ssd(p^.vertex_set, m1, m2, n_offset, s_offset, s);
      dispose(p);
      p := q
   end;
   if not ok then
      dispose_set_list(p)
end; */
/* find_list_of_ssds */
/*@+"ssnec.p"*/


/*

  953:    +++  ++
  954:    +++  ++
  955:    ---  -- p/ssnec.p         11      52     635 p/ssnec.p
  956: |    4:    procedure insert_ss_offset
  957: |   19:    procedure insert_ss_offset_in_2_3_tree
  958: |   40:    procedure insert_ss_offset_in_both
  959: |   50:    procedure find_ss_offset_in_2_3_tree
  960: |   82:    procedure visit_sss
  961: |  113:    function found_ss
  962: |  123:    procedure visit_sss_in_2_3_tree
  963: |  169:    function sub_find_ss
  964: |  213:    function find_ss
  965: |  225:    procedure insert_set_in_list_of_sss_to_find
  966: |  264:    procedure find_list_of_sss
  967:    +++  ++
  968:    +++  ++

*/

Static Void insert_ss_offset(a, ss, ss_offset, local_ss_offset_list)
long *a;
t_ss_r **ss;
t_ss_offset *ss_offset;
t_ss_offset_list **local_ss_offset_list;
{
  t_ss_offset_list *p;

  p = (t_ss_offset_list *)Malloc(sizeof(t_ss_offset_list));
  if (p == NULL)
    _OutMem();
  p->ss = *ss;
  p->ss_offset = *ss_offset;
  P_setcpy(p->vertex_set, a);
  p->pointer = *local_ss_offset_list;
  *local_ss_offset_list = p;
}  /* insert_ss_offset */


Static Void insert_ss_offset_in_2_3_tree(a, ss, ss_offset)
long *a;
t_ss_r **ss;
t_ss_offset *ss_offset;
{
  t_2_3_element element;

  /*$ifdef TRACE*/
  ntr_set(" InsertSSOffsetIn2- ", 20L, 957L, 1L, 1L, offset_key(a), a);
  /*$endif TRACE*/
  element.tree_type = ss_offset_tree;
  element.UU.ss_offset_element = NULL;
  insert_ss_offset(a, ss, ss_offset, &element.UU.ss_offset_element);
  element.key = offset_key(a);
  insert_in_2_3_tree(&element, &ss_offset_2_3_tree);
}  /* insert_ss_offset_in_2_3_tree */


Static Void insert_ss_offset_in_both(a, ss, ss_offset)
long *a;
t_ss_r **ss;
t_ss_offset *ss_offset;
{
  if (!boolean_option[111])
    insert_ss_offset_in_2_3_tree(a, ss, ss_offset);
  else
    insert_ss_offset(a, ss, ss_offset, &link_ss_offset_list);
}  /* insert_ss_offset_in_both */


Static Void find_ss_offset_in_2_3_tree(a, p)
long *a;
t_ss_offset_list **p;
{
  t_2_3_leaf *result;

  /*$ifdef TRACE*/
  ntr_set(" FindSSOffsetIn2-3t ", 20L, 957L, 1L, -1L, offset_key(a), a);
  if (trace_flag[TRACE_FLAG_FACTOR * 957])
    visit_2_3_tree_preorder(0L, &ss_offset_2_3_tree);
  /*$endif TRACE*/
  *p = NULL;
  if (ss_offset_2_3_tree != NULL) {
    find_in_2_3_tree(&ss_offset_2_3_tree, offset_key(a), &result);
    if (result != NULL)
      *p = result->UU.ss_offset_list;
  }
  /*$ifdef TRACE*/
  ntr_boolean(" FindSSOffsetIn2-3t ", 20L, 957L, 8L, -1L, -1L, *p == NULL);
  if (!trace_flag[TRACE_FLAG_FACTOR * 957])
    return;
  /*$endif TRACE*/
  if (*p != NULL) {
    print_ss_offset_list(*p);
    write_line_stdout();
  }
}  /* find_ss_offset_in_2_3_tree */


Static Void visit_sss(a, p, b, g, size_of_a, size_of_g, ss, ss_offset)
long *a;
t_ss_offset_list *p;
boolean *b;
long *g;
t_cell_index *size_of_a, *size_of_g;
t_ss_r **ss;
t_ss_offset *ss_offset;
{
  t_cell_index size_of_g0;
  t_vertex_set g0, g1;

  while (p != NULL && *b && *size_of_a * 2 < *size_of_g) {
    P_setcpy(g0, p->vertex_set);
    if (P_setequal(a, g0)) {
      *ss_offset = p->ss_offset;
      *ss = p->ss;
      *b = false;
      continue;
    }
    P_setint(g1, delta, g0);
    size_of_g0 = marginal_dimension(g1);
    if (false) {
      P_setcpy(g, g0);
      *ss_offset = p->ss_offset;
      *ss = p->ss;
      *size_of_g = size_of_g0;
    }
    p = p->pointer;
  }
}  /* visit_sss */


/* Local variables for found_ss: */
struct LOC_found_ss {
  long *a, *g0;
  t_ss_r **ss;
  t_offset *g_offset;
  boolean b;
  t_cell_index size_of_a, size_of_g;
} ;

Local Void visit_sss_in_2_3_tree(x_key, tree, LINK)
t_2_3_key x_key;
t_2_3_node **tree;
struct LOC_found_ss *LINK;
{
  if (*tree == NULL)
    return;
  if ((*tree)->node_type != interior) {
    visit_sss(LINK->a, (*tree)->UU.leaf_->UU.ss_offset_list, &LINK->b,
	      LINK->g0, &LINK->size_of_a, &LINK->size_of_g, LINK->ss,
	      LINK->g_offset);
    return;
  }
  if (x_key < (*tree)->UU.U1.lowofsecond)
    visit_sss_in_2_3_tree(x_key, &(*tree)->UU.U1.firstchild, LINK);
  if ((*tree)->UU.U1.thirdchild == NULL || x_key < (*tree)->UU.U1.lowofthird)
    visit_sss_in_2_3_tree(x_key, &(*tree)->UU.U1.secondchild, LINK);
  visit_sss_in_2_3_tree(x_key, &(*tree)->UU.U1.thirdchild, LINK);
}  /* visit_sss_in_2_3_tree */


Static boolean found_ss(a_, tmp_sss, g0_, ss_, g_offset_)
long *a_;
t_ss_offset_list **tmp_sss;
long *g0_;
t_ss_r **ss_;
t_ss_offset *g_offset_;
{
  struct LOC_found_ss Local_Var;
  t_ss_offset_list *p;

  Local_Var.a = a_;
  Local_Var.g0 = g0_;
  Local_Var.ss = ss_;
  Local_Var.g_offset = g_offset_;
  Local_Var.b = true;
  if (!boolean_option[111]) {
    find_ss_offset_in_2_3_tree(Local_Var.a, &p);
    while (p != NULL && Local_Var.b) {
      if (P_setequal(Local_Var.a, p->vertex_set)) {
	*Local_Var.g_offset = p->ss_offset;
	*Local_Var.ss = p->ss;
	Local_Var.b = false;
      } else
	p = p->pointer;
    }
  }
  if (!Local_Var.b)
    return (!Local_Var.b);
  P_setcpy(Local_Var.g0, delta);
  *Local_Var.g_offset = N_START - FIRST_INDEX;   /* ??? */
  if (datastructure == necessary)
    Local_Var.size_of_g = number_of_cells;
  else
    Local_Var.size_of_g = max_cell_number;
  Local_Var.size_of_a = marginal_dimension(Local_Var.a);
  visit_sss(Local_Var.a, *tmp_sss, &Local_Var.b, Local_Var.g0,
	    &Local_Var.size_of_a, &Local_Var.size_of_g, Local_Var.ss,
	    Local_Var.g_offset);
  if (!Local_Var.b)
    return (!Local_Var.b);
  if (!boolean_option[111])
    visit_sss_in_2_3_tree(offset_key(Local_Var.a), &ss_offset_2_3_tree,
			  &Local_Var);
  else
    visit_sss(Local_Var.a, link_ss_offset_list, &Local_Var.b, Local_Var.g0,
	      &Local_Var.size_of_a, &Local_Var.size_of_g, Local_Var.ss,
	      Local_Var.g_offset);
  return (!Local_Var.b);
}  /* found_ss */


Static boolean sub_find_ss(a, tmp_sss, use_temporary, m1, m2, n_offset,
			   ss_offset, ss)
long *a;
t_ss_offset_list **tmp_sss;
boolean use_temporary;
t_integer *m1, *m2;
t_offset *n_offset;
t_ss_offset *ss_offset;
t_ss_r **ss;
{
  boolean Result = false;
  boolean ok;
  t_vertex_set b, g;
  t_integer ss_size;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubFindSs          ", sizeof(pch20));
  ntr_set(tzt, 20L, 963L, 1L, -1L, -1L, a);
  /*$endif TRACE*/
  if (em)
    write_warning_em(stdout, 963L, " SubFindSs          ");
  *ss = NULL;
  *ss_offset = -1;
  if (marginal_dimension(a) <= max_cell_number) {
    *m1 = count_continuous(a);
    *m2 = *m1 + *m1 * (*m1 + 1) / 2 + 1;
    P_setint(b, a, delta);
    *n_offset = find_marginal(b, &ok);
    if (found_ss(a, tmp_sss, g, ss, ss_offset))
      Result = true;   /* ok */
    else {   /* ok */
      ss_size = *m2 * (last_index(b) - FIRST_INDEX + 1);
      if (true)
	ok = return_ss_space(&ss_size, ss, ss_offset);
      trace_covariance(a, b, m1, m2, n_offset, *ss_offset, ss_size, ok);
      if (ok) {
	Result = true;
	sub_find_the_covariance_ss(a, n_offset, ss_offset, ss, m1, m2, false);
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 963L, 1L)) {
	  write_pch(stdout, tzt, 20L);
	  print_ssd_ss(a, *n_offset, *ss_offset, ss, *m1, *m2, NULL, 3L,
		       false, false, 2L, false);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	if (use_temporary)
	  insert_ss_offset(a, ss, ss_offset, tmp_sss);
	else
	  insert_ss_offset_in_both(a, ss, ss_offset);
      }
      /* else
         sub_find_ss := false */
    }
  }
  /*$ifdef TRACE*/
  ntr_4(tzt, 20L, 963L, 1L, -2L, -1L, *m1, *m2);
  ntr_4(tzt, 20L, 963L, 1L, -2L, -2L, *n_offset, *ss_offset);
  ntr_boolean(tzt, 20L, 963L, 1L, -2L, -3L, ok);
  /*$endif TRACE*/
  return Result;
}  /* sub_find_ss */


Static boolean find_ss(a, m1, m2, n_offset, ss_offset, ss)
long *a;
t_integer *m1, *m2;
t_offset *n_offset;
t_ss_offset *ss_offset;
t_ss_r **ss;
{
  t_ss_offset_list *p = NULL;

  return (sub_find_ss(a, &p, false, m1, m2, n_offset, ss_offset, ss));
}  /* find_ss */


/* Not used:
procedure insert_set_in_list_of_sss_to_find(var a : t_vertex_set;
                                            var set_list :
                                                 t_link_set_list);
var
   p, q  : t_link_set_list;
   card_a : t_integer;
   b  : boolean;
begin
   if set_list <> nil then begin
      card_a := cardinality(a);
      b := true;
      p := set_list;
      q := p;
      if a = p^.vertex_set then
         b := false
      else if cardinality(p^.vertex_set) <= card_a then begin
         insert_set_in_set_list(a, set_list);
         b := false
      end else
         p := p^.pointer;
      while (p <> nil) and b do
         if a = p^.vertex_set then
            b := false
         else if cardinality(p^.vertex_set) <= card_a then begin
            insert_set_in_set_list(a, p);
            q^.pointer := p;
            b := false
         end else begin
            q := p;
            p := p^.pointer
         end;
      if p = nil then begin
         insert_set_in_set_list(a, p);
         q^.pointer := p
      end
   end else
      insert_set_in_set_list(a, set_list)
end; */
/* insert_set_in_list_of_sss_to_find */

/* Not used:
procedure find_list_of_sss(var p  : t_link_set_list;
                           var ok : boolean);
var
   q     : t_link_set_list;
   m1, m2    : t_integer;
   n_offset  : t_offset;
   ss_offset : t_ss_offset;
   ss     : t_ss; / * T_SS, find_ss * /
begin
   ok := true;
   while (p <> nil) and ok do begin
      q := p^.pointer;
      ok := find_ss(p^.vertex_set, m1, m2, n_offset, ss_offset, ss);
      dispose(p);
      p := q
   end;
   if not ok then
      dispose_set_list(p)
end; */
/* find_list_of_sss */
/*@+"ghknec.p"*/

/*

  969:    +++  ++
  970:    +++  ++
  971:    ---  -- p/ghknec.p         36     178    1907 p/ghknec.p
  972: |    4:    procedure insert_r_offset
  973: |   19:    procedure insert_r_offset_in_2_3_tree
  974: |   40:    procedure insert_r_offset_in_both
  975: |   50:    procedure find_r_offset_in_2_3_tree
  976: |   82:    procedure visit_ghks
  977: |  113:    function found_ghk
  978: |  123:    procedure visit_ghks_in_2_3_tree
  979: |  169:    procedure cholesky
  980: |  207:    procedure cholesky_scaled
  981: |  245:    procedure invert
  982: |  268:    procedure mult_upper
  983: |  290:    procedure write_matrix
  984: |  309:    procedure write_headed_matrix
  985: |  321:    procedure write_vector_
  986: |  334:    procedure write_vector
  987: |  348:    procedure write_headed_vector
  988: |  360:    procedure write_mult_lower
  989: |  385:    procedure write_headed_mult_lower
  990: |  397:    procedure write_mult_upper
  991: |  422:    procedure write_headed_mult_upper
  992: |  434:    procedure write_mult_sym
  993: |  457:    procedure write_headed_mult_sym
  994: |  471:    procedure find_one_k
  995: |  523:    procedure mult_symmetric_matrix_and_vector
  996: |  547:    function find_determinant_from_cholesky
  997: |  568:    function find_g
  998: |  603:    function find_scalar_product
  999: |  626:    procedure sub_find_the_ghks
1000: |  711:    function sub_find_ghk
1001: |  779:    function find_ghk
1002: |  793:    function find_ghk_
1003: |  821:    function find_determinants
1004: |  893:    function find_determinant_of_sum
1005: |  972:    function find_gs
1006: | 1026:    procedure insert_set_in_list_of_ghks_to_find
1007: | 1065:    procedure find_list_of_ghks
1008:    +++  ++
1009:    +++  ++

*/

Static boolean test_positive_diag_s(l, l_offset, n)
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
{
  t_integer i = 0;
  boolean ok = true;

  while (ok && i < *n) {
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(l, l_offset, *l_offset + sm_index(i, i, *n),
	      " TestPositiveDiagS  ", 20L, 970L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    ok = ((*l)->z[*l_offset + sm_index(i, i, *n)] > 0);
    i++;
  }
  return ok;
}  /* test_positive_diag_s */


Static boolean test_positive_diag_t(l, l_offset, n)
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  t_integer i = 0;
  boolean ok = true;

  while (ok && i < *n) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(l, l_offset, *l_offset + sm_index(i, i, *n),
	      " TestPositiveDiagT  ", 20L, 970L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    ok = ((*l)->z[*l_offset + sm_index(i, i, *n)] > 0);
    i++;
  }
  return ok;
}  /* test_positive_diag_t */


Static Void insert_r_offset(a, r, r_offset, local_r_offset_list)
long *a;
t_r_r **r;
t_r_offset *r_offset;
t_r_offset_list **local_r_offset_list;
{
  t_r_offset_list *p;

  p = (t_r_offset_list *)Malloc(sizeof(t_r_offset_list));
  if (p == NULL)
    _OutMem();
  p->r = *r;
  p->r_offset = *r_offset;
  P_setcpy(p->vertex_set, a);
  p->pointer = *local_r_offset_list;
  *local_r_offset_list = p;
}  /* insert_r_offset */


Static Void insert_r_offset_in_2_3_tree(a, r, r_offset)
long *a;
t_r_r **r;
t_r_offset *r_offset;
{
  t_2_3_element element;

  /*$ifdef TRACE*/
  ntr_set(" InsertROffsetIn2-3 ", 20L, 975L, 1L, 1L, offset_key(a), a);
  /*$endif TRACE*/
  element.tree_type = r_offset_tree;
  element.UU.r_offset_element = NULL;
  insert_r_offset(a, r, r_offset, &element.UU.r_offset_element);
  element.key = offset_key(a);
  insert_in_2_3_tree(&element, &r_offset_2_3_tree);
}  /* insert_r_offset_in_2_3_tree */


Static Void insert_r_offset_in_both(a, r, r_offset)
long *a;
t_r_r **r;
t_r_offset *r_offset;
{
  if (!boolean_option[111])
    insert_r_offset_in_2_3_tree(a, r, r_offset);
  else
    insert_r_offset(a, r, r_offset, &link_r_offset_list);
}  /* insert_r_offset_in_both */


Static Void find_r_offset_in_2_3_tree(a, p)
long *a;
t_r_offset_list **p;
{
  t_2_3_leaf *result;

  /*$ifdef TRACE*/
  ntr_set(" FindROffsetIn2-3tr ", 20L, 975L, 1L, -1L, offset_key(a), a);
  if (trace_flag[TRACE_FLAG_FACTOR * 975])
    visit_2_3_tree_preorder(0L, &r_offset_2_3_tree);
  /*$endif TRACE*/
  *p = NULL;
  if (r_offset_2_3_tree != NULL) {
    find_in_2_3_tree(&r_offset_2_3_tree, offset_key(a), &result);
    if (result != NULL)
      *p = result->UU.r_offset_list;
  }
  /*$ifdef TRACE*/
  ntr_boolean(" FindROffsetIn2-3tr ", 20L, 975L, 8L, -1L, -1L, *p == NULL);
  if (!trace_flag[TRACE_FLAG_FACTOR * 975])
    return;
  /*$endif TRACE*/
  if (*p != NULL) {
    print_r_offset_list(*p);
    write_line_stdout();
  }
}  /* find_r_offset_in_2_3_tree */


Static Void visit_ghks(a, p, b, g, size_of_a, size_of_g, r, r_offset)
long *a;
t_r_offset_list *p;
boolean *b;
long *g;
t_cell_index *size_of_a, *size_of_g;
t_r_r **r;
t_r_offset *r_offset;
{
  t_cell_index size_of_g0;
  t_vertex_set g0, g1;

  while (p != NULL && *b && *size_of_a * 2 < *size_of_g) {
    P_setcpy(g0, p->vertex_set);
    if (P_setequal(a, g0)) {
      *r_offset = p->r_offset;
      *r = p->r;
      *b = false;
      continue;
    }
    P_setint(g1, delta, g0);
    size_of_g0 = marginal_dimension(g1);
    if (false) {
      P_setcpy(g, g0);
      *r_offset = p->r_offset;
      *r = p->r;
      *size_of_g = size_of_g0;
    }
    p = p->pointer;
  }
}  /* visit_ghks */


/* Local variables for found_ghk: */
struct LOC_found_ghk {
  long *a, *g0;
  t_r_r **r;
  t_offset *g_offset;
  boolean b;
  t_cell_index size_of_a, size_of_g;
} ;

Local Void visit_ghks_in_2_3_tree(x_key, tree, LINK)
t_2_3_key x_key;
t_2_3_node **tree;
struct LOC_found_ghk *LINK;
{
  if (*tree == NULL)
    return;
  if ((*tree)->node_type != interior) {
    visit_ghks(LINK->a, (*tree)->UU.leaf_->UU.r_offset_list, &LINK->b,
	       LINK->g0, &LINK->size_of_a, &LINK->size_of_g, LINK->r,
	       LINK->g_offset);
    return;
  }
  if (x_key < (*tree)->UU.U1.lowofsecond)
    visit_ghks_in_2_3_tree(x_key, &(*tree)->UU.U1.firstchild, LINK);
  if ((*tree)->UU.U1.thirdchild == NULL || x_key < (*tree)->UU.U1.lowofthird)
    visit_ghks_in_2_3_tree(x_key, &(*tree)->UU.U1.secondchild, LINK);
  visit_ghks_in_2_3_tree(x_key, &(*tree)->UU.U1.thirdchild, LINK);
}  /* visit_ghks_in_2_3_tree */


Static boolean found_ghk(a_, tmp_ghks, g0_, r_, g_offset_)
long *a_;
t_r_offset_list **tmp_ghks;
long *g0_;
t_r_r **r_;
t_r_offset *g_offset_;
{
  struct LOC_found_ghk Local_Var;
  t_r_offset_list *p;

  Local_Var.a = a_;
  Local_Var.g0 = g0_;
  Local_Var.r = r_;
  Local_Var.g_offset = g_offset_;
  Local_Var.b = true;
  if (!boolean_option[111]) {
    find_r_offset_in_2_3_tree(Local_Var.a, &p);
    while (p != NULL && Local_Var.b) {
      if (P_setequal(Local_Var.a, p->vertex_set)) {
	*Local_Var.g_offset = p->r_offset;
	*Local_Var.r = p->r;
	Local_Var.b = false;
      } else
	p = p->pointer;
    }
  }
  if (!Local_Var.b)
    return (!Local_Var.b);
  P_setcpy(Local_Var.g0, delta);
  *Local_Var.g_offset = N_START - FIRST_INDEX;   /* ??? */
  if (datastructure == necessary)
    Local_Var.size_of_g = number_of_cells;
  else
    Local_Var.size_of_g = max_cell_number;
  Local_Var.size_of_a = marginal_dimension(Local_Var.a);
  visit_ghks(Local_Var.a, *tmp_ghks, &Local_Var.b, Local_Var.g0,
	     &Local_Var.size_of_a, &Local_Var.size_of_g, Local_Var.r,
	     Local_Var.g_offset);
  if (!Local_Var.b)
    return (!Local_Var.b);
  if (!boolean_option[111])
    visit_ghks_in_2_3_tree(offset_key(Local_Var.a), &r_offset_2_3_tree,
			   &Local_Var);
  else
    visit_ghks(Local_Var.a, link_r_offset_list, &Local_Var.b, Local_Var.g0,
	       &Local_Var.size_of_a, &Local_Var.size_of_g, Local_Var.r,
	       Local_Var.g_offset);
  return (!Local_Var.b);
}  /* found_ghk */


Static Void clear_s(l, l_offset, n)
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
{
  t_integer h, i, k;

  for (k = 0; k < *n; k++) {
    for (i = k + 1; i < *n; i++) {
      h = sm_index(k, i, *n);
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ass(l, l_offset, *l_offset + h, _INVALID_REAL,
		" ClearS             ", 20L, 970L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*l)->z[*l_offset + h] = _INVALID_REAL;
    }
  }
}  /* clear_s */


Static Void ok_cholesky(t, force, silent, ok, ifail)
t_long_real *t;
boolean *force, *silent, *ok;
t_integer *ifail;
{   /* force and */
  if (*t <= 0) {
    if (!*silent) {
      warning_begin(stdout, false);
      write_pch(stdout, " Singular matrix in Cholesky.", 29L);
      if (*force) {
	write_line(stdout);
	write_pch(stdout, " ``Forcing'' decomposition!!!", 29L);
      }
      warning_end(stdout, false);
    }
    *t = cholesky_epsilon;
    *ok = false;
    *ifail = 7;
  }
  if (0 < *t && *t < ROUND_ERROR) {
    if (!*silent) {
      warning_begin(stdout, false);
      write_pch(stdout, " Almost singular matrix in Cholesky.", 36L);
      write_line(stdout);
      write_pch(stdout, " Expect instables estimates.", 28L);
      warning_end(stdout, false);
    }
    *t = ROUND_ERROR;
    *ifail = 4;
  }
  if (0 >= *t || *t >= cholesky_epsilon)
    return;
  if (!*silent) {
    warning_begin(stdout, false);
    write_pch(stdout, " Ill-conditioned matrix in Cholesky.", 36L);
    write_line(stdout);
    write_pch(stdout, " Estimates may variate.", 23L);
    warning_end(stdout, false);
  }
  *t = cholesky_epsilon;
  *ifail = 1;
}  /* ok_cholesky */


/* Local variables for cholesky_s_s: */
struct LOC_cholesky_s_s {
  boolean force, silent;
} ;


Static Void cholesky_s_s(x, l, x_offset, l_offset, force_, silent_, ok, n,
			 ifail)
t_s_r **x, **l;
t_s_offset *x_offset, *l_offset;
boolean force_, silent_, *ok;
t_integer *n, *ifail;
{
  struct LOC_cholesky_s_s Local_Var;
  t_integer g, h, i, j;
  t_integer k = 0;
  t_long_real t;
  double TEMP;

  Local_Var.force = force_;
  Local_Var.silent = silent_;
  clear_s(l, l_offset, n);
  *ok = true;
  while ((*ok || Local_Var.force) && k < *n) {
    g = sm_index(k, k, *n);
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(x, x_offset, *x_offset + g, " CholsekySS         ", 20L, 979L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    t = (*x)->z[*x_offset + g];
    for (j = 0; j < k; j++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(l, l_offset, *l_offset + sm_index(j, k, *n),
		" CholsekySS         ", 20L, 979L, 1L);
	  /* ntr */
      TEMP = (*l)->z[*l_offset + sm_index(j, k, *n)];
      /*$endif TRACE-ARRAY*/
      t -= TEMP * TEMP;
    }
    ok_cholesky(&t, &Local_Var.force, &Local_Var.silent, ok, ifail);
    if (t >= 0) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ass(l, l_offset, *l_offset + g, sqrt(t), " CholsekySS         ",
		20L, 979L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*l)->z[*l_offset + g] = sqrt(t);
      for (i = k + 1; i < *n; i++) {
	h = sm_index(k, i, *n);
	/*$ifdef TRACE-ARRAY*/
	ntr_s_ref(x, x_offset, *x_offset + h, " CholsekySS         ", 20L,
		  979L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	t = (*x)->z[*x_offset + h];
	for (j = 0; j < k; j++) {
	  /*$ifdef TRACE-ARRAY*/
	  ntr_s_ref(l, l_offset, *l_offset + sm_index(j, i, *n),
		    " CholsekySS         ", 20L, 979L, 1L);
	      /* ntr */
	  ntr_s_ref(l, l_offset, *l_offset + sm_index(j, k, *n),
		    " CholsekySS         ", 20L, 979L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  t -= (*l)->z[*l_offset + sm_index(j, i, *n)] *
	       (*l)->z[*l_offset + sm_index(j, k, *n)];
	}
	/*$ifdef TRACE-ARRAY*/
	ntr_s_ref(l, l_offset, *l_offset + g, " CholsekySS         ", 20L,
		  979L, 1L);
	    /* ntr */
	ntr_s_ass(l, l_offset, *l_offset + h, t / (*l)->z[*l_offset + g],
		  " CholsekySS         ", 20L, 979L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*l)->z[*l_offset + h] = t / (*l)->z[*l_offset + g];
      }
    } else
      *ok = false;
    k++;
  }
}  /* cholesky_s_s */


/* Local variables for cholesky_scaled_s_s: */
struct LOC_cholesky_scaled_s_s {
  boolean force, silent;
} ;


Static Void cholesky_scaled_s_s(x, l, x_offset, l_offset, force_, silent_, ok,
				n, factor, ifail)
t_s_r **x, **l;
t_s_offset *x_offset, *l_offset;
boolean force_, silent_, *ok;
t_integer *n;
t_long_real factor;
t_integer *ifail;
{
  struct LOC_cholesky_scaled_s_s Local_Var;
  t_integer g, h, i, j;
  t_integer k = 0;
  t_long_real t;
  double TEMP;

  Local_Var.force = force_;
  Local_Var.silent = silent_;
  clear_s(l, l_offset, n);
  *ok = true;
  while ((*ok || Local_Var.force) && k < *n) {
    g = sm_index(k, k, *n);
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(x, x_offset, *x_offset + g, " CholsekyScaledSS   ", 20L, 980L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    t = (*x)->z[*x_offset + g] * factor;
    for (j = 0; j < k; j++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(l, l_offset, *l_offset + sm_index(j, k, *n),
		" CholsekyScaledSS   ", 20L, 979L, 1L);
	  /* ntr */
      TEMP = (*l)->z[*l_offset + sm_index(j, k, *n)];
      /*$endif TRACE-ARRAY*/
      t -= TEMP * TEMP;
    }
    ok_cholesky(&t, &Local_Var.force, &Local_Var.silent, ok, ifail);
    if (t >= 0) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ass(l, l_offset, *l_offset + g, sqrt(t), " CholsekyScaledSS   ",
		20L, 979L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*l)->z[*l_offset + g] = sqrt(t);
      for (i = k + 1; i < *n; i++) {
	h = sm_index(k, i, *n);
	/*$ifdef TRACE-ARRAY*/
	ntr_s_ref(x, x_offset, *x_offset + h, " CholsekyScaledSS   ", 20L,
		  979L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	t = (*x)->z[*x_offset + h] * factor;
	for (j = 0; j < k; j++) {
	  /*$ifdef TRACE-ARRAY*/
	  ntr_s_ref(l, l_offset, *l_offset + sm_index(j, i, *n),
		    " CholsekyScaledSS   ", 20L, 979L, 1L);
	      /* ntr */
	  ntr_s_ref(l, l_offset, *l_offset + sm_index(j, k, *n),
		    " CholsekyScaledSS   ", 20L, 979L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  t -= (*l)->z[*l_offset + sm_index(j, i, *n)] *
	       (*l)->z[*l_offset + sm_index(j, k, *n)];
	}
	/*$ifdef TRACE-ARRAY*/
	ntr_s_ref(l, l_offset, *l_offset + g, " CholsekyScaledSS   ", 20L,
		  979L, 1L);
	    /* ntr */
	ntr_s_ass(l, l_offset, *l_offset + h, t / (*l)->z[*l_offset + g],
		  " CholsekyScaledSS   ", 20L, 979L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*l)->z[*l_offset + h] = t / (*l)->z[*l_offset + g];
      }
    } else
      *ok = false;
    k++;
  }
}  /* cholesky_scaled_s_s */


Static Void clear_t(l, l_offset, n)
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  t_integer h, i, k;

  for (k = 0; k < *n; k++) {
    for (i = k + 1; i < *n; i++) {
      h = sm_index(k, i, *n);
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(l, l_offset, *l_offset + h, _INVALID_REAL,
		" ClearT             ", 20L, 970L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*l)->z[*l_offset + h] = _INVALID_REAL;
    }
  }
}  /* clear_t */


/* Local variables for cholesky_t_t: */
struct LOC_cholesky_t_t {
  boolean force, silent;
} ;


Static Void cholesky_t_t(x, l, x_offset, l_offset, force_, silent_, ok, n,
			 ifail)
t_t_r **x, **l;
t_t_offset *x_offset, *l_offset;
boolean force_, silent_, *ok;
t_integer *n, *ifail;
{
  struct LOC_cholesky_t_t Local_Var;
  t_integer g, h, i, j;
  t_integer k = 0;
  t_long_real t;
  double TEMP;

  Local_Var.force = force_;
  Local_Var.silent = silent_;
  clear_t(l, l_offset, n);
  *ok = true;
  while ((*ok || Local_Var.force) && k < *n) {
    g = sm_index(k, k, *n);
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(x, x_offset, *x_offset + g, " CholsekyTT         ", 20L, 979L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    t = (*x)->z[*x_offset + g];
    for (j = 0; j < k; j++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(l, l_offset, *l_offset + sm_index(j, k, *n),
		" CholsekyTT         ", 20L, 979L, 1L);
	  /* ntr */
      TEMP = (*l)->z[*l_offset + sm_index(j, k, *n)];
      /*$endif TRACE-ARRAY*/
      t -= TEMP * TEMP;
    }
    ok_cholesky(&t, &Local_Var.force, &Local_Var.silent, ok, ifail);
    if (t >= 0) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(l, l_offset, *l_offset + g, sqrt(t), " CholsekyTT         ",
		20L, 979L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*l)->z[*l_offset + g] = sqrt(t);
      for (i = k + 1; i < *n; i++) {
	h = sm_index(k, i, *n);
	/*$ifdef TRACE-ARRAY*/
	ntr_t_ref(x, x_offset, *x_offset + h, " CholsekyTT         ", 20L,
		  979L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	t = (*x)->z[*x_offset + h];
	for (j = 0; j < k; j++) {
	  /*$ifdef TRACE-ARRAY*/
	  ntr_t_ref(l, l_offset, *l_offset + sm_index(j, i, *n),
		    " CholsekyTT         ", 20L, 979L, 1L);
	      /* ntr */
	  ntr_t_ref(l, l_offset, *l_offset + sm_index(j, k, *n),
		    " CholsekyTT         ", 20L, 979L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  t -= (*l)->z[*l_offset + sm_index(j, i, *n)] *
	       (*l)->z[*l_offset + sm_index(j, k, *n)];
	}
	/*$ifdef TRACE-ARRAY*/
	ntr_t_ref(l, l_offset, *l_offset + g, " CholsekyTT         ", 20L,
		  979L, 1L);
	    /* ntr */
	ntr_t_ass(l, l_offset, *l_offset + h, t / (*l)->z[*l_offset + g],
		  " CholsekyTT         ", 20L, 979L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*l)->z[*l_offset + h] = t / (*l)->z[*l_offset + g];
      }
    } else
      *ok = false;
    k++;
  }
}  /* cholesky_t_t */


Static Void invert_s_r(l, m, l_offset, m_offset, n)
t_s_r **l;
t_r_r **m;
t_s_offset *l_offset;
t_r_offset *m_offset;
t_integer *n;
{
  t_integer i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    k = sm_index(i, i, *n);
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(l, l_offset, *l_offset + k, " Invert_S_R         ", 20L, 981L,
	      1L);
	/* ntr */
    ntr_r_ass(m, m_offset, *m_offset + k, 1 / (*l)->z[*l_offset + k],
	      " Invert_S_R         ", 20L, 981L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*m)->z[*m_offset + k] = 1 / (*l)->z[*l_offset + k];
    for (j = i + 1; j < *n; j++) {
      t = 0.0;
      for (k = i; k < j; k++) {
	/*$ifdef TRACE-ARRAY*/
	ntr_s_ref(l, l_offset, *l_offset + sm_index(k, j, *n),
		  " Invert_S_R         ", 20L, 981L, 1L);
	    /* ntr */
	ntr_r_ref(m, m_offset, *m_offset + sm_index(i, k, *n),
		  " Invert_S_R         ", 20L, 981L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	t -= (*m)->z[*m_offset + sm_index(i, k, *n)] *
	     (*l)->z[*l_offset + sm_index(k, j, *n)];
      }
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(l, l_offset, *l_offset + sm_index(j, j, *n),
		" Invert_S_R         ", 20L, 981L, 1L);
	  /* ntr */
      /* ntr */
      ntr_r_ass(m, m_offset, *m_offset + sm_index(j, i, *n),
		t / (*l)->z[*l_offset + sm_index(j, j, *n)],
		" Invert_S_R         ", 20L, 981L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*m)->z[*m_offset + sm_index(j, i, *n)] =
	t / (*l)->z[*l_offset + sm_index(j, j, *n)];
    }
  }
}  /* invert_s_r */


Static Void invert_s_t(l, m, l_offset, m_offset, n)
t_s_r **l;
t_t_r **m;
t_s_offset *l_offset;
t_t_offset *m_offset;
t_integer *n;
{
  t_integer i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    k = sm_index(i, i, *n);
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(l, l_offset, *l_offset + k, " Invert_S_R         ", 20L, 981L,
	      1L);
	/* ntr */
    ntr_t_ass(m, m_offset, *m_offset + k, 1 / (*l)->z[*l_offset + k],
	      " Invert_S_R         ", 20L, 981L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*m)->z[*m_offset + k] = 1 / (*l)->z[*l_offset + k];
    for (j = i + 1; j < *n; j++) {
      t = 0.0;
      for (k = i; k < j; k++) {
	/*$ifdef TRACE-ARRAY*/
	ntr_s_ref(l, l_offset, *l_offset + sm_index(k, j, *n),
		  " Invert_S_R         ", 20L, 981L, 1L);
	    /* ntr */
	ntr_t_ref(m, m_offset, *m_offset + sm_index(i, k, *n),
		  " Invert_S_R         ", 20L, 981L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	t -= (*m)->z[*m_offset + sm_index(i, k, *n)] *
	     (*l)->z[*l_offset + sm_index(k, j, *n)];
      }
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(l, l_offset, *l_offset + sm_index(j, j, *n),
		" Invert_S_R         ", 20L, 981L, 1L);
	  /* ntr */
      /* ntr */
      ntr_t_ass(m, m_offset, *m_offset + sm_index(j, i, *n),
		t / (*l)->z[*l_offset + sm_index(j, j, *n)],
		" Invert_S_R         ", 20L, 981L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*m)->z[*m_offset + sm_index(j, i, *n)] =
	t / (*l)->z[*l_offset + sm_index(j, j, *n)];
    }
  }
}  /* invert_s_t */


Static Void invert_t_t(l, m, l_offset, m_offset, n)
t_t_r **l, **m;
t_t_offset *l_offset, *m_offset;
t_integer *n;
{
  t_integer i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    k = sm_index(i, i, *n);
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(l, l_offset, *l_offset + k, " Invert_S_R         ", 20L, 981L,
	      1L);
	/* ntr */
    ntr_t_ass(m, m_offset, *m_offset + k, 1 / (*l)->z[*l_offset + k],
	      " Invert_S_R         ", 20L, 981L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*m)->z[*m_offset + k] = 1 / (*l)->z[*l_offset + k];
    for (j = i + 1; j < *n; j++) {
      t = 0.0;
      for (k = i; k < j; k++) {
	/*$ifdef TRACE-ARRAY*/
	ntr_t_ref(l, l_offset, *l_offset + sm_index(k, j, *n),
		  " Invert_S_R         ", 20L, 981L, 1L);
	    /* ntr */
	ntr_t_ref(m, m_offset, *m_offset + sm_index(i, k, *n),
		  " Invert_S_R         ", 20L, 981L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	t -= (*m)->z[*m_offset + sm_index(i, k, *n)] *
	     (*l)->z[*l_offset + sm_index(k, j, *n)];
      }
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(l, l_offset, *l_offset + sm_index(j, j, *n),
		" Invert_S_R         ", 20L, 981L, 1L);
	  /* ntr */
      /* ntr */
      ntr_t_ass(m, m_offset, *m_offset + sm_index(j, i, *n),
		t / (*l)->z[*l_offset + sm_index(j, j, *n)],
		" Invert_S_R         ", 20L, 981L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*m)->z[*m_offset + sm_index(j, i, *n)] =
	t / (*l)->z[*l_offset + sm_index(j, j, *n)];
    }
  }
}  /* invert_t_t */


Static Void mult_upper_r_r(m, y, m_offset, y_offset, n)
t_r_r **m, **y;
t_r_offset *m_offset, *y_offset;
t_integer *n;
{
  t_integer h, i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = i; j < *n; j++) {
      if (i < j)
	h = j;
      else
	h = i;
      t = 0.0;
      for (k = h; k < *n; k++) {
	/*$ifdef TRACE-ARRAY*/
	ntr_r_ref(m, m_offset, *m_offset + sm_index(k, i, *n),
		  " MultUpperRR        ", 20L, 982L, 1L);
	    /* ntr */
	ntr_r_ref(m, m_offset, *m_offset + sm_index(k, j, *n),
		  " MultUpperRR        ", 20L, 982L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	t += (*m)->z[*m_offset + sm_index(k, i, *n)] *
	     (*m)->z[*m_offset + sm_index(k, j, *n)];
      }
      /*$ifdef TRACE-ARRAY*/
      ntr_r_ass(y, y_offset, *y_offset + sm_index(i, j, *n), t,
		" MultUpperRR        ", 20L, 982L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*y)->z[*y_offset + sm_index(i, j, *n)] = t;
    }
  }
}  /* mult_upper_r_r */


Static Void mult_upper_t_t(m, y, m_offset, y_offset, n)
t_t_r **m, **y;
t_t_offset *m_offset, *y_offset;
t_integer *n;
{
  t_integer h, i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = i; j < *n; j++) {
      if (i < j)
	h = j;
      else
	h = i;
      t = 0.0;
      for (k = h; k < *n; k++) {
	/*$ifdef TRACE-ARRAY*/
	ntr_t_ref(m, m_offset, *m_offset + sm_index(k, i, *n),
		  " MultUpperTT        ", 20L, 982L, 1L);
	    /* ntr */
	ntr_t_ref(m, m_offset, *m_offset + sm_index(k, j, *n),
		  " MultUpperTT        ", 20L, 982L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	t += (*m)->z[*m_offset + sm_index(k, i, *n)] *
	     (*m)->z[*m_offset + sm_index(k, j, *n)];
      }
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(y, y_offset, *y_offset + sm_index(i, j, *n), t,
		" MultUpperTT        ", 20L, 982L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*y)->z[*y_offset + sm_index(i, j, *n)] = t;
    }
  }
}  /* mult_upper_t_t */


Static Void write_matrix_s(l, l_offset, n)
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
{
  t_integer i, j;

  for (i = 0; i < *n; i++) {
    if (!global_write_options->line_form) {
      for (j = 0; j < i; j++)
	write_space(stdout, print_width + 2);
    }
    for (j = i; j < *n; j++)
      write_real(stdout, (*l)->z[*l_offset + sm_index(i, j, *n)],
		 print_width + 2, print_dec);
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_matrix_s */


Static Void write_matrix_r(l, l_offset, n)
t_r_r **l;
t_r_offset *l_offset;
t_integer *n;
{
  t_integer i, j;

  for (i = 0; i < *n; i++) {
    if (!global_write_options->line_form) {
      for (j = 0; j < i; j++)
	write_space(stdout, print_width + 2);
    }
    for (j = i; j < *n; j++)
      write_real(stdout, (*l)->z[*l_offset + sm_index(i, j, *n)],
		 print_width + 2, print_dec);
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_matrix_r */


Static Void write_matrix_t(l, l_offset, n)
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  t_integer i, j;

  for (i = 0; i < *n; i++) {
    if (!global_write_options->line_form) {
      for (j = 0; j < i; j++)
	write_space(stdout, print_width + 2);
    }
    for (j = i; j < *n; j++)
      write_real(stdout, (*l)->z[*l_offset + sm_index(i, j, *n)],
		 print_width + 2, print_dec);
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_matrix_t */


Static Void write_headed_matrix_s(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_matrix_s(l, l_offset, n);
}  /* write_headed_matrix_s */


Static Void write_headed_matrix_r(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_r_r **l;
t_r_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_matrix_r(l, l_offset, n);
}  /* write_headed_matrix_r */


Static Void write_headed_matrix_t(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_t_r **l;
t_t_offset l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_matrix_t(l, &l_offset, n);
}  /* write_headed_matrix_t */


Static Void write_vector_(l, l_offset, n)
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  t_integer i;

  for (i = 0; i < *n; i++)
    write_real(stdout, (*l)->z[*l_offset + i], print_width + 2, print_dec);
  if (*n > 1) {
    if (!global_write_options->line_form)
      write_line(stdout);
  }
}  /* write_vector_ */


Static Void write_vector_s(l, l_offset, n)
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
{
  t_integer i;

  for (i = 0; i < *n; i++)
    write_real(stdout, (*l)->z[*l_offset + i], print_width + 2, print_dec);
  if (!global_write_options->line_form)
    write_line(stdout);
  if (*n > 1)
    write_line(stdout);
}  /* write_vector_s */


Static Void write_vector_ss(l, l_offset, n)
t_ss_r **l;
t_ss_offset *l_offset;
t_integer *n;
{
  t_integer i;

  for (i = 0; i < *n; i++)
    write_real(stdout, (*l)->z[*l_offset + i], print_width + 2, print_dec);
  if (!global_write_options->line_form)
    write_line(stdout);
  if (*n > 1)
    write_line(stdout);
}  /* write_vector_ss */


Static Void write_vector_r(l, l_offset, n)
t_r_r **l;
t_r_offset *l_offset;
t_integer *n;
{
  t_integer i;

  for (i = 0; i < *n; i++)
    write_real(stdout, (*l)->z[*l_offset + i], print_width + 2, print_dec);
  if (!global_write_options->line_form)
    write_line(stdout);
  if (*n > 1)
    write_line(stdout);
}  /* write_vector_r */


Static Void write_vector_t(l, l_offset, n)
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  t_integer i;

  for (i = 0; i < *n; i++)
    write_real(stdout, (*l)->z[*l_offset + i], print_width + 2, print_dec);
  if (!global_write_options->line_form)
    write_line(stdout);
  if (*n > 1)
    write_line(stdout);
}  /* write_vector_t */


Static Void write_headed_vector_s(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_vector_s(l, l_offset, n);
}  /* write_headed_vector_s */


Static Void write_headed_vector_ss(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_ss_r **l;
t_ss_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_vector_ss(l, l_offset, n);
}  /* write_headed_vector_ss */


Static Void write_headed_vector_r(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_r_r **l;
t_r_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_vector_r(l, l_offset, n);
}  /* write_headed_vector_r */


Static Void write_headed_vector_t(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_vector_t(l, l_offset, n);
}  /* write_headed_vector_t */


Static Void write_mult_lower_s(l, l_offset, n)
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
{
  t_integer h, i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = 0; j < *n; j++) {
      if (i < j)
	h = i;
      else
	h = j;
      t = 0.0;
      for (k = 0; k <= h; k++)
	t += (*l)->z[*l_offset + sm_index(k, i, *n)] *
	     (*l)->z[*l_offset + sm_index(k, j, *n)];
      write_real(stdout, t, print_width + 2, print_dec);
    }
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_mult_lower_s */


Static Void write_headed_mult_lower_s(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_mult_lower_s(l, l_offset, n);
}  /* write_headed_mult_lower_s */


Static Void write_mult_lower_scaled_s(l, l_offset, n, factor)
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
t_long_real factor;
{
  t_integer h, i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = 0; j < *n; j++) {
      if (i < j)
	h = i;
      else
	h = j;
      t = 0.0;
      for (k = 0; k <= h; k++)
	t += (*l)->z[*l_offset + sm_index(k, i, *n)] *
	     (*l)->z[*l_offset + sm_index(k, j, *n)];
      write_real(stdout, factor * t, print_width + 2, print_dec);
    }
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_mult_lower_scaled_s */


Static Void write_headed_mult_lower_scaled_s(text, w, l, l_offset, n, factor)
Char *text;
t_integer w;
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
t_long_real factor;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_mult_lower_scaled_s(l, l_offset, n, factor);
}  /* write_headed_mult_lower_scaled_s */


Static Void write_mult_lower_t(l, l_offset, n)
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  t_integer h, i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = 0; j < *n; j++) {
      if (i < j)
	h = i;
      else
	h = j;
      t = 0.0;
      for (k = 0; k <= h; k++)
	t += (*l)->z[*l_offset + sm_index(k, i, *n)] *
	     (*l)->z[*l_offset + sm_index(k, j, *n)];
      write_real(stdout, t, print_width + 2, print_dec);
    }
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_mult_lower_t */


Static Void write_headed_mult_lower_t(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_mult_lower_t(l, l_offset, n);
}  /* write_headed_mult_lower_t */


Static Void write_mult_upper_r(l, l_offset, n)
t_r_r **l;
t_r_offset *l_offset;
t_integer *n;
{
  t_integer h, i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = 0; j < *n; j++) {
      if (i < j)
	h = j;
      else
	h = i;
      t = 0.0;
      for (k = h; k < *n; k++)
	t += (*l)->z[*l_offset + sm_index(k, i, *n)] *
	     (*l)->z[*l_offset + sm_index(k, j, *n)];
      write_real(stdout, t, print_width + 2, print_dec);
    }
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_mult_upper_r */


Static Void write_headed_mult_upper_r(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_r_r **l;
t_r_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_mult_upper_r(l, l_offset, n);
}  /* write_headed_mult_upper_r */


Static Void write_mult_upper_t(l, l_offset, n)
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  t_integer h, i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = 0; j < *n; j++) {
      if (i < j)
	h = j;
      else
	h = i;
      t = 0.0;
      for (k = h; k < *n; k++)
	t += (*l)->z[*l_offset + sm_index(k, i, *n)] *
	     (*l)->z[*l_offset + sm_index(k, j, *n)];
      write_real(stdout, t, print_width + 2, print_dec);
    }
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_mult_upper_t */


Static Void write_headed_mult_upper_t(text, w, l, l_offset, n)
Char *text;
t_integer w;
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_mult_upper_t(l, l_offset, n);
}  /* write_headed_mult_upper_t */


Static Void write_mult_sym_s_r(x, y, x_offset, y_offset, n)
t_s_r **x;
t_r_r **y;
t_s_offset *x_offset;
t_r_offset *y_offset;
t_integer *n;
{
  t_integer i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = 0; j < *n; j++) {
      t = 0.0;
      for (k = 0; k < *n; k++)
	t += (*x)->z[*x_offset + sm_index(k, i, *n)] *
	     (*y)->z[*y_offset + sm_index(k, j, *n)];
      write_real(stdout, t, print_width + 2, print_dec);
    }
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_mult_sym_s_r */


Static Void write_headed_mult_sym_s_r(text, w, x, y, x_offset, y_offset, n)
Char *text;
t_integer w;
t_s_r **x;
t_r_r **y;
t_s_offset *x_offset;
t_r_offset *y_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_mult_sym_s_r(x, y, x_offset, y_offset, n);
}  /* write_headed_mult_sym_s_r */


Static Void write_mult_sym_s_t(x, y, x_offset, y_offset, n)
t_s_r **x;
t_t_r **y;
t_s_offset *x_offset;
t_t_offset *y_offset;
t_integer *n;
{
  t_integer i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = 0; j < *n; j++) {
      t = 0.0;
      for (k = 0; k < *n; k++)
	t += (*x)->z[*x_offset + sm_index(k, i, *n)] *
	     (*y)->z[*y_offset + sm_index(k, j, *n)];
      write_real(stdout, t, print_width + 2, print_dec);
    }
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_mult_sym_s_t */


Static Void write_headed_mult_sym_s_t(text, w, x, y, x_offset, y_offset, n)
Char *text;
t_integer w;
t_s_r **x;
t_t_r **y;
t_s_offset *x_offset;
t_t_offset *y_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_mult_sym_s_t(x, y, x_offset, y_offset, n);
}  /* write_headed_mult_sym_s_t */


Static Void write_mult_sym_t_t(x, y, x_offset, y_offset, n)
t_t_r **x, **y;
t_t_offset *x_offset, *y_offset;
t_integer *n;
{
  t_integer i, j, k;
  t_long_real t;

  for (i = 0; i < *n; i++) {
    for (j = 0; j < *n; j++) {
      t = 0.0;
      for (k = 0; k < *n; k++)
	t += (*x)->z[*x_offset + sm_index(k, i, *n)] *
	     (*y)->z[*y_offset + sm_index(k, j, *n)];
      write_real(stdout, t, print_width + 2, print_dec);
    }
    if (!global_write_options->line_form)
      write_line(stdout);
  }
  if (*n > 1)
    write_line(stdout);
}  /* write_mult_sym_t_t */


Static Void write_headed_mult_sym_t_t(text, w, x, y, x_offset, y_offset, n)
Char *text;
t_integer w;
t_t_r **x, **y;
t_t_offset *x_offset, *y_offset;
t_integer *n;
{
  write_pch(stdout, text, w);
  write_space(stdout, 40 - w);
  if (*n > 1 || *n == 0)
    write_line(stdout);
  write_mult_sym_t_t(x, y, x_offset, y_offset, n);
}  /* write_headed_mult_sym_t_t */


Static Void find_one_k_s_r(count, x, y, l, m, x_offset, y_offset, l_offset,
			   m_offset, n, ok)
t_long_integer *count;
t_s_r **x;
t_r_r **y;
t_s_r **l;
t_r_r **m;
t_s_offset *x_offset;
t_r_offset *y_offset;
t_s_offset *l_offset;
t_r_offset *m_offset;
t_integer *n;
boolean *ok;
{
  t_integer ifail = 0;

  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 994])
    write_headed_matrix_s(" Input(1):                              ", 10L, x,
			  x_offset, n);
  /*$endif TRACE*/
  *ok = test_positive_diag_s(x, x_offset, n);
  if (*ok) {
    if (*count != 1)
      cholesky_scaled_s_s(x, l, x_offset, l_offset, boolean_option[105],
			  false, ok, n, 1.0 / *count, &ifail);
    else
      cholesky_s_s(x, l, x_offset, l_offset, boolean_option[105], false, ok,
		   n, &ifail);
  }
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 994] || ifail > 0) {
    write_headed_matrix_s(" Input:                                 ", 10L, x,
			  x_offset, n);
    write_headed_matrix_s(" Cholesky:                              ", 10L, l,
			  l_offset, n);
    write_headed_mult_lower_scaled_s(" Cholesky * Cholesky':                  ",
				     30L, l, l_offset, n, (double)(*count));
  }
  /*$endif TRACE*/
  if (*ok) {
    invert_s_r(l, m, l_offset, m_offset, n);
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 994]) {
      write_headed_matrix_r(" Inverse(Cholesky):                     ", 20L,
			    m, m_offset, n);
      write_headed_mult_upper_r(" Inverse(Cholesky) * Inverse(Cholesky)':",
				40L, m, m_offset, n);
    }
    /*$endif TRACE*/
    mult_upper_r_r(m, y, m_offset, y_offset, n);
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 994]) {
      write_headed_matrix_r(" Inverse:                               ", 10L,
			    y, y_offset, n);
      write_headed_mult_sym_s_r(" Input * Inverse:                       ",
				20L, x, y, x_offset, y_offset, n);
    }
    /*$endif TRACE*/
    return;
  }
  if (trace_flag_set(20L, 999L, 2L))
    return;
  if (!note_warnings)
    return;
  write_pch(stdout, " Note-4 (FindOneK): ", 20L);
  write_pch(stdout, " Cholesky not succeeded. Cell ", 25L);
  /* write_integer(output, i, 3);
     write_pch(output, ' has @@@@@', 5);
     write_integer(output, count, 3);
     write_pch(output, ' cases / @', 9);
     if n < count - 1 then
        write_pch(output,
                    ' Cholesky/Determinnt', 20)
     else
        write_pch(output,
                    ' Non-positive matrix', 20); */
  if (!test_positive_diag_s(x, x_offset, n))
    write_pch(stdout, " Non-positive diagonal (1).", 27L);
  write_integer(stdout, *n, 3L);
  write_line(stdout);
}  /* find_one_k_s_r */


Static Void find_one_k_s_t(count, x, y, l, m, x_offset, y_offset, l_offset,
			   m_offset, n, ok)
t_long_integer *count;
t_s_r **x;
t_t_r **y;
t_s_r **l;
t_t_r **m;
t_s_offset *x_offset;
t_t_offset *y_offset;
t_s_offset *l_offset;
t_t_offset *m_offset;
t_integer *n;
boolean *ok;
{
  t_integer ifail = 0;

  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 994])
    write_headed_matrix_s(" Input(1):                              ", 10L, x,
			  x_offset, n);
  /*$endif TRACE*/
  *ok = test_positive_diag_s(x, x_offset, n);
  if (*ok) {
    if (*count != 1)
      cholesky_scaled_s_s(x, l, x_offset, l_offset, boolean_option[105],
			  false, ok, n, 1.0 / *count, &ifail);
    else
      cholesky_s_s(x, l, x_offset, l_offset, boolean_option[105], false, ok,
		   n, &ifail);
  }
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 994] || ifail > 0) {
    write_headed_matrix_s(" Input:                                 ", 10L, x,
			  x_offset, n);
    write_headed_matrix_s(" Cholesky:                              ", 10L, l,
			  l_offset, n);
    write_headed_mult_lower_scaled_s(" Cholesky * Cholesky':                  ",
				     30L, l, l_offset, n, (double)(*count));
  }
  /*$endif TRACE*/
  if (*ok) {
    invert_s_t(l, m, l_offset, m_offset, n);
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 994]) {
      write_headed_matrix_t(" Inverse(Cholesky):                     ", 20L,
			    m, *m_offset, n);
      write_headed_mult_upper_t(" Inverse(Cholesky) * Inverse(Cholesky)':",
				40L, m, m_offset, n);
    }
    /*$endif TRACE*/
    mult_upper_t_t(m, y, m_offset, y_offset, n);
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 994]) {
      write_headed_matrix_t(" Inverse:                               ", 10L,
			    y, *y_offset, n);
      write_headed_mult_sym_s_t(" Input * Inverse:                       ",
				20L, x, y, x_offset, y_offset, n);
    }
    /*$endif TRACE*/
    return;
  }
  if (trace_flag_set(20L, 994L, 2L))
    return;
  if (!note_warnings)
    return;
  write_pch(stdout, " Note-4 (FindOneK): ", 20L);
  write_pch(stdout, " Cholesky not succeeded. Cell ", 25L);
  /* write_integer(output, i, 3);
     write_pch(output, ' has @@@@@', 5);
     write_integer(output, count, 3);
     write_pch(output, ' cases / @', 9); */
  /* if n < count - 1 then
       write_pch(output,
                   ' Cholesky/Determinnt', 20)
    else
       write_pch(output,
                   ' Non-positive matrix', 20); */
  if (!test_positive_diag_s(x, x_offset, n))
    write_pch(stdout, " Non-positive diagonal (2).", 27L);
  write_integer(stdout, *n, 3L);
  write_line(stdout);
}  /* find_one_k_s_t */


Static Void mult_symmetric_matrix_and_vector_s_r_r(s, k, h, s_offset,
						   k_offset, h_offset, n)
t_s_r **s;
t_r_r **k, **h;
t_s_offset *s_offset;
t_r_offset *k_offset, *h_offset;
t_integer *n;
{
  t_integer i, j;
  t_long_real t;

  for (j = 0; j < *n; j++) {
    t = 0.0;
    for (i = 0; i < *n; i++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(s, s_offset, *s_offset + i, " MultSymmMatVectSRR ", 20L, 982L,
		1L);
	  /* ntr */
      ntr_r_ref(k, k_offset, *k_offset + sm_index(i, j, *n),
		" MultSymmMatVectSRR ", 20L, 982L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      t += (*s)->z[*s_offset + i] * (*k)->z[*k_offset + sm_index(i, j, *n)];
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_r_ass(h, h_offset, *h_offset + j, t, " MultSymmMatVectSRR ", 20L,
	      982L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*h)->z[*h_offset + j] = t;
  }
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 995]) {
    write_headed_vector_s(" Means:@@@                              ", 7L, s,
			  s_offset, n);
    write_headed_vector_r(" h:@@@@@@@                              ", 3L, h,
			  h_offset, n);
  }
  /*$endif TRACE*/
}  /* mult_symmetric_matrix_and_vector_s_r_r */


Static Void mult_symmetric_matrix_and_vector_s_t_t(s, k, h, s_offset,
						   k_offset, h_offset, n)
t_s_r **s;
t_t_r **k, **h;
t_s_offset *s_offset;
t_t_offset *k_offset, *h_offset;
t_integer *n;
{
  t_integer i, j;
  t_long_real t;

  for (j = 0; j < *n; j++) {
    t = 0.0;
    for (i = 0; i < *n; i++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(s, s_offset, *s_offset + i, " MultSymmMatVectSRR ", 20L, 982L,
		1L);
	  /* ntr */
      ntr_t_ref(k, k_offset, *k_offset + sm_index(i, j, *n),
		" MultSymmMatVectSRR ", 20L, 982L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      t += (*s)->z[*s_offset + i] * (*k)->z[*k_offset + sm_index(i, j, *n)];
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ass(h, h_offset, *h_offset + j, t, " MultSymmMatVectSRR ", 20L,
	      982L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*h)->z[*h_offset + j] = t;
  }
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 995]) {
    write_headed_vector_s(" Means:@@@                              ", 7L, s,
			  s_offset, n);
    write_headed_vector_t(" h:@@@@@@@                              ", 3L, h,
			  h_offset, n);
  }
  /*$endif TRACE*/
}  /* mult_symmetric_matrix_and_vector_s_t_t */


Static Void mult_symmetric_matrix_and_vector_ss_t_t(s, k, h, s_offset,
						    k_offset, h_offset, n)
t_ss_r **s;
t_t_r **k, **h;
t_ss_offset *s_offset;
t_t_offset k_offset, *h_offset;
t_integer *n;
{
  t_integer i, j;
  t_long_real t;

  for (j = 0; j < *n; j++) {
    t = 0.0;
    for (i = 0; i < *n; i++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_ss_ref(s, s_offset, *s_offset + i, " MultSymmMatVectSRR ", 20L,
		 982L, 1L);
	  /* ntr */
      ntr_t_ref(k, &k_offset, k_offset + sm_index(i, j, *n),
		" MultSymmMatVectSRR ", 20L, 982L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      t += (*s)->z[*s_offset + i] * (*k)->z[k_offset + sm_index(i, j, *n)];
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ass(h, h_offset, *h_offset + j, t, " MultSymmMatVectSRR ", 20L,
	      982L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*h)->z[*h_offset + j] = t;
  }
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 995]) {
    write_headed_vector_ss(" Means:@@@                              ", 7L, s,
			   s_offset, n);
    write_headed_vector_t(" h:@@@@@@@                              ", 3L, h,
			  h_offset, n);
  }
  /*$endif TRACE*/
}  /* mult_symmetric_matrix_and_vector_ss_t_t */


Static Void mult_symmetric_matrix_and_vector_t_t_t(s, k, h, s_offset,
						   k_offset, h_offset, n)
t_t_r **s, **k, **h;
t_t_offset *s_offset, *k_offset, *h_offset;
t_integer *n;
{
  t_integer i, j;
  t_long_real t;

  for (j = 0; j < *n; j++) {
    t = 0.0;
    for (i = 0; i < *n; i++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(s, s_offset, *s_offset + i, " MultSymmMatVectSRR ", 20L, 982L,
		1L);
	  /* ntr */
      ntr_t_ref(k, k_offset, *k_offset + sm_index(i, j, *n),
		" MultSymmMatVectSRR ", 20L, 982L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      t += (*s)->z[*s_offset + i] * (*k)->z[*k_offset + sm_index(i, j, *n)];
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ass(h, h_offset, *h_offset + j, t, " MultSymmMatVectSRR ", 20L,
	      982L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*h)->z[*h_offset + j] = t;
  }
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 995]) {
    write_headed_vector_t(" Means:@@@                              ", 7L, s,
			  s_offset, n);
    write_headed_vector_t(" h:@@@@@@@                              ", 3L, h,
			  h_offset, n);
  }
  /*$endif TRACE*/
}  /* mult_symmetric_matrix_and_vector_t_t_t */


Static t_long_real find_determinant_from_cholesky_s(l, l_offset, n)
t_s_r **l;
t_s_offset *l_offset;
t_integer *n;
{
  t_integer i;
  t_long_real t = 1.0;

  for (i = 0; i < *n; i++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(l, l_offset, *l_offset + sm_index(i, i, *n),
	      " FindDetFromCholS   ", 20L, 996L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    t *= (*l)->z[*l_offset + sm_index(i, i, *n)];
  }
  t *= t;
  /*$ifdef TRACE*/
  if (!trace_flag[TRACE_FLAG_FACTOR * 996])
    return t;
  write_pch(stdout, " Determinant/s:", 15L);
  write_real(stdout, t, 14L, 4L);
  write_line(stdout);
  /*$endif TRACE*/
  return t;
}  /* find_determinant_from_cholesky_s */


Static t_long_real find_determinant_from_cholesky_t(l, l_offset, n)
t_t_r **l;
t_t_offset *l_offset;
t_integer *n;
{
  t_integer i;
  t_long_real t = 1.0;

  for (i = 0; i < *n; i++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(l, l_offset, *l_offset + sm_index(i, i, *n),
	      " FindDetFromCholS   ", 20L, 996L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    t *= (*l)->z[*l_offset + sm_index(i, i, *n)];
  }
  t *= t;
  /*$ifdef TRACE*/
  if (!trace_flag[TRACE_FLAG_FACTOR * 996])
    return t;
  write_pch(stdout, " Determinant/t:", 15L);
  write_real(stdout, t, 14L, 4L);
  write_line(stdout);
  /*$endif TRACE*/
  return t;
}  /* find_determinant_from_cholesky_t */


Static t_long_real find_g(dimension, count, determinant, product)
t_long_integer dimension, count;
t_long_real determinant, product;
{
  t_long_real x = dimension;

  /* 6.5 */
  x = -x * LN_2_PI_HALF;
  x += log((double)count / n[0]);
  x -= log(determinant) / 2;   /* Det(SSD/n) */
  x -= product / 2;
  /*$ifdef TRACE*/
  if (!trace_flag[TRACE_FLAG_FACTOR * 997])
    return x;
  write_pch(stdout, " FindG:             ", 10L);
  write_real(stdout, dimension * LN_2_PI_HALF, print_width, print_dec);
  write_real(stdout, (double)count / n[0], print_width, print_dec);
  write_real(stdout, determinant, print_width, print_dec);
  write_real(stdout, product, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " FindG:             ", 10L);
  write_real(stdout, -dimension * LN_2_PI_HALF, print_width, print_dec);
  write_real(stdout, log((double)count / n[0]), print_width, print_dec);
  write_real(stdout, log(determinant) / -2, print_width, print_dec);
  write_real(stdout, product / -2, print_width, print_dec);
  write_real(stdout, x, print_width, print_dec);
  write_line(stdout);
  /*$endif TRACE*/
  return x;
}  /* find_g */


Static t_long_real find_scalar_product_s_r(s, r, s_offset, r_offset, n)
t_s_r **s;
t_r_r **r;
t_s_offset *s_offset;
t_r_offset *r_offset;
t_integer *n;
{
  t_integer i;
  t_long_real t = 0.0;

  for (i = 0; i < *n; i++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(s, s_offset, *s_offset + i, " FindScaledProdSR   ", 20L, 998L,
	      1L);
	/* ntr */
    ntr_r_ref(r, r_offset, *r_offset + i, " FindScaledProdSR   ", 20L, 998L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    t = addprod(&t, &(*s)->z[*s_offset + i], &(*r)->z[*r_offset + i]);
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 998])
      trace_1(" FindScalarR: ", 14L, i, -1L, *s_offset, *r_offset,
	      *s_offset + i, *r_offset + i, (*s)->z[*s_offset + i],
	      (*r)->z[*r_offset + i], t);
    /*$endif TRACE*/
  }
  return t;
}  /* find_scalar_product_s_r */


Static t_long_real find_scalar_product_s_r_(s, r, s_offset, r_offset, n)
t_s_r **s;
t_r_r **r;
t_s_offset *s_offset;
t_r_offset *r_offset;
t_integer *n;
{
  t_integer i;
  t_long_real t = 0.0;

  for (i = 0; i < *n; i++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(s, s_offset, *s_offset + i, " FindScaledProdSR_  ", 20L, 998L,
	      1L);
	/* ntr */
    ntr_r_ref(r, r_offset, *r_offset + i, " FindScaledProdSR_  ", 20L, 998L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    t = addprod(&t, &(*s)->z[*s_offset + i], &(*r)->z[*r_offset + i]);
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 998])
      trace_1(" FindScalar_: ", 14L, i, -1L, *s_offset, *r_offset,
	      *s_offset + i, *r_offset + i, (*s)->z[*s_offset + i],
	      (*r)->z[*r_offset + i], t);
    /*$endif TRACE*/
  }
  return t;
}  /* find_scalar_product_s_r_ */


Static t_long_real find_scalar_product_ss_t(s, r, s_offset, r_offset, n)
t_ss_r **s;
t_t_r **r;
t_ss_offset *s_offset;
t_t_offset *r_offset;
t_integer *n;
{
  t_integer i;
  t_long_real t = 0.0;

  for (i = 0; i < *n; i++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_ss_ref(s, s_offset, *s_offset + i, " FindScaledProdSR_  ", 20L, 998L,
	       1L);
	/* ntr */
    ntr_t_ref(r, r_offset, *r_offset + i, " FindScaledProdSR_  ", 20L, 998L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    t = addprod(&t, &(*s)->z[*s_offset + i], &(*r)->z[*r_offset + i]);
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 998])
      trace_1(" FindScalarT: ", 14L, i, -1L, *s_offset, *r_offset,
	      *s_offset + i, *r_offset + i, (*s)->z[*s_offset + i],
	      (*r)->z[*r_offset + i], t);
    /*$endif TRACE*/
  }
  return t;
}  /* find_scalar_product_ss_t */


Static Void sub_find_the_ghks(a, det, g, h, n_offset, s_offset, r_offset, s,
			      r, m1, m2)
long *a;
boolean det, g, h;
t_offset *n_offset;
t_s_offset *s_offset;
t_r_offset *r_offset;
t_s_r **s;
t_r_r **r;
t_integer *m1, *m2;
{
  t_integer i, j, size, count;
  t_vertex_set b, c;
  t_s_offset v_offset, x_offset, l_offset;
  t_r_offset k_offset, h_offset, m_offset;
  boolean ok;
  /* log2pi, x: t_long_real; */
  t_s_r *l;   /* T_S, return_tmp_s_space */
  t_r_r *m;   /* T_R, return_tmp_r_space */
  /*$ifdef TRACE*/
  pch20 tzt;
  long FORLIM1;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubFindTheGhKs     ", sizeof(pch20));
  /* write_line(output); */
  ntr_set(tzt, 20L, 999L, 1L, 0L, 1L, a);
  /*$endif TRACE*/
  P_setint(b, a, delta);
  P_setint(c, a, gamma_);
  /* log2pi := 2 * LN_2_PI_HALF; */
  x_offset = *s_offset;
  h_offset = *r_offset;
  size = *m1 * (*m1 + 1) / 2;
  ok = return_tmp_s_space(size, &l, &l_offset);
  if (ok)
    ok = return_tmp_r_space(&size, &m, &m_offset);
  if (!ok)
    return;
  for (i = 0; i < marginal_dimension(b); i++) {
    v_offset = x_offset + *m1;
    k_offset = h_offset + *m1;
    count = n[*n_offset + i];
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 999])
      trace_1(" SubFindTheGhKs: ", 17L, i, count, x_offset, v_offset,
	      h_offset, k_offset, -1.0, -1.0, -1.0);
    /*$endif TRACE*/
    if (count > 0 && !boolean_option[127] || count > 1)
      find_one_k_s_r(&count, s, r, &l, &m, &v_offset, &k_offset, &l_offset,
		     &m_offset, m1, &ok);
    else
      ok = false;
    if (ok) {
      if (h) {
	mult_symmetric_matrix_and_vector_s_r_r(s, r, r, &x_offset, &k_offset,
					       &h_offset, m1);
	if (det) {
	  /*$ifdef TRACE-ARRAY*/
	  ntr_s_ass(s, s_offset, x_offset + *m2 - 1, _INVALID_REAL, tzt, 20L,
		    999L, -2L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  (*s)->z[x_offset + *m2 - 1] = find_determinant_from_cholesky_s(&l,
	      &l_offset, m1);
	  /*$ifdef TRACE-ARRAY*/
	  ntr_s_ass(s, s_offset, x_offset + *m2 - 1, _INVALID_REAL, tzt, 20L,
		    999L, 2L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  /*$ifdef TRACE-ARRAY*/
	  ntr_r_ass(r, r_offset, h_offset + *m2 - 1, _INVALID_REAL, tzt, 20L,
		    999L, -2L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  if (g) {
	    /* 6.5 */
	    /*$ifdef TRACE-ARRAY*/
	    ntr_s_ref(s, s_offset, x_offset + *m2 - 1, tzt, 20L, 999L, 1L);
		/* ntr */
	    /*$endif TRACE-ARRAY*/
	    (*r)->z[h_offset + *m2 - 1] = find_g(count_continuous(c), count,
		(*s)->z[x_offset + *m2 - 1],
		find_scalar_product_s_r(s, r, &x_offset, &h_offset, m1));
	    /*$ifdef TRACE-ARRAY*/
	    ntr_r_ass(r, r_offset, h_offset + *m2 - 1, _INVALID_REAL, tzt,
		      20L, 999L, 2L);
		/* ntr */
	    /*$endif TRACE-ARRAY*/
	  } else {
	    /*$ifdef TRACE-ARRAY*/
	    ntr_r_ass(r, r_offset, h_offset + *m2 - 1, _INVALID_REAL, tzt,
		      20L, 999L, 1L);
		/* ntr */
	    /*$endif TRACE-ARRAY*/
	    (*r)->z[h_offset + *m2 - 1] = _INVALID_REAL;
	  }
	  /*$ifdef TRACE-ARRAY*/
	  ntr_s_upd(s, s_offset, x_offset + *m2 - 1,
		    exp(*m1 * log((double)count)), 3L, tzt, 20L, 999L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  (*s)->z[x_offset + *m2 - 1] *= exp(*m1 * log((double)count));
	} else {
	  /*$ifdef TRACE-ARRAY*/
	  ntr_r_ass(r, r_offset, h_offset + *m2 - 1, _INVALID_REAL, tzt, 20L,
		    999L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  (*r)->z[h_offset + *m2 - 1] = _INVALID_REAL;
	  /* s^.z^[x_offset + m2 - 1] := _invalid_real */
	}
      }
    } else {
      if (!trace_flag_set(20L, 999L, 2L)) {
	if (note_warnings) {
	  write_pch(stdout, " Note-4 (SubFindTheGhks): FindOneK. ", 36L);
	  print_vertex_set(a);
	  if (count > 0 && !boolean_option[127] || count > 1) {
	    write_integer(stdout, count, 3L);
	    write_pch(stdout, " cases.", 7L);
	  }
	  write_line(stdout);
	}
      }
      FORLIM1 = *m2;
      for (j = 0; j < FORLIM1; j++) {
	/*$ifdef TRACE-ARRAY*/
	ntr_r_ass(r, r_offset, x_offset + j, _INVALID_REAL, tzt, 20L, 999L,
		  1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*r)->z[x_offset + j] = _INVALID_REAL;
      }
    }
    x_offset += *m2;
    h_offset += *m2;
  }
  free_tmp_s_space();   /* size, l, l_offset */
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  free_tmp_r_space();   /* size, m, m_offset */
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
}  /* sub_find_the_ghks */


Static boolean sub_find_ghk(a, det, g, h, tmp_ghks, use_temporary, m1, m2,
			    n_offset, r_offset, r)
long *a;
boolean det, g, h;
t_r_offset_list **tmp_ghks;
boolean use_temporary;
t_integer *m1, *m2;
t_offset *n_offset;
t_r_offset *r_offset;
t_r_r **r;
{
  boolean Result, ok;
  t_vertex_set b, g0;
  t_long_integer r_size;
  t_s_offset s_offset;
  t_s_r *s;   /* T_S, find_ssd */
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubFindGhK         ", sizeof(pch20));
  ntr_set(tzt, 20L, 1000L, 1L, -1L, -1L, a);
  /*$endif TRACE*/
  if (em)
    write_warning_em(stdout, 1000L, " SubFindGhK         ");
  *r = NULL;
  *r_offset = -1;
  if (marginal_dimension(a) <= max_cell_number) {
    return_ghk_size(a, m1, m2);
    P_setint(b, a, delta);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1000L, 2L, -1L, -1L, b);
    /*$endif TRACE*/
    *n_offset = find_marginal(b, &ok);
    if (found_ghk(a, tmp_ghks, g0, r, r_offset))
      Result = true;
    else {
      r_size = *m2 * (last_index(b) - FIRST_INDEX + 1);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1000L, 3L, -1L, -1L);
      /*$endif TRACE*/
      if (ok)
	ok = find_ssd(a, m1, m2, n_offset, &s_offset, &s);
      if (ok)
	ok = return_r_space(&r_size, r, r_offset);
      trace_covariance(a, b, m1, m2, n_offset, *r_offset, r_size, ok);
      Result = ok;
      if (ok) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1000L, 4L, -1L, -1L);
	/*$endif TRACE*/
	sub_find_the_ghks(a, det, g, h, n_offset, &s_offset, r_offset, &s, r,
			  m1, m2);
	if (use_temporary)
	  insert_r_offset(a, r, r_offset, tmp_ghks);
	else
	  insert_r_offset_in_both(a, r, r_offset);
      }
    }
  } else {
    Result = false;
    /*$ifdef TRACE*/
  }
  ntr(tzt, 20L, 1000L, 8L, *m1, *m2);
  ntr(tzt, 20L, 1000L, 8L, *n_offset, *r_offset);
  /*$endif TRACE*/
  return Result;
}  /* sub_find_ghk */


Static boolean find_ghk(a, det, g, h, m1, m2, n_offset, r_offset, r)
long *a;
boolean det, g, h;
t_integer *m1, *m2;
t_offset *n_offset;
t_r_offset *r_offset;
t_r_r **r;
{
  t_r_offset_list *p = NULL;

  return (sub_find_ghk(a, det, g, h, &p, false, m1, m2, n_offset, r_offset, r));
}  /* find_ghk */


Static boolean find_ghk_(a, det, g, h, m1, m2, n_offset, t_offset_, t)
long *a;
boolean det, g, h;
t_integer *m1, *m2;
t_offset *n_offset;
t_t_offset *t_offset_;
t_t_r **t;
{
  boolean Result;
  t_r_offset_list *p = NULL;
  t_r_offset r_offset;
  t_r_r *r;   /* T_R, sub_find_ghk */
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindGhk_           ", sizeof(pch20));
  ntr_set(tzt, 20L, 1002L, 1L, -1L, -1L, a);
  /*$endif TRACE*/
  Result = sub_find_ghk(a, det, g, h, &p, false, m1, m2, n_offset, &r_offset,
			&r);
  *t_offset_ = r_offset;
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1002L, 2L, -1L, -1L, r != NULL);
  /*$endif TRACE*/
  /*$ifdef CAST*/
  if (r != NULL) {
    *t = (t_t_r *)Malloc(sizeof(t_t_r));
    if (*t == NULL)
      _OutMem();
    /* Cast; Dispose is missing (leaking!!!!) ??? */
    (*t)->z = r->z;   /* Cast of T_R to T_T !!!!. */
  } else {
    *t = (t_t_r *)r;   /* Cast of T_R to T_T !!!!. */
    /*$endif CAST*/
    /*$ifdef TRACE*/
  }
  ntr_set(tzt, 20L, 1002L, 8L, r_offset, *t_offset_, a);
  /*$endif TRACE*/
  return Result;
}  /* find_ghk_ */


Static boolean find_determinants(a, m1, m2, n_offset, s_offset, s)
long *a;
t_integer *m1, *m2;
t_offset *n_offset;
t_s_offset *s_offset;
t_s_r **s;
{
  t_long_integer i, size, count;
  t_vertex_set b;
  t_s_offset x_offset, l_offset;
  boolean fail = false;
  boolean ok;
  t_s_r *l;   /* T_S, return_tmp_s_space */
  t_integer ifail = 0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindDeterminants   ", sizeof(pch20));
  ntr_set(tzt, 20L, 1003L, 1L, -1L, -1L, a);
  ntr_4(tzt, 20L, 1003L, 1L, -1L, -1L, *m1, *m2);
  ntr_4(tzt, 20L, 1003L, 1L, -1L, -2L, *n_offset, *s_offset);
  /*$endif TRACE*/
  ok = find_ssd(a, m1, m2, n_offset, s_offset, s);
  /*$ifdef TRACE*/
  ntr_4(tzt, 20L, 1003L, 1L, -2L, -1L, *m1, *m2);
  ntr_4(tzt, 20L, 1003L, 1L, -2L, -2L, *n_offset, *s_offset);
  /*$endif TRACE*/
  if (ok) {
    P_setint(b, a, delta);
    size = marginal_dimension(b) - 1;
    i = 0;
    x_offset = *s_offset + *m2 - 1;
    while ((i <= size && n[*n_offset + i] - 1 < *m1) &
	   is_invalid_real((*s)->z[x_offset])) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(s, s_offset, x_offset, tzt, 20L, 1003L, 1L);
      /*$endif TRACE-ARRAY*/
      x_offset += *m2;
      i++;
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(s, s_offset, x_offset, tzt, 20L, 1003L, 1L);
    /*$endif TRACE-ARRAY*/
    if (is_invalid_real((*s)->z[x_offset])) {
      size = *m1 * (*m1 + 1) / 2;
      ok = return_tmp_s_space(size, &l, &l_offset);
      if (ok) {
	x_offset = *s_offset + *m1;
	for (i = 0; i < marginal_dimension(b); i++) {
	  count = n[*n_offset + i];
	  /*$ifdef TRACE*/
	  if (trace_flag[TRACE_FLAG_FACTOR * 1003]) {
	    trace_1(" FindDeterminants: ", 19L, i, count, x_offset, -1L, -1L,
		    -1L, -1.0, -1.0, -1.0);
	    write_line(stdout);
	    write_headed_matrix_s(" Input(2):                              ",
				  10L, s, &x_offset, m1);
	  }
	  /*$endif TRACE*/
	  if (count > 0 && !boolean_option[127] || count > 1) {
	    cholesky_s_s(s, &l, &x_offset, &l_offset, false, false, &ok, m1,
			 &ifail);
	    /*$ifdef TRACE*/
	    if (trace_flag[TRACE_FLAG_FACTOR * 1003] || ifail > 0) {
	      write_headed_matrix_s(" Input:                                 ",
				    10L, s, &x_offset, m1);
	      write_headed_matrix_s(" Cholesky:                              ",
				    10L, &l, &l_offset, m1);
	      write_headed_mult_lower_s(
		" Cholesky * Cholesky':@@@@@@@@          ", 22L, &l,
		&l_offset, m1);
	    }
	    /*$endif TRACE*/
	    if (ok) {
	      /*$ifdef TRACE-ARRAY*/
	      ntr_s_ass(s, s_offset, x_offset - *m1 + *m2 - 1, _INVALID_REAL,
			tzt, 20L, 1003L, -2L);
		  /* ntr */
	      /*$endif TRACE-ARRAY*/
	      (*s)->z[x_offset - *m1 + *m2 - 1] =
		find_determinant_from_cholesky_s(&l, &l_offset, m1);
	      /*$ifdef TRACE-ARRAY*/
	      ntr_s_ass(s, s_offset, x_offset - *m1 + *m2 - 1, _INVALID_REAL,
			tzt, 20L, 1003L, 2L);
		  /* ntr */
	      /*$endif TRACE-ARRAY*/
	    } else {   /* ntr */
	      fail = true;
	      /*$ifdef TRACE-ARRAY*/
	      ntr_s_ass(s, s_offset, x_offset - *m1 + *m2 - 1, _INVALID_REAL,
			tzt, 20L, 1003L, 1L);
	      /*$endif TRACE-ARRAY*/
	      (*s)->z[x_offset - *m1 + *m2 - 1] = _INVALID_REAL;
	      if (note_warnings) {
		write_pch(stdout, " Note-4 (FindDeterminants):", 27L);
		write_pch(stdout, " Cholesky not succeeded. Cell ", 30L);
		write_integer(stdout, i, 3L);
		write_pch(stdout, " has ", 5L);
		write_integer(stdout, count, 3L);
		write_pch(stdout, " cases / ", 9L);
		if (*m1 < count - 1)
		  write_pch(stdout, " Cholesky/Determinnt", 20L);
		else
		  write_pch(stdout, " Non-positive matrix", 20L);
		if (!test_positive_diag_s(s, &x_offset, m1))
		  write_pch(stdout, " Non-positive diagonal (3).", 27L);
		write_integer(stdout, *m1, 3L);
		write_line(stdout);
	      }
	    }
	  }  /* if ((count > 0) and  ... */
	  else {
	    /* if ok then */
	    if (note_warnings) {
	      write_pch(stdout, " Note-3 (FindDeterminants):", 27L);
	      write_pch(stdout, " To few cases in matrix. Cell ", 30L);
	      write_integer(stdout, i, 3L);
	      write_pch(stdout, " has ", 5L);
	      write_integer(stdout, count, 3L);
	      write_pch(stdout, " cases.", 7L);
	      write_line(stdout);
	    }
	  }
	  x_offset += *m2;
	}  /* for i := 0 to marginal_dimension(b) - 1 */
	if (fail) {
	  if (note_warnings) {
	    write_pch(stdout, " Note: Determinants not found:", 30L);
	    print_vertex_set(b);
	    write_pch(stdout, " / ", 3L);
	    P_setint(b, a, gamma_);
	    print_vertex_set(b);
	    write_line(stdout);
	  }
	}
	free_tmp_s_space();   /* size, l, l_offset */
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
      }  /* if ok then begin */
      else {
	if (note_warnings) {
	  write_pch(stdout, " Note-2 (FindDeterminants): TmpSSpace.", 38L);
	  write_line(stdout);
	}
      }
    }  /* if is_invalid_real(s^.z^[x_offset]) then begin */
  }  /* if ok then begin */
  else {
    if (note_warnings) {
      write_pch(stdout, " Note-1 (FindDeterminants): FindSsd.", 36L);
      write_line(stdout);
    }
  }
  /*$ifdef TRACE*/
  ntr_4(tzt, 20L, 1003L, 1L, -3L, 1L, *m1, *m2);
  ntr_4(tzt, 20L, 1003L, 1L, -3L, 2L, *n_offset, *s_offset);
  ntr_boolean(tzt, 20L, 1003L, 1L, -3L, -3L, ok);
  /*$endif TRACE*/
  return ok;
}  /* find_determinants */


Static boolean find_determinant_of_sum(a, m1, m2, n_offset, s_offset, s, x, y)
long *a;
t_integer *m1, *m2;
t_offset *n_offset;
t_s_offset *s_offset;
t_s_r **s;
t_long_real *x, *y;
{
  t_long_integer i, j, size, count;
  t_vertex_set b;
  t_s_offset x_offset, l_offset, m_offset;
  boolean ok;
  t_s_r *l, *m;   /* T_S, return_tmp_s_space/l */
  t_integer ifail = 0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindDeterminantOfS ", sizeof(pch20));
  ntr_set(tzt, 20L, 1004L, 1L, -1L, -1L, a);
  ntr_4(tzt, 20L, 1004L, 1L, -1L, -1L, *m1, *m2);
  ntr_4(tzt, 20L, 1004L, 1L, -1L, -2L, *n_offset, *s_offset);
  /*$endif TRACE*/
  *x = _INVALID_REAL;
  *y = _INVALID_REAL;
  ok = find_ssd(a, m1, m2, n_offset, s_offset, s);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1004L, 8L))
    write_headed_ssd_s(" FindDetermnntOfSum                     ", 20L, a,
		       *n_offset, *s_offset, s, *m1, *m2, NULL, false, 2L,
		       false);
  /*$endif TRACE*/
  if (ok) {
    P_setint(b, a, delta);
    size = *m1 * (*m1 + 1) / 2;
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1004L, 1L, marginal_dimension(b) - 1, size, b);
    /*$endif TRACE*/
    ok = return_tmp_s_space(size * 2, &l, &l_offset);
    if (ok) {
      x_offset = *s_offset + *m1;
      for (j = 0; j <= size; j++) {
	/*$ifdef TRACE-ARRAY*/
	ntr_s_ass(&l, &l_offset, l_offset + j, 0.0, " FindDetermnntOfSum ",
		  20L, 1004L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	l->z[l_offset + j] = 0.0;
      }
      *y = 0.0;
      for (i = 0; i < marginal_dimension(b); i++) {
	count = n[*n_offset + i];
	/*$ifdef TRACE*/
	if (trace_flag[TRACE_FLAG_FACTOR * 1004]) {
	  trace_1(" FindDeterminantOf: ", 20L, i, count, x_offset, -1L, -1L,
		  -1L, -1.0, -1.0, -1.0);
	  write_headed_matrix_s(" Term:                                  ",
				10L, s, &x_offset, m1);
	}
	/*$endif TRACE*/
	if (count > 0)
	  *y += count * log((double)count);
	for (j = 0; j < size; j++) {
	  /*$ifdef TRACE-ARRAY*/
	  ntr_s_ref(&l, &l_offset, x_offset + j, " FindDetermnntOfSum ", 20L,
		    1004L, 1L);
	      /* ntr */
	  /* ntr */
	  ntr_s_upd(&l, &l_offset, l_offset + j, (*s)->z[x_offset + j], 1L,
		    " FindDetermnntOfSum ", 20L, 1004L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  l->z[l_offset + j] += (*s)->z[x_offset + j];
	}
	x_offset += *m2;
      }
      if (n[0] > 0) {
	m_offset = l_offset + size;
	m = l;
	cholesky_s_s(&l, &m, &l_offset, &m_offset, false, false, &ok, m1,
		     &ifail);
	/*$ifdef TRACE*/
	if (trace_flag[TRACE_FLAG_FACTOR * 1004] || ifail > 0) {
	  write_headed_matrix_s(" Input(3):                              ",
				10L, &l, &l_offset, m1);
	  write_headed_matrix_s(" Cholesky:                              ",
				10L, &m, &m_offset, m1);
	  write_headed_mult_lower_s(" Cholesky * Cholesky':@@@@@@@           ",
				    22L, &m, &m_offset, m1);
	}
	/*$endif TRACE*/
	if (ok) {
	  *x = find_determinant_from_cholesky_s(&m, &m_offset, m1);
	  if (*x > 0)
	    *x = log(*x);
	} else {
	  *x = _INVALID_REAL;
	  if (note_warnings) {
	    write_pch(stdout, " Note-4 (FindDeterminntOfSum):", 30L);
	    write_pch(stdout, " Cholesky not succeeded. Table", 30L);
	    write_pch(stdout, " has ", 5L);
	    write_integer(stdout, n[0], 3L);
	    write_pch(stdout, " cases / ", 9L);
	    if (*m1 < n[0] - 1)
	      write_pch(stdout, " Cholesky/Determinnt", 20L);
	    else
	      write_pch(stdout, " Non-positive matrix", 20L);
	    if (!test_positive_diag_s(&l, &l_offset, m1))
	      write_pch(stdout, " Non-positive diagonal (4).", 27L);
	    write_integer(stdout, *m1, 3L);
	    write_line(stdout);
	  }
	}
      } else {
	if (note_warnings) {
	  write_pch(stdout, " Note-3 (FindDeterminntOfSum):", 30L);
	  write_pch(stdout, " To few cases in matrix. Table", 30L);
	  write_pch(stdout, " has ", 5L);
	  write_integer(stdout, n[0], 3L);
	  write_pch(stdout, " cases.", 7L);
	  write_line(stdout);
	}
      }
      free_tmp_s_space();   /* 2 * size, l, l_offset */
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
      return ok;
    }
    if (note_warnings) {
      write_pch(stdout, " Note-2 (FindDeterminntOfSum): TmpSSpac.", 40L);
      write_line(stdout);
    }
    return ok;
  }
  if (note_warnings) {
    write_pch(stdout, " Note-1 (FindDeterminntOfSum): FindSsd.", 39L);
    write_line(stdout);
  }
  return ok;
}  /* find_determinant_of_sum */


Static boolean find_gs(a, m1, m2, n_offset, r_offset, r)
long *a;
t_integer *m1, *m2;
t_offset *n_offset;
t_r_offset *r_offset;
t_r_r **r;
{
  t_long_integer i, size, count;
  t_vertex_set b, c;
  t_s_offset s_offset, x_offset;
  t_s_r *s;   /* T_S, find_ssd */
  t_r_offset h_offset;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindGs             ", sizeof(pch20));
  /*$endif TRACE*/
  ok = find_ssd(a, m1, m2, n_offset, &s_offset, &s);
  if (ok)
    ok = find_ghk(a, true, true, true, m1, m2, n_offset, r_offset, r);
  if (ok) {
    P_setint(b, a, delta);
    P_setint(c, a, gamma_);
    size = marginal_dimension(b) - 1;
    i = 0;
    x_offset = *r_offset + *m2 - 1;
    while ((i <= size && n[*n_offset + i] - 1 < *m1) &
	   is_invalid_real((*r)->z[x_offset])) {
      /*$ifdef TRACE-ARRAY*/
      ntr_r_ref(r, r_offset, x_offset, tzt, 20L, 1005L, 1L);
      /*$endif TRACE-ARRAY*/
      x_offset += *m2;
      i++;
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_r_ref(r, r_offset, x_offset, tzt, 20L, 1005L, 1L);
    /*$endif TRACE-ARRAY*/
    if (!is_invalid_real((*r)->z[x_offset]))
      return true;
    x_offset = s_offset;
    h_offset = *r_offset;
    ok = find_determinants(a, m1, m2, n_offset, &s_offset, &s);
    if (!ok)
      return false;
    for (i = 0; i < marginal_dimension(b); i++) {
      count = n[*n_offset + i];
      /*$ifdef TRACE*/
      if (trace_flag[TRACE_FLAG_FACTOR * 1005])
	trace_1(" FindGs: ", 9L, i, count, x_offset, h_offset, -1L,
		-1L, -1.0, -1.0, -1.0);
      /*$endif TRACE*/
      if (count > 0 && !boolean_option[127] || count > 1) {
	/*$ifdef TRACE-ARRAY*/
	ntr_r_ass(r, r_offset, h_offset + *m2 - 1, _INVALID_REAL, tzt, 20L,
		  1005L, -2L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*r)->z[h_offset + *m2 - 1] = find_g(count_continuous(c), count,
	    s->z[x_offset + *m2 - 1],
	    find_scalar_product_s_r_(&s, r, &x_offset, &h_offset, m1));
	/*$ifdef TRACE-ARRAY*/
	ntr_r_ass(r, r_offset, h_offset + *m2 - 1, _INVALID_REAL, tzt, 20L,
		  1005L, 2L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
      }
      x_offset += *m2;
      h_offset += *m2;
    }
    return true;
  }
}  /* find_gs */


/* Not used:
procedure insert_set_in_list_of_ghks_to_find(var a: t_vertex_set;
                                             var set_list:
                                                 t_link_set_list);
var
   p, q: t_link_set_list;
   card_a: t_long_integer;
   b: boolean;
begin
   if set_list <> nil then begin
      card_a := cardinality(a);
      b := true;
      p := set_list;
      q := p;
      if a = p^.vertex_set then
         b := false
      else if cardinality(p^.vertex_set) <= card_a then begin
         insert_set_in_set_list(a, set_list);
         b := false
      end else
         p := p^.pointer;
      while (p <> nil) and b do
         if a = p^.vertex_set then
            b := false
         else if cardinality(p^.vertex_set) <= card_a then begin
            insert_set_in_set_list(a, p);
            q^.pointer := p;
            b := false
         end else begin
            q := p;
            p := p^.pointer
         end;
      if p = nil then begin
         insert_set_in_set_list(a, p);
         q^.pointer := p
      end
   end else
      insert_set_in_set_list(a, set_list)
end; */
/* insert_set_in_list_of_ghks_to_find */

/* Not used:
procedure find_list_of_ghks(var p: t_link_set_list;
                            var ok: boolean);
var
   q    : t_link_set_list;
   m1, m2   : t_integer;
   n_offset : t_offset;
   r_offset : t_r_offset;
   s    : t_r; / * T_R, find_ghk * /
begin
   ok := true;
   while (p <> nil) and ok do begin
      q := p^.pointer;
      ok := find_ghk(p^.vertex_set, true, true, true,
                     m1, m2, n_offset, r_offset, s);
      dispose(p);
      p := q
   end;
   if not ok then
      dispose_set_list(p)
end; */
/* find_list_of_ghks */
/*@+"rmcsh.p"*/


Static Void revers_offset_list(p)
t_offset_list **p;
{
  t_offset_list *hp1 = NULL;
  t_offset_list *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_offset_list */


Static Void delete_node_in_adjacency_matrix(matrix, link_node)
t_adjacency_matrix *matrix;
t_am_node **link_node;
{
  if ((*link_node)->node_type == first) {
    matrix->vertex_list[(*link_node)->UU.vertex - MIN_VERTEX] = (*link_node)->
								forward_link;
    if ((*link_node)->forward_link != NULL) {
      (*link_node)->forward_link->node_type = first;
      (*link_node)->forward_link->UU.vertex = (*link_node)->UU.vertex;
    }
  } else {
    if ((*link_node)->forward_link != NULL)
      (*link_node)->forward_link->UU.backward_link = (*link_node)->UU.backward_link;
    (*link_node)->UU.backward_link->forward_link = (*link_node)->forward_link;
  }
  _Free(*link_node);
}  /* delete_node_in_adjacency_matrix */


Static Void delete_edge_in_adjacency_matrix(matrix, link_edge)
t_adjacency_matrix *matrix;
t_am_edge_list *link_edge;
{
  t_am_node_ref *p, *q;

  p = link_edge->nodes;
  while (p != NULL) {
    delete_node_in_adjacency_matrix(matrix, &p->node);
    q = p;
    p = p->pointer;
    _Free(q);
  }
  if (link_edge->forward_link != NULL)
    link_edge->forward_link->backward_link = link_edge->backward_link;
  if (link_edge->backward_link != NULL)
    link_edge->backward_link->forward_link = link_edge->forward_link;
  else
    matrix->am_edge_list = link_edge->forward_link;
  _Free(link_edge);
}  /* delete_edge_in_adjacency_matrix */


Static Void return_and_delete_edges_with_vertex(matrix, v, edges)
t_adjacency_matrix *matrix;
t_vertex v;
t_set_list **edges;
{
  while (matrix->vertex_list[v - MIN_VERTEX] != NULL) {
    insert_set_in_set_list(matrix->vertex_list[v - MIN_VERTEX]->link_edge->
			   vertex_set, edges);
    delete_edge_in_adjacency_matrix(matrix,
      matrix->vertex_list[v - MIN_VERTEX]->link_edge);
  }
}  /* return_and_delete_edges_with_vertex */


Static Void return_and_delete_edges_with_vertices(matrix, a, edges)
t_adjacency_matrix *matrix;
long *a;
t_set_list **edges;
{
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      return_and_delete_edges_with_vertex(matrix, v, edges);
  }
}  /* return_and_delete_edges_with_vertices */


Static Void insert_edge_in_adjacency_matrix(matrix, edge)
t_adjacency_matrix *matrix;
long *edge;
{
  t_vertex v;
  t_am_edge_list *p_edge;
  t_am_node *p_node;
  t_am_node_ref *p_ref;

  if (P_setequal(edge, empty_set))
    return;
  p_edge = (t_am_edge_list *)Malloc(sizeof(t_am_edge_list));
  if (p_edge == NULL)
    _OutMem();
  P_setcpy(p_edge->vertex_set, edge);
  p_edge->nodes = NULL;
  p_edge->forward_link = matrix->am_edge_list;
  p_edge->backward_link = NULL;
  if (matrix->am_edge_list != NULL)
    matrix->am_edge_list->backward_link = p_edge;
  matrix->am_edge_list = p_edge;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, edge)) {
      p_node = (t_am_node *)Malloc(sizeof(t_am_node));
      if (p_node == NULL)
	_OutMem();
      if (matrix->vertex_list[v - MIN_VERTEX] != NULL) {
	matrix->vertex_list[v - MIN_VERTEX]->node_type = not_first;
	matrix->vertex_list[v - MIN_VERTEX]->UU.backward_link = p_node;
      }
      p_node->node_type = first;
      p_node->UU.vertex = v;
      p_node->forward_link = matrix->vertex_list[v - MIN_VERTEX];
      p_node->link_edge = p_edge;
      matrix->vertex_list[v - MIN_VERTEX] = p_node;
      p_ref = (t_am_node_ref *)Malloc(sizeof(t_am_node_ref));
      if (p_ref == NULL)
	_OutMem();
      p_ref->node = matrix->vertex_list[v - MIN_VERTEX];
      p_ref->pointer = matrix->am_edge_list->nodes;
      matrix->am_edge_list->nodes = p_ref;
    }
  }
}  /* insert_edge_in_adjacency_matrix */


Static Void insert_edges_in_adjacency_matrix(matrix, edges)
t_adjacency_matrix *matrix;
t_set_list *edges;
{
  while (edges != NULL) {
    insert_edge_in_adjacency_matrix(matrix, edges->vertex_set);
    edges = edges->pointer;
  }
}  /* insert_edges_in_adjacency_matrix */


Static Void new_adjacency_matrix(matrix)
t_adjacency_matrix *matrix;
{
  t_vertex v;

  matrix->am_edge_list = NULL;
  for (v = first_vertex; v <= last_vertex; v++)
    matrix->vertex_list[v - MIN_VERTEX] = NULL;
}  /* new_adjacency_matrix */


Static Void create_adjacency_matrix(matrix, edges)
t_adjacency_matrix *matrix;
t_set_list *edges;
{
  new_adjacency_matrix(matrix);
  insert_edges_in_adjacency_matrix(matrix, edges);
}  /* create_adjacency_matrix */


Static Void delete_edges_with_vertex(matrix, v)
t_adjacency_matrix *matrix;
t_vertex *v;
{
  t_set_list *g_c_a = NULL;

  return_and_delete_edges_with_vertex(matrix, *v, &g_c_a);
  dispose_set_list(&g_c_a);
}  /* delete_edges_with_vertex */


Static Void delete_edges_with_vertices(matrix, a)
t_adjacency_matrix *matrix;
long *a;
{
  t_set_list *g_c_a = NULL;

  return_and_delete_edges_with_vertices(matrix, a, &g_c_a);
  dispose_set_list(&g_c_a);
}  /* delete_edges_with_vertices */


/* Local variables for restricted_maximim_cardinality_search_on_hypergraph: */
struct LOC_restricted_maximim_cardinality_search_on_hypergraph {
  t_adjacency_matrix *matrix_gc;
  boolean *no_exhausted_edges;
  short *alpha, *beta;
  t_vertex *invers_order;
  t_offset_list **r;
  t_0_max_dimension i;
  t_am_edge_list *s;
  t_offset_list *q;
} ;

Local Void init_sets(s, sets, LINK)
t_am_edge_list *s;
t_hyper_set_list **sets;
struct LOC_restricted_maximim_cardinality_search_on_hypergraph *LINK;
{
  t_hyper_set_node *set_node;

  *sets = (t_hyper_set_list *)Malloc(sizeof(t_hyper_set_list));
  if (*sets == NULL)
    _OutMem();
  (*sets)->forward_link = NULL;
  (*sets)->backward_link = NULL;
  (*sets)->node = NULL;
  while (s != NULL) {
    set_node = (t_hyper_set_node *)Malloc(sizeof(t_hyper_set_node));
    if (set_node == NULL)
      _OutMem();
    set_node->link_edge = s;
    set_node->hyper_set = *sets;
    s->beta = -1;
    s->gamma = -1;
    s->size = 0;
    s->card = cardinality(s->vertex_set);
    s->hyper_set_node = set_node;
    if ((*sets)->node != NULL) {
      set_node->forward_link = (*sets)->node;
      (*sets)->node->backward_link = set_node;
    } else
      set_node->forward_link = NULL;
    set_node->backward_link = NULL;
    (*sets)->node = set_node;
    s = s->forward_link;
  }
}  /* init_sets */

Local Void delete_node(sets, s, LINK)
t_hyper_set_list **sets;
t_am_edge_list **s;
struct LOC_restricted_maximim_cardinality_search_on_hypergraph *LINK;
{
  t_hyper_set_node *set_node;

  set_node = (*sets)->node;
  *s = set_node->link_edge;
  if (set_node->forward_link != NULL)
    set_node->forward_link->backward_link = NULL;
  (*sets)->node = set_node->forward_link;
  _Free(set_node);
  /*$ifdef TRACE*/
  ntr_set(" DeleteNode         ", 20L, 1026L, 1L, -1L, -1L, (*s)->vertex_set);
  /*$endif TRACE*/
}  /* delete_node */

Local Void unlink_node(s, set_node, LINK)
t_am_edge_list **s;
t_hyper_set_node **set_node;
struct LOC_restricted_maximim_cardinality_search_on_hypergraph *LINK;
{
  *set_node = (*s)->hyper_set_node;
  if ((*set_node)->forward_link != NULL)
    (*set_node)->forward_link->backward_link = (*set_node)->backward_link;
  if ((*set_node)->backward_link != NULL)
    (*set_node)->backward_link->forward_link = (*set_node)->forward_link;
  else
    (*set_node)->hyper_set->node = (*set_node)->forward_link;
}  /* unlink_node */

Local Void relink_node(sets, set_node, LINK)
t_hyper_set_list **sets;
t_hyper_set_node **set_node;
struct LOC_restricted_maximim_cardinality_search_on_hypergraph *LINK;
{
  t_hyper_set_list *tmp_sets;

  tmp_sets = (*set_node)->hyper_set->backward_link;
  if (tmp_sets == NULL) {
    tmp_sets = (t_hyper_set_list *)Malloc(sizeof(t_hyper_set_list));
    if (tmp_sets == NULL)
      _OutMem();
    tmp_sets->forward_link = *sets;
    tmp_sets->backward_link = NULL;
    tmp_sets->node = NULL;
    (*sets)->backward_link = tmp_sets;
    *sets = tmp_sets;
  }
  if (tmp_sets->node != NULL) {
    (*set_node)->forward_link = tmp_sets->node;
    tmp_sets->node->backward_link = *set_node;
  } else
    (*set_node)->forward_link = NULL;
  (*set_node)->backward_link = NULL;
  tmp_sets->node = *set_node;
  (*set_node)->hyper_set = tmp_sets;
}  /* relink_node */

Local Void discard_node(s, set_node, LINK)
t_am_edge_list **s;
t_hyper_set_node **set_node;
struct LOC_restricted_maximim_cardinality_search_on_hypergraph *LINK;
{
  _Free(*set_node);
  (*s)->hyper_set_node = NULL;
}  /* discard_node */

Local Void clean_up_sets(sets, LINK)
t_hyper_set_list **sets;
struct LOC_restricted_maximim_cardinality_search_on_hypergraph *LINK;
{
  t_hyper_set_list *tmp_sets;

  while ((*sets)->forward_link != NULL && (*sets)->node == NULL) {
    tmp_sets = *sets;
    *sets = (*sets)->forward_link;
    (*sets)->backward_link = NULL;
    _Free(tmp_sets);
  }
  if ((*sets)->node == NULL) {
    _Free(*sets);
    *sets = NULL;
  }
}  /* clean_up_sets */

Local Void write_sets(sets, LINK)
t_hyper_set_list **sets;
struct LOC_restricted_maximim_cardinality_search_on_hypergraph *LINK;
{
  t_am_edge_list *s_tmp;
  t_hyper_set_list *tmp_sets;
  t_hyper_set_node *set_node_tmp;
  FILE *TEMP;

  write_char_n_text(stdout, '+', 50L);
  write_line(stdout);
  tmp_sets = *sets;
  while (tmp_sets != NULL) {
    set_node_tmp = tmp_sets->node;
    while (set_node_tmp != NULL) {
      s_tmp = set_node_tmp->link_edge;
      write_integer_text(stdout, s_tmp->beta, 3L);
      write_integer_text(stdout, s_tmp->gamma, 3L);
      write_integer_text(stdout, s_tmp->size, 3L);
      write_integer_text(stdout, s_tmp->card, 3L);
      write_char_n_text(stdout, ' ', 3L);
      print_vertex_set(s_tmp->vertex_set);
      write_line(stdout);
      set_node_tmp = set_node_tmp->forward_link;
    }
    write_char_n_text(stdout, '+', 50L);
    write_line(stdout);
    tmp_sets = tmp_sets->forward_link;
  }
  TEMP = stdout;
  flush_file(&TEMP);
}  /* write_sets */

Local Void report_results(LINK)
struct LOC_restricted_maximim_cardinality_search_on_hypergraph *LINK;
{
  t_vertex_set a, b;
  t_vertex v;
  FILE *TEMP;

  write_char_n_text(stdout, '=', 50L);
  write_line(stdout);
  LINK->s = LINK->matrix_gc->am_edge_list;
  while (LINK->s != NULL) {
    write_integer_text(stdout, LINK->s->beta, 3L);
    write_integer_text(stdout, LINK->s->gamma, 3L);
    write_integer_text(stdout, LINK->s->size, 3L);
    write_integer_text(stdout, LINK->s->card, 3L);
    write_char_n_text(stdout, ' ', 3L);
    print_vertex_set(LINK->s->vertex_set);
    write_line(stdout);
    LINK->s = LINK->s->forward_link;
  }
  write_char_n_text(stdout, '=', 50L);
  write_line(stdout);
  write_char_n_text(stdout, '=', 50L);
  write_line(stdout);
  revers_offset_list(LINK->r);
  LINK->q = *LINK->r;
  P_setcpy(a, empty_set);
  while (LINK->q != NULL) {
    write_integer(stdout, LINK->q->offset, 4L);
    write_space(stdout, 2L);
    print_vertex_set(LINK->q->vertex_set);
    write_space(stdout, 2L);
    P_setint(b, a, LINK->q->vertex_set);
    print_vertex_set(b);
    P_setunion(a, a, LINK->q->vertex_set);
    write_space(stdout, 2L);
    for (v = first_vertex; v <= last_vertex; v++) {
      if (LINK->beta[v - MIN_VERTEX] <= LINK->q->offset) {
	if (P_inset(v, LINK->q->vertex_set))
	  print_vertex(v);
      }
    }
    write_space(stdout, 2L);
    LINK->i = dimension;
    while (LINK->beta[LINK->invers_order[LINK->i-1] - MIN_VERTEX] <=
	   LINK->q->offset) {
      if (P_inset(LINK->invers_order[LINK->i-1], LINK->q->vertex_set))
	print_vertex(LINK->invers_order[LINK->i-1]);
      LINK->i--;
    }
    write_line(stdout);
    LINK->q = LINK->q->pointer;
  }
  revers_offset_list(LINK->r);
  write_char_n_text(stdout, '=', 50L);
  write_line(stdout);
  write_space(stdout, 2L);
  write_char(stdout, 'V');
  write_pch(stdout, "  ", 2L);
  write_pch(stdout, "  alpha(V)", 10L);
  write_space(stdout, 3L);
  write_pch(stdout, "   beta(V)", 10L);
  write_line(stdout);
  for (v = first_vertex; v <= last_vertex; v++) {
    write_space(stdout, 2L);
    print_vertex_on_file(stdout, v, 0L);
    write_pch(stdout, ": ", 2L);
    write_integer(stdout, (long)LINK->alpha[v - MIN_VERTEX], 10L);
    write_space(stdout, 3L);
    write_integer(stdout, (long)LINK->beta[v - MIN_VERTEX], 10L);
    write_line(stdout);
  }
  write_line(stdout);
  write_char_n_text(stdout, '%', 50L);
  write_line(stdout);
  if (*LINK->no_exhausted_edges)
    write_pch_40_text(stdout, " Decomposabel: No exhausted edges ", 34L);
  else
    write_pch_40_text(stdout, " Decomposabel: exhausted edges @@@@@@   ", 34L);
  write_line(stdout);
  write_char_n_text(stdout, '%', 50L);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}  /* report_results */


Static Void restricted_maximim_cardinality_search_on_hypergraph(matrix_gc_, a,
  no_exhausted_edges_, alpha_, beta_, invers_order_, r_)
t_adjacency_matrix *matrix_gc_;
long *a;
boolean *no_exhausted_edges_;
short *alpha_, *beta_;
t_vertex *invers_order_;
t_offset_list **r_;
{
  struct LOC_restricted_maximim_cardinality_search_on_hypergraph Local_Var;
  t_vertex v;
  t_0_max_dimension k = 0;
  t_am_node *p;
  t_am_edge_list *t;
  t_hyper_set_list *sets;
  t_hyper_set_node *set_node;

  Local_Var.matrix_gc = matrix_gc_;
  Local_Var.no_exhausted_edges = no_exhausted_edges_;
  Local_Var.alpha = alpha_;
  Local_Var.beta = beta_;
  Local_Var.invers_order = invers_order_;
  Local_Var.r = r_;
  for (v = first_vertex; v <= last_vertex; v++)
    Local_Var.beta[v - MIN_VERTEX] = MAX_DIMENSION;
  for (v = first_vertex; v <= last_vertex; v++)
    Local_Var.alpha[v - MIN_VERTEX] = 0;
  init_sets(Local_Var.matrix_gc->am_edge_list, &sets, &Local_Var);
  if (!P_setequal(a, empty_set)) {
    Local_Var.s = Local_Var.matrix_gc->am_edge_list;
    while (!P_subset(a, Local_Var.s->vertex_set))
      Local_Var.s = Local_Var.s->forward_link;
    unlink_node(&Local_Var.s, &set_node, &Local_Var);
    relink_node(&sets, &set_node, &Local_Var);
  }
  *Local_Var.no_exhausted_edges = true;
  *Local_Var.r = NULL;
  Local_Var.i = dimension + 1;
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 1024])
    write_sets(&sets, &Local_Var);
  /*$endif TRACE*/
  clean_up_sets(&sets, &Local_Var);
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 1024])
    write_sets(&sets, &Local_Var);
  /*$endif TRACE*/
  while (sets != NULL) {
    delete_node(&sets, &Local_Var.s, &Local_Var);
    k++;
    Local_Var.s->beta = k;
    Local_Var.s->size = -1;
    insert_offset(Local_Var.s->vertex_set, Local_Var.s->gamma, Local_Var.r);
    for (v = first_vertex; v <= last_vertex; v++) {
      if (Local_Var.alpha[v - MIN_VERTEX] == 0) {
	if (P_inset(v, Local_Var.s->vertex_set)) {
	  /*$ifdef TRACE*/
	  ntr_vertex(" RestrictMCSOnHyper ", 20L, 1026L, 1L, -1L, -1L, &v);
	  /*$endif TRACE*/
	  Local_Var.i--;
	  Local_Var.alpha[v - MIN_VERTEX] = Local_Var.i;
	  Local_Var.invers_order[Local_Var.i-1] = v;
	  Local_Var.beta[v - MIN_VERTEX] = k;
	  p = Local_Var.matrix_gc->vertex_list[v - MIN_VERTEX];
	  while (p != NULL) {
	    if (p->link_edge->size >= 0) {
	      t = p->link_edge;
	      t->gamma = k;
	      unlink_node(&t, &set_node, &Local_Var);
	      t->size++;
	      if (t->size < t->card)
		relink_node(&sets, &set_node, &Local_Var);
	      else if (t->size == t->card) {
		t->size = -1;
		discard_node(&t, &set_node, &Local_Var);
		*Local_Var.no_exhausted_edges = false;
	      } else
		note_error(51L);
	      /*$ifdef TRACE*/
	      if (trace_flag[TRACE_FLAG_FACTOR * 1024]) {
		/*$endif TRACE*/
		write_sets(&sets, &Local_Var);
	      }
	    }
	    p = p->forward_link;
	  }
	}
      }
    }
    clean_up_sets(&sets, &Local_Var);
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 1024]) {
      /*$endif TRACE*/
      write_sets(&sets, &Local_Var);
    }
  }
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 1024]) {
    /*$endif TRACE*/
    report_results(&Local_Var);
  }
}  /* restricted_maximim_cardinality_search_on_hypergraph */


Static boolean test_acyclic_hypergraph(beta, r)
short *beta;
t_offset_list **r;
{
  t_vertex v;
  t_0_max_dimension i = 1;
  t_offset_list *t, *s;
  boolean acyclic = true;
  t_v_arr_of_order index;

  for (v = first_vertex; v <= last_vertex; v++)
    index[v - MIN_VERTEX] = 0;
  t = *r;
  while (t != NULL && acyclic) {
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, t->vertex_set))
	index[v - MIN_VERTEX] = i;
    }
    s = *r;
    while (s != NULL && acyclic) {
      if (s->offset == i) {
	for (v = first_vertex; v <= last_vertex; v++) {
	  if (beta[v - MIN_VERTEX] < i && index[v - MIN_VERTEX] < i) {
	    if (P_inset(v, s->vertex_set))
	      acyclic = false;
	  }
	}
      }
      s = s->pointer;
    }
    t = t->pointer;
    i++;
  }
  return acyclic;
}  /* test_acyclic_hypergraph */


typedef t_long_real t_l[NULL_VERTEX - MIN_VERTEX + 1];


/*@+"lexm.p"*/


Static Void marked_lex_m(s, adj_list, order, invers_order, fill_in_adj_list)
long *s;
t_vertex_list **adj_list;
short *order;
t_vertex *invers_order;
t_vertex_list **fill_in_adj_list;
{
  t_vertex_list *reach[MAX_DIMENSION + 1];
  t_0_max_dimension i, j;
  t_0_max_dimension k = 1;
  t_vertex v, w, z;
  t_long_integer lab[MAX_2_DIMENSION];
  t_v_arr_of_boolean reached;
  t_l l;
  t_vertex_list *p, *q, *r;
  short a, m;
  t_vertex FORLIM1;

  for (v = first_vertex; v <= last_vertex; v++) {
    l[v - MIN_VERTEX] = 1.0;
    order[v - MIN_VERTEX] = 0;
  }
  for (i = dimension + 1; i >= 1; i--) {
    for (j = 1; j <= k; j++)
      reach[j] = NULL;
    if (i == dimension + 1) {
      v = last_vertex + 1;
      for (w = first_vertex; w <= last_vertex; w++) {
	if (P_inset(w, s)) {
	  insert_vertex_in_vertex_list(w,
	    &reach[(int)((long)floor(l[w - MIN_VERTEX] + 0.5))]);
	  P_putbits_UB(reached, w - MIN_VERTEX, 1, 0, 3);
	  l[w - MIN_VERTEX] += 1.0 / 2;
	} else
	  P_clrbits_B(reached, w - MIN_VERTEX, 0, 3);
      }
    } else {
      v = first_vertex;
      while (order[v - MIN_VERTEX] != 0 || l[v - MIN_VERTEX] != k)
	v++;
      invers_order[i-1] = v;
      order[v - MIN_VERTEX] = i;
      for (w = first_vertex; w <= last_vertex; w++) {
	P_clrbits_B(reached, w - MIN_VERTEX, 0, 3);
	P_putbits_UB(reached, w - MIN_VERTEX, order[w - MIN_VERTEX] != 0, 0,
		     3);
      }
      p = adj_list[v - MIN_VERTEX];
      while (p != NULL) {
	w = p->vertex;
	if (order[w - MIN_VERTEX] == 0) {
	  insert_vertex_in_vertex_list(w,
	    &reach[(int)((long)floor(l[w - MIN_VERTEX] + 0.5))]);
	  P_putbits_UB(reached, w - MIN_VERTEX, 1, 0, 3);
	  l[w - MIN_VERTEX] += 1.0 / 2;
	  insert_vertex_in_vertex_list(v, &fill_in_adj_list[w - MIN_VERTEX]);
	  insert_vertex_in_vertex_list(w, &fill_in_adj_list[v - MIN_VERTEX]);
	}
	p = p->pointer;
      }
    }
    for (j = 1; j <= k; j++) {
      p = reach[j];
      while (p != NULL) {
	w = p->vertex;
	q = p;
	p = p->pointer;
	_Free(q);
	q = adj_list[w - MIN_VERTEX];
	while (q != NULL) {
	  z = q->vertex;
	  if (!P_getbits_UB(reached, z - MIN_VERTEX, 0, 3)) {
	    r = (t_vertex_list *)Malloc(sizeof(t_vertex_list));
	    if (r == NULL)
	      _OutMem();
	    r->vertex = z;
	    P_putbits_UB(reached, z - MIN_VERTEX, 1, 0, 3);
	    if (l[z - MIN_VERTEX] > j) {
	      r->pointer = reach[(int)((long)floor(l[z - MIN_VERTEX] + 0.5))];
	      reach[(int)((long)floor(l[z - MIN_VERTEX] + 0.5))] = r;
	      l[z - MIN_VERTEX] += 1.0 / 2;
	      if (v > last_vertex)
		write_pch(stdout, "%%% e9 %%%", 10L);
	      else {
		insert_vertex_in_vertex_list(v,
		  &fill_in_adj_list[z - MIN_VERTEX]);
		insert_vertex_in_vertex_list(z,
		  &fill_in_adj_list[v - MIN_VERTEX]);
	      }
	    } else {
	      r->pointer = p;
	      p = r;
	    }
	  }
	  q = q->pointer;
	}
      }
    }
    a = k * 2 + 1;
    for (m = 0; m <= a - 1; m++)
      lab[m] = 0;
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 1039]) {
      write_line(stdout);
      write_pch(stdout, " Order:   ", 10L);
      FORLIM1 = last_vertex;
      for (v = first_vertex; v <= FORLIM1; v++)
	write_integer(stdout, (long)order[v - MIN_VERTEX], 5L);
      write_line(stdout);
      write_pch(stdout, " L:       ", 10L);
      FORLIM1 = last_vertex;
      for (v = first_vertex; v <= FORLIM1; v++)
	write_real(stdout, l[v - MIN_VERTEX], 5L, 1L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    for (v = first_vertex; v <= last_vertex; v++) {
      if (order[v - MIN_VERTEX] == 0)
	lab[(int)((long)floor(2 * l[v - MIN_VERTEX] + 0.5)) - 1] = 1;
    }
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 1039]) {
      write_pch(stdout, " Lab:     ", 10L);
      for (m = 0; m <= a - 1; m++)
	write_integer(stdout, lab[m], 5L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    k = 0;
    for (m = 0; m <= a - 1; m++) {
      if (lab[m] == 1) {
	k++;
	lab[m] = k;
      }
    }
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 1039]) {
      write_pch(stdout, " K:       ", 10L);
      write_integer(stdout, (long)k, 5L);
      write_line(stdout);
      write_pch(stdout, " Lab:     ", 10L);
      for (m = 0; m <= a - 1; m++)
	write_integer(stdout, lab[m], 5L);
      write_line(stdout);
    }
    FORLIM1 = last_vertex;
    /*$endif TRACE*/
    for (v = first_vertex; v <= FORLIM1; v++) {
      if (order[v - MIN_VERTEX] == 0)
	l[v - MIN_VERTEX] = lab[(int)((long)floor(2 * l[v - MIN_VERTEX] + 0.5)) - 1];
    }
    /*$ifdef TRACE*/
    if (trace_flag[TRACE_FLAG_FACTOR * 1039]) {
      write_pch(stdout, " L:       ", 10L);
      FORLIM1 = last_vertex;
      for (v = first_vertex; v <= FORLIM1; v++)
	write_real(stdout, l[v - MIN_VERTEX], 5L, 1L);
      write_line(stdout);
    }
    /*$endif TRACE*/
  }
}  /* marked_lex_m */


Static Void lex_m(adj_list, order, invers_order, fill_in_adj_list)
t_vertex_list **adj_list;
short *order;
t_vertex *invers_order;
t_vertex_list **fill_in_adj_list;
{
  marked_lex_m(empty_set, adj_list, order, invers_order, fill_in_adj_list);
}  /* lex_m */


/*@+"maxcard.p"*/


Static Void marked_maximum_cardinality_search(s, adj_list, order, invers_order)
long *s;
t_vertex_list **adj_list;
short *order;
t_vertex *invers_order;
{
  t_vertex_set set_num[MAX_DIMENSION + 1];
  t_0_max_dimension i, j;
  t_vertex v, w;
  t_v_arr_of_order size;
  t_vertex_list *p;

  for (i = 0; i <= dimension; i++)
    P_setcpy(set_num[i], empty_set);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, s)) {
      size[v - MIN_VERTEX] = 1;
      P_addset(set_num[1], v);
    } else {
      size[v - MIN_VERTEX] = 0;
      P_addset(set_num[0], v);
    }
  }
  invers_order[dimension] = last_vertex + 1;
  order[last_vertex - MIN_VERTEX + 1] = dimension + 1;
  if (P_setequal(s, empty_set))
    j = 0;
  else
    j = 1;
  for (i = dimension; i >= 1; i--) {
    v = first_vertex;
    while (!P_inset(v, set_num[j]))
      v++;
    order[v - MIN_VERTEX] = i;
    invers_order[i-1] = v;
    size[v - MIN_VERTEX] = -1;
    P_remset(set_num[j], v);
    p = adj_list[v - MIN_VERTEX];
    while (p != NULL) {
      w = p->vertex;
      if (size[w - MIN_VERTEX] >= 0) {
	P_remset(set_num[size[w - MIN_VERTEX]], w);
	size[w - MIN_VERTEX]++;
	P_addset(set_num[size[w - MIN_VERTEX]], w);
      }
      p = p->pointer;
    }
    j++;
    while (j > 0 && P_setequal(set_num[j], empty_set))
      j--;
  }
}  /* marked_maximum_cardinality_search */


Static Void maximum_cardinality_search(adj_list, order, invers_order)
t_vertex_list **adj_list;
short *order;
t_vertex *invers_order;
{
  t_vertex_set set_num[MAX_DIMENSION + 1];
  t_0_max_dimension i;
  t_0_max_dimension j = 0;
  t_vertex v, w;
  t_v_arr_of_order size;
  t_vertex_list *p;

  for (i = 0; i <= dimension; i++)
    P_setcpy(set_num[i], empty_set);
  for (v = first_vertex; v <= last_vertex; v++) {
    size[v - MIN_VERTEX] = 0;
    P_addset(set_num[0], v);
  }
  invers_order[dimension] = last_vertex + 1;
  order[last_vertex - MIN_VERTEX + 1] = dimension + 1;
  for (i = dimension; i >= 1; i--) {
    v = first_vertex;
    while (!P_inset(v, set_num[j]))
      v++;
    order[v - MIN_VERTEX] = i;
    invers_order[i-1] = v;
    size[v - MIN_VERTEX] = -1;
    P_remset(set_num[j], v);
    p = adj_list[v - MIN_VERTEX];
    while (p != NULL) {
      w = p->vertex;
      if (size[w - MIN_VERTEX] >= 0) {
	P_remset(set_num[size[w - MIN_VERTEX]], w);
	size[w - MIN_VERTEX]++;
	P_addset(set_num[size[w - MIN_VERTEX]], w);
      }
      p = p->pointer;
    }
    j++;
    while (j > 0 && P_setequal(set_num[j], empty_set))
      j--;
  }
}  /* maximum_cardinality_search */


Static Void fill_in_computation(adj_list, order, invers_order,
				fill_in_adj_list)
t_vertex_list **adj_list;
short *order;
t_vertex *invers_order;
t_vertex_list **fill_in_adj_list;
{
  t_vertex v, w;
  t_long_integer i;
  t_vertex_list *p;
  t_v_arr_of_vertex follow;
  t_v_arr_of_order index;

  for (v = first_vertex; v <= last_vertex; v++)
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
  for (i = 1; i <= dimension; i++) {
    w = invers_order[i-1];
    follow[w - MIN_VERTEX] = w;
    index[w - MIN_VERTEX] = i;
    p = adj_list[w - MIN_VERTEX];
    while (p != NULL) {
      v = p->vertex;
      if (order[v - MIN_VERTEX] < i) {
	while (index[v - MIN_VERTEX] < i) {
	  index[v - MIN_VERTEX] = i;
	  insert_vertex_in_vertex_list(v, &fill_in_adj_list[w - MIN_VERTEX]);
	  insert_vertex_in_vertex_list(w, &fill_in_adj_list[v - MIN_VERTEX]);
	  v = follow[v - MIN_VERTEX];
	}
	if (follow[v - MIN_VERTEX] == v)
	  follow[v - MIN_VERTEX] = w;
      }
      p = p->pointer;
    }
  }
}  /* fill_in_computation */


Static boolean test_for_zero_fill_in(adj_list, order, invers_order)
t_vertex_list **adj_list;
short *order;
t_vertex *invers_order;
{
  t_vertex v, w;
  t_long_integer i = 1;
  t_vertex_list *p;
  boolean ok = true;
  t_v_arr_of_vertex follow;
  t_v_arr_of_order index;

  while (i <= dimension && ok == true) {
    w = invers_order[i-1];
    follow[w - MIN_VERTEX] = w;
    index[w - MIN_VERTEX] = i;
    p = adj_list[w - MIN_VERTEX];
    while (p != NULL) {
      v = p->vertex;
      if (order[v - MIN_VERTEX] < i) {
	index[v - MIN_VERTEX] = i;
	if (follow[v - MIN_VERTEX] == v)
	  follow[v - MIN_VERTEX] = w;
      }
      p = p->pointer;
    }
    p = adj_list[w - MIN_VERTEX];
    while (p != NULL && ok == true) {
      v = p->vertex;
      if (order[v - MIN_VERTEX] < i) {
	if (index[follow[v - MIN_VERTEX] - MIN_VERTEX] < i)
	  ok = false;
      }
      p = p->pointer;
    }
    i++;
  }
  return ok;
}  /* test_for_zero_fill_in */


Static boolean marked_test_for_zero_fill_in(s, adj_list, order, invers_order)
long *s;
t_vertex_list **adj_list;
short *order;
t_vertex *invers_order;
{
  t_vertex u, v, w;
  t_long_integer i = 1;
  t_vertex_list *p;
  boolean ok = true;
  t_v_arr_of_vertex follow;
  t_v_arr_of_order index;

  u = last_vertex + 1;
  order[u - MIN_VERTEX] = dimension + 1;
  invers_order[dimension] = u;
  while (i <= dimension && ok) {
    w = invers_order[i-1];
    follow[w - MIN_VERTEX] = w;
    index[w - MIN_VERTEX] = i;
    p = adj_list[w - MIN_VERTEX];
    while (p != NULL) {
      v = p->vertex;
      if (order[v - MIN_VERTEX] < i) {
	index[v - MIN_VERTEX] = i;
	if (follow[v - MIN_VERTEX] == v)
	  follow[v - MIN_VERTEX] = w;
      }
      p = p->pointer;
    }
    if (P_inset(w, s)) {
      if (order[u - MIN_VERTEX] < i) {
	index[u - MIN_VERTEX] = i;
	if (follow[u - MIN_VERTEX] == u)
	  follow[u - MIN_VERTEX] = w;
      }
    }
    p = adj_list[w - MIN_VERTEX];
    while (p != NULL && ok) {
      v = p->vertex;
      if (order[v - MIN_VERTEX] < i) {
	if (index[follow[v - MIN_VERTEX] - MIN_VERTEX] < i)
	  ok = false;
      }
      p = p->pointer;
    }
    if (P_inset(w, s) && ok) {
      if (order[u - MIN_VERTEX] < i) {
	if (index[follow[u - MIN_VERTEX] - MIN_VERTEX] < i)
	  ok = false;
      }
    }
    i++;
  }
  if (!ok)
    return false;
  follow[u - MIN_VERTEX] = u;
  index[u - MIN_VERTEX] = i;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, s)) {
      if (order[v - MIN_VERTEX] < i) {
	index[v - MIN_VERTEX] = i;
	if (follow[v - MIN_VERTEX] == v)
	  follow[v - MIN_VERTEX] = u;
      }
    }
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, s)) {
      if (order[v - MIN_VERTEX] < i) {
	if (index[follow[v - MIN_VERTEX] - MIN_VERTEX] < i)
	  ok = false;
      }
    }
  }
  return ok;
}  /* marked_test_for_zero_fill_in */


/*@+"printf.p"*/


/*

1053:    +++  ++
1054:    +++  ++
1055:    ---  -- p/printf.p         11      55     770 p/printf.p
1056: |    4:    procedure describe_d_complete_node
1057: |   25:    procedure describe_c_complete_node
1058: |   43:    procedure describe_m_complete_node
1059: |   61:    procedure describe_d_ips_node
1060: |  103:    procedure describe_r_ips_node
1061: |  238:    procedure describe_r_ips_node_short
1062: |  276:    procedure describe_c_ips_node
1063: |  314:    procedure describe_m_ips_node
1064: |  353:    procedure sub_print_formula
1065: |  417:    procedure print_formula
1066: |  424:    procedure note_trace_model_formula
1067:    +++  ++
1068:    +++  ++

*/


Static Void describe_d_complete_node(d_complete_leaf, dept, denominator, full)
t_power_set **d_complete_leaf;
t_integer *dept;
boolean denominator, *full;
{
  write_space(stdout, *dept);
  if (*full) {   /* vertex_set */
    write_integer(stdout, marginal_dimension((*d_complete_leaf)->a), 12L);
    write_pch(stdout, " / ", 3L);
  }
  if (em)
    write_pch(stdout, "   p ( I ", 9L);
  else
    write_pch(stdout, "   N ( I ", 9L);
  /* vertex_set */
  print_vertex_set_table((*d_complete_leaf)->a);
  write_pch(stdout, " ) ", 3L);
  if (denominator)
    write_pch(stdout, " ^ -1 ", 6L);
  write_line(stdout);
}  /* describe_d_complete_node */


Static Void describe_c_complete_node(c_complete_leaf, dept, denominator, full)
t_power_set **c_complete_leaf;
t_integer *dept;
boolean denominator, *full;
{
  write_space(stdout, *dept);
  if (*full) {   /* vertex_set */
    write_integer(stdout, marginal_dimension((*c_complete_leaf)->a), 12L);
    write_pch(stdout, " / ", 3L);
  }
  write_pch(stdout, "   Cov ( ", 9L);   /* vertex_set */
  print_vertex_set_table((*c_complete_leaf)->a);
  write_pch(stdout, " ) ", 3L);
  if (denominator)
    write_pch(stdout, " ^ -1 ", 6L);
  write_line(stdout);
}  /* describe_c_complete_node */


Static Void describe_m_complete_node(m_complete_leaf, dept, denominator, full)
t_power_set **m_complete_leaf;
t_integer *dept;
boolean denominator, *full;
{
  write_space(stdout, *dept);
  if (*full) {   /* vertex_set */
    write_integer(stdout, marginal_dimension((*m_complete_leaf)->a), 12L);
    write_pch(stdout, " / ", 3L);
  }
  write_pch(stdout, "   COV ( ", 9L);   /* vertex_set */
  print_vertex_set_table((*m_complete_leaf)->a);
  write_pch(stdout, " ) ", 3L);
  if (denominator)
    write_pch(stdout, " ^ -1 ", 6L);
  write_line(stdout);
}  /* describe_m_complete_node */


Static Void describe_d_ips_node(d_ips_leaf, dept, full)
t_ips_element **d_ips_leaf;
t_integer *dept;
boolean *full;
{
  t_ips_set_list *q;
  t_set_list *cliques = NULL;
  t_integer stop;

  write_space(stdout, *dept);
  if (*full) {
    write_integer(stdout, marginal_dimension((*d_ips_leaf)->a), 12L);
    if ((*d_ips_leaf)->radim_part)
      write_pch(stdout, " /    R ", 8L);
    else
      write_pch(stdout, " /    P ", 8L);
  } else if ((*d_ips_leaf)->radim_part)
    write_pch(stdout, "   R ", 5L);
  else
    write_pch(stdout, "   P ", 5L);
  q = (*d_ips_leaf)->gen_class;
  while (q != NULL) {
    insert_set_in_set_list(q->vertex_set, &cliques);
    q = q->pointer;
  }
  if (*full)
    print_g_c_stop(cliques, 21L, line_length, &stop);
  else
    print_g_c_stop(cliques, 6L, line_length, &stop);
  if (stop > line_length - cardinality((*d_ips_leaf)->a) &&
      line_length < MAX_LINE_LENGTH) {
    write_line(stdout);
    write_space(stdout, 19L);
  }
  dispose_set_list(&cliques);
  write_pch(stdout, " ( I ", 5L);
  print_vertex_set((*d_ips_leaf)->a);
  write_pch(stdout, " ) ", 3L);
  write_line(stdout);
}  /* describe_d_ips_node */


Static Void describe_r_ips_node(r_ips_leaf, dept, full)
t_radim_element **r_ips_leaf;
t_integer *dept;
boolean *full;
{
  t_radim_part *r;
  t_offset_list *s;
  t_ips_set_list *q;
  t_set_list *cliques = NULL;
  t_integer stop;

  write_space(stdout, *dept);
  if (*full) {
    write_integer(stdout, marginal_dimension((*r_ips_leaf)->a), 12L);
    write_pch(stdout, " /    F ", 8L);
  } else
    write_pch(stdout, "   F ", 5L);
  q = (*r_ips_leaf)->gen_class;
  while (q != NULL) {
    /*$ifdef TRACE*/
    ntr_set("                    ", 0L, 1060L, 1L, -1L, q->n_offset,
	    q->vertex_set);
	/*ntr*/
    /*$endif TRACE*/
    insert_set_in_set_list(q->vertex_set, &cliques);
    q = q->pointer;
  }
  if (*full)
    print_g_c_stop(cliques, 21L, line_length, &stop);
  else
    print_g_c_stop(cliques, 6L, line_length, &stop);
  if (stop > line_length - cardinality((*r_ips_leaf)->a) &&
      line_length < MAX_LINE_LENGTH) {
    write_line(stdout);
    write_space(stdout, 19L);
  }
  dispose_set_list(&cliques);
  write_pch(stdout, " ( I ", 5L);
  print_vertex_set((*r_ips_leaf)->a);
  write_pch(stdout, " ) : ", 5L);
  write_line(stdout);
  if ((*r_ips_leaf)->radim_parts != NULL) {
    r = (*r_ips_leaf)->radim_parts;
    while (r != NULL) {
      write_space(stdout, 20L);
      write_pch(stdout, "Generators: ", 12L);
      /*$ifdef TRACE*/
      if (trace_flag[TRACE_FLAG_FACTOR * 1060]) {
	s = r->generators;
	while (s != NULL) {
	  ntr_set("                    ", 0L, 1060L, 1L, -1L, s->offset,
		  s->vertex_set);
	      /*ntr*/
	  s = s->pointer;
	}
      }
      /*$endif TRACE*/
      s = r->generators;
      while (s != NULL) {
	print_vertex_set(s->vertex_set);
	s = s->pointer;
      }
      write_line(stdout);
      write_space(stdout, 23L);
      write_pch(stdout, "Upper: ", 7L);
      s = r->upper;
      cliques = NULL;
      while (s != NULL) {
	/*$ifdef TRACE*/
	ntr_set("                    ", 0L, 1060L, 1L, -1L, s->offset,
		s->vertex_set);
	    /*ntr*/
	/*$endif TRACE*/
	insert_set_in_set_list(s->vertex_set, &cliques);
	s = s->pointer;
      }
      print_g_c_stop(cliques, 30L, line_length, &stop);
      dispose_set_list(&cliques);
      write_line(stdout);
      write_space(stdout, 23L);
      write_pch(stdout, "Lower: ", 7L);
      s = r->lower;
      cliques = NULL;
      while (s != NULL) {
	/*$ifdef TRACE*/
	ntr_set("                    ", 0L, 1060L, 1L, -1L, s->offset,
		s->vertex_set);
	    /*ntr*/
	/*$endif TRACE*/
	insert_set_in_set_list(s->vertex_set, &cliques);
	s = s->pointer;
      }
      print_g_c_stop(cliques, 30L, line_length, &stop);
      dispose_set_list(&cliques);
      write_line(stdout);
      write_space(stdout, 23L);
      write_pch(stdout, "From:  ", 7L);
      s = r->from;
      cliques = NULL;
      while (s != NULL) {
	/*$ifdef TRACE*/
	ntr_set("                    ", 0L, 1060L, 1L, -1L, s->offset,
		s->vertex_set);
	    /*ntr*/
	/*$endif TRACE*/
	insert_set_in_set_list(s->vertex_set, &cliques);
	s = s->pointer;
      }
      print_g_c_stop(cliques, 30L, line_length, &stop);
      dispose_set_list(&cliques);
      write_line(stdout);
      r = r->pointer;
    }
  }
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 1059]) {
    /*$endif TRACE*/
    describe_ips_list((*r_ips_leaf)->ips_list, true);
  }
}  /* describe_r_ips_node */


/* Not used:
procedure describe_r_ips_node_short(var r_ips_leaf : t_link_radim_element;
                                    var dept   : t_integer;
                                    var full   : boolean);
var
   q   : t_link_ips_set_list;
   cliques : t_link_set_list;
   stop   : t_integer;
begin
   write_space(output, dept);
   if full then begin
      write_integer(output,
                    marginal_dimension(r_ips_leaf^.a), 12);
      write_pch(output, ' /    F @@', 8)
   end else
      write_pch(output, '   F @@@@@', 5);
   q := r_ips_leaf^.gen_class;
   cliques := nil;
   while q <> nil do begin
      insert_set_in_set_list(q^.vertex_set, cliques);
      q := q^.pointer
   end;
   if full then
      print_g_c_stop(cliques, 21, line_length, stop)
   else
      print_g_c_stop(cliques, 6, line_length, stop);
   if (stop > line_length - cardinality(r_ips_leaf^.a))
      and (line_length < max_line_length) then
   begin
      write_line(output);
      write_space(output, 19)
   end;
   dispose_set_list(cliques);
   write_pch(output, ' ( I @@@@@', 5);
   print_vertex_set(r_ips_leaf^.a);
   write_pch(output, ' ) @@@@@@@', 3);
   write_line(output)
end; */
/* describe_r_ips_node_short */

Static Void describe_c_ips_node(c_ips_leaf, model_set, dept, full)
t_cips_element **c_ips_leaf;
long *model_set;
t_integer *dept;
boolean *full;
{
  t_cips_set_list *q;
  t_set_list *cliques = NULL;
  t_integer stop;

  write_space(stdout, *dept);
  if (*full) {
    write_integer(stdout, cardinality(model_set), 12L);
    write_pch(stdout, " /    P ", 8L);
  } else
    write_pch(stdout, "   P ", 5L);
  q = (*c_ips_leaf)->generators;
  while (q != NULL) {
    insert_set_in_set_list(q->vertex_set, &cliques);
    q = q->pointer;
  }
  if (*full)
    print_g_c_stop(cliques, 21L, line_length, &stop);
  else
    print_g_c_stop(cliques, 6L, line_length, &stop);
  if (stop > line_length - cardinality(model_set) &&
      line_length < MAX_LINE_LENGTH) {
    write_line(stdout);
    write_space(stdout, 19L);
  }
  dispose_set_list(&cliques);
  write_pch(stdout, " ( I ", 5L);
  print_vertex_set(model_set);
  write_pch(stdout, " ) ", 3L);
  write_line(stdout);
}  /* describe_c_ips_node */


Static Void describe_m_ips_node(m_ips_leaf, model_set, dept, full)
t_mips_element **m_ips_leaf;
long *model_set;
t_integer *dept;
boolean *full;
{
  t_integer stop;

  write_space(stdout, *dept);
  write_pch(stdout, "   F ( I ", 9L);
  print_vertex_set_table(model_set);
  if ((*m_ips_leaf)->complete)
    write_pch(stdout, " % ", 3L);
  else
    write_pch(stdout, " : ", 3L);
  print_g_c_stop((*m_ips_leaf)->discrete_, 21L, line_length, &stop);
  write_pch(stdout, " / ", 3L);
  print_g_c_stop((*m_ips_leaf)->linear, 21L, line_length, &stop);
  write_pch(stdout, " / ", 3L);
  print_g_c_stop((*m_ips_leaf)->quadratic, 21L, line_length, &stop);
  write_pch(stdout, " ) ", 3L);
  /* if m_ips_leaf^.full_specified then
       write_pch(output, '[f]@@@@@@@', 3); */
  if ((*m_ips_leaf)->mixed_characteristics != NULL) {
    if ((*m_ips_leaf)->mixed_characteristics->degenerated)
      write_pch(stdout, "[0]", 3L);
    if ((*m_ips_leaf)->mixed_characteristics->mim_model)
      write_pch(stdout, "[m]", 3L);
    if ((*m_ips_leaf)->mixed_characteristics->d_collapsible)
      write_pch(stdout, "[d]", 3L);
    if ((*m_ips_leaf)->mixed_characteristics->mean_linear)
      write_pch(stdout, "[l]", 3L);
    if ((*m_ips_leaf)->mixed_characteristics->q_equivalent)
      write_pch(stdout, "[q]", 3L);
    /*  if m_ips_leaf^.homogeneous then
          write_pch(output, '[h]@@@@@@@', 3); */
  }
  write_line(stdout);
}  /* describe_m_ips_node */


Static Void sub_print_formula(model, dept, full)
t_model **model;
t_integer dept;
boolean *full;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;

  write_space(stdout, dept + 2);
  write_pch(stdout, "/ ", 2L);
  write_integer(stdout, (*model)->dim, 4L);
  write_pch(stdout, "/ ", 2L);
  write_model_type(model);
  write_pch(stdout, ": ", 2L);
  print_model_g_c(model, dept);
  write_line(stdout);
  formula = (*model)->formula_node;
  if (formula == NULL) {
    write_space(stdout, dept + 2);
    write_pch(stdout, "Nil;", 4L);
    write_line(stdout);
    return;
  }
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    decomposition_element = formula->UU.decomposition_node_;
    sub_print_formula(&decomposition_element->left_model, dept + 1, full);
    sub_print_formula(&decomposition_element->right_model, dept + 1, full);
    formula = decomposition_element->separator;
    switch (formula->node_type) {

    case d_complete_node:
      describe_d_complete_node(&formula->UU.d_complete_leaf, &dept, true,
			       full);
      break;

    case c_complete_node:
      describe_c_complete_node(&formula->UU.c_complete_leaf, &dept, true,
			       full);
      break;

    case m_complete_node:
      describe_m_complete_node(&formula->UU.m_complete_leaf, &dept, true,
			       full);
      break;
    }
    break;

  case d_complete_node:
    describe_d_complete_node(&formula->UU.d_complete_leaf, &dept, false, full);
    break;

  case c_complete_node:
    describe_c_complete_node(&formula->UU.c_complete_leaf, &dept, false, full);
    break;

  case m_complete_node:
    describe_m_complete_node(&formula->UU.m_complete_leaf, &dept, false, full);
    break;

  case d_ips_node:
    if (formula->UU.d_ips_leaf != NULL)
      describe_d_ips_node(&formula->UU.d_ips_leaf, &dept, full);
    break;

  case r_ips_node:
    if (formula->UU.r_ips_leaf != NULL)
      describe_r_ips_node(&formula->UU.r_ips_leaf, &dept, full);
    break;

  case c_ips_node:
    describe_c_ips_node(&formula->UU.c_ips_leaf, (*model)->id->vertices,
			&dept, full);
    break;

  case m_ips_node:
    describe_m_ips_node(&formula->UU.m_ips_leaf, (*model)->id->vertices,
			&dept, full);
    break;
  }
}  /* sub_print_formula */


/* Local variables for print_formula: */
struct LOC_print_formula {
  boolean full;
} ;


Static Void print_formula(model, full_)
t_model **model;
boolean full_;
{
  struct LOC_print_formula Local_Var;

  Local_Var.full = full_;
  sub_print_formula(model, 0L, &Local_Var.full);
}  /* print_formula */


/*Has-forward-1*/

Static Void proc_return_model_parity PP((t_model **model,
					 t_long_integer *parity));


/*Has-forward-1*/

Static Void ntr_model_formula(t, w, o, p, n, m, model)
Char *t;
t_long_integer w, o, p, n, m;
t_model *model;
{
  t_long_integer parity;
  FILE *TEMP;

  if (!trace_flag_set(w, o, p))
    return;
  write_pch(stdout, t, w);
  write_char(stdout, ':');
  write_integer(stdout, n, 3L);
  write_char(stdout, '/');
  write_integer(stdout, m, 3L);
  write_char(stdout, '#');
  if (model->id->paritet == 0) {
    proc_return_model_parity(&model, &parity);
    write_integer(stdout, -parity, 10L);
  } else
    write_integer(stdout, model->id->paritet, 10L);
  write_char(stdout, '/');
  write_char(stdout, ' ');
  print_vertex_set_table(model->id->vertices);
  write_char(stdout, '/');
  write_char(stdout, '/');
  write_char(stdout, ' ');
  print_model_g_c(&model, 10L);
  write_model_type(&model);
  write_char(stdout, '|');
  print_g_c(model->id->causal_structure, 0L, line_length);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_line(stdout);
  print_formula(&model, true);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


/*@+"listop.p"*/


/*

1069:    +++  ++
1070:    +++  ++
1071:    ---  -- p/listop.p         17      73    1116 p/listop.p
1072: |    4:    function class_size
1073: |   16:    function g_c_size
1074: |   28:    procedure insert_edge_in_adj_list
1075: |   47:    procedure adj_set_to_adj_list
1076: |   52:    procedure insert_edge_in_adj_list_fast
1077: |   68:    procedure adj_list_to_adj_set
1078: |   84:    procedure dispose_adj_list
1079: |  100:    procedure hypergraph_sets_to_graph_sets
1080: |  123:    procedure find_connected_component
1081: |  156:    procedure find_connected_component_list
1082: |  191:    procedure find_c
1083: |  220:    function adj_set_decomposable
1084: |  247:    procedure find_edges
1085: |  284:    function was_edge_in_one_clique
1086: |  339:    procedure fix_edges_argument
1087: |  348:    procedure and_fix_edges_argument
1088: |  373:    function return_restricted_g_c
1089:    +++  ++
1090:    +++  ++

*/


Static t_long_integer class_size(q)
t_g_c_list *q;
{
  t_long_integer tmp_size = 0;

  while (q != NULL) {
    tmp_size++;
    q = q->pointer;
  }
  return tmp_size;
}  /* class_size */


Static t_long_integer g_c_size(q)
t_set_list *q;
{
  t_long_integer tmp_size = 0;

  while (q != NULL) {
    tmp_size++;
    q = q->pointer;
  }
  return tmp_size;
}  /* g_c_size */


Static Void insert_edge_in_adj_list(adj_list, v1, v2)
t_vertex_list **adj_list;
t_vertex *v1, *v2;
{
  t_vertex_list *p;
  boolean b = true;

  p = adj_list[*v1 - MIN_VERTEX];
  while (p != NULL && b) {
    if (*v2 == p->vertex)
      b = false;
    else
      p = p->pointer;
  }
  if (p == NULL) {
    insert_vertex_in_vertex_list(*v1, &adj_list[*v2 - MIN_VERTEX]);
    insert_vertex_in_vertex_list(*v2, &adj_list[*v1 - MIN_VERTEX]);
  }
}  /* insert_edge_in_adj_list */


Local Void insert_edge_in_adj_list_fast(adj_list, v1, v2)
t_vertex_list **adj_list;
t_vertex v1, v2;
{
  insert_vertex_in_vertex_list(v1, &adj_list[v2 - MIN_VERTEX]);
  insert_vertex_in_vertex_list(v2, &adj_list[v1 - MIN_VERTEX]);
}  /* insert_edge_in_adj_list_fast */


Static Void adj_set_to_adj_list(adj_set, adj_list)
t_vertex_set *adj_set;
t_vertex_list **adj_list;
{
  t_vertex v1, v2;

  for (v1 = first_vertex; v1 <= last_vertex; v1++)
    adj_list[v1 - MIN_VERTEX] = NULL;
  for (v1 = first_vertex; v1 <= last_vertex - 1; v1++) {
    for (v2 = v1 + 1; v2 <= last_vertex; v2++) {
      if (P_inset(v2, adj_set[v1 - MIN_VERTEX]))
	insert_edge_in_adj_list_fast(adj_list, v1, v2);
    }
  }
}  /* adj_set_to_adj_list */


Static Void adj_list_to_adj_set(adj_list, adj_set)
t_vertex_list **adj_list;
t_vertex_set *adj_set;
{
  t_vertex_list *p_vertex;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
    p_vertex = adj_list[v - MIN_VERTEX];
    while (p_vertex != NULL) {
      P_addset(adj_set[v - MIN_VERTEX], p_vertex->vertex);
      p_vertex = p_vertex->pointer;
    }
  }
}  /* adj_list_to_adj_set */


Static Void dispose_adj_list(adj_list)
t_vertex_list **adj_list;
{
  t_vertex_list *p, *q;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    p = adj_list[v - MIN_VERTEX];
    while (p != NULL) {
      q = p->pointer;
      _Free(p);
      p = q;
    }
    adj_list[v - MIN_VERTEX] = NULL;
  }
}  /* dispose_adj_list */


Static Void return_boundary(s, bd, g_c)
long *s, *bd;
t_set_list **g_c;
{
  t_vertex_set a;
  t_set_list *p;

  P_setcpy(bd, empty_set);
  p = *g_c;
  while (p != NULL) {
    P_setint(a, p->vertex_set, s);
    if (!P_setequal(a, empty_set))
      P_setunion(bd, bd, p->vertex_set);
    p = p->pointer;
  }
  P_setdiff(bd, bd, s);
}  /* return_boundary */


Static Void hypergraph_sets_to_graph_sets(p_g_c, model_set, adj_set)
t_set_list *p_g_c;
long *model_set;
t_vertex_set *adj_set;
{
  t_vertex v;
  t_vertex_set a;

  P_setcpy(model_set, empty_set);
  for (v = first_vertex; v <= last_vertex; v++)
    P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  while (p_g_c != NULL) {
    P_setcpy(a, p_g_c->vertex_set);
    P_setunion(model_set, model_set, a);
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, a))
	P_setunion(adj_set[v - MIN_VERTEX], adj_set[v - MIN_VERTEX], a);
    }
    p_g_c = p_g_c->pointer;
  }
  for (v = first_vertex; v <= last_vertex; v++)
    P_remset(adj_set[v - MIN_VERTEX], v);
  P_remset(model_set, double_vertex);
}  /* hypergraph_sets_to_graph_sets */


Static Void find_connected_component(g, d, a, u, adj_list)
long *g, *d, *a;
t_vertex *u;
t_vertex_list **adj_list;
{
  t_v_arr_of_boolean explored;
  t_vertex_list *queue = NULL;
  t_vertex_list *p;
  t_vertex v, w;
  /*$ifdef TRACE*/
  pch20 tzt;
  long TEMP;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindConnComponent  ", sizeof(pch20));
  ntr_vertex_and_set(tzt, 20L, 1080L, 1L, -1L, -1L, u, d);
  /*$endif TRACE*/
  P_addset(P_expset(a, 0L), *u);   /* empty_set + */
  for (v = first_vertex; v <= last_vertex; v++)
    P_clrbits_B(explored, v - MIN_VERTEX, 0, 3);
  TEMP = *u - MIN_VERTEX;
  P_putbits_UB(explored, TEMP, 1, 0, 3);
  insert_vertex_in_vertex_list(*u, &queue);
  while (queue != NULL) {
    v = queue->vertex;
    p = queue;
    queue = queue->pointer;
    _Free(p);
    p = adj_list[v - MIN_VERTEX];
    while (p != NULL) {
      w = p->vertex;
      if ((!P_getbits_UB(explored, w - MIN_VERTEX, 0, 3)) & (!P_inset(w, d)) &
	  P_inset(w, g)) {
	insert_vertex_in_vertex_list(w, &queue);
	P_addset(a, w);
	P_putbits_UB(explored, w - MIN_VERTEX, 1, 0, 3);
      }
      p = p->pointer;
    }
  }
  /*$ifdef TRACE*/
  ntr_vertex_and_set(tzt, 20L, 1080L, 1L, -9L, -9L, u, a);
  /*$endif TRACE*/
}  /* find_connected_component */


Static Void find_connected_components(g, d, g_c, u, adj_list)
long *g, *d;
t_set_list **g_c;
t_vertex *u;
t_vertex_list **adj_list;
{
  t_vertex_list *p;
  t_vertex_set a;
  t_vertex w;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindConnComponents ", sizeof(pch20));
  ntr_vertex_and_set(tzt, 20L, 1080L, 1L, -1L, -1L, u, d);
  /*$endif TRACE*/
  *g_c = NULL;
  p = adj_list[*u - MIN_VERTEX];
  while (p != NULL) {
    w = p->vertex;
    if ((!P_inset(w, d)) & P_inset(w, g)) {
      find_connected_component(g, d, a, &w, adj_list);
      insert_clique(a, g_c);
    }
    p = p->pointer;
  }
}  /* find_connected_components */


Static Void find_connected_component_list(g, d, a, a_list, u, adj_list)
long *g, *d, *a;
t_vertex_list **a_list;
t_vertex *u;
t_vertex_list **adj_list;
{
  t_v_arr_of_boolean explored;
  t_vertex_list *queue = NULL;
  t_vertex_list *q, *p;
  t_vertex v, w;
  long TEMP;

  P_addset(P_expset(a, 0L), *u);   /* empty_set + */
  insert_vertex_in_vertex_list(*u, a_list);
  for (v = first_vertex; v <= last_vertex; v++)
    P_clrbits_B(explored, v - MIN_VERTEX, 0, 3);
  TEMP = *u - MIN_VERTEX;
  P_putbits_UB(explored, TEMP, 1, 0, 3);
  insert_vertex_in_vertex_list(*u, &queue);
  while (queue != NULL) {
    v = queue->vertex;
    q = queue;
    queue = queue->pointer;
    _Free(q);
    p = adj_list[v - MIN_VERTEX];
    while (p != NULL) {
      w = p->vertex;
      if ((!P_getbits_UB(explored, w - MIN_VERTEX, 0, 3)) & (!P_inset(w, d)) &
	  P_inset(w, g)) {
	insert_vertex_in_vertex_list(w, &queue);
	insert_vertex_in_vertex_list(w, a_list);
	P_addset(a, w);
	P_putbits_UB(explored, w - MIN_VERTEX, 1, 0, 3);
      }
      p = p->pointer;
    }
  }
}  /* find_connected_component_list */


Static Void find_c(adj_set, order, invers_order, fill_in_adj_list, c,
		   complete)
t_vertex_set *adj_set;
short *order;
t_vertex *invers_order;
t_vertex_list **fill_in_adj_list;
t_vertex_set *c;
uchar *complete;
{
  t_1_max_dimension i;
  t_vertex_list *p;
  t_vertex u, v;
  int TEMP;

  P_setcpy(c[last_vertex - MIN_VERTEX + 1], empty_set);
  P_putbits_UB(complete, last_vertex - MIN_VERTEX + 1, 1, 0, 3);
  for (i = 1; i <= dimension; i++) {
    u = invers_order[i-1];
    P_setcpy(c[u - MIN_VERTEX], empty_set);
    P_putbits_UB(complete, u - MIN_VERTEX, 1, 0, 3);
    p = fill_in_adj_list[u - MIN_VERTEX];
    while (p != NULL) {
      v = p->vertex;
      if (i < order[v - MIN_VERTEX]) {
	TEMP = (P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) &&
		P_subset(c[u - MIN_VERTEX], adj_set[v - MIN_VERTEX]));
	P_clrbits_B(complete, u - MIN_VERTEX, 0, 3);
	P_putbits_UB(complete, u - MIN_VERTEX, TEMP, 0, 3);
	P_addset(c[u - MIN_VERTEX], v);
      }
      p = p->pointer;
    }
  }
}  /* find_c */


Static boolean adj_set_decomposable(adj_set)
t_vertex_set *adj_set;
{
  boolean Result;
  t_v_arr_of_v_lists adj_list, fill_in_adj_list;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_vertex v;

  adj_set_to_adj_list(adj_set, adj_list);
  if (mixed_data) {
    for (v = first_vertex; v <= last_vertex; v++) {
      order[v - MIN_VERTEX] = 1;
      fill_in_adj_list[v - MIN_VERTEX] = NULL;
    }
    marked_lex_m(delta, adj_list, order, invers_order, fill_in_adj_list);
    /* marked_maximum_cardinality_search(delta, adj_list, order, invers_order)
    adj_set_decomposable := marked_test_for_zero_fill_in(delta,
                                                         adj_list, order,
                                                         invers_order);
     */
    dispose_adj_list(fill_in_adj_list);
  } else
    maximum_cardinality_search(adj_list, order, invers_order);
  Result = test_for_zero_fill_in(adj_list, order, invers_order);
  dispose_adj_list(adj_list);
  return Result;
}  /* adj_set_decomposable */


Static Void find_edges(adj_list_1, adj_set_2, link_edge_list)
t_vertex_list **adj_list_1;
t_vertex_set *adj_set_2;
t_edge_list **link_edge_list;
{
  t_v_arr_of_boolean explored;
  t_vertex_list *queue, *q, *p;
  t_vertex u, v, w;

  for (v = first_vertex; v <= last_vertex; v++)
    P_clrbits_B(explored, v - MIN_VERTEX, 0, 3);
  u = first_vertex;
  do {
    P_putbits_UB(explored, u - MIN_VERTEX, 1, 0, 3);
    queue = NULL;
    insert_vertex_in_vertex_list(u, &queue);
    while (queue != NULL) {
      v = queue->vertex;
      q = queue;
      queue = queue->pointer;
      _Free(q);
      p = adj_list_1[v - MIN_VERTEX];
      while (p != NULL) {
	w = p->vertex;
	if (!P_inset(v, adj_set_2[w - MIN_VERTEX]) && v < w)
	  insert_edge_in_edge_list(v, w, link_edge_list);
	if (!P_getbits_UB(explored, w - MIN_VERTEX, 0, 3)) {
	  insert_vertex_in_vertex_list(w, &queue);
	  P_putbits_UB(explored, w - MIN_VERTEX, 1, 0, 3);
	}
	p = p->pointer;
      }
    }
    while (P_getbits_UB(explored, u - MIN_VERTEX, 0, 3) && u < last_vertex)
      u++;
  } while (!P_getbits_UB(explored, u - MIN_VERTEX, 0, 3));   /* find_edges */
}


Static boolean was_edge_in_one_clique(v, w, g_c, a)
t_vertex *v, *w;
t_set_list **g_c;
long *a;
{
  t_set_list *p_g_c, *q_g_c, *r_g_c;
  boolean first_;
  boolean second = false;
  boolean ok;
  t_vertex_set b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " WasEdgeInOneClique ", sizeof(pch20));
  ntr_vertex_pair_and_g_c(tzt, 20L, 1085L, 1L, -1L, -1L, v, w, g_c);
  P_addset(P_expset(b, 0L), *v);
  P_addset(b, *w);
  /*$endif TRACE*/
  if (P_subset(b, (*g_c)->vertex_set)) {
    first_ = true;
    r_g_c = NULL;
    P_setcpy(a, (*g_c)->vertex_set);
  } else
    first_ = false;
  q_g_c = *g_c;
  p_g_c = (*g_c)->pointer;
  while (p_g_c != NULL && !second) {
    if (P_subset(b, p_g_c->vertex_set)) {
      if (first_)
	second = true;
      first_ = true;
      r_g_c = q_g_c;
      P_setcpy(a, p_g_c->vertex_set);
    }
    q_g_c = p_g_c;
    p_g_c = p_g_c->pointer;
  }
  ok = (first_ && !second);
  if (ok) {
    if (r_g_c == NULL) {
      p_g_c = *g_c;
      *g_c = (*g_c)->pointer;
      _Free(p_g_c);
    } else {
      p_g_c = r_g_c->pointer;
      r_g_c->pointer = r_g_c->pointer->pointer;
      _Free(p_g_c);
    }
  }
  /*$ifdef TRACE*/
  ntr_set_and_boolean(tzt, 20L, 1085L, 8L, 1L, 1L, a, ok);
  /*$endif TRACE*/
  return ok;
}  /* was_edge_in_one_clique */


Static Void fix_edges_argument(fix_gc)
t_set_list **fix_gc;
{
  t_vertex_set a;

  hypergraph_sets_to_graph_sets(*fix_gc, a, fix_edges_adj_set);   /**/
  _Free(fix_edges_gc);
  fix_edges_gc = *fix_gc;
}  /* fix_edges_argument */


Static Void and_fix_edges_argument(fix_gc)
t_set_list **fix_gc;
{
  t_v_arr_of_v_sets tmp_fix_edges_adj_set;
  t_vertex v;
  t_vertex_set a;
  t_set_list *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  hypergraph_sets_to_graph_sets(*fix_gc, a, tmp_fix_edges_adj_set);
  for (v = first_vertex; v <= last_vertex; v++)
    P_setunion(fix_edges_adj_set[v - MIN_VERTEX],
	       fix_edges_adj_set[v - MIN_VERTEX],
	       tmp_fix_edges_adj_set[v - MIN_VERTEX]);
  p = *fix_gc;
  while (p != NULL) {
    insert_clique(p->vertex_set, &fix_edges_gc);
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  memcpy(tzt, " AndFixEdgesArgument", sizeof(pch20));
  ntr_g_c(tzt, 20L, 1087L, 1L, -1L, -1L, fix_gc);
  ntr_g_c(tzt, 20L, 1087L, 1L, -1L, -1L, &fix_edges_gc);
  /*$endif TRACE*/
  _Free(*fix_gc);
}  /* and_fix_edges_argument */


Static t_set_list *return_restricted_g_c(old_g_c, a)
t_set_list **old_g_c;
long *a;
{
  t_set_list *new_g_c = NULL;
  t_set_list *p;
  t_vertex_set vertex_set;

  p = *old_g_c;
  while (p != NULL) {
    P_setint(vertex_set, p->vertex_set, a);
    insert_clique(vertex_set, &new_g_c);
    p = p->pointer;
  }
  return new_g_c;
}  /* return_restricted_g_c */


/*@+"subsup.p"*/


Static Void exclude_vertex_sets_in_list(set_list, remove_set, exclude_list)
t_set_list **set_list;
_PROCEDURE remove_set;
t_set_list **exclude_list;
{
  boolean cont = true;
  t_set_list *p, *q;

  while (*set_list != NULL && cont) {
    if (!((remove_set.link != NULL) ? (*(boolean(*) PP((long *a,
		  t_set_list **list_of_cliques,
		  Anyptr _link)))remove_set.proc)((*set_list)->vertex_set,
	  exclude_list, remove_set.link) : (
	  *(boolean(*) PP((long *a, t_set_list **list_of_cliques)))
	    remove_set.proc)((*set_list)->vertex_set, exclude_list))) {
      cont = false;
      break;
    }
    p = *set_list;
    *set_list = (*set_list)->pointer;
    _Free(p);
  }
  if (*set_list == NULL)
    return;
  p = *set_list;
  q = (*set_list)->pointer;
  while (q != NULL) {
    if ((remove_set.link != NULL) ? (*(boolean(*) PP((long *a,
						      t_set_list **list_of_cliques,
						      Anyptr _link)))remove_set.proc)(
	  q->vertex_set, exclude_list, remove_set.link) : (
	  *(boolean(*) PP((long *a, t_set_list **list_of_cliques)))
	   remove_set.proc)(q->vertex_set, exclude_list)) {
      p->pointer = q->pointer;
      _Free(q);
      q = p->pointer;
    } else {
      p = q;
      q = p->pointer;
    }
  }
}  /* exclude_vertex_sets_in_list */


/*$ifdef On-DOS
procedure exclude_sub_vertex_sets_in_list(var set_list: t_link_set_list;
                                          var exclude_list: t_link_set_list);
var
   cont: boolean;
   p, q: t_link_set_list;
begin
   cont := true;
   while (set_list <> nil) and cont do begin
      if subset_of_an_edge(set_list^.vertex_set, exclude_list) then begin
         p := set_list;
         set_list := set_list^.pointer;
         dispose(p)
      end else
         cont := false
   end;
   if set_list <> nil then begin
      p := set_list;
      q := set_list^.pointer;
      while q <> nil do begin
         if subset_of_an_edge(q^.vertex_set, exclude_list) then begin
            p^.pointer := q^.pointer;
            dispose(q);
            q := p^.pointer
         end else begin
            p := q;
            q := p^.pointer
         end
      end
   end
end;

procedure exclude_super_vertex_sets_in_list(var set_list: t_link_set_list;
                                            var exclude_list: t_link_set_list);
var
   cont: boolean;
   p, q: t_link_set_list;
begin
   cont := true;
   while (set_list <> nil) and cont do begin
      if contains_an_edge(set_list^.vertex_set, exclude_list) then begin
         p := set_list;
         set_list := set_list^.pointer;
         dispose(p)
      end else
         cont := false
   end;
   if set_list <> nil then begin
      p := set_list;
      q := set_list^.pointer;
      while q <> nil do begin
         if contains_an_edge(q^.vertex_set, exclude_list) then begin
            p^.pointer := q^.pointer;
            dispose(q);
            q := p^.pointer
         end else begin
            p := q;
            q := p^.pointer
         end
      end
   end
end;
 $endif On-DOS*/

/*@+"subm.p"*/


/*

1100:    +++  ++
1101:    +++  ++
1102:    ---  -- p/subm.p          8      46     624 p/subm.p
1103: |    4:    function return_g_c_copy
1104: |   46:    function return_g_c_copy_for_mixed_model
1105: |   56:    function test_grap_submodel
1106: |  115:    function sub_is_hier_subm
1107: |  203:    function is_hierarchical_submodel
1108: |  235:    function is_submodel
1109: |  267:    function test_current_submodel_of_base
1110: |  275:    function test_current_submodel_of_base_ifail
1111:    +++  ++
1112:    +++  ++

*/


Static t_set_list *return_g_c_copy(model)
t_model **model;
{
  /* Replace cliques_of_mixed_model of 'newmodel.p' by this !!! */
  t_set_list *p;
  t_set_list *g_c = NULL;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnGcCopy       ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1103L, 1L, -1L, -1L, model);
  ntr_model_numbers(tzt, 20L, 1103L, 1L, -1L, -1L, model);
  if (trace_flag[TRACE_FLAG_FACTOR * 1103])
    print_formula(model, true);
  /*$endif TRACE*/
  if ((*model)->id->model_type == pure_discrete) {
    copy_set_list((*model)->id->UU.g_c_log_linear, &g_c);
    return g_c;
  }
  if ((*model)->id->model_type == pure_continuous) {
    copy_set_list((*model)->id->UU.g_c_covariance, &g_c);
    return g_c;
  }
  if ((*model)->id->model_type != mixed) {
    note_error_model(stdout, 1103L, 1L, " ReturnGcCopy       ", *model, false);
    return g_c;
  }
  p = (*model)->id->UU.U1.g_c_discrete;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c);
    p = p->pointer;
  }
  p = (*model)->id->UU.U1.g_c_linear;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c);
    p = p->pointer;
  }
  p = (*model)->id->UU.U1.g_c_quadratic;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c);
    p = p->pointer;
  }
  return g_c;
}  /* return_g_c_copy */


Static t_set_list *return_g_c_copy_id(identification)
t_model_specification **identification;
{
  /* Replace cliques_of_mixed_model of 'newmodel.p' by this !!! */
  t_set_list *p;
  t_set_list *g_c = NULL;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnGcCopyID     ", sizeof(pch20));
  /*$endif TRACE*/
  if ((*identification)->model_type == pure_discrete) {
    copy_set_list((*identification)->UU.g_c_log_linear, &g_c);
    return g_c;
  }
  if ((*identification)->model_type == pure_continuous) {
    copy_set_list((*identification)->UU.g_c_covariance, &g_c);
    return g_c;
  }
  if ((*identification)->model_type != mixed) {
    note_error_id(stdout, 1103L, 1L, " ReturnGcCopy       ", *identification,
		  false);
    return g_c;
  }
  p = (*identification)->UU.U1.g_c_discrete;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c);
    p = p->pointer;
  }
  p = (*identification)->UU.U1.g_c_linear;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c);
    p = p->pointer;
  }
  p = (*identification)->UU.U1.g_c_quadratic;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c);
    p = p->pointer;
  }
  return g_c;
}  /* return_g_c_copy_id */


Static t_set_list *return_g_c_copy_for_mixed_id(identification)
t_model_specification **identification;
{
  if ((*identification)->model_type == pure_discrete)
    return ((*identification)->UU.g_c_log_linear);
  if ((*identification)->model_type == pure_continuous)
    return ((*identification)->UU.g_c_covariance);
  if ((*identification)->model_type == mixed)
    return (return_g_c_copy_id(identification));
}  /* return_g_c_copy_for_mixed_id */


Static t_set_list *return_g_c_copy_for_mixed_model(model)
t_model **model;
{
  return (return_g_c_copy_for_mixed_id(&(*model)->id));
}  /* return_g_c_copy_for_mixed_model */


Static Void add_id_cliques(add_list, list_of_cliques)
t_model_specification *add_list;
t_set_list **list_of_cliques;
{
  t_set_list *g_c_a;

  g_c_a = return_g_c_copy_id(&add_list);
  add_cliques(g_c_a, list_of_cliques);
  dispose_set_list(&g_c_a);
}  /* add_id_cliques */


Static Void add_id_not_sub_cliques(add_list, list_of_sets, list_of_cliques)
t_model_specification *add_list;
t_set_list **list_of_sets, **list_of_cliques;
{
  t_set_list *g_c_a;

  g_c_a = return_g_c_copy_id(&add_list);
  add_not_sub_cliques(g_c_a, list_of_sets, list_of_cliques);
  dispose_set_list(&g_c_a);
}  /* add_id_not_sub_cliques */


Static boolean test_grap_submodel(currrent_model, base_model, current_adj_set,
				  base_adj_set, g)
t_model **currrent_model, **base_model;
t_vertex_set *current_adj_set, *base_adj_set;
long *g;
{
  boolean Result = false;
  t_set_list *current_g_c, *base_g_c;
  t_vertex_set g2;
  t_vertex u;
  boolean ok;

  current_g_c = return_g_c_copy_for_mixed_model(currrent_model);
  base_g_c = return_g_c_copy_for_mixed_model(base_model);
  hypergraph_sets_to_graph_sets(current_g_c, g, current_adj_set);
  hypergraph_sets_to_graph_sets(base_g_c, g2, base_adj_set);
  if (P_setequal(g, g2)) {
    ok = true;
    u = first_vertex;
    while (ok && u < last_vertex) {
      ok = P_subset(current_adj_set[u - MIN_VERTEX],
		    base_adj_set[u - MIN_VERTEX]);
      u++;
    }
    if (ok && u == last_vertex)
      ok = P_subset(current_adj_set[u - MIN_VERTEX],
		    base_adj_set[u - MIN_VERTEX]);
    if (ok) {
      u = first_vertex;
      while (ok && u < last_vertex) {
	ok = P_setequal(current_adj_set[u - MIN_VERTEX],
			base_adj_set[u - MIN_VERTEX]);
	u++;
      }
      if (ok && u == last_vertex)
	ok = P_setequal(current_adj_set[u - MIN_VERTEX],
			base_adj_set[u - MIN_VERTEX]);
      if (ok) {
	write_pch(stdout, " Collaps.", 9L);
	write_line(stdout);
	write_pch(stdout, " Models ", 8L);
	print_g_c(current_g_c, 8L, line_length);
	write_line(stdout);
	write_pch(stdout, " and    ", 8L);
	print_g_c(base_g_c, 8L, line_length);
	write_line(stdout);
	write_pch(stdout, " on ", 4L);
	print_vertex_set(g);
	write_pch(stdout, " identical.", 11L);
      } else
	Result = true;
    } else {
      write_pch(stdout,
		  " Edges of graph 1 not subset of edges of graph 2", 48L);
      write_line(stdout);
    }
  } else {
    write_pch(stdout, " Graphs has not same sets of vertexes", 37L);
    write_line(stdout);
  }
  dispose_g_c_copy_for_mixed_model(currrent_model, &current_g_c);
  dispose_g_c_copy_for_mixed_model(base_model, &base_g_c);
  return Result;
}  /* test_grap_submodel */


Static boolean sub_is_hier_subm(current_g_c, base_g_c, q_current_g_c,
  q_base_g_c, write_options, test_labels, ok_identical)
t_set_list **current_g_c, **base_g_c, *q_current_g_c, *q_base_g_c;
t_test_write_options **write_options;
t_test_labels **test_labels;
boolean ok_identical;
{
  t_vertex_set g1, g2;
  t_set_list *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubIsHierSubm.     ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 1106L, 1L, -1L, -1L, current_g_c);
  ntr_g_c(tzt, 20L, 1106L, 1L, -1L, -2L, base_g_c);
  ntr_g_c(tzt, 20L, 1106L, 1L, -2L, -1L, &q_current_g_c);
  ntr_g_c(tzt, 20L, 1106L, 1L, -2L, -2L, &q_base_g_c);
  /*$endif TRACE*/
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  P_setcpy(g1, empty_set);
  p = *current_g_c;
  while (p != NULL) {
    P_setunion(g1, g1, p->vertex_set);
    p = p->pointer;
  }
  P_setcpy(g2, empty_set);
  p = *base_g_c;
  while (p != NULL) {
    P_setunion(g2, g2, p->vertex_set);
    p = p->pointer;
  }
  if (P_subset(g1, g2)) {
    if (test_sub_g_c(*current_g_c, *base_g_c) & test_sub_g_c(q_current_g_c,
							     q_base_g_c)) {
      if (test_list_of_sets_subset_of_list_of_sets(*base_g_c, *current_g_c) &
	  test_list_of_sets_subset_of_list_of_sets(q_base_g_c, q_current_g_c)) {
	if (!(*write_options)->line_form && (*write_options)->write_test) {
	  if (ok_identical)
	    return true;
	  write_space(stdout, (*test_labels)->indent + 1);
	  write_pch(stdout, "Collaps.", 8L);
	  write_line(stdout);
	  write_space(stdout, (*test_labels)->indent + 1);
	  write_pch(stdout, "Models  ", 8L);
	  print_g_c(*current_g_c, (*test_labels)->indent + 9, line_length);
	  write_line(stdout);
	  write_space(stdout, (*test_labels)->indent + 1);
	  write_pch(stdout, "and     ", 8L);
	  print_g_c(*base_g_c, (*test_labels)->indent + 9, line_length);
	  write_line(stdout);
	  write_space(stdout, (*test_labels)->indent + 1);
	  write_pch(stdout, "on ", 3L);
	  print_vertex_set(g1);
	  write_pch(stdout, " (maybe) identical.", 19L);
	  write_line(stdout);
	  return false;
	} else {
	  return ok_identical;
	  /* null */
	}
      } else
	return true;
    }
    /* test_list_ */
    if (!(*write_options)->line_form) {
      write_space(stdout, (*test_labels)->indent + 1);
      write_pch(stdout,
		  "Edges of graph 1 not subset of edges of graph 2", 47L);
      write_line(stdout);
      return false;
    }
    if (!(*write_options)->write_test)
      return false;
    write_space(stdout, 1L);
    write_pch(stdout, "Edges of ", 9L);
    print_g_c(*current_g_c, 10L, line_length);
    write_pch(stdout, " not subset of edges of ", 24L);
    print_g_c(*base_g_c, 10L, line_length);
    write_line(stdout);
    return false;
  }
  /* test_sub_... */
  if (!(*write_options)->line_form) {
    write_space(stdout, (*test_labels)->indent + 1);
    write_pch(stdout, "Vertexes of graph 1 not subset of edges of graph 2",
		50L);
    write_line(stdout);
    return false;
  }
  if (!(*write_options)->write_test)
    return false;
  write_space(stdout, 1L);
  write_pch(stdout, "Vertexes of ", 12L);
  print_g_c(*current_g_c, 13L, line_length);
  write_pch(stdout, " not subset of edges of ", 24L);
  print_g_c(*base_g_c, 24L, line_length);
  write_line(stdout);
  /* g1 <= g2 */
  return false;
}  /* sub_is_hier_subm */


Static Void remove_double(add_list, list_of_cliques)
t_set_list *add_list, **list_of_cliques;
{
  t_vertex_set a;

  *list_of_cliques = NULL;
  while (add_list != NULL) {
    P_setint(a, add_list->vertex_set, delta_gamma);
    insert_clique(a, list_of_cliques);
    add_list = add_list->pointer;
  }
}  /* remove_double */


Static boolean is_hierarchical_submodel(current_id, base_id, ok_identical,
					line_form, write_test)
t_model_specification **current_id, **base_id;
boolean ok_identical, line_form, write_test;
{
  boolean Result;
  t_set_list *current_g_c, *base_g_c, *q_current_g_c, *q_base_g_c, *tmp;
  t_test_write_options *write_options;
  t_test_labels *test_labels;
  boolean unfold;
  boolean current_full = false, base_full = false;
  pch20 txt;

  memcpy(txt, " IsHierarchicalSubm.", sizeof(pch20));
  /*$ifdef TRACE*/
  ntr_double_id(txt, 20L, 1107L, 1L, -1L, -1L, current_id, base_id);
  /*$endif TRACE*/
  if ((*current_id)->model_type == mixed) {
    current_full = (*current_id)->UU.U1.full_specified;
    q_current_g_c = (*current_id)->UU.U1.g_c_quadratic;
  } else {
    q_current_g_c = NULL;

  }
  if ((*base_id)->model_type == mixed) {
    base_full = (*base_id)->UU.U1.full_specified;
    q_base_g_c = (*base_id)->UU.U1.g_c_quadratic;
  } else
    q_base_g_c = NULL;

  current_g_c = return_g_c_copy_for_mixed_id(current_id);
  base_g_c = return_g_c_copy_for_mixed_id(base_id);

  /*$ifdef TRACE*/
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  ntr_g_c(txt, 20L, 1107L, 1L, -2L, -1L, &q_current_g_c);
  ntr_g_c(txt, 20L, 1107L, 1L, -2L, -2L, &q_base_g_c);
  /*$endif TRACE*/
  write_options = new_test_write_options_false();
  write_options->line_form = line_form;
  write_options->write_test = write_test;
  test_labels = new_test_labels_empty();
  if (!base_full && current_full) {
    /*$ifdef TRACE*/
    ntr(txt, 20L, 1107L, 1L, -3L, -1L);
    /*$endif TRACE*/
    remove_double(current_g_c, &tmp);
    dispose_g_c_copy_for_mixed_id(current_id, &current_g_c);
    current_g_c = tmp;
    remove_double(q_current_g_c, &tmp);
    Result = sub_is_hier_subm(&current_g_c, &base_g_c, tmp, q_base_g_c,
			      &write_options, &test_labels, true);
    dispose_set_list(&tmp);
  } else if (base_full && !current_full) {
    /*$ifdef TRACE*/
    ntr(txt, 20L, 1107L, 1L, -3L, -2L);
    /*$endif TRACE*/
    unfold_quadratic(&q_current_g_c, &tmp, &unfold, txt, 20L, true, false);
    q_current_g_c = tmp;
    Result = sub_is_hier_subm(&current_g_c, &base_g_c, q_current_g_c,
			      q_base_g_c, &write_options, &test_labels, true);
    dispose_set_list(&tmp);
  } else {
    /*$ifdef TRACE*/
    ntr(txt, 20L, 1107L, 1L, -3L, -3L);
    /*$endif TRACE*/
    Result = sub_is_hier_subm(&current_g_c, &base_g_c, q_current_g_c,
			      q_base_g_c, &write_options, &test_labels,
			      ok_identical);
  }
  _Free(write_options);
  _Free(test_labels);
  dispose_g_c_copy_for_mixed_id(current_id, &current_g_c);
  dispose_g_c_copy_for_mixed_id(base_id, &base_g_c);
  return Result;
}  /* is_hierarchical_submodel */


Static boolean is_submodel(current_id, base_id, ok_identical)
t_model_specification **current_id, **base_id;
boolean ok_identical;
{
  /*$ifdef TRACE*/
  boolean Result = false;
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IsSubmodel         ", sizeof(pch20));
  ntr_double_id(tzt, 20L, 1108L, 1L, -1L, -1L, current_id, base_id);
  /*$endif TRACE*/
  if (current_and_base()) {
    if (is_hierarchical_submodel(current_id, base_id, ok_identical, false,
				 true)) {
      if (test_identical_c_s((*base_id)->causal_structure,
			     (*current_id)->causal_structure)) {
	Result = true;
	/*$ifdef TRACE*/
      }
    }
  }
  ntr_double_id(tzt, 20L, 1108L, 1L, -1L, -8L, current_id, base_id);
  /*$endif TRACE*/
  return Result;
}  /* is_submodel */


Static boolean identical_continuous_set(current_model, base_model)
t_model **current_model, **base_model;
{
  boolean Result;
  t_vertex_set a, b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IdenticalConsSet.  ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1107L, 1L, -1L, -1L, current_model);
  ntr_model_g_c(tzt, 20L, 1107L, 1L, -1L, -2L, base_model);
  /*$endif TRACE*/
  P_setcpy(a, (*current_model)->id->vertices);
  P_setint(a, a, gamma_);
  P_setcpy(b, (*base_model)->id->vertices);
  P_setint(b, b, gamma_);
  if (!P_setequal(a, b)) {
    write_space(stdout, 1L);
    write_pch(stdout, "Continuous vertices not identical.", 34L);
    write_line(stdout);
  }
  Result = P_setequal(a, b);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1107L, 1L, -2L, -1L, (*current_model)->id->vertices);
  ntr_set(tzt, 20L, 1107L, 1L, -2L, -2L, (*base_model)->id->vertices);
  /*$endif TRACE*/
  return Result;
}  /* identical_continuous_set */


Static boolean test_current_submodel_of_base(ok_identical)
boolean ok_identical;
{
  boolean Result = false;

  if (!current_and_base())
    return Result;
  if (is_submodel(&link_current->model->id, &link_base->model->id,
		  ok_identical)) {
    if (identical_continuous_set(&link_current->model, &link_base->model))
      return true;
  }
  return Result;
}  /* test_current_submodel_of_base */


Static boolean test_current_submodel_of_base_ifail(ifail, ok_identical)
t_integer *ifail;
boolean ok_identical;
{
  /*$ifdef TRACE*/
  boolean Result = false;
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubmodelIfail      ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1110L, 1L, -1L, -1L, &link_current->model);
  ntr_model_g_c(tzt, 20L, 1110L, 1L, -1L, -1L, &link_base->model);
  if (current_and_base_ifail(ifail)) {
    if (is_hierarchical_submodel(&link_current->model->id,
				 &link_base->model->id, ok_identical, false,
				 true)) {
      if (test_identical_c_s_ifail(link_base->model, link_current->model,
				   ifail)) {
	if (identical_continuous_set(&link_current->model, &link_base->model))
	  Result = true;
	else
	  *ifail = 18;
      }
    } else {
      *ifail = 27;
      /*$ifdef TRACE*/
    }
  }
  ntr_model_g_c(tzt, 20L, 1110L, 1L, -1L, *ifail, &link_current->model);
  ntr_model_g_c(tzt, 20L, 1110L, 1L, -1L, *ifail, &link_base->model);
  /*$endif TRACE*/
  return Result;
}  /* test_current_submodel_of_base_ifail */


Local Void find_complete(a, adj_set, list_of_cliques, lv, v)
long *a;
t_vertex_set *adj_set;
t_set_list **list_of_cliques;
t_vertex *lv, v;
{
  t_vertex_set b;

  if (v != *lv)
    find_complete(a, adj_set, list_of_cliques, lv, v + 1);
  if (!P_subset(a, adj_set[v - MIN_VERTEX]))
    return;
  P_setcpy(b, a);
  P_addset(b, v);
  insert_clique(b, list_of_cliques);
  if (v != *lv)
    find_complete(b, adj_set, list_of_cliques, lv, v + 1);
}  /* find_complete */


/*@+"cliques.p"*/


/*

1113:    +++  ++
1114:    +++  ++
1115:    ---  -- p/cliques.p          8      31     478 p/cliques.p
1116: |    4:    procedure find_sub_cliques
1117: |   12:    procedure find_complete
1118: |   66:    procedure find_cliques_decomposable
1119: |   94:    procedure find_cliques_graphical
1120: |  150:    procedure find_cliques_and_order
1121: |  180:    procedure find_cliques
1122: |  192:    procedure find_cliques
1123: |  195:    procedure find_complete
1124:    +++  ++
1125:    +++  ++

*/


Static Void find_sub_cliques(adj_set_, sub_set, list_of_cliques)
t_vertex_set *adj_set_;
long *sub_set;
t_set_list **list_of_cliques;
{
  t_v_arr_of_v_sets adj_set;
  t_vertex_set a, b;
  t_vertex u, v, w, lv;
  t_set_list *p;

  memcpy(adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  lv = first_vertex;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, sub_set)) {
      P_setint(a, sub_set, adj_set[v - MIN_VERTEX]);
      P_setcpy(b, empty_set);
      w = first_vertex;
      for (u = first_vertex; u <= last_vertex; u++) {
	if (P_inset(u, sub_set)) {
	  if (P_inset(u, a))
	    P_addset(b, w);
	  w++;
	}
      }
      P_setcpy(adj_set[lv - MIN_VERTEX], b);
      lv++;
    }
  }
  lv--;
  find_complete(empty_set, adj_set, list_of_cliques, &lv, first_vertex);
  p = *list_of_cliques;
  while (p != NULL) {
    P_setcpy(a, p->vertex_set);
    P_setcpy(b, empty_set);
    w = first_vertex;
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, sub_set)) {
	if (P_inset(w, a))
	  P_addset(b, v);
	w++;
      }
    }
    P_setcpy(p->vertex_set, b);
    p = p->pointer;
  }
}  /* find_sub_cliques */


Static Void find_cliques_decomposable(sub_set, adj_list, order, invers_order,
				      list_of_cliques)
long *sub_set;
t_vertex_list **adj_list;
short *order;
t_vertex *invers_order;
t_set_list **list_of_cliques;
{
  t_vertex_set decomp_set;
  t_1_max_dimension i;
  t_vertex_list *p;
  t_vertex u, v;

  for (i = 1; i <= dimension; i++) {
    u = invers_order[i-1];
    if (P_inset(u, sub_set)) {
      P_setcpy(decomp_set, empty_set);
      p = adj_list[u - MIN_VERTEX];
      while (p != NULL) {
	v = p->vertex;
	if (i < order[v - MIN_VERTEX])
	  P_addset(decomp_set, v);
	p = p->pointer;
      }
      P_addset(decomp_set, u);
      insert_clique(decomp_set, list_of_cliques);
    }
  }
}  /* find_cliques_decomposable */


Static Void find_cliques_graphical(sub_set, adj_list, adj_set, invers_order,
				   c, complete, list_of_cliques)
long *sub_set;
t_vertex_list **adj_list;
t_vertex_set *adj_set;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
t_set_list **list_of_cliques;
{
  t_1_max_dimension i = 1;
  t_1_max_dimension j;
  t_vertex_set a, b, g, d;
  t_vertex u, v;
  t_set_list *p, *q;

  P_setcpy(g, sub_set);
  P_setcpy(b, g);
  while (!P_setequal(b, empty_set)) {
    u = invers_order[i-1];
    while (!(P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) & P_inset(u, g))) {
      i++;
      u = invers_order[i-1];
    }
    if (P_subset(c[u - MIN_VERTEX], adj_set[u - MIN_VERTEX]) &
	P_getbits_UB(complete, u - MIN_VERTEX, 0, 3)) {
      j = i + 1;
      v = invers_order[j-1];
      P_setcpy(d, c[v - MIN_VERTEX]);
      P_addset(d, v);
      while ((P_subset(d, c[u - MIN_VERTEX]) && j < dimension) & P_inset(v, g)) {
	j++;
	v = invers_order[j-1];
	P_setcpy(d, c[v - MIN_VERTEX]);
	P_addset(d, v);
      }
      i = j - 1;
      u = invers_order[i-1];
      find_connected_component(g, c[u - MIN_VERTEX], a, &u, adj_list);
      P_setunion(d, a, c[u - MIN_VERTEX]);
      insert_clique(d, list_of_cliques);
    } else {
      find_connected_component(g, c[u - MIN_VERTEX], a, &u, adj_list);
      p = NULL;
      P_setunion(d, a, c[u - MIN_VERTEX]);
      find_sub_cliques(adj_set, d, &p);
      while (p != NULL) {
	insert_clique(p->vertex_set, list_of_cliques);
	q = p;
	p = p->pointer;
	_Free(q);
      }
    }
    P_setdiff(g, g, a);
    P_setdiff(b, g, c[u - MIN_VERTEX]);
    i++;
  }
}  /* find_cliques_graphical */


Static Void find_cliques_and_order(adj_set, adj_list, fill_in_adj_list, order,
  invers_order, c, complete, decomposable, sub_set, list_of_cliques)
t_vertex_set *adj_set;
t_vertex_list **adj_list, **fill_in_adj_list;
short *order;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
boolean *decomposable;
long *sub_set;
t_set_list **list_of_cliques;
{
  t_vertex v;

  maximum_cardinality_search(adj_list, order, invers_order);
  if (test_for_zero_fill_in(adj_list, order, invers_order)) {
    *decomposable = true;
    find_cliques_decomposable(sub_set, adj_list, order, invers_order,
			      list_of_cliques);
    return;
  }
  *decomposable = false;
  for (v = first_vertex; v <= last_vertex; v++)
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
  lex_m(adj_list, order, invers_order, fill_in_adj_list);
  find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
  find_cliques_graphical(sub_set, adj_list, adj_set, invers_order, c,
			 complete, list_of_cliques);
}  /* find_cliques_and_order */


Local Void find_complete_(a, adj_set, list_of_cliques, v)
long *a;
t_vertex_set *adj_set;
t_set_list **list_of_cliques;
t_vertex v;
{
  t_vertex_set b;

  if (v != last_vertex)
    find_complete_(a, adj_set, list_of_cliques, v + 1);
  P_setcpy(b, a);
  P_addset(b, v);
  if (!P_subset(a, adj_set[v - MIN_VERTEX]))
    return;
  insert_clique(b, list_of_cliques);
  if (v != last_vertex)
    find_complete_(b, adj_set, list_of_cliques, v + 1);
}  /* find_complete */

Local Void find_cliques_(adj_set, list_of_cliques)
t_vertex_set *adj_set;
t_set_list **list_of_cliques;
{
  *list_of_cliques = NULL;
  find_complete_(empty_set, adj_set, list_of_cliques, first_vertex);
}  /* find_cliques */


Static Void find_cliques(adj_set, sub_set, list_of_cliques)
t_vertex_set *adj_set;
long *sub_set;
t_set_list **list_of_cliques;
{
  t_v_arr_of_v_lists adj_list, fill_in_adj_list;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;
  boolean decomposable;
  t_vertex v;
  t_vertex_set inter;

  *list_of_cliques = NULL;
  if (cardinality(sub_set) <= 10) {
    if (P_setequal(sub_set, delta_gamma))
      find_cliques_(adj_set, list_of_cliques);
    else
      find_sub_cliques(adj_set, sub_set, list_of_cliques);
    return;
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    P_setint(inter, sub_set, adj_set[v - MIN_VERTEX]);
    if (P_inset(v, sub_set))
      P_setcpy(adj_set[v - MIN_VERTEX], inter);
    else
      P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  }
  /*$ifdef NOT-Fpc*/
  /*$endif NOT-Fpc*/
  adj_set_to_adj_list(adj_set, adj_list);
  find_cliques_and_order(adj_set, adj_list, fill_in_adj_list, order,
			 invers_order, c, complete, &decomposable, sub_set,
			 list_of_cliques);
  if (!decomposable)
    dispose_adj_list(fill_in_adj_list);
  dispose_adj_list(adj_list);
}  /* find_cliques */


/*@+"hyper.p"*/


/*

1126:    +++  ++
1127:    +++  ++
1128:    ---  -- p/hyper.p          4      15     255 p/hyper.p
1129: |    4:    function test_graphical
1130: |   87:    function test_decomposable_hypergraph
1131: |  141:    procedure find_graphical_and_decomposable_gc
1132: |  192:    procedure pick_partitioning
1133:    +++  ++
1134:    +++  ++

*/


Static boolean test_graphical(adj_set, gc)
t_vertex_set *adj_set;
t_set_list **gc;
{
  t_set_list *p, *q;
  t_set_list *work = NULL;
  t_set_list *gc_a, *gc_b;
  boolean ok = true;
  t_vertex_set a, g;
  t_vertex v;
  t_integer count = 0;

  P_setcpy(g, empty_set);
  p = *gc;
  while (p != NULL) {
    count++;
    P_setunion(g, g, p->vertex_set);
    insert_set_in_set_list(empty_set, &work);
    p = p->pointer;
  }
  if (count > 2) {
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, g) && ok) {
	gc_a = NULL;
	gc_b = NULL;
	p = *gc;
	while (p != NULL) {
	  if (P_inset(v, p->vertex_set)) {
	    q = work;
	    work = work->pointer;
	    P_setcpy(q->vertex_set, p->vertex_set);
	    q->pointer = gc_b;
	    gc_b = q;
	  } else {
	    P_setint(a, adj_set[v - MIN_VERTEX], p->vertex_set);
	    if (!P_setequal(a, empty_set)) {
	      q = work;
	      work = work->pointer;
	      P_setcpy(q->vertex_set, p->vertex_set);
	      q->pointer = gc_a;
	      gc_a = q;
	    }
	  }
	  p = p->pointer;
	}
	p = gc_a;
	while (ok && p != NULL) {
	  P_setint(a, adj_set[v - MIN_VERTEX], p->vertex_set);
	  P_addset(a, v);
	  ok = false;
	  q = gc_b;
	  while (q != NULL && !ok) {
	    if (P_subset(a, q->vertex_set))
	      ok = true;
	    else
	      q = q->pointer;
	  }
	  p = p->pointer;
	}
	if (gc_a != NULL) {
	  p = gc_a;
	  q = gc_a->pointer;
	  while (q != NULL) {
	    p = p->pointer;
	    q = q->pointer;
	  }
	  p->pointer = work;
	  work = gc_a;
	}
	if (gc_b != NULL) {
	  p = gc_b;
	  q = gc_b->pointer;
	  while (q != NULL) {
	    p = p->pointer;
	    q = q->pointer;
	  }
	  p->pointer = work;
	  work = gc_b;
	}
      }
    }
  }
  dispose_set_list(&work);
  return ok;
}  /* test_graphical */


Static boolean test_decomposable_hypergraph(g_c, a, b, d, g_c_a, g_c_b)
t_set_list **g_c;
long *a, *b, *d;
t_set_list **g_c_a, **g_c_b;
{
  t_set_list *g_c_c = NULL, *g_c_e = NULL;
  t_set_list *p, *p1, *p2;
  boolean ok;
  t_vertex_set vertex_set;

  *g_c_a = NULL;
  *g_c_b = NULL;
  p = *g_c;
  while (p != NULL) {
    P_setint(vertex_set, p->vertex_set, a);
    insert_clique(vertex_set, g_c_a);
    P_setint(vertex_set, p->vertex_set, b);
    insert_clique(vertex_set, g_c_b);
    p = p->pointer;
  }
  p = *g_c_a;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c_c);
    p = p->pointer;
  }
  p = *g_c_b;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c_c);
    p = p->pointer;
  }
  p1 = *g_c_a;
  while (p1 != NULL) {
    p2 = *g_c_b;
    while (p2 != NULL) {
      P_setint(vertex_set, p1->vertex_set, p2->vertex_set);
      insert_clique(vertex_set, &g_c_e);
      p2 = p2->pointer;
    }
    p1 = p1->pointer;
  }
  if (g_c_e != NULL)
    ok = (P_setequal(g_c_e->vertex_set, d) && g_c_e->pointer == NULL) &
	 test_list_of_sets_subset_of_list_of_sets(*g_c, g_c_c);
  else
    ok = false;
  if (!ok) {
    dispose_set_list(g_c_a);
    dispose_set_list(g_c_b);
  }
  dispose_set_list(&g_c_c);
  dispose_set_list(&g_c_e);
  return ok;
}  /* test_decomposable_hypergraph */


Static Void find_graphical_and_decomposable_gc(h_g_c, d_g_c, g_g_c,
					       decomposable, graphical)
t_set_list **h_g_c, **d_g_c, **g_g_c;
boolean *decomposable, *graphical;
{
  t_v_arr_of_v_sets fill_in_adj_set, adj_set;
  t_v_arr_of_v_lists adj_list;
  t_vertex v;
  t_vertex_set model_set;
  t_v_arr_of_v_lists fill_in_adj_list;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;

  *g_g_c = NULL;
  *d_g_c = NULL;
  for (v = first_vertex; v <= last_vertex; v++) {
    order[v - MIN_VERTEX] = 1;
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
    P_setcpy(c[v - MIN_VERTEX], empty_set);
    P_clrbits_B(complete, v - MIN_VERTEX, 0, 3);
  }
  *graphical = true;
  *decomposable = true;
  hypergraph_sets_to_graph_sets(*h_g_c, model_set, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  if (!test_graphical(adj_set, h_g_c)) {
    *graphical = false;
    find_cliques_and_order(adj_set, adj_list, fill_in_adj_list, order,
			   invers_order, c, complete, decomposable, model_set,
			   g_g_c);
    if (!*decomposable) {
      adj_list_to_adj_set(fill_in_adj_list, fill_in_adj_set);
      find_cliques(fill_in_adj_set, model_set, d_g_c);
    }
  } else {
    maximum_cardinality_search(adj_list, order, invers_order);
    if (!test_for_zero_fill_in(adj_list, order, invers_order)) {
      *decomposable = false;
      lex_m(adj_list, order, invers_order, fill_in_adj_list);
      adj_list_to_adj_set(fill_in_adj_list, fill_in_adj_set);
      find_cliques(fill_in_adj_set, model_set, d_g_c);
    }
  }
  dispose_adj_list(fill_in_adj_list);
  dispose_adj_list(adj_list);
}  /* find_graphical_and_decomposable_gc */


Static Void pick_partitioning(adj_list, g, list_of_sets, a, d, b)
t_vertex_list **adj_list;
long *g;
t_set_list *list_of_sets;
long *a, *d, *b;
{
  t_integer s, s1, s2;
  t_vertex u;
  t_vertex_set vertex_set;

  s = dimension;
  while (list_of_sets != NULL) {
    u = first_vertex;
    P_setdiff(vertex_set, g, list_of_sets->vertex_set);
    while (!P_inset(u, vertex_set))
      u++;
    find_connected_component(g, list_of_sets->vertex_set, a, &u, adj_list);
    P_setunion(vertex_set, a, list_of_sets->vertex_set);
    s1 = cardinality(vertex_set);
    P_setdiff(vertex_set, g, a);
    s2 = cardinality(vertex_set);
    if (s1 < s && s2 < s) {
      P_setcpy(d, list_of_sets->vertex_set);
      s = s1;
      if (s2 > s)
	s = s2;
    }
    list_of_sets = list_of_sets->pointer;
  }
  u = first_vertex;
  P_setdiff(vertex_set, g, d);
  while (!P_inset(u, vertex_set))
    u++;
  find_connected_component(g, d, a, &u, adj_list);
  P_setdiff(b, g, a);
  P_setdiff(b, b, d);
}  /* pick_partitioning */


/*@+"fillin.p"*/


Static t_long_real state_space_size(q)
t_set_list *q;
{
  t_long_real tmp_size = 0.0;

  while (q != NULL) {
    tmp_size += marginal_dimension_real(q->vertex_set);
    q = q->pointer;
  }
  return tmp_size;
}  /* state_space_size */


Static t_vertex select_vertex(g, adj_set)
long *g;
t_vertex_set *adj_set;
{
  t_vertex v, u = MAX_VERTEX;
  t_long_real size, size_u = _INFINITY_REAL;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, g)) {
      switch (c_factorizes) {

      case 1:
	size = variable_description[v - MIN_VERTEX]->UU.U0.levels;
	break;

      case 2:
	size = cardinality(adj_set[v - MIN_VERTEX]);
	break;

      case 3:
	size = marginal_dimension_real(adj_set[v - MIN_VERTEX]);
	break;
      }
      if (size < size_u) {
	size_u = size;
	u = v;
      }
    }
  }
  return u;
}  /* select_vertex */


/* Local variables for find_smallest_state_fill_in: */
struct LOC_find_smallest_state_fill_in {
  t_long_real size, old_size;
  t_set_list *fill_in, *fill_in_start, *r, *result;
  t_vertex v1, v2;
} ;

/*$endif TRACE*/

Local Void find_d(g, adj_set, LINK)
long *g;
t_vertex_set *adj_set;
struct LOC_find_smallest_state_fill_in *LINK;
{
  t_vertex v, u;
  t_v_arr_of_v_sets new_adj_set;
  t_set_list *p;
  t_vertex_set a, b, c, v_set, u_set;
  /*$ifdef TRACE*/
  pch20 tzt_;
  t_vertex FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt_, " FindD              ", sizeof(pch20));
  ntr_set_and_g_c(tzt_, 20L, 1141L, 1L, -1L, cardinality(g), g,
		  &LINK->fill_in);
  ntr_g_c(tzt_, 20L, 1141L, 1L, -1L, -1L, &LINK->result);
  /*$endif TRACE*/
  if (adj_set_decomposable(adj_set)) {
    find_cliques(adj_set, g, &LINK->r);
    if (LINK->fill_in_start != NULL)
      LINK->fill_in_start->pointer = LINK->r;
    else
      LINK->fill_in = LINK->r;
    LINK->size = state_space_size(LINK->fill_in);
    if (LINK->size < LINK->old_size) {
      LINK->old_size = LINK->size;
      dispose_set_list(&LINK->result);
      copy_set_list(LINK->fill_in, &LINK->result);
    }
    /*$ifdef TRACE*/
    ntr_g_c(tzt_, 20L, 1141L, 2L, -1L, -1L, &LINK->r);
    ntr_real(tzt_, 20L, 1141L, 2L, -1L, -1L, &LINK->size);
    ntr_g_c(tzt_, 20L, 1141L, 2L, -1L, -1L, &LINK->result);
    /*$endif TRACE*/
    if (LINK->fill_in_start != NULL)
      LINK->fill_in_start->pointer = NULL;
    dispose_set_list(&LINK->r);
    return;
  }
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  p->pointer = LINK->fill_in;
  LINK->fill_in = p;
  if (LINK->fill_in_start == NULL)
    LINK->fill_in_start = LINK->fill_in;
  FORLIM = LINK->v2;
  for (u = LINK->v1; u <= FORLIM; u++) {
    if (P_inset(u, g)) {
      P_addset(P_expset(u_set, 0L), u);
      P_setcpy(a, adj_set[u - MIN_VERTEX]);
      P_setunion(p->vertex_set, a, u_set);
      /*$ifdef TRACE*/
      ntr_2_sets(tzt_, 20L, 1141L, 2L, -1L, -1L, u_set, a);
      /*$endif TRACE*/
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  P_addset(P_expset(v_set, 0L), v);
	  P_setdiff(b, a, v_set);
	  P_setdiff(c, adj_set[v - MIN_VERTEX], u_set);
	  P_setunion(new_adj_set[v - MIN_VERTEX], c, b);
	} else
	  P_setcpy(new_adj_set[v - MIN_VERTEX], adj_set[v - MIN_VERTEX]);
      }
      P_setcpy(new_adj_set[u - MIN_VERTEX], empty_set);
      P_setdiff(b, g, u_set);
      find_d(b, new_adj_set, LINK);
    }
  }
  LINK->fill_in = LINK->fill_in->pointer;
  _Free(p);
}  /* find_d */


Static t_set_list *find_smallest_state_fill_in(g, adj_set)
long *g;
t_vertex_set *adj_set;
{
  struct LOC_find_smallest_state_fill_in Local_Var;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$ifdef TRACE*/
  memcpy(tzt, " FindSmalStateFillIn", sizeof(pch20));
  ntr(tzt, 20L, 1140L, 2L, -1L, -1L);
  /*$endif TRACE*/
  Local_Var.v1 = first_vertex;
  while (!P_inset(Local_Var.v1, g))
    Local_Var.v1++;
  Local_Var.v2 = last_vertex;
  while (!P_inset(Local_Var.v2, g))
    Local_Var.v2--;
  Local_Var.result = NULL;
  Local_Var.fill_in = NULL;
  Local_Var.fill_in_start = NULL;
  Local_Var.old_size = _INFINITY_REAL;
  find_d(g, adj_set, &Local_Var);
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 1140L, 2L, -1L, -1L, &Local_Var.result);
  /*$endif TRACE*/
  return Local_Var.result;
}  /* find_smallest_state_fill_in */


Static t_set_list *find_fill_in_(gc)
t_set_list **gc;
{
  t_set_list *fill_in, *p, *fill_in_start;
  boolean ok;
  t_vertex_set a, b, c, v_set, u_set, g;
  t_vertex v, u;
  t_v_arr_of_v_sets adj_set;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  hypergraph_sets_to_graph_sets(*gc, g, adj_set);
  if (sorted & (cardinality(g) < 8))
    return (find_smallest_state_fill_in(g, adj_set));
  else {
    /*$ifdef TRACE*/
    memcpy(tzt, " FindFillIn_        ", sizeof(pch20));
    ntr(tzt, 20L, 1142L, 2L, -1L, -1L);
    /*$endif TRACE*/
    fill_in_start = NULL;
    fill_in = NULL;
    ok = !adj_set_decomposable(adj_set);
    while (ok) {
      u = select_vertex(g, adj_set);
      P_addset(P_expset(u_set, 0L), u);
      P_setcpy(a, adj_set[u - MIN_VERTEX]);
      P_setunion(b, a, u_set);
      insert_set_in_set_list(b, &fill_in);
      if (fill_in_start == NULL)
	fill_in_start = fill_in;
      P_setdiff(g, g, u_set);
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  P_addset(P_expset(v_set, 0L), v);
	  P_setdiff(b, a, v_set);
	  P_setdiff(c, adj_set[v - MIN_VERTEX], u_set);
	  P_setunion(adj_set[v - MIN_VERTEX], c, b);
	}
      }
      P_setcpy(adj_set[u - MIN_VERTEX], empty_set);
      ok = !adj_set_decomposable(adj_set);
    }
    find_cliques(adj_set, g, &p);
    if (fill_in != NULL)
      fill_in_start->pointer = p;
    else
      fill_in = p;
    state_space_size(fill_in);
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 1142L, 2L, -1L, -1L, &fill_in);
    /*$endif TRACE*/
    return fill_in;
  }
}  /* find_fill_in_ */


Static t_set_list *find_fill_in(generating_class)
t_set_list **generating_class;
{
  boolean decomposable = false, graphical = false;
  t_set_list *fill_in;
  t_set_list *ggc = NULL;

  if (!fast) {
    fill_in = find_fill_in_(generating_class);
    return fill_in;
  }
  fill_in = NULL;
  find_graphical_and_decomposable_gc(generating_class, &fill_in, &ggc,
				     &decomposable, &graphical);
  if (graphical && decomposable) {
    copy_set_list(*generating_class, &fill_in);
    return fill_in;
  }
  if (!graphical && decomposable)
    fill_in = ggc;
  else if (ggc != NULL)
    dispose_set_list(&ggc);
  return fill_in;
}  /* find_fill_in */


/*@+"collaps.p"*/

/*

1146:    +++  ++
1147:    +++  ++
1148:    ---  -- p/collaps.p          9      45     553 p/collaps.p
1149: |    3:    function is_complete_in_mixed_gc
1150: |   74:    function check_decompose_mixed_gc
1151: |  107:    procedure cut_of_mixed
1152: |  189:    procedure cut_of_hierarchical
1153: |  246:    procedure cut_of_graphical
1154: |  299:    procedure print_order_
1155: |  332:    procedure return_collaps_set_discrete
1156: |  378:    procedure return_collaps_set_mixed
1157: |  462:    procedure return_collaps_set
1158:    +++  ++
1159:    +++  ++

*/

Static boolean is_complete_in_mixed_gc(a, unfolded, full_specified,
  homogeneous, discrete_gc, linear_gc, quadratic_gc)
long *a;
boolean *unfolded, *full_specified, *homogeneous;
t_set_list **discrete_gc, **linear_gc, **quadratic_gc;
{
  t_vertex v, w;
  boolean ok;
  t_vertex_set b, c, d;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IsCompleteInMixed  ", sizeof(pch20));
  ntr_set(tzt, 20L, 1149L, 1L, 1L, -3L, a);
  ntr_3_booleans(tzt, 20L, 1149L, 1L, 1L, -2L, *full_specified,
		 *full_specified, *homogeneous);
      /*ntr*/
  ntr_triple_g_c(tzt, 20L, 1149L, 1L, 1L, -1L, discrete_gc, linear_gc,
		 quadratic_gc);
      /*ntr*/
  /*$endif TRACE*/
  P_setint(d, a, delta);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1149L, 1L, 1L, 1L, d);
  /*$endif TRACE*/
  if (P_setequal(d, empty_set))
    ok = true;
  else
    ok = subset_of_an_edge(d, discrete_gc);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1149L, 1L, 1L, 2L, ok);
  /*$endif TRACE*/
  P_setcpy(b, empty_set);
  if (ok) {
    P_setint(b, a, gamma_);
    v = first_vertex;
    while (v <= last_vertex && ok) {
      if (P_inset(v, b)) {
	P_setcpy(c, d);
	P_addset(c, v);
	ok = subset_of_an_edge(c, linear_gc);
      }
      v++;
    }
  }
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1149L, 1L, 1L, 3L, b);
  ntr_boolean(tzt, 20L, 1149L, 1L, 1L, 3L, ok);
  /*$endif TRACE*/
  if (ok) {
    if (*unfolded || *full_specified) {
      v = first_vertex;
      while (v <= last_vertex && ok) {
	if (P_inset(v, b)) {
	  if (*homogeneous)
	    P_setcpy(c, empty_set);
	  else
	    P_setcpy(c, d);
	  P_addset(c, v);
	  if (*full_specified)
	    P_setunion(c, c, double_vertex_set);
	  ok = subset_of_an_edge(c, quadratic_gc);
	  w = v + 1;
	  while (w <= last_vertex && ok) {
	    if (P_inset(w, b)) {
	      if (*homogeneous)
		P_setcpy(c, empty_set);
	      else
		P_setcpy(c, d);
	      P_addset(c, v);
	      P_addset(c, w);
	      ok = subset_of_an_edge(c, quadratic_gc);
	    }
	    w++;
	  }
	}
	v++;
      }
    } else {
      /*$ifdef TRACE*/
      ntr_set(tzt, 20L, 1149L, 1L, 3L, 1L, a);
      ntr_set(tzt, 20L, 1149L, 1L, 3L, 1L, b);
      ntr_boolean(tzt, 20L, 1149L, 1L, 3L, 1L, true);
      /*$endif TRACE*/
      if (!P_setequal(b, empty_set)) {
	/* What if only 2-factor-interactions are gived ?!?!?
	   Then this is not working,
	   and models are "unfolded" by "check_mixed_model".
	 */
	if (*homogeneous) {
	  ok = subset_of_an_edge(b, quadratic_gc);
	  /*$ifdef TRACE*/
	  ntr_boolean(tzt, 20L, 1149L, 1L, 4L, 1L, ok);
	  /*$endif TRACE*/
	} else {
	  ok = subset_of_an_edge(a, quadratic_gc);
	  /*$ifdef TRACE*/
	  ntr_boolean(tzt, 20L, 1149L, 1L, 4L, 2L, ok);
	  /*$endif TRACE*/
	}
      }
    }
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1149L, 1L, 1L, 4L, ok);
  /*$endif TRACE*/
  return ok;
}  /* is_complete_in_mixed_gc */


Static boolean sub_ok_to_decompose_mixed_gc(unfolded, graphical,
  full_specified, homogeneous, discrete_gc, linear_gc, quadratic_gc, adj_list,
  g, c_u, u)
boolean *unfolded, *graphical, *full_specified, *homogeneous;
t_set_list **discrete_gc, **linear_gc, **quadratic_gc;
t_vertex_list **adj_list;
long *g, *c_u;
t_vertex *u;
{
  t_vertex_set a;
  t_vertex_list *a_list;
  boolean ok = false;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubOkToDecomposeM. ", sizeof(pch20));
  ntr_2_sets(tzt, 20L, 1151L, 1L, 1L, -3L, g, c_u);
  ntr_3_booleans(tzt, 20L, 1151L, 1L, 1L, -2L, *graphical, *full_specified,
		 *homogeneous);
      /*ntr*/
  ntr_triple_g_c(tzt, 20L, 1151L, 1L, 1L, -1L, discrete_gc, linear_gc,
		 quadratic_gc);
      /*ntr*/
  /*$endif TRACE*/
  if (P_subset(c_u, delta)) {
    if (*graphical || P_setequal(c_u, empty_set))
      ok = true;
    else
      ok = subset_of_an_edge(c_u, discrete_gc);
  } else {
    a_list = NULL;
    find_connected_component_list(g, c_u, a, &a_list, u, adj_list);
    dispose_vertex_list(&a_list);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1151L, 1L, 2L, 1L, a);
    /*$endif TRACE*/
    if (P_subset(a, gamma_))
      ok = true;
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1151L, 1L, 3L, -1L, ok);
  /*$endif TRACE*/
  if (ok)
    ok = is_complete_in_mixed_gc(c_u, unfolded, full_specified, homogeneous,
				 discrete_gc, linear_gc, quadratic_gc);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1151L, 1L, 4L, -1L, ok);
  /*$endif TRACE*/
  return ok;
}  /* sub_ok_to_decompose_mixed_gc */


Static Void cut_of_mixed(unfolded, graphical, full_specified, homogeneous,
			 discrete_gc, linear_gc, quadratic_gc, g, adj_list,
			 adj_set, invers_order, c, complete, s, r)
boolean *unfolded, *graphical, *full_specified, *homogeneous;
t_set_list **discrete_gc, **linear_gc, **quadratic_gc;
long *g;
t_vertex_list **adj_list;
t_vertex_set *adj_set;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
long *s, *r;
{
  t_1_max_dimension i = 1;
  t_1_max_dimension j;
  t_vertex_set a, b;
  t_vertex u, v;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " CutOfMixed         ", sizeof(pch20));
  ntr_3_sets(tzt, 20L, 1151L, 1L, 1L, -3L, g, s, r);
  ntr_3_booleans(tzt, 20L, 1151L, 1L, 1L, -2L, *graphical, *full_specified,
		 *homogeneous);
      /*ntr*/
  ntr_triple_g_c(tzt, 20L, 1151L, 1L, 1L, -1L, discrete_gc, linear_gc,
		 quadratic_gc);
      /*ntr*/
  /*$endif TRACE*/
  if (incomplete_table) {
    P_setcpy(r, g);
    return;
  }
  if (P_setequal(s, empty_set)) {
    P_setcpy(r, empty_set);
    return;
  }
  u = invers_order[i-1];
  while (!P_inset(u, s)) {
    /*$ifdef TRACE*/
    ntr_vertex(tzt, 20L, 1151L, 1L, 2L, (long)i, &u);
    /*$endif TRACE*/
    while ((!(P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) & P_inset(u, g))) &
	   (!P_inset(u, s))) {
      /*$ifdef TRACE*/
      ntr_vertex(tzt, 20L, 1151L, 1L, 3L, (long)i, &u);
      /*$endif TRACE*/
      i++;
      u = invers_order[i-1];
    }
    if (P_inset(u, s))
      break;
    /*$ifdef TRACE*/
    ntr_vertex(tzt, 20L, 1151L, 1L, 4L, (long)i, &u);
    ntr_2_sets(tzt, 20L, 1151L, 1L, 4L, (long)i, c[u - MIN_VERTEX],
	       adj_set[u - MIN_VERTEX]);
    /*$endif TRACE*/
    if (!boolean_option[109] || i <= dimension)
      ok = sub_ok_to_decompose_mixed_gc(unfolded, graphical, full_specified,
	  homogeneous, discrete_gc, linear_gc, quadratic_gc, adj_list, g,
	  c[u - MIN_VERTEX], &u);
    else {
      note_error_triple_g_c(stdout, 1151L, 1L, " CutOfMixed:        ",
			    *discrete_gc, *linear_gc, *quadratic_gc, s, r,
			    false);
      ok = false;
    }
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 1151L, 1L, 4L, (long)i, ok);
    /*$endif TRACE*/
    if (ok) {
      /*$ifdef TRACE*/
      ntr_vertex(tzt, 20L, 1151L, 1L, 5L, (long)i, &u);
      ntr_2_sets(tzt, 20L, 1151L, 1L, 5L, (long)i, c[u - MIN_VERTEX],
		 adj_set[u - MIN_VERTEX]);
      /*$endif TRACE*/
      if (*graphical)
	ok = P_subset(c[u - MIN_VERTEX], adj_set[u - MIN_VERTEX]);
      else {
	if (true) {
	  P_setcpy(b, c[u - MIN_VERTEX]);
	  P_addset(b, invers_order[i-1]);
	  /*$ifdef TRACE*/
	  ntr_vertex(tzt, 20L, 1151L, 1L, 6L, (long)i, &u);
	  /*$endif TRACE*/
	  ok = is_complete_in_mixed_gc(b, unfolded, full_specified,
				       homogeneous, discrete_gc, linear_gc,
				       quadratic_gc);
	}
      }
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1151L, 1L, 5L, (long)i, ok);
      /*$endif TRACE*/
      find_connected_component(g, c[u - MIN_VERTEX], a, &u, adj_list);
      P_setcpy(b, c[u - MIN_VERTEX]);
      P_addset(b, u);
      /*$ifdef TRACE*/
      ntr_set(tzt, 20L, 1151L, 1L, 5L, -1L, a);
      /*$endif TRACE*/
      if (ok && P_setequal(b, a)) {
	j = i + 1;
	v = invers_order[j-1];
	P_setcpy(b, c[v - MIN_VERTEX]);
	P_addset(b, v);
	/*$ifdef TRACE*/
	ntr_vertex(tzt, 20L, 1151L, 1L, 7L, (long)j, &v);
	ntr_set(tzt, 20L, 1151L, 1L, 7L, (long)j, b);
	/*$endif TRACE*/
	while (P_subset(b, c[u - MIN_VERTEX]) & (!P_inset(v, s))) {
	  j++;
	  v = invers_order[j-1];
	  P_setcpy(b, c[v - MIN_VERTEX]);
	  P_addset(b, v);
	  /*$ifdef TRACE*/
	  ntr_vertex(tzt, 20L, 1151L, 1L, 8L, (long)j, &v);
	  ntr_set(tzt, 20L, 1151L, 1L, 8L, (long)j, b);
	  /*$endif TRACE*/
	}
	P_setcpy(a, c[u - MIN_VERTEX]);
	P_addset(a, u);
	i = j - 1;
	u = invers_order[i-1];
	P_setdiff(a, a, c[u - MIN_VERTEX]);
	/*$ifdef TRACE*/
	ntr_vertex(tzt, 20L, 1151L, 1L, 9L, (long)i, &u);
	ntr_set(tzt, 20L, 1151L, 1L, 9L, (long)i, a);
	/*$endif TRACE*/
      }
      /* else
         find_connected_component(g, c[u], a, u, adj_list) */
      /*$ifdef TRACE*/
      ntr_set(tzt, 20L, 1151L, 1L, 9L, -1L, a);
      /*$endif TRACE*/
      P_setdiff(g, g, a);
    }
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1151L, 1L, 10L, -1L, g);
    /*$endif TRACE*/
    i++;
    u = invers_order[i-1];
    /*$ifdef TRACE*/
    ntr_vertex(tzt, 20L, 1151L, 1L, 11L, (long)i, &u);
    /*$endif TRACE*/
  }
  P_setcpy(r, g);
}  /* cut_of_mixed */


Static Void cut_of_hierarchical(g_c, g_, adj_list, invers_order, c, complete,
				s, r)
t_set_list **g_c;
long *g_;
t_vertex_list **adj_list;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
long *s, *r;
{
  t_vertex_set g;
  t_1_max_dimension i = 1;
  t_1_max_dimension j;
  t_vertex_set a, b;
  t_vertex u, v;

  P_setcpy(g, g_);
  if (incomplete_table) {
    P_setcpy(r, g);
    return;
  }
  if (P_setequal(s, empty_set)) {
    P_setcpy(r, empty_set);
    return;
  }
  u = invers_order[i-1];
  while (!P_inset(u, s)) {
    while ((!(P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) & P_inset(u, g))) &
	   (!P_inset(u, s))) {
      i++;
      u = invers_order[i-1];
    }
    if (P_inset(u, s))
      break;
    if (subset_of_an_edge(c[u - MIN_VERTEX], g_c)) {
      P_setcpy(b, c[u - MIN_VERTEX]);
      P_addset(b, u);
      if (subset_of_an_edge(b, g_c)) {
	j = i + 1;
	v = invers_order[j-1];
	P_setcpy(b, c[v - MIN_VERTEX]);
	P_addset(b, v);
	while (P_subset(b, c[u - MIN_VERTEX]) & (!P_inset(v, s))) {
	  j++;
	  v = invers_order[j-1];
	  P_setcpy(b, c[v - MIN_VERTEX]);
	  P_addset(b, v);
	}
	P_setcpy(a, c[u - MIN_VERTEX]);
	P_addset(a, u);
	i = j - 1;
	u = invers_order[i-1];
	P_setdiff(a, a, c[u - MIN_VERTEX]);
      } else
	find_connected_component(g, c[u - MIN_VERTEX], a, &u, adj_list);
      P_setdiff(g, g, a);
    }
    i++;
    u = invers_order[i-1];
  }
  P_setcpy(r, g);
}  /* cut_of_hierarchical */


Static Void cut_of_graphical(g_, adj_list, adj_set, invers_order, c, complete,
			     s, r)
long *g_;
t_vertex_list **adj_list;
t_vertex_set *adj_set;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
long *s, *r;
{
  t_vertex_set g;
  t_1_max_dimension i = 1;
  t_1_max_dimension j;
  t_vertex_set a, b;
  t_vertex u, v;

  P_setcpy(g, g_);
  if (incomplete_table) {
    P_setcpy(r, g);
    return;
  }
  if (P_setequal(s, empty_set)) {
    P_setcpy(r, empty_set);
    return;
  }
  u = invers_order[i-1];
  while (!P_inset(u, s)) {
    while ((!(P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) & P_inset(u, g))) &
	   (!P_inset(u, s))) {
      i++;
      u = invers_order[i-1];
    }
    if (P_inset(u, s))
      break;
    if (P_subset(c[u - MIN_VERTEX], adj_set[u - MIN_VERTEX])) {
      j = i + 1;
      v = invers_order[j-1];
      P_setcpy(b, c[v - MIN_VERTEX]);
      P_addset(b, v);
      while (P_subset(b, c[u - MIN_VERTEX]) & (!P_inset(v, s))) {
	j++;
	v = invers_order[j-1];
	P_setcpy(b, c[v - MIN_VERTEX]);
	P_addset(b, v);
      }
      P_setcpy(a, c[u - MIN_VERTEX]);
      P_addset(a, u);
      i = j - 1;
      u = invers_order[i-1];
      P_setdiff(a, a, c[u - MIN_VERTEX]);
    } else
      find_connected_component(g, c[u - MIN_VERTEX], a, &u, adj_list);
    P_setdiff(g, g, a);
    i++;
    u = invers_order[i-1];
  }
  P_setcpy(r, g);
}  /* cut_of_graphical */


Static Void print_order_(g, adj_list, invers_order, order, c, complete)
long *g;
t_vertex_list **adj_list;
t_vertex *invers_order;
short *order;
t_vertex_set *c;
uchar *complete;
{
  t_vertex v;

  write_line(stdout);
  write_space(stdout, 2L);
  write_char(stdout, 'V');
  write_pch(stdout, "  ", 2L);
  write_pch(stdout, " Order(V) ", 10L);
  write_space(stdout, 2L);
  write_pch(stdout, "C(V)", 4L);
  write_space(stdout, dimension - 2L);
  write_pch(stdout, "Complete(V)  ", 13L);
  write_line(stdout);
  for (v = first_vertex; v <= last_vertex; v++) {
    write_space(stdout, 2L);
    print_vertex_on_file(stdout, v, 0L);
    write_pch(stdout, ": ", 2L);
    write_integer(stdout, (long)order[v - MIN_VERTEX], 10L);
    write_space(stdout, 3L);
    print_vertex_set_table_full(c[v - MIN_VERTEX]);
    write_boolean(stdout, P_getbits_UB(complete, v - MIN_VERTEX, 0, 3));
    write_line(stdout);
  }
}  /* print_order_ */


Static Void return_collaps_set_discrete(a, g_, g_c, graphical, r)
long *a, *g_;
t_set_list **g_c;
boolean *graphical;
long *r;
{
  /* var atoms_list : t_link_set_list; */
  t_vertex_set g;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_lists fill_in_adj_list, adj_list;
  t_v_arr_of_v_sets adj_set, c;
  t_v_arr_of_boolean complete;
  t_vertex v;

  P_setcpy(g, g_);
  if (P_setequal(a, g) || em) {
    P_setcpy(r, g);
    return;
  }
  if (subset_of_an_edge(a, g_c) && !incomplete_table) {
    P_setcpy(r, a);
    return;
  }
  hypergraph_sets_to_graph_sets(*g_c, g, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  for (v = first_vertex; v <= last_vertex; v++)
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
  marked_lex_m(a, adj_list, order, invers_order, fill_in_adj_list);
  find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1155L, 1L))
    print_order_(g, adj_list, invers_order, order, c, complete);
  /*$endif TRACE*/
  dispose_adj_list(fill_in_adj_list);
  if (*graphical)
    cut_of_graphical(g, adj_list, adj_set, invers_order, c, complete, a, r);
  else
    cut_of_hierarchical(g_c, g, adj_list, invers_order, c, complete, a, r);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1155L, 8L))
    print_vertex_set(r);
  /*$endif TRACE*/
  P_setunion(r, r, a);
  dispose_adj_list(adj_list);
}  /* return_collaps_set_discrete */


Static Void return_collaps_set_mixed(a, g_, unfolded, graphical,
  full_specified, homogeneous, discrete_gc, linear_gc, quadratic_gc, r)
long *a, *g_;
boolean *unfolded, *graphical, *full_specified, *homogeneous;
t_set_list **discrete_gc, **linear_gc, **quadratic_gc;
long *r;
{
  /* var atoms_list: t_link_set_list; */
  t_vertex_set g;
  t_set_list *g_c;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_lists fill_in_adj_list, adj_list;
  t_v_arr_of_v_sets adj_set, c;
  t_v_arr_of_boolean complete;
  t_vertex v;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  P_setcpy(g, g_);
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnCollapsSetM. ", sizeof(pch20));
  ntr_3_sets(tzt, 20L, 1156L, 1L, 0L, -1L, a, g, r);
  ntr_3_booleans(tzt, 20L, 1156L, 1L, 1L, -1L, *graphical, *full_specified,
		 *homogeneous);
      /*ntr*/
  ntr_triple_g_c(tzt, 20L, 1156L, 1L, 2L, -1L, discrete_gc, linear_gc,
		 quadratic_gc);
      /*ntr*/
  /*$endif TRACE*/
  if (P_setequal(a, g) || em)
    P_setcpy(r, g);
  else if (subset_of_an_edge(a, discrete_gc) && !incomplete_table)
    P_setcpy(r, a);
  else {
    g_c = NULL;
    add_cliques(*discrete_gc, &g_c);
    add_cliques(*linear_gc, &g_c);
    if (*homogeneous) {
      if (*full_specified)   /* or not mim_model */
	add_delta_gamma_cliques(*quadratic_gc, &g_c);
      else
	add_cliques(*quadratic_gc, &g_c);
    } else {
      if (*full_specified)   /* or not mim_model */
	add_delta_gamma_cliques(*quadratic_gc, &g_c);
      else
	add_cliques(*quadratic_gc, &g_c);
    }
    hypergraph_sets_to_graph_sets(g_c, g, adj_set);
    dispose_set_list(&g_c);
    adj_set_to_adj_list(adj_set, adj_list);
    for (v = first_vertex; v <= last_vertex; v++)
      fill_in_adj_list[v - MIN_VERTEX] = NULL;
    marked_lex_m(a, adj_list, order, invers_order, fill_in_adj_list);
    find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1156L, 2L))
      print_order_(g, adj_list, invers_order, order, c, complete);
    /*$endif TRACE*/
    dispose_adj_list(fill_in_adj_list);
    cut_of_mixed(graphical, unfolded, full_specified, homogeneous,
		 discrete_gc, linear_gc, quadratic_gc, g, adj_list, adj_set,
		 invers_order, c, complete, a, r);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1156L, 1L, 3L, -1L, r);
    /*$endif TRACE*/
    P_setunion(r, r, a);
    dispose_adj_list(adj_list);
    /*$ifdef TRACE*/
  }
  ntr_3_sets(tzt, 20L, 1156L, 8L, 100L, -1L, a, g, r);
  ntr_3_booleans(tzt, 20L, 1156L, 8L, 101L, -1L, *graphical, *full_specified,
		 *homogeneous);
      /*ntr*/
  /*ntr*/
  /*$endif TRACE*/
  ntr_triple_g_c(tzt, 20L, 1156L, 8L, 102L, -1L, discrete_gc, linear_gc,
		 quadratic_gc);
}  /* return_collaps_set_mixed */


Static Void return_collaps_set(a, model, r)
long *a;
t_model **model;
long *r;
{
  /* p_list, */
  t_set_list *g_c;
  boolean unfolded;

  /* p_list := return_atoms_from_expression(link_current^.model); */
  if (mixed_data && (*model)->id->model_type == mixed) {
    note_mixed(stdout, " CollapsModel", 13L);
    unfolded = true;   /* p_list, */

    return_collaps_set_mixed(a, (*model)->id->vertices, &unfolded,
      &(*model)->graphical, &(*model)->id->UU.U1.full_specified,
      &(*model)->id->UU.U1.homogeneous, &(*model)->id->UU.U1.g_c_discrete,
      &(*model)->id->UU.U1.g_c_linear, &(*model)->id->UU.U1.g_c_quadratic, r);
    return;
  }
  g_c = return_g_c_copy(model);   /* p_list, */
  return_collaps_set_discrete(a, (*model)->id->vertices, &g_c,
			      &(*model)->graphical, r);
  dispose_set_list(&g_c);
  /* dispose_set_list(p_list) */
}  /* return_collaps_set */


Static boolean ok_to_decompose_mixed_gc(unfolded, graphical, full_specified,
  homogeneous, discrete_gc, linear_gc, quadratic_gc, d, a, b, g)
boolean *unfolded, *graphical, *full_specified, *homogeneous;
t_set_list **discrete_gc, **linear_gc, **quadratic_gc;
long *d, *a, *b, *g;
{
  t_vertex_set vertex_set;
  t_set_list *g_c = NULL;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_lists fill_in_adj_list, adj_list;
  t_v_arr_of_v_sets adj_set, c;
  t_v_arr_of_boolean complete;
  t_vertex v;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnCollapsSetM. ", sizeof(pch20));
  ntr_3_sets(tzt, 20L, 1156L, 1L, 1L, -1L, d, a, b);
  ntr_3_booleans(tzt, 20L, 1156L, 1L, 1L, -2L, *graphical, *full_specified,
		 *homogeneous);
      /*ntr*/
  ntr_triple_g_c(tzt, 20L, 1156L, 1L, 1L, -3L, discrete_gc, linear_gc,
		 quadratic_gc);
      /*ntr*/
  /*$endif TRACE*/

  add_cliques(*discrete_gc, &g_c);
  add_cliques(*linear_gc, &g_c);
  if (*homogeneous) {
    if (*full_specified)   /* or not mim_model */
      add_delta_gamma_cliques(*quadratic_gc, &g_c);
    else
      add_cliques(*quadratic_gc, &g_c);
  } else {
    if (*full_specified)   /* or not mim_model */
      add_delta_gamma_cliques(*quadratic_gc, &g_c);
    else
      add_cliques(*quadratic_gc, &g_c);
  }
  hypergraph_sets_to_graph_sets(g_c, g, adj_set);
  dispose_set_list(&g_c);
  adj_set_to_adj_list(adj_set, adj_list);
  for (v = first_vertex; v <= last_vertex; v++)
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
  marked_lex_m(a, adj_list, order, invers_order, fill_in_adj_list);
  find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1156L, 2L))
    print_order_(g, adj_list, invers_order, order, c, complete);
  /*$endif TRACE*/
  dispose_adj_list(fill_in_adj_list);

  v = first_vertex;
  if (!P_setequal(a, empty_set))
    P_setcpy(vertex_set, a);
  else
    P_setdiff(vertex_set, g, d);
  while ((v < last_vertex) & (!P_inset(v, vertex_set)))
    v++;

  ok = sub_ok_to_decompose_mixed_gc(unfolded, graphical, full_specified,
      homogeneous, discrete_gc, linear_gc, quadratic_gc, adj_list, g, d, &v);
  dispose_adj_list(adj_list);
  /*$ifdef TRACE*/
  ntr_3_sets(tzt, 20L, 1156L, 1L, 2L, 1L, vertex_set, g, d);
  ntr_boolean(tzt, 20L, 1156L, 1L, 2L, 2L, ok);
  ntr_triple_g_c(tzt, 20L, 1156L, 1L, 2L, 3L, discrete_gc, linear_gc,
		 quadratic_gc);
      /*ntr*/
  /*$endif TRACE*/
  return ok;
}  /* return_collaps_set_mixed */


/*@-"df.c"*/
/*@+"radim.p"*/


/*

1160:    +++  ++
1161:    +++  ++
1162:    ---  -- p/radim.p          9      31     496 p/radim.p
1163: |    4:    procedure set_list_to_ips_set_list
1164: |   20:    procedure sub_insert_d_ips_element
1165: |   48:    procedure find_upper_and_lower
1166: |   58:    procedure insert_set
1167: |   91:    function ok_to_insert_in_r_ips_leaf
1168: |  205:    procedure seek_dj
1169: |  233:    procedure return_ips_list_for_radim_elements
1170: |  257:    procedure find_of_one_radim_marginals_and_insert_offsets
1171: |  274:    procedure revers_list
1172:    +++  ++
1173:    +++  ++

*/

Static Void set_list_to_ips_set_list(set_list, ips_set_list)
t_set_list *set_list;
t_ips_set_list **ips_set_list;
{
  t_ips_set_list *p;

  *ips_set_list = NULL;
  while (set_list != NULL) {
    p = (t_ips_set_list *)Malloc(sizeof(t_ips_set_list));
    if (p == NULL)
      _OutMem();
    p->pointer = *ips_set_list;
    p->n_offset = MAX_OFFSET;
    P_setcpy(p->vertex_set, set_list->vertex_set);
    *ips_set_list = p;
    set_list = set_list->pointer;
  }
}  /* set_list_to_ips_set_list */


Static Void sub_insert_d_ips_element(ips_list, ips_set_list, a, radim_part,
				     n_offset, p_offset, link_q_tables)
t_list_ips_elements **ips_list;
t_ips_set_list *ips_set_list;
long *a;
boolean radim_part;
t_offset n_offset, p_offset;
t_offset_list *link_q_tables;
{
  t_list_ips_elements *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubInsertDipselemen", sizeof(pch20));
  ntr_set(tzt, 20L, 1161L, 1L, n_offset, p_offset, a);
  /*$endif TRACE*/
  q = (t_list_ips_elements *)Malloc(sizeof(t_list_ips_elements));
  if (q == NULL)
    _OutMem();
  q->pointer = *ips_list;
  q->ips_element.gen_class = ips_set_list;
  P_setcpy(q->ips_element.a, a);
  q->ips_element.radim_part = radim_part;
  q->ips_element.n_offset = n_offset;
  q->ips_element.p_offset = p_offset;
  q->ips_element.link_q_tables = link_q_tables;
  *ips_list = q;
}  /* sub_insert_d_ips_element */


/* Local variables for find_upper_and_lower: */
struct LOC_find_upper_and_lower {
  long *count;
  t_offset_list **upper, **lower, **from;
  t_vertex_set b;
} ;

Local Void insert_set(set_upper, set_lower, LINK)
long *set_upper, *set_lower;
struct LOC_find_upper_and_lower *LINK;
{
  /*$ifdef TRACE*/
  ntr_2_sets(" InsertSet          ", 20L, 1166L, 1L, -1L, -1L, set_upper,
	     set_lower);
  /*$endif TRACE*/
  (*LINK->count)++;
  P_setdiff(LINK->b, set_upper, set_lower);
  insert_offset(LINK->b, 123L, LINK->upper);
  insert_offset(set_lower, 123L, LINK->lower);
  insert_offset(empty_set, 123L, LINK->from);
}  /* insert_set */


Static Void find_upper_and_lower(beta, invers_order, r, count_, upper_,
				 lower_, from_)
short *beta;
t_vertex *invers_order;
t_offset_list **r;
t_integer *count_;
t_offset_list **upper_, **lower_, **from_;
{
  struct LOC_find_upper_and_lower Local_Var;
  t_vertex_set a;
  t_offset_list *q;
  t_long_integer i;

  Local_Var.count = count_;
  Local_Var.upper = upper_;
  Local_Var.lower = lower_;
  Local_Var.from = from_;
  *Local_Var.count = 0;
  q = *r;
  while (q != NULL) {
    P_setcpy(a, empty_set);
    i = dimension;
    while (beta[invers_order[i-1] - MIN_VERTEX] <= q->offset) {
      if (P_inset(invers_order[i-1], q->vertex_set))
	P_addset(a, invers_order[i-1]);
      i--;
    }
    insert_set(q->vertex_set, a, &Local_Var);
    q = q->pointer;
  }
}  /* find_upper_and_lower */


Static boolean ok_to_insert_in_r_ips_leaf(a, ips_generating_class,
  generating_class, link_q_tables, r_ips_leaf)
long *a;
t_ips_set_list **ips_generating_class;
t_set_list *generating_class;
t_offset_list *link_q_tables;
t_radim_element **r_ips_leaf;
{
  boolean error, found;
  t_integer pred_count, count;
  t_vertex_set vertex_set;
  t_offset_list *r_;
  t_v_arr_of_order alpha, beta;
  t_o_arr_of_vertex invers_order;
  t_radim_part *p;
  t_set_list *fill_in, *tmp_set_list;
  t_offset_list *q;
  t_adjacency_matrix matrix_gc;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " OkToInsertInRIpsLea", sizeof(pch20));
  /*$endif TRACE*/
  if (!boolean_option[124] && !em && mean_ips_in_use == normal_ips &&
      !P_setequal(generating_class->vertex_set, empty_set)) {
    /*$ifdef TRACE*/
    ntr_set_and_g_c(tzt, 20L, 1167L, 1L, -1L, -1L, a, &generating_class);
    /*$endif TRACE*/
    *r_ips_leaf = (t_radim_element *)Malloc(sizeof(t_radim_element));
    if (*r_ips_leaf == NULL)
      _OutMem();
    P_setcpy((*r_ips_leaf)->a, a);
    (*r_ips_leaf)->gen_class = *ips_generating_class;
    (*r_ips_leaf)->link_q_tables = link_q_tables;
    (*r_ips_leaf)->radim_parts = NULL;
    (*r_ips_leaf)->ips_list = NULL;
    (*r_ips_leaf)->lower_n_offsets = NULL;
    if (link_q_tables == NULL)
      fill_in = find_fill_in(&generating_class);
    else {
      tmp_set_list = NULL;
      copy_set_list(generating_class, &tmp_set_list);
      q = link_q_tables;
      while (q != NULL) {
	P_setint(vertex_set, a, q->vertex_set);
	insert_clique(vertex_set, &tmp_set_list);
	q = q->pointer;
      }
      fill_in = find_fill_in(&tmp_set_list);
      dispose_set_list(&tmp_set_list);
    }
    /*$ifdef TRACE*/
    ntr_set_and_g_c(tzt, 20L, 1167L, 2L, -1L, -1L, a, &fill_in);
    /*$endif TRACE*/
    create_adjacency_matrix(&matrix_gc, fill_in);
    pred_count = 0;
    error = false;
    while (generating_class != NULL && !error) {
      p = (*r_ips_leaf)->radim_parts;
      found = false;
      while (!found && p != NULL) {
	P_setunion(vertex_set, p->upper->vertex_set, p->lower->vertex_set);
	if (P_subset(generating_class->vertex_set, vertex_set))
	  found = true;
	if (!found)
	  p = p->pointer;
      }
      if (found)
	insert_offset(generating_class->vertex_set, 111L, &p->generators);
      else {
	p = (t_radim_part *)Malloc(sizeof(t_radim_part));
	if (p == NULL)
	  _OutMem();
	p->pointer = (*r_ips_leaf)->radim_parts;
	(*r_ips_leaf)->radim_parts = p;
	p->upper = NULL;
	p->lower = NULL;
	p->from = NULL;
	p->generators = NULL;
	insert_offset(generating_class->vertex_set, 222L, &p->generators);
	/*$ifdef TRACE*/
	ntr_set(tzt, 20L, 1167L, 3L, -1L, -1L, a);
	/*$endif TRACE*/
	restricted_maximim_cardinality_search_on_hypergraph(&matrix_gc,
	  generating_class->vertex_set, &found, alpha, beta, invers_order,
	  &r_);
	find_upper_and_lower(beta, invers_order, &r_, &count, &p->upper,
			     &p->lower, &p->from);
	if (pred_count == 0)
	  pred_count = count;
	else
	  error = (pred_count != count);
	dispose_offset_list(&r_);
      }
      generating_class = generating_class->pointer;
    }
    delete_edges_with_vertices(&matrix_gc, a);
    dispose_set_list(&fill_in);
    if (error)
      note_error(101L);
    if (error) {
      dispose_r_ips_element(*r_ips_leaf);
      _Free(*r_ips_leaf);
      return false;
    } else
      return true;
  } else
    return false;
}  /* ok_to_insert_in_r_ips_leaf */


Static Void seek_dj(d, radim_part, c, offset)
long *d;
t_radim_part **radim_part;
long *c;
t_offset *offset;
{
  boolean found = false;
  t_offset_list *upper, *lower;
  t_vertex_set vertex_set;

  upper = (*radim_part)->upper;
  lower = (*radim_part)->lower;
  while (upper != NULL && !found) {
    P_setunion(vertex_set, upper->vertex_set, lower->vertex_set);
    if (P_subset(d, vertex_set))
      found = true;
    else {
      upper = upper->pointer;
      lower = lower->pointer;
    }
  }
  if (found) {
    P_setunion(c, upper->vertex_set, lower->vertex_set);
    *offset = upper->offset;
  } else
    note_error(102L);
}  /* seek_dj */


/*$endif TRACE*/

Local Void revers_list(p)
t_integer_list **p;
{
  t_integer_list *hp1 = NULL;
  t_integer_list *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_list */


/* Not used:
procedure return_ips_list_for_radim_elements
(    radim_list: t_link_list_radim_elements;
 var ips_list: t_link_list_ips_elements);
var
   upper, lower: t_link_offset_list;
   both: t_vertex_set;
begin
   while radim_list <> nil do begin
      if radim_list^.radim_element.radim_parts <> nil then begin
         upper := radim_list^.radim_element.radim_parts^.upper;
         lower := radim_list^.radim_element.radim_parts^.lower;
         while upper <> nil do begin
            both := upper^.vertex_set + lower^.vertex_set;
            sub_insert_d_ips_element(ips_list,
                                     radim_list^.radim_element.gen_class,
                                     both, true, 333, 333, nil);
            upper := upper^.pointer;
            lower := lower^.pointer
         end
      end;
      radim_list := radim_list^.pointer
   end
end; */
/* return_ips_list_for_radim_elements */

Static Void find_of_one_radim_marginals_and_insert_offsets(radim_element,
							   ok_n, ok_p, fpa)
t_radim_element *radim_element;
boolean *ok_n, *ok_p;
t_e_p_cell_index *fpa;
{
  t_long_integer m, tmp_fpa, max_m;
  t_vertex_set a, d, g;
  t_radim_part *radim_part;
  t_offset_list *generators, *upper, *lower, *from;
  t_offset dummy_offset;
  t_integer_list *integer_list;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$ifdef TRACE*/
  memcpy(tzt, " FindOfOneRadimMargi", sizeof(pch20));
  /*$ifdef TRACE*/
  *ok_n = true;
  *ok_p = true;
  tmp_fpa = *fpa;
  radim_element->ips_list = NULL;
  radim_part = radim_element->radim_parts;
  if (radim_part != NULL) {
    generators = radim_part->generators;
    while (generators != NULL && *ok_n) {
      generators->offset = return_offset(generators->vertex_set, ok_n);
      /*$ifdef TRACE*/
      ntr_set(tzt, 20L, 1170L, 1L, tmp_fpa, generators->offset,
	      generators->vertex_set);
	  /*ntr*/
      /*$endif TRACE*/
      generators = generators->pointer;
    }
    from = radim_part->from;
    upper = radim_part->upper;
    lower = radim_part->lower;
    P_setunion(a, upper->vertex_set, lower->vertex_set);
    P_setcpy(g, a);
    upper->offset = tmp_fpa;
    lower->offset = return_offset(a, ok_n);
    m = marginal_dimension(a);
    if (m < MAX_P_CELL_NUMBER_MAX - tmp_fpa)
      tmp_fpa += m;
    else
      *ok_p = false;
    sub_insert_d_ips_element(&radim_element->ips_list,
			     radim_element->gen_class, a, true, lower->offset,
			     upper->offset, NULL);
    upper = upper->pointer;
    lower = lower->pointer;
    from = from->pointer;
    max_m = m;
    while (upper != NULL && *ok_p) {
      P_setunion(a, upper->vertex_set, lower->vertex_set);
      upper->offset = tmp_fpa;
      lower->offset = return_offset(a, ok_n);
      m = marginal_dimension(a);
      if (m < MAX_P_CELL_NUMBER_MAX - tmp_fpa)
	tmp_fpa += m;
      else
	*ok_p = false;
      if (m > max_m)
	max_m = m;
      sub_insert_d_ips_element(&radim_element->ips_list,
			       radim_element->gen_class, a, true,
			       lower->offset, upper->offset, NULL);
      P_setint(d, g, a);
      P_setunion(g, g, a);
      seek_dj(d, &radim_part, d, &dummy_offset);
      P_setcpy(from->vertex_set, d);
      from->offset = dummy_offset;
      from = from->pointer;
      upper = upper->pointer;
      lower = lower->pointer;
    }
    radim_part = radim_part->pointer;
  }
  m = max_m;
  if (ips_in_use == 1)
    m += tmp_fpa - *fpa;
  if (m < MAX_P_CELL_NUMBER_MAX - tmp_fpa)
    tmp_fpa += m;
  else
    *ok_p = false;
  if (*ok_p && !TURBO_PC)
    *ok_p = space_in_p_array(tmp_fpa, 0L);
  if (*ok_n && *ok_p)
    *fpa = tmp_fpa - m;
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1170L, 2L, tmp_fpa, *fpa, *ok_p);
  /*$endif TRACE*/
  if (*ok_p) {
    while (radim_part != NULL && *ok_n) {
      generators = radim_part->generators;
      while (generators != NULL && *ok_n) {
	generators->offset = return_offset(generators->vertex_set, ok_n);
	generators = generators->pointer;
      }
      from = radim_part->from;
      upper = radim_part->upper;
      lower = radim_part->lower;
      P_setunion(a, upper->vertex_set, lower->vertex_set);
      seek_dj(a, &radim_element->radim_parts, d, &dummy_offset);
      upper->offset = dummy_offset;
      P_setcpy(g, a);
      lower->offset = return_offset(a, ok_n);
      upper = upper->pointer;
      lower = lower->pointer;
      from = from->pointer;
      while (upper != NULL) {
	P_setunion(a, upper->vertex_set, lower->vertex_set);
	seek_dj(a, &radim_element->radim_parts, d, &dummy_offset);
	upper->offset = dummy_offset;
	P_setint(d, g, a);
	P_setunion(g, g, a);
	seek_dj(d, &radim_part, d, &dummy_offset);
	P_setcpy(from->vertex_set, d);
	from->offset = dummy_offset;
	lower->offset = return_offset(a, ok_n);
	from = from->pointer;
	upper = upper->pointer;
	lower = lower->pointer;
      }
      radim_part = radim_part->pointer;
    }
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1170L, 7L, -1L, -1L, *ok_n);
  /*$endif TRACE*/
  if (radim_element->radim_parts != NULL) {
    lower = radim_element->radim_parts->lower;
    integer_list = NULL;
    while (lower != NULL && *ok_n) {
      insert_integer_in_integer_list(return_offset(lower->vertex_set, ok_n),
				     &integer_list);
      lower = lower->pointer;
    }
    revers_list(&integer_list);
    dispose_integer_list(&radim_element->lower_n_offsets);
    radim_element->lower_n_offsets = integer_list;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_boolean(tzt, 20L, 1170L, 8L, -1L, -1L, *ok_n);
}  /* find_of_one_radim_marginals_and_insert_offsets */


/*@+"dbasic.p"*/

/*

1174:    +++  ++
1175:    +++  ++
1176:    ---  -- p/dbasic.p         17      57     960 p/dbasic.p
1177: |    4:    function insert_in_complete_discrete_leaf
1178: |   24:    function insert_in_complete_mixed_leaf
1179: |   37:    function insert_in_complete_continuous_leaf
1180: |   50:    procedure insert_in_complete_node
1181: |   76:    procedure decompose_model
1182: |  118:    procedure decompose_model_and_insert_node
1183: |  159:    procedure decompose_mixed_model
1184: |  212:    procedure decompose_mixed_model_and_insert_node
1185: |  256:    procedure find_formula_for_two_set_model
1186: |  293:    procedure find_formula_for_one_set_model
1187: |  314:    procedure return_and_delete_edges_with_vertices_list
1188: |  327:    function subset_of_an_edge_in_matrix
1189: |  350:    procedure trace_nonempty_adjacency_matrix
1190: |  365:    procedure note_trace_adjacency_matrix
1191: |  378:    function return_edges_from_adjacency_matrix
1192: |  393:    procedure add_edges_from_adjacency_matrix
1193: |  405:    procedure meet_mixed
1194:    +++  ++
1195:    +++  ++

*/

Static t_power_set *insert_in_complete_discrete_leaf(a)
long *a;
{
  t_power_set *d_complete_leaf;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " CompleteDiscreteLea", sizeof(pch20));
  ntr_set(tzt, 20L, 1177L, 1L, 1L, 1L, a);
  /*$endif TRACE*/
  d_complete_leaf = (t_power_set *)Malloc(sizeof(t_power_set));
  if (d_complete_leaf == NULL)
    _OutMem();
  P_setcpy(d_complete_leaf->a, a);
  d_complete_leaf->factor = 1;
  d_complete_leaf->cardinality = cardinality(a);
  d_complete_leaf->offset = MAX_OFFSET;
  return d_complete_leaf;
}  /* insert_in_complete_discrete_leaf */


Static t_power_set *insert_in_complete_mixed_leaf(a)
long *a;
{
  t_power_set *d_complete_leaf;

  d_complete_leaf = (t_power_set *)Malloc(sizeof(t_power_set));
  if (d_complete_leaf == NULL)
    _OutMem();
  P_setcpy(d_complete_leaf->a, a);
  d_complete_leaf->factor = 1;
  d_complete_leaf->cardinality = cardinality(a);
  d_complete_leaf->offset = MAX_OFFSET;
  return d_complete_leaf;
}  /* insert_in_complete_mixed_leaf */


Static t_power_set *insert_in_complete_continuous_leaf(a)
long *a;
{
  t_power_set *d_complete_leaf;

  d_complete_leaf = (t_power_set *)Malloc(sizeof(t_power_set));
  if (d_complete_leaf == NULL)
    _OutMem();
  P_setcpy(d_complete_leaf->a, a);
  d_complete_leaf->factor = 1;
  d_complete_leaf->cardinality = cardinality(a);
  d_complete_leaf->offset = MAX_OFFSET;
  return d_complete_leaf;
}  /* insert_in_complete_continuous_leaf */


Static Void insert_in_complete_node(a, link_formula_node, model_type)
long *a;
t_formula_node **link_formula_node;
t_model_type model_type;
{
  *link_formula_node = (t_formula_node *)Malloc(sizeof(t_formula_node));
  if (*link_formula_node == NULL)
    _OutMem();
  (*link_formula_node)->tmp_m_ips_leaf = NULL;
  switch (model_type) {

  case pure_discrete:
    (*link_formula_node)->node_type = d_complete_node;
    (*link_formula_node)->UU.d_complete_leaf = insert_in_complete_discrete_leaf(a);
    break;

  case mixed:
    (*link_formula_node)->node_type = m_complete_node;
    (*link_formula_node)->UU.d_complete_leaf = insert_in_complete_mixed_leaf(a);
    break;

  case cg_regression:
    /* blank case */
    break;

  case pure_continuous:
    (*link_formula_node)->node_type = c_complete_node;
    (*link_formula_node)->UU.d_complete_leaf = insert_in_complete_continuous_leaf(a);
    break;
  }
}  /* insert_in_complete_node */


Static Void decompose_model(a, b, c, g_c_a, g_c_b, model, causal_structure,
			    homogeneous, model_type)
long *a, *b, *c;
t_set_list **g_c_a, **g_c_b;
t_model **model;
t_set_list *causal_structure;
boolean homogeneous;
t_model_type model_type;
{
  /* C separator; a and b contains c. */
  t_decomposition_element *decomposition_element;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DecomposeModel     ", sizeof(pch20));
  ntr_3_sets(tzt, 20L, 1181L, 1L, 1L, 1L, a, b, c);
  ntr_g_c(tzt, 20L, 1181L, 1L, 2L, 1L, g_c_a);
  ntr_g_c(tzt, 20L, 1181L, 1L, 2L, 2L, g_c_b);
  /*$endif TRACE*/
  (*model)->formula_node = (t_formula_node *)Malloc(sizeof(t_formula_node));
  if ((*model)->formula_node == NULL)
    _OutMem();
  (*model)->formula_node->tmp_m_ips_leaf = NULL;
  (*model)->formula_node->node_type = decomposition_node;
  decomposition_element = (t_decomposition_element *)
			  Malloc(sizeof(t_decomposition_element));
  if (decomposition_element == NULL)
    _OutMem();
  (*model)->formula_node->UU.decomposition_node_ = decomposition_element;
  new_model(&decomposition_element->left_model);
  insert_g_c_in_model(g_c_a, a, &causal_structure, false, homogeneous,
		      &decomposition_element->left_model);
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1181L, 1L, 3L, 99L,
		&decomposition_element->left_model);
      /*ntr*/
  /*$endif TRACE*/
  new_model(&decomposition_element->right_model);
  if (*g_c_b != NULL) {
    insert_g_c_in_model(g_c_b, b, &causal_structure, false, homogeneous,
			&decomposition_element->right_model);
	/*ntr*/
    /*$ifdef TRACE*/
    /*$endif TRACE*/
    ntr_model_g_c(tzt, 20L, 1181L, 1L, 4L, 99L,
		  &decomposition_element->right_model);
  }
  insert_in_complete_node(c, &decomposition_element->separator, model_type);
}  /* decompose_model */


Static Void decompose_model_and_insert_node(a_, c_, g_, g_c_a, g_c_b,
  dimensions_a, dimensions_b, link_formula_node, model, causal_structure,
  homogeneous, model_type)
long *a_, *c_, *g_;
t_set_list **g_c_a, **g_c_b;
t_long_integer *dimensions_a, *dimensions_b;
t_formula_node **link_formula_node;
t_model **model;
t_set_list *causal_structure;
boolean homogeneous;
t_model_type model_type;
{
  /* C separator; a and c disjoint. */
  t_vertex_set a, c, g;
  t_decomposition_element *decomposition_element;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  P_setcpy(a, a_);
  P_setcpy(c, c_);
  P_setcpy(g, g_);
  /*$ifdef TRACE*/
  memcpy(tzt, " DecomposeModelAndIn", sizeof(pch20));
  ntr_3_sets(tzt, 20L, 1182L, 1L, 1L, 1L, a, c, g);
  ntr_g_c(tzt, 20L, 1182L, 1L, 2L, *dimensions_a, g_c_a);
  ntr_g_c(tzt, 20L, 1182L, 1L, 2L, *dimensions_b, g_c_b);
  /*$endif TRACE*/
  P_setdiff(g, g, a);
  P_setunion(a, a, c);
  decompose_model(a, g, c, g_c_a, g_c_b, model, causal_structure, homogeneous,
		  model_type);
  decomposition_element = (*model)->formula_node->UU.decomposition_node_;
  decomposition_element->left_model->dim = *dimensions_a;
  decomposition_element->left_model->formula_node = *link_formula_node;
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1182L, 1L, 3L, 99L,
		&decomposition_element->left_model);
      /*ntr*/
  decomposition_element->right_model->dim = *dimensions_b;
  if (*g_c_b != NULL)   /*ntr*/
    ntr_model_g_c(tzt, 20L, 1182L, 1L, 4L, 99L,
		  &decomposition_element->right_model);
  /*$endif TRACE*/
  *model = decomposition_element->right_model;
}  /* decompose_model_and_insert_node */


Static Void decompose_mixed_model(a, b, c, g_c_d_a, g_c_l_a, g_c_q_a, g_c_d_b,
  g_c_l_b, g_c_q_b, model, causal_structure, full_specified, homogeneous_a,
  homogeneous_b, model_type)
long *a, *b, *c;
t_set_list **g_c_d_a, **g_c_l_a, **g_c_q_a, **g_c_d_b, **g_c_l_b, **g_c_q_b;
t_model **model;
t_set_list *causal_structure;
boolean full_specified, homogeneous_a, homogeneous_b;
t_model_type model_type;
{
  t_decomposition_element *decomposition_element;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DecomposeMixedModel", sizeof(pch20));
  ntr_3_sets(tzt, 20L, 1183L, 1L, 1L, 1L, a, b, c);
  ntr_triple_g_c(tzt, 20L, 1183L, 1L, 2L, 1L, g_c_d_a, g_c_l_a, g_c_q_a);
  ntr_triple_g_c(tzt, 20L, 1183L, 1L, 2L, 1L, g_c_d_b, g_c_l_b, g_c_q_b);
  /*$endif TRACE*/
  (*model)->formula_node = (t_formula_node *)Malloc(sizeof(t_formula_node));
  if ((*model)->formula_node == NULL)
    _OutMem();
  (*model)->formula_node->tmp_m_ips_leaf = NULL;
  (*model)->formula_node->node_type = decomposition_node;
  decomposition_element = (t_decomposition_element *)
			  Malloc(sizeof(t_decomposition_element));
  if (decomposition_element == NULL)
    _OutMem();
  (*model)->formula_node->UU.decomposition_node_ = decomposition_element;
  new_model(&decomposition_element->left_model);
  insert_mixed_g_c_in_model(g_c_d_a, g_c_l_a, g_c_q_a, a, &causal_structure,
			    full_specified, homogeneous_a,
			    &decomposition_element->left_model);
  *g_c_d_a = NULL;
  *g_c_l_a = NULL;
  *g_c_q_a = NULL;
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1183L, 1L, 3L, 99L,
		&decomposition_element->left_model);
  /*$endif TRACE*/
  new_model(&decomposition_element->right_model);
  if (*g_c_d_b != NULL || *g_c_l_b != NULL || *g_c_q_b != NULL) {
    insert_mixed_g_c_in_model(g_c_d_b, g_c_l_b, g_c_q_b, b, &causal_structure,
			      full_specified, homogeneous_b,
			      &decomposition_element->right_model);
    *g_c_d_b = NULL;
    *g_c_l_b = NULL;
    *g_c_q_b = NULL;
    /*$ifdef TRACE*/
    /*$endif TRACE*/
    ntr_model_g_c(tzt, 20L, 1183L, 1L, 4L, 99L,
		  &decomposition_element->right_model);
  }
  insert_in_complete_node(c, &decomposition_element->separator, model_type);
}  /* decompose_mixed_model */


Static Void decompose_mixed_model_and_insert_node(a_, c_, g_, g_c_d_a,
  g_c_l_a, g_c_q_a, g_c_d_b, g_c_l_b, g_c_q_b, dimensions_a, dimensions_b,
  link_formula_node, model, causal_structure, full_specified, homogeneous,
  node_homogeneous, model_type)
long *a_, *c_, *g_;
t_set_list **g_c_d_a, **g_c_l_a, **g_c_q_a, **g_c_d_b, **g_c_l_b, **g_c_q_b;
t_long_integer *dimensions_a, *dimensions_b;
t_formula_node **link_formula_node;
t_model **model;
t_set_list *causal_structure;
boolean full_specified, homogeneous, node_homogeneous;
t_model_type model_type;
{
  /* C separator; a and c disjoint. */
  t_vertex_set a, c, g;
  t_decomposition_element *decomposition_element;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  P_setcpy(a, a_);
  P_setcpy(c, c_);
  P_setcpy(g, g_);
  /*$ifdef TRACE*/
  memcpy(tzt, " DecomposeMixedMoAdI", sizeof(pch20));
  ntr_3_sets(tzt, 20L, 1184L, 1L, 1L, 1L, a, c, g);
  ntr_triple_g_c(tzt, 20L, 1184L, 1L, 2L, *dimensions_a, g_c_d_a, g_c_l_a,
		 g_c_q_a);
  ntr_triple_g_c(tzt, 20L, 1184L, 1L, 2L, *dimensions_b, g_c_d_b, g_c_l_b,
		 g_c_q_b);
  /*$endif TRACE*/
  P_setdiff(g, g, a);
  P_setunion(a, a, c);
  decompose_mixed_model(a, g, c, g_c_d_a, g_c_l_a, g_c_q_a, g_c_d_b, g_c_l_b,
			g_c_q_b, model, causal_structure, full_specified,
			node_homogeneous, homogeneous, model_type);
  decomposition_element = (*model)->formula_node->UU.decomposition_node_;
  decomposition_element->left_model->dim = *dimensions_a;
  decomposition_element->left_model->formula_node = *link_formula_node;
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1184L, 1L, 3L, 99L,
		&decomposition_element->left_model);
  decomposition_element->right_model->dim = *dimensions_b;
  if (*g_c_d_b != NULL || *g_c_l_b != NULL || *g_c_q_b != NULL)
    ntr_model_g_c(tzt, 20L, 1184L, 1L, 4L, 99L,
		  &decomposition_element->right_model);
  /*$endif TRACE*/
  *model = decomposition_element->right_model;
}  /* decompose_mixed_model_and_insert_node */


Static Void find_formula_for_two_set_model(model, a_, b_, causal_structure,
					   homogeneous, model_type)
t_model *model;
long *a_, *b_;
t_set_list **causal_structure;
boolean homogeneous;
t_model_type model_type;
{
  t_vertex_set a, b, g, c;
  t_long_integer dim_a, dim_b, dim_c;
  t_set_list *g_c_a = NULL, *g_c_b = NULL;
  t_formula_node *link_formula_node;

  P_setcpy(a, a_);
  P_setcpy(b, b_);
  P_setint(c, a, b);
  P_setunion(g, a, b);
  dim_a = marginal_dimension(a);
  dim_b = marginal_dimension(b);
  dim_c = marginal_dimension(c);
  model->dim = myaddsubi(&dim_a, &dim_b, &dim_c);
  model->found_expression = true;
  model->found_ps = !em;
  insert_set_in_set_list(a, &g_c_a);
  insert_set_in_set_list(b, &g_c_b);
  insert_in_complete_node(a, &link_formula_node, model_type);
  P_setdiff(a, a, c);
  decompose_model_and_insert_node(a, c, g, &g_c_a, &g_c_b, &dim_a, &dim_b,
				  &link_formula_node, &model,
				  *causal_structure, homogeneous, model_type);
  insert_in_complete_node(b, &link_formula_node, model_type);
  model->formula_node = link_formula_node;
  model->found_expression = true;
  model->found_ps = !em;
}  /* find_formula_for_two_set_model */


Static Void find_formula_for_one_set_model(model, c, causal_structure,
					   homogeneous, model_type)
t_model *model;
long *c;
t_set_list **causal_structure;
boolean homogeneous;
t_model_type model_type;
{
  t_long_integer dim_c;
  t_formula_node *link_formula_node;

  dim_c = marginal_dimension(c);
  if (dim_c < _INFINITY)
    model->dim = dim_c;
  else
    model->dim = _INFINITY;
  insert_in_complete_node(c, &link_formula_node, model_type);
  model->formula_node = link_formula_node;
  model->found_expression = true;
  model->found_ps = !em;
}  /* find_formula_for_one_set_model */


Static Void return_and_delete_edges_with_vertices_list(matrix, a_list, edges)
t_adjacency_matrix *matrix;
t_vertex_list *a_list;
t_set_list **edges;
{
  while (a_list != NULL) {
    return_and_delete_edges_with_vertex(matrix, a_list->vertex, edges);
    a_list = a_list->pointer;
  }
}  /* return_and_delete_edges_with_vertices_list */


Static boolean subset_of_an_edge_in_matrix(i, a, invers_order, matrix)
t_1_max_dimension i;
long *a;
t_vertex *invers_order;
t_adjacency_matrix *matrix;
{
  t_am_node *p;
  boolean b = true;
  t_vertex u;

  while (!P_inset(invers_order[i-1], a) && i < dimension)
    i++;
  u = invers_order[i-1];
  p = matrix->vertex_list[u - MIN_VERTEX];
  while (p != NULL && b) {
    if (P_subset(a, p->link_edge->vertex_set))
      b = false;
    else
      p = p->forward_link;
  }
  return (!b);
}  /* subset_of_an_edge_in_matrix */


Static Void trace_nonempty_adjacency_matrix(matrix)
t_adjacency_matrix *matrix;
{
  t_am_edge_list *p, *q;

  p = matrix->am_edge_list;
  while (p != NULL) {
    warning_begin(stdout, false);
    write_char(stdout, ' ');
    print_vertex_set(p->vertex_set);
    warning_end(stdout, false);
    q = p;
    p = p->forward_link;
    _Free(q);
  }
}  /* trace_nonempty_adjacency_matrix */


Static Void ntr_adjacency_matrix(matrix)
t_adjacency_matrix *matrix;
{
  t_am_edge_list *p;

  p = matrix->am_edge_list;
  write_char(stdout, ' ');
  while (p != NULL) {
    print_vertex_set(p->vertex_set);
    p = p->forward_link;
  }
  write_line(stdout);
}


Static Void ntr_adjacency_matrixs(c, w, o, p, n, m, d_matrix, l_matrix,
				  q_matrix)
Char *c;
t_long_integer w, o, p, n, m;
t_adjacency_matrix *d_matrix, *l_matrix, *q_matrix;
{
  FILE *TEMP;

  if (!do_trace(c, w, o, p, n, m))
    return;
  write_line(stdout);
  write_pch(stdout, " D: ", 4L);
  ntr_adjacency_matrix(d_matrix);
  write_pch(stdout, " L: ", 4L);
  ntr_adjacency_matrix(l_matrix);
  write_pch(stdout, " Q: ", 4L);
  ntr_adjacency_matrix(q_matrix);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static Void ntr_adjacency_matrixs_and_separators(c, w, o, p, n, m, d_matrix,
						 l_matrix, q_matrix, s_matrix)
Char *c;
t_long_integer w, o, p, n, m;
t_adjacency_matrix *d_matrix, *l_matrix, *q_matrix, *s_matrix;
{
  FILE *TEMP;

  if (!do_trace(c, w, o, p, n, m))
    return;
  write_line(stdout);
  write_pch(stdout, " D: ", 4L);
  ntr_adjacency_matrix(d_matrix);
  write_pch(stdout, " L: ", 4L);
  ntr_adjacency_matrix(l_matrix);
  write_pch(stdout, " Q: ", 4L);
  ntr_adjacency_matrix(q_matrix);
  write_pch(stdout, " S: ", 4L);
  ntr_adjacency_matrix(s_matrix);
  TEMP = stdout;
  flush_file(&TEMP);
}


Static t_set_list *return_edges_from_adjacency_matrix(matrix)
t_adjacency_matrix *matrix;
{
  t_am_edge_list *p;
  t_set_list *q = NULL;

  p = matrix->am_edge_list;
  while (p != NULL) {
    insert_set_in_set_list(p->vertex_set, &q);
    p = p->forward_link;
  }
  return q;
}  /* return_edges_from_adjacency_matrix */


Static Void add_edges_from_adjacency_matrix(matrix, q)
t_adjacency_matrix *matrix;
t_set_list **q;
{
  t_am_edge_list *p;

  p = matrix->am_edge_list;
  while (p != NULL) {
    insert_clique(p->vertex_set, q);
    p = p->forward_link;
  }
}  /* add_edges_from_adjacency_matrix */


Static Void meet_mixed(p_d, p_l, p_q, full_specified, homogeneous, q_d, q_l,
		       q_q, c)
t_set_list *p_d, *p_l, *p_q;
boolean full_specified, homogeneous;
t_set_list **q_d, **q_l, **q_q;
long *c;
{
  /* homogeneous not used !!! */
  t_vertex_set tmp_set, vertex_set;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " MeetMixed          ", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 1193L, 1L, -1L, -1L, &p_d, &p_l, &p_q);
  ntr_set(tzt, 20L, 1193L, 1L, -1L, -1L, c);
  /*$endif TRACE*/
  *q_d = NULL;
  *q_l = NULL;
  *q_q = NULL;
  insert_clique(empty_set, q_d);
  while (p_d != NULL) {
    P_setint(vertex_set, c, p_d->vertex_set);
    insert_clique(vertex_set, q_d);
    p_d = p_d->pointer;
  }
  while (p_l != NULL) {
    P_setint(vertex_set, c, p_l->vertex_set);
    P_setint(tmp_set, vertex_set, gamma_);
    if (!P_setequal(tmp_set, empty_set))
      insert_clique(vertex_set, q_l);
    p_l = p_l->pointer;
  }
  while (p_q != NULL) {   /* and not full_specified */
    P_setint(vertex_set, c, p_q->vertex_set);
    P_setint(tmp_set, vertex_set, gamma_);
    if (!P_setequal(tmp_set, empty_set)) {
      if ((!full_specified) | (P_inset(double_vertex, c) ==
			       P_inset(double_vertex, vertex_set)))
	    /* boolean_option[80] or */
	      insert_clique(vertex_set, q_q);
    }
    p_q = p_q->pointer;
  }
  /*$ifdef TRACE*/
  ntr_triple_g_c(tzt, 20L, 1193L, 8L, -1L, -1L, q_d, q_l, q_q);
  /*$endif TRACE*/
}  /* meet_mixed */


/*@+"dimension.p"*/


/*

1196:    +++  ++
1197:    +++  ++
1198:    ---  -- p/dimension.p       12      53     783 p/dimension.p
1199: |    4:    function find_discrete_dimension
1200: |   35:    procedure update_discrete_dimension_set
1201: |   50:    procedure update_discrete_dimension_gc

1206: |  345:    function dim_pure_cont_transf
1207: |  351:    function sub_find_continuous_dimension
1208: |  418:    function find_continuous_dimension
1209: |  434:    procedure update_continuous_dimension_set
1210: |  467:    procedure update_continuous_dimension_gc

1202: |   64:    function dim_quadratic_transf ( cum_sum_of_plus_one )
1203: |   70:    function sub_find_mixed_dimension
1203: |   70:    function find_mixed_dimension
1204: |  213:    procedure update_mixed_dimension_set
1205: |  293:    procedure update_mixed_dimension

1211:    +++  ++
1212:    +++  ++

*/

Static t_long_integer find_discrete_dimension(p)
t_set_list *p;
{
  long Result;
  t_set_list *q = NULL;
  t_vertex_set c, vertex_set;
  t_long_integer d1, d2, d3;

  if (p->pointer == NULL) {
    d1 = marginal_dimension(p->vertex_set);
    d1 = mysubi(&d1, (long)DISCRETE_DIMENSION_SHIFT);
    return d1;
  }
  P_setcpy(c, p->vertex_set);
  d1 = marginal_dimension(c);
  d2 = find_discrete_dimension(p->pointer);
  p = p->pointer;
  while (p != NULL) {
    P_setint(vertex_set, c, p->vertex_set);
    insert_clique(vertex_set, &q);
    p = p->pointer;
  }
  d3 = find_discrete_dimension(q);
  d1 = mysubi(&d1, (long)DISCRETE_DIMENSION_SHIFT);
  Result = myaddsubi(&d1, &d2, &d3);
  dispose_set_list(&q);
  return Result;
}  /* find_discrete_dimension */


Static Void update_discrete_dimension_set(dim, a, sign)
t_long_integer *dim;
long *a;
t_integer sign;
{
  t_long_integer dimension_a;

  if (*dim >= _INFINITY)
    return;
  dimension_a = marginal_dimension(a);
  dimension_a = mysubi(&dimension_a, (long)DISCRETE_DIMENSION_SHIFT);
  *dim = myaddsigni(dim, &dimension_a, sign);
}  /* update_discrete_dimension_set */


Static Void update_discrete_dimension_gc(dim, g_c)
t_long_integer *dim;
t_set_list **g_c;
{
  t_long_integer dimension_a;

  if (*dim < _INFINITY) {
    dimension_a = find_discrete_dimension(*g_c);
    *dim = myaddi(dim, &dimension_a);
  }
}  /* update_discrete_dimension_gc */


Static t_long_integer dim_pure_cont_transf(d)
t_long_integer d;
{
  /*SLL, page 215, 6.45*/
  return ((d + 1) * (d + 2) / 2);   /* - 2 */
  /* - 2 */
  /* ?!?!? */
}  /* dim_pure_cont_transf */


Static t_long_integer sub_find_continuous_dimension(p, indent)
t_set_list *p;
t_integer indent;
{
  /*var*/
  long Result;
  t_set_list *q = NULL;
  t_vertex_set c, vertex_set;
  t_long_integer d1, d2, d3;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindcontinuousDimen", sizeof(pch20));
  ntr_g_c(tzt, 20L, 1207L, 1L, -1L, 2L, &p);
  /*$endif TRACE*/
  if (p->pointer == NULL) {
    d1 = cardinality(p->vertex_set);
    if (d1 != _INFINITY)
      d1 = dim_pure_cont_transf(d1);
    return d1;
  }
  P_setcpy(c, p->vertex_set);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1207L, 0L)) {
    write_space(stdout, indent);
    write_pch(stdout, " C-Find:  ", 10L);
    print_triple_g_c(&q, &q, &p, 0L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1207L, 0L)) {
    write_space(stdout, indent);
    write_pch(stdout, " C-Quadrat", 10L);
    print_vertex_set(c);
    write_line(stdout);
  }
  /*$endif TRACE*/
  d1 = cardinality(c);
  d2 = sub_find_continuous_dimension(p->pointer, indent + 1);
  p = p->pointer;
  while (p != NULL) {
    P_setint(vertex_set, c, p->vertex_set);
    insert_clique(vertex_set, &q);
    p = p->pointer;
  }
  if (q == NULL)
    insert_clique(empty_set, &q);
  d3 = sub_find_continuous_dimension(q, indent + 1);
  d1 = dim_pure_cont_transf(d1);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1207L, 0L)) {
    write_space(stdout, indent);
    write_pch(stdout, " C-Found: ", 10L);
    print_triple_g_c(&p, &p, &q, 0L);
    /* write_space(output, 5); */
    write_line(stdout);
    write_space(stdout, indent + 1);
    print_vertex_set_table(c);
    write_integer(stdout, d1, 3L);
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, d2, 3L);
    write_pch(stdout, " - ", 3L);
    write_integer(stdout, d3, 3L);
    write_pch(stdout, " = ", 3L);
    write_integer(stdout, myaddsubi(&d1, &d2, &d3), 3L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  Result = myaddsubi(&d1, &d2, &d3);
  dispose_set_list(&q);
  return Result;
}  /* sub_find_continuous_dimension */


Static t_long_integer cum_sum_of_plus_one(d)
t_long_integer d;
{
  /*SLL, page 215, 6.45*/
  return ((d + 1) * (d + 2) / 2);
}  /* cum_sum_of_plus_one */


Static t_long_integer sub_find_mixed_dimension(d, l, q, full_specified,
					       homogeneous, indent)
t_set_list *d, *l, *q;
boolean full_specified, homogeneous;
t_integer indent;
{
  long Result;
  t_set_list *q_d, *q_l, *q_q;
  t_vertex_set c, e;
  t_long_integer a, r, d0, d1;
  t_long_integer d2 = 1, d3 = 1;
  boolean do_intersection = true, one_discrete = false;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindMixedDimension ", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 1208L, 2L, -indent, 2L, &d, &l, &q);
  ntr_boolean(tzt, 20L, 1208L, 2L, 1L, 2L, full_specified);
  ntr_boolean(tzt, 20L, 1208L, 2L, 1L, 3L, homogeneous);
  /*$endif TRACE*/
  /* if d = nil then begin end
     else if (d^.pointer = nil) and (l = nil) and (q = nil) then begin */
  if (d != NULL) {
    if (d->pointer == NULL)
      one_discrete = true;
  }
  if (one_discrete && l == NULL && q == NULL) {
    if (P_setequal(d->vertex_set, empty_set)) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1203L, 2L)) {
	write_space(stdout, indent);
	write_pch(stdout, " Empty set", 10L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      r = 1;
      Result = 1;
    } else {
      d1 = marginal_dimension(d->vertex_set);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1203L, 2L)) {
	write_space(stdout, indent);
	write_pch(stdout, " Discrete:", 10L);
	if (trace_flag_set(20L, 1203L, 7L))
	  print_vertex_set_table(d->vertex_set);
	write_integer(stdout, d1, 3L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      r = d1;
      Result = d1;
    }
  } else {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1203L, 2L)) {
      if (trace_flag_set(20L, 1203L, 7L)) {
	write_space(stdout, indent);
	write_pch(stdout, " Find:    ", 10L);
	print_triple_g_c(&d, &l, &q, 0L);
	write_line(stdout);
      }
    }
    /*$endif TRACE*/
    if (q != NULL) {
      P_setcpy(c, q->vertex_set);
      d0 = count_continuous(c);
      d1 = marginal_dimension(c);
      if (d1 < _INFINITY) {
	if (full_specified && !boolean_option[108]) {
	  if (d0 != 0) {
	    /* Not possible! */
	    if (d0 == 1)
	      d1 = mymulti(&d1, 3L);
	    else if (d0 == 2) {
	      do_intersection = false;
	      P_setint(e, c, gamma_);
	      if (subset_of_an_edge(e, &q->pointer))
		d1--;
	    } else {
	      /*
	      d1 := mymulti(d1, 4)
	      */

	      /* 22. september 2002:
	         It does not work for some with d0 > 2 !!!!

	         "unfold_quadratic" does fix it !!!

	       A := (d0 - 1) * d0 * 2):
	            4 * "number of edges" =
	            4 * cum_sum_of_plus_one(d0-2),
	            dimension of quadratic.

	       B := mymulti(3, cum_sum_of_plus_one(d0-2)):
	            3 * "number of edges" =
	            3 * cum_sum_of_plus_one(d0-2),
	            what the dimension of the intersection should be.

	       C := d0 + 1,
	            d3, found dimension of intersection,
	                continuous set with d0 variables.

	       A  := mymulti(4, cum_sum_of_plus_one(d0-2));
	       B  := mymulti(3, cum_sum_of_plus_one(d0-2));
	       C  := d0 + 1;
	       a  := A - B + C; */

	      a = cum_sum_of_plus_one(d0 - 2);
	      do_intersection = false;
	      d1 = mymulti(&d1, a);
	      P_setint(e, c, gamma_);
	      if (subset_of_an_edge(e, &q->pointer)) {
		d1--;


	      }
	    }
	  }
	} else
	  d1 = mymulti(&d1, cum_sum_of_plus_one(d0));
      }
      d2 = sub_find_mixed_dimension(d, l, q->pointer, full_specified,
				    homogeneous, indent + 1);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1203L, 2L)) {
	write_space(stdout, indent);
	write_pch(stdout, " Quadratic", 10L);
	if (trace_flag_set(20L, 1203L, 7L))
	  print_vertex_set(c);
	write_line(stdout);
	write_pch(stdout, " Q ", 3L);
	write_integer(stdout, d1, 3L);
	write_pch(stdout, " / ", 3L);
	write_integer(stdout, d2, 3L);
	write_pch(stdout, " // ", 4L);
	write_integer(stdout, d0, 3L);
	write_pch(stdout, " / ", 3L);
	if (!full_specified || boolean_option[108])
	  write_integer(stdout, cum_sum_of_plus_one(d0), 3L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      meet_mixed(d, l, q->pointer, full_specified, homogeneous, &q_d, &q_l,
		 &q_q, c);
    } else if (l != NULL) {
      P_setcpy(c, l->vertex_set);
      d1 = marginal_dimension(c);
      d1 = mymulti(&d1, 2L);
      d2 = sub_find_mixed_dimension(d, l->pointer, NULL, full_specified,
				    homogeneous, indent + 1);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1203L, 2L)) {
	write_space(stdout, indent);
	write_pch(stdout, " Linear   ", 10L);
	if (trace_flag_set(20L, 1203L, 7L))
	  print_vertex_set(c);
	write_line(stdout);
	write_pch(stdout, " L ", 3L);
	write_integer(stdout, d1, 3L);
	write_pch(stdout, " / ", 3L);
	write_integer(stdout, d2, 3L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      meet_mixed(d, l->pointer, NULL, full_specified, homogeneous, &q_d, &q_l,
		 &q_q, c);
    } else if (d != NULL) {
      P_setcpy(c, d->vertex_set);
      d1 = marginal_dimension(c);
      d2 = sub_find_mixed_dimension(d->pointer, NULL, NULL, full_specified,
				    homogeneous, indent + 1);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1203L, 2L)) {
	write_space(stdout, indent);
	write_pch(stdout, " Discrete ", 10L);
	if (trace_flag_set(20L, 1203L, 7L))
	  print_vertex_set(c);
	write_line(stdout);
	write_pch(stdout, " D ", 3L);
	write_integer(stdout, d1, 3L);
	write_pch(stdout, " / ", 3L);
	write_integer(stdout, d2, 3L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      meet_mixed(d->pointer, NULL, NULL, full_specified, homogeneous, &q_d,
		 &q_l, &q_q, c);
    } else {
      d1 = 1;
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1203L, 2L)) {
	write_space(stdout, indent);
	write_pch(stdout, " Null     ", 10L);
	write_line(stdout);
	write_pch(stdout, " N ", 3L);
	write_integer(stdout, d1, 3L);
	write_pch(stdout, " / ", 3L);
	write_integer(stdout, d2, 3L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      q_d = NULL;
      q_l = NULL;
      q_q = NULL;
    }
    if (q_d != NULL || q_l != NULL || q_q != NULL) {
      if (do_intersection)
	d3 = sub_find_mixed_dimension(q_d, q_l, q_q, full_specified,
				      homogeneous, indent + 1);
      else
	d3 = 0;
    }
    dispose_set_list(&q_d);
    dispose_set_list(&q_l);
    dispose_set_list(&q_q);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1203L, 2L)) {
      write_space(stdout, indent);
      if (trace_flag_set(20L, 1203L, 7L)) {
	write_pch(stdout, " Found:   ", 10L);
	print_triple_g_c(&d, &l, &q, 0L);
	/* write_space(output, 5); */
	write_line(stdout);
      }
      write_space(stdout, indent + 1);
      if (trace_flag_set(20L, 1203L, 7L))
	print_vertex_set_table(c);
      write_integer(stdout, d1, 3L);
      write_pch(stdout, " + ", 3L);
      write_integer(stdout, d2, 3L);
      write_pch(stdout, " - ", 3L);
      write_integer(stdout, d3, 3L);
      write_pch(stdout, " = ", 3L);
      write_integer(stdout, myaddsubi(&d1, &d2, &d3), 3L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    r = myaddsubi(&d1, &d2, &d3);
    Result = myaddsubi(&d1, &d2, &d3);
  }
  /*$ifdef TRACE*/
  ntr_triple_g_c(tzt, 20L, 1208L, 7L, -indent, r, &d, &l, &q);
  /*$endif TRACE*/
  return Result;
}  /* sub_find_mixed_dimension */


Static t_long_integer gc_dimension(p, u, v)
t_set_list *p;
t_vertex *u, *v;
{
  long Result;
  t_set_list *tmp = NULL;
  t_vertex_set b;

  while (p != NULL) {
    if (P_inset(*v, p->vertex_set) & P_inset(*u, p->vertex_set)) {
      P_setint(b, p->vertex_set, delta);
      insert_clique(b, &tmp);
    }
    p = p->pointer;
  }
  if (tmp == NULL)
    Result = 0;
  else
    Result = find_discrete_dimension(tmp) + 1;
  dispose_set_list(&tmp);
  return Result;
}  /* gc_dimension */


Static t_long_integer find_mixed_dimension(d, l, q, full_specified,
					   homogeneous, indent)
t_set_list *d, *l, *q;
boolean full_specified, homogeneous;
t_integer indent;
{
  long Result;
  boolean unfold;
  t_set_list *unfolded_q;
  t_long_integer dim_1, dim_2;
  t_vertex u, v;
  t_vertex_set g;
  pch20 txt;

  memcpy(txt, " FindMixedDimension ", sizeof(pch20));
  /*$ifdef TRACE*/
  ntr_triple_g_c(txt, 20L, 1208L, 1L, -indent, 2L, &d, &l, &q);
  ntr_boolean(txt, 20L, 1208L, 1L, 1L, 2L, full_specified);
  ntr_boolean(txt, 20L, 1208L, 1L, 1L, 3L, homogeneous);
  /*$endif TRACE*/
  unfold_quadratic(&q, &unfolded_q, &unfold, txt, 20L, false, false);
  if (unfold) {
    dim_1 = sub_find_mixed_dimension(d, l, unfolded_q, full_specified,
				     homogeneous, indent);
    dispose_set_list(&unfolded_q);
  } else
    dim_1 = sub_find_mixed_dimension(d, l, q, full_specified, homogeneous,
				     indent);
  P_setcpy(g, empty_set);
  add_union_of_gc(d, g);

  if (P_setequal(g, empty_set)) {
    if (q != NULL)
      dim_1 = sub_find_continuous_dimension(q, 0L);
  }

  dim_2 = find_discrete_dimension(d) + 1;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, gamma_)) {
      dim_2 += gc_dimension(l, &v, &v);
      if (full_specified)
	dim_2 += gc_dimension(q, &v, &double_vertex);
      else
	dim_2 += gc_dimension(q, &v, &v);
      for (u = v + 1; u <= last_vertex; u++) {
	if (P_inset(u, gamma_))
	  dim_2 += gc_dimension(q, &v, &u);
      }
    }
  }
  if (dim_1 != dim_2)
    note_error_triple_g_c_int(stdout, 1208L, 1L, " FindMixedDimension ", d, l,
			      q, dim_1, dim_2, false);
  Result = dim_2;
  /*$ifdef TRACE*/
  ntr_triple_g_c(txt, 20L, 1208L, 8L, -indent, dim_1, &d, &l, &q);
  /*$endif TRACE*/
  return Result;
}  /* find_mixed_dimension */


Static Void update_mixed_dimension_set(dim, full_specified, homogeneous, a,
				       sign)
t_long_integer *dim;
boolean *full_specified, *homogeneous;
long *a;
t_integer sign;
{
  t_set_list *tmp_discrete_g_c, *tmp_linear_g_c, *tmp_quadratic_g_c, *g_c;
  t_long_integer d0, d1, d, dimension_a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " UpdateMixedDimenSet", sizeof(pch20));
  if (trace_flag_set(20L, 1209L, 0L)) {
    ntr(tzt, 20L, 1209L, 1L, -1L, *dim);
    ntr_boolean(tzt, 20L, 1209L, 1L, -1L, -1L, *homogeneous);
    ntr_boolean(tzt, 20L, 1209L, 1L, -1L, -2L, *full_specified);
    ntr_set(tzt, 20L, 1209L, 1L, -1L, -1L, a);
    d = 0;
    dimension_a = 0;
  }
  /*$endif TRACE*/
  if (*dim < _INFINITY) {
    d = count_continuous(a);
    dimension_a = marginal_dimension(a);
    if (dimension_a < _INFINITY) {
      if (*homogeneous) {
	g_c = NULL;
	insert_set_in_set_list(a, &g_c);
	split_g_c_in_mixed_terms(g_c, *full_specified, *homogeneous,
				 &tmp_discrete_g_c, &tmp_linear_g_c,
				 &tmp_quadratic_g_c);
	dispose_set_list(&g_c);
	dimension_a = find_mixed_dimension(tmp_discrete_g_c, tmp_linear_g_c,
	    tmp_quadratic_g_c, *full_specified, *homogeneous, 0L);
	dispose_set_list(&tmp_discrete_g_c);
	dispose_set_list(&tmp_linear_g_c);
	dispose_set_list(&tmp_quadratic_g_c);
	*dim = myaddsigni(dim, &dimension_a, sign);
      } else {
	d0 = cum_sum_of_plus_one(d);
	d1 = mymulti(&dimension_a, d0);
	*dim = myaddsigni(dim, &d1, sign);
      }
    } else
      *dim = _INFINITY;
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1209L, 8L))
    return;
  /*$endif TRACE*/
  ntr_boolean(tzt, 20L, 1209L, 8L, -1L, -1L, *homogeneous);
  ntr_set(tzt, 20L, 1209L, 8L, d, sign, a);
  if (*homogeneous)
    dimension_a = mymulti(&dimension_a, sign);
  else {
    d0 = cum_sum_of_plus_one(d);
    d1 = mymulti(&d0, sign);
    ntr(tzt, 20L, 1209L, 8L, d0, d1);
    dimension_a = mymulti(&dimension_a, d1);
  }
  ntr(tzt, 20L, 1209L, 8L, dimension_a, *dim);
}  /* update_mixed_dimension_set */


Static Void update_mixed_dimension(dim, full_specified, homogeneous, upper,
				   lower, complete, g_c_d, g_c_l, g_c_q)
t_long_integer *dim;
boolean *full_specified, *homogeneous;
long *upper, *lower;
boolean complete;
t_set_list **g_c_d, **g_c_l, **g_c_q;
{
  /* a, b       : t_vertex_set; */
  t_long_integer dimension_a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " UpdateMixedDimensio", sizeof(pch20));
  ntr(tzt, 20L, 1210L, 1L, -1L, *dim);
  ntr_boolean(tzt, 20L, 1210L, 1L, -1L, -1L, *homogeneous);
  ntr_boolean(tzt, 20L, 1210L, 1L, -1L, -2L, complete);
  ntr_2_sets(tzt, 20L, 1210L, 1L, -1L, -1L, upper, lower);
  /*$endif TRACE*/
  if (complete) {
    dimension_a = *dim;
    update_mixed_dimension_set(dim, full_specified, homogeneous, upper, 1L);
    dimension_a = mysubi(dim, dimension_a);
    /* update_mixed_dimension_set(dim, full_specified, homogeneous, lower, -1) */
  } else if (*dim < _INFINITY) {
    /*$ifdef TRACE*/
    dimension_a = find_mixed_dimension(*g_c_d, *g_c_l, *g_c_q,
				       *full_specified, *homogeneous, 0L);
    *dim = myaddi(dim, &dimension_a);
  }
  ntr(tzt, 20L, 1210L, 1L, dimension_a, *dim);
  /*$endif TRACE*/
}  /* update_mixed_dimension */


Static t_long_integer find_continuous_dimension(p)
t_set_list *p;
{
  t_set_list *d, *l, *q;
  t_long_integer a, b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindcontinuousDimen", sizeof(pch20));
  ntr_g_c(tzt, 20L, 1208L, 1L, -1L, 2L, &p);
  /*$endif TRACE*/
  split_g_c_in_mixed_terms(p, false, false, &d, &l, &q);
  a = find_mixed_dimension(d, l, q, false, false, 0L);
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 1208L, 1L, -2L, a, &p);
  /*$endif TRACE*/
  dispose_set_list(&d);
  dispose_set_list(&l);
  dispose_set_list(&q);
  b = sub_find_continuous_dimension(p, 0L);
  if (labs(a - b) > 0.01)
    note_error_reals(stdout, 1208L, 1L, " FindcontinuousDimen", (double)a,
		     (double)b, NULL, NULL);
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 1208L, 1L, -3L, b, &p);
  /*$endif TRACE*/
  return b;
}  /* find_continuous_dimension */


Static Void update_continuous_dimension_set(dim, a, sign)
t_long_integer *dim;
long *a;
t_integer sign;
{
  t_long_integer d1, x;

  if (*dim >= _INFINITY)
    return;
  d1 = cardinality(a);
  x = dim_pure_cont_transf(d1);

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1209L, 0L)) {
    write_pch(stdout, " C-update:", 10L);
    print_vertex_set_table(a);
    write_line(stdout);
    write_integer(stdout, *dim, 3L);
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, sign, 3L);
    write_pch(stdout, " * ", 3L);
    write_integer(stdout, x, 3L);
    write_pch(stdout, " = ", 3L);
    write_integer(stdout, myaddsigni(dim, &x, sign), 3L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  *dim = myaddsigni(dim, &x, sign);
}  /* update_continuous_dimension_set */


Static Void update_continuous_dimension_gc(dim, g_c)
t_long_integer *dim;
t_set_list **g_c;
{
  t_long_integer dimension_a;

  if (*dim < _INFINITY) {
    dimension_a = find_continuous_dimension(*g_c);
    *dim = myaddi(dim, &dimension_a);
  }
}  /* update_continuous_dimension_gc */


Static t_long_integer find_dimension(model, full_specified, homogeneous)
t_model **model;
boolean full_specified, homogeneous;
{
  long Result;
  t_long_integer dimension;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindDimension      ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1211L, 1L, -1L, 2L, model);
  /*$endif TRACE*/
  if ((*model)->id != NULL) {
    if ((*model)->id->model_type == pure_discrete)
      dimension = find_discrete_dimension((*model)->id->UU.g_c_log_linear);
    else if ((*model)->id->model_type == pure_continuous)
      dimension = find_continuous_dimension((*model)->id->UU.g_c_covariance);
    else if ((*model)->id->model_type == mixed)
      dimension = find_mixed_dimension((*model)->id->UU.U1.g_c_discrete,
	  (*model)->id->UU.U1.g_c_linear, (*model)->id->UU.U1.g_c_quadratic,
	  full_specified, homogeneous, 1L);
  } else
    write_pch(stdout, " Model is corrupted!", 20L);
  Result = dimension;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1211L, 1L, -1L, dimension);
  /*$endif TRACE*/
  return Result;
}  /* find_dimension */


/*@+"ddiscre.p"*/

/*

1213:    +++  ++
1214:    +++  ++
1215:    ---  -- p/ddiscr.p          4      21     275 p/ddiscr.p
1216: |    4:    procedure new_d_ips_leaf
1217: |   20:    procedure insert_in_discrete_node
1218: |   47:    procedure decompose_non_decomposable
1219: |  221:    procedure find_partitioning
1220:    +++  ++
1221:    +++  ++

*/

Static Void new_d_ips_leaf(d_ips_leaf, ips_set_list, a, radim_part, n_offset,
			   p_offset, link_q_tables)
t_ips_element **d_ips_leaf;
t_ips_set_list **ips_set_list;
long *a;
boolean radim_part;
t_offset n_offset, p_offset;
t_offset_list *link_q_tables;
{
  *d_ips_leaf = (t_ips_element *)Malloc(sizeof(t_ips_element));
  if (*d_ips_leaf == NULL)
    _OutMem();
  (*d_ips_leaf)->gen_class = *ips_set_list;
  P_setcpy((*d_ips_leaf)->a, a);
  (*d_ips_leaf)->radim_part = radim_part;
  (*d_ips_leaf)->n_offset = n_offset;
  (*d_ips_leaf)->p_offset = p_offset;
  (*d_ips_leaf)->link_q_tables = link_q_tables;
}  /* new_d_ips_leaf */


Static Void insert_in_discrete_node(a, generating_class, formula_node)
long *a;
t_set_list **generating_class;
t_formula_node **formula_node;
{
  t_ips_set_list *ips_set_list;

  *formula_node = (t_formula_node *)Malloc(sizeof(t_formula_node));
  if (*formula_node == NULL)
    _OutMem();
  (*formula_node)->tmp_m_ips_leaf = NULL;
  (*formula_node)->node_type = null_node;
  if (*generating_class == NULL)
    return;
  if ((*generating_class)->pointer == NULL &&
      P_setequal((*generating_class)->vertex_set, a)) {
    (*formula_node)->node_type = d_complete_node;
    (*formula_node)->UU.d_complete_leaf = insert_in_complete_discrete_leaf(a);
    return;
  }
  set_list_to_ips_set_list(*generating_class, &ips_set_list);
  (*formula_node)->node_type = r_ips_node;
  if (!ok_to_insert_in_r_ips_leaf(a, &ips_set_list, *generating_class, NULL,
				  &(*formula_node)->UU.r_ips_leaf)) {
    (*formula_node)->node_type = d_ips_node;
    new_d_ips_leaf(&(*formula_node)->UU.d_ips_leaf, &ips_set_list, a, false,
		   MAX_OFFSET, MAX_OFFSET, NULL);
  }
}  /* insert_in_discrete_node */


Static Void decompose_non_decomposable(model, graphical, matrix_gc, model_set,
  adj_list, adj_set, invers_order, c, complete, constant, dim)
t_model **model;
boolean *graphical;
t_adjacency_matrix *matrix_gc;
long *model_set;
t_vertex_list **adj_list;
t_vertex_set *adj_set;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
t_long_real *constant;
t_long_integer *dim;
{
  t_1_max_dimension i = 1;
  t_1_max_dimension j;
  t_long_integer dimension_a, dimension_b;
  t_vertex u, v;
  t_vertex_set a, b, g;
  t_set_list *g_c_a = NULL, *g_c_b = NULL;
  t_adjacency_matrix matrix_separators;
  t_vertex_list *a_list = NULL;
  boolean ok;
  t_formula_node *formula_node;
  t_model *current_model;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DecomposeNonDecomp ", sizeof(pch20));
  if (trace_flag_set(20L, 1218L, 1L))
    sub_print_invers_order(invers_order, c, complete);
  /*$endif TRACE*/
  current_model = *model;
  new_adjacency_matrix(&matrix_separators);
  *dim = 0;
  P_setdiff(b, delta, model_set);
  *constant = 1 / marginal_dimension_real(b);
  P_setcpy(g, model_set);
  P_setcpy(b, g);
  while (!P_setequal(b, empty_set)) {
    u = invers_order[i-1];
    /*$ifdef TRACE*/
    ntr_vertex_and_set(tzt, 20L, 1218L, 1L, 103L, (long)i, &u, b);
    /*$endif TRACE*/
    while (!(P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) & P_inset(u, g))) {
      i++;
      u = invers_order[i-1];
      /*$ifdef TRACE*/
      ntr_vertex_and_set(tzt, 20L, 1218L, 2L, 103L, (long)i, &u, empty_set);
      /*$endif TRACE*/
    }
    /*$ifdef TRACE*/
    ntr_vertex_and_set(tzt, 20L, 1218L, 2L, 104L, (long)i, &u,
		       c[u - MIN_VERTEX]);
    /*$endif TRACE*/
    if (*graphical)
      ok = true;
    else
      ok = subset_of_an_edge_in_matrix(i, c[u - MIN_VERTEX], invers_order,
				       matrix_gc);
    if (ok || i == dimension) {
      if (*graphical)
	ok = P_subset(c[u - MIN_VERTEX], adj_set[u - MIN_VERTEX]);
      else if (ok) {
	P_setcpy(b, c[u - MIN_VERTEX]);
	P_addset(b, invers_order[i-1]);
	ok = subset_of_an_edge_in_matrix(i, b, invers_order, matrix_gc);
      }
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1218L, 4L, 104L, 0L, ok);
      /*$endif TRACE*/
      if (ok || boolean_option[123]) {
	if (ok) {
	  delete_edges_with_vertex(matrix_gc, &u);
	  delete_edges_with_vertex(&matrix_separators, &u);
	}
	j = i + 1;
	if (j < dimension) {
	  v = invers_order[j-1];
	  P_setcpy(b, c[v - MIN_VERTEX]);
	  P_addset(b, v);
	  while ((P_subset(b, c[u - MIN_VERTEX]) && j < dimension) &
		 P_inset(v, g)) {
	    if (ok) {
	      delete_edges_with_vertex(matrix_gc, &v);
	      delete_edges_with_vertex(&matrix_separators, &v);
	    }
	    j++;
	    v = invers_order[j-1];
	    P_setcpy(b, c[v - MIN_VERTEX]);
	    P_addset(b, v);
	    /*$ifdef TRACE*/
	    /*$endif TRACE*/
	    ntr_vertex_and_set(tzt, 20L, 1218L, 5L, 105L, (long)j, &v, b);
	  }
	}
	P_setcpy(b, c[u - MIN_VERTEX]);
	P_addset(b, u);
	i = j - 1;
	u = invers_order[i-1];
      }
      dimension_a = *dim;
      /*$ifdef TRACE*/
      ntr_vertex_and_set(tzt, 20L, 1218L, 6L, 106L, (long)i, &u, b);
      ntr_boolean(tzt, 20L, 1218L, 7L, 107L, *dim, ok);
      /*$endif TRACE*/
      if (ok) {
	/* Eliminating complete subgraph */
	P_setdiff(a, b, c[u - MIN_VERTEX]);
	g_c_a = NULL;
	insert_clique(b, &g_c_a);
	insert_in_complete_node(b, &formula_node, pure_discrete);
	insert_edge_in_adjacency_matrix(&matrix_separators, c[u - MIN_VERTEX]);
	update_discrete_dimension_set(dim, b, 1L);
      } else {
	find_connected_component_list(g, c[u - MIN_VERTEX], a, &a_list, &u,
				      adj_list);
	return_and_delete_edges_with_vertices_list(matrix_gc, a_list, &g_c_a);
	return_and_delete_edges_with_vertices_list(&matrix_separators, a_list,
						   &g_c_b);
	dispose_vertex_list(&a_list);
	insert_clique(c[u - MIN_VERTEX], &g_c_a);
	add_cliques(g_c_b, &g_c_a);
	dispose_set_list(&g_c_b);
	P_setunion(b, a, c[u - MIN_VERTEX]);
	insert_in_discrete_node(b, &g_c_a, &formula_node);
	insert_edge_in_adjacency_matrix(&matrix_separators, c[u - MIN_VERTEX]);
	update_discrete_dimension_gc(dim, &g_c_a);
      }
      /*$ifdef TRACE*/
      ntr_4_sets(tzt, 20L, 1218L, 8L, 108L, *dim, g, a, c[u - MIN_VERTEX], b);
      /*$endif TRACE*/
      dimension_a = mysubi(dim, dimension_a);
      if (!P_setequal(g, b)) {
	P_setdiff(b, g, a);
	g_c_b = return_edges_from_adjacency_matrix(matrix_gc);
	add_edges_from_adjacency_matrix(&matrix_separators, &g_c_b);
	dimension_b = find_discrete_dimension(g_c_b);
	decompose_model_and_insert_node(a, c[u - MIN_VERTEX], g, &g_c_a,
	  &g_c_b, &dimension_a, &dimension_b, &formula_node, &current_model,
	  NULL, false, pure_discrete);
	update_discrete_dimension_set(dim, c[u - MIN_VERTEX], -1L);
      } else {
	dispose_set_list(&g_c_a);
	current_model->dim = dimension_a;
	current_model->formula_node = formula_node;
      }
      P_setdiff(g, g, a);
      P_setdiff(b, g, c[u - MIN_VERTEX]);
      /*$ifdef TRACE*/
      ntr_model_formula(tzt, 20L, 1218L, 8L, 888L, 1L, current_model);
      ntr_model_formula(tzt, 20L, 1218L, 8L, 888L, 2L, *model);
      /*$endif TRACE*/
      /*$ifdef TRACE*/
      /*$endif TRACE*/
      ntr_4_sets(tzt, 20L, 1218L, 8L, 999L, *dim, g, a, empty_set, b);
    } else if (i > dimension) {
      note_error_model(stdout, 1218L, 1L, " DecomposeNoNDec.:  ", *model,
		       false);
      P_setcpy(b, empty_set);
    }
    i++;
  }
  delete_edges_with_vertices(&matrix_separators, g);
  trace_nonempty_adjacency_matrix(&matrix_separators);
}  /* decompose_non_decomposable */


Static Void find_partitioning(g_c_1, g_c_2, adj_list, adj_set, g,
			      check_incomplete, list_of_sets)
t_set_list **g_c_1, **g_c_2;
t_vertex_list **adj_list;
t_vertex_set *adj_set;
long *g;
boolean check_incomplete;
t_set_list **list_of_sets;
{
  boolean ok;
  boolean continue_ = true;
  t_set_list *g_c_a, *g_c_b;
  t_vertex_set a, d, b;
  t_vertex u;
  t_1_max_dimension i = 1;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_lists fill_in_adj_list;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;
  long TEMP;

  if (mixed_data)
    ok = false;
  else {
    maximum_cardinality_search(adj_list, order, invers_order);
    ok = test_for_zero_fill_in(adj_list, order, invers_order);
  }
  if (ok)
    find_c(adj_set, order, invers_order, adj_list, c, complete);
  else {
    for (u = first_vertex; u <= last_vertex; u++)
      fill_in_adj_list[u - MIN_VERTEX] = NULL;
    if (mixed_data)
      marked_lex_m(delta, adj_list, order, invers_order, fill_in_adj_list);
    else
      lex_m(adj_list, order, invers_order, fill_in_adj_list);
    find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
    dispose_adj_list(fill_in_adj_list);
  }
  *list_of_sets = NULL;
  while (continue_ && i <= dimension) {
    while (!((TEMP = invers_order[i-1] - MIN_VERTEX, P_getbits_UB(complete,
		TEMP, 0, 3)) & P_inset(invers_order[i-1], g)) &&
	   i < dimension)
      i++;
    u = invers_order[i-1];
    if (!(P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) & P_inset(u, g))) {
      continue_ = false;
      break;
    }
    find_connected_component(g, c[u - MIN_VERTEX], a, &u, adj_list);
    P_setunion(b, a, c[u - MIN_VERTEX]);
    if (P_setequal(g, b)) {
      continue_ = false;
      break;
    }
    ok = true;
    if (mixed_data) {
      P_setint(d, c[u - MIN_VERTEX], gamma_);
      if (!P_setequal(d, empty_set)) {
	P_setint(d, a, delta);
	if (!P_setequal(d, empty_set)) {
	  P_setdiff(d, g, a);
	  P_setint(d, d, delta);
	  if (!P_setequal(d, empty_set))
	    ok = false;
	}
      }
    }
    if (ok) {
      P_setdiff(d, g, a);
      ok = test_decomposable_hypergraph(g_c_1, b, d, c[u - MIN_VERTEX],
					&g_c_a, &g_c_b);
    }
    if (ok) {
      dispose_set_list(&g_c_a);
      dispose_set_list(&g_c_b);
      ok = test_decomposable_hypergraph(g_c_2, b, d, c[u - MIN_VERTEX],
					&g_c_a, &g_c_b);
    }
    if (ok && incomplete_table && check_incomplete) {
      dispose_set_list(&g_c_a);
      dispose_set_list(&g_c_b);
      ok = test_decomposable_hypergraph(&g_c_q_tables, b, d,
					c[u - MIN_VERTEX], &g_c_a, &g_c_b);
    }
    if (ok) {
      dispose_set_list(&g_c_a);
      dispose_set_list(&g_c_b);
      insert_set_minimal(c[u - MIN_VERTEX], list_of_sets);
    }
    i++;
  }
}  /* find_partitioning */


/*@+"incomp.p"*/


Static Void insert_q_in_discrete_node(a, gc, link_q_tables, dim, formula_node)
long *a;
t_set_list **gc;
t_offset_list **link_q_tables;
t_long_integer *dim;
t_formula_node **formula_node;
{
  t_ips_set_list *ips_set_list;
  t_set_list *list_of_cliques = NULL;
  t_vertex_set vertex_set;

  *formula_node = (t_formula_node *)Malloc(sizeof(t_formula_node));
  if (*formula_node == NULL)
    _OutMem();
  (*formula_node)->tmp_m_ips_leaf = NULL;
  (*formula_node)->node_type = null_node;
  while (*gc != NULL) {
    P_setint(vertex_set, (*gc)->vertex_set, a);
    insert_clique(vertex_set, &list_of_cliques);
    *gc = (*gc)->pointer;
  }
  *dim = 0;
  if (list_of_cliques != NULL) {
    if ((list_of_cliques->pointer == NULL &&
	 P_setequal(list_of_cliques->vertex_set, a)) ||
	P_setequal(list_of_cliques->vertex_set, empty_set)) {
      (*formula_node)->node_type = d_complete_node;
      (*formula_node)->UU.d_complete_leaf = insert_in_complete_discrete_leaf(a);
    } else {
      *dim = find_discrete_dimension(list_of_cliques);
      set_list_to_ips_set_list(list_of_cliques, &ips_set_list);
      (*formula_node)->node_type = r_ips_node;
      if (!ok_to_insert_in_r_ips_leaf(a, &ips_set_list, list_of_cliques,
	    *link_q_tables, &(*formula_node)->UU.r_ips_leaf)) {
	(*formula_node)->node_type = d_ips_node;
	new_d_ips_leaf(&(*formula_node)->UU.d_ips_leaf, &ips_set_list, a,
		       false, MAX_OFFSET, MAX_OFFSET, *link_q_tables);
      }
    }
  }
  dispose_set_list(&list_of_cliques);
}  /* insert_q_in_discrete_node */


Static Void partitioning_incomplete_table(model, current_g_c, g_c_n,
					  model_set, constant, dim)
t_model **model;
t_set_list **current_g_c, **g_c_n;
long *model_set;
t_long_real *constant;
t_long_integer *dim;
{
  t_v_arr_of_v_lists adj_list;
  t_v_arr_of_v_sets adj_set;
  t_vertex_set a, b, d, g, e, f, vertex_set;
  t_set_list *list_of_sets, *g_c_a, *g_c_b, *g_c_a1, *g_c_a2, *g_c_b1,
	     *g_c_b2, *causal_structure;
  boolean ok = false;
  t_offset_list *q;
  t_offset_list *insert_list = NULL;
  t_long_integer dimension_a;
  t_formula_node *formula_node;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1226L, 0L)) {
    write_pch(stdout, " Q-tables: ", 11L);
    print_g_c(*g_c_n, 15L, line_length);
    write_pch(stdout, " GC: ", 5L);
    print_g_c(*current_g_c, 15L, line_length);
  }
  /*$endif TRACE*/
  hypergraph_sets_to_graph_sets(*current_g_c, g, adj_set);
  if (decompose_incomplete) {
    adj_set_to_adj_list(adj_set, adj_list);
    find_partitioning(current_g_c, g_c_n, adj_list, adj_set, g, false,
		      &list_of_sets);
    if (list_of_sets != NULL) {
      pick_partitioning(adj_list, g, list_of_sets, a, d, b);
      dispose_set_list(&list_of_sets);
      P_setunion(e, a, d);
      P_setunion(f, b, d);
      ok = test_decomposable_hypergraph(current_g_c, e, f, d, &g_c_a1, &g_c_b1);
      ok = test_decomposable_hypergraph(g_c_n, e, f, d, &g_c_a2, &g_c_b2);
    }
    dispose_adj_list(adj_list);
  }
  if (ok) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1226L, 0L)) {
      write_pch(stdout, " Decomp   ", 10L);
      write_line(stdout);
      write_space(stdout, 1L);
      write_pch(stdout, "Model ", 6L);
      print_g_c(*current_g_c, 9L, line_length);
      write_space(stdout, 1L);
      write_pch(stdout, "and Q ", 6L);
      print_g_c(*g_c_n, 9L, line_length);
      write_line(stdout);
      write_space(stdout, 1L);
      write_pch(stdout, "Partition of ", 13L);
      print_vertex_set(g);
      write_pch(stdout, " in ", 4L);
      P_setunion(e, a, d);
      print_vertex_set(e);
      write_char(stdout, ',');
      P_setunion(f, b, d);
      print_vertex_set(f);
      write_pch(stdout, " by ", 4L);
      print_vertex_set(d);
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (*dim < _INFINITY)
      *dim += 1 - marginal_dimension(d);
    /* Copy g_c_a1 and g_c_b1 ALL models: !!!! */
    copy_set_list(g_c_a1, &g_c_a);
    copy_set_list(g_c_b1, &g_c_b);
    causal_structure = NULL;   /* homogeneous*/
    decompose_model(e, f, d, &g_c_a, &g_c_b, model, causal_structure, false,
		    pure_discrete);
    partitioning_incomplete_table(
      &(*model)->formula_node->UU.decomposition_node_->left_model, &g_c_a1,
      &g_c_a2, model_set, constant, dim);
    dispose_set_list(&g_c_a1);
    dispose_set_list(&g_c_a2);
    partitioning_incomplete_table(
      &(*model)->formula_node->UU.decomposition_node_->right_model, &g_c_b1,
      &g_c_b2, model_set, constant, dim);
    dispose_set_list(&g_c_b1);
    dispose_set_list(&g_c_b2);
    return;
  }
  if (P_setequal(model_set, empty_set))
    return;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1226L, 0L)) {
    write_pch(stdout, " Insert   ", 10L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  q = q_tables_offsets;
  while (q != NULL) {
    P_setint(vertex_set, q->vertex_set, g);
    if (!P_setequal(vertex_set, empty_set)) {
      if (true)
	insert_offset(q->vertex_set, q->offset, &insert_list);
    }
    q = q->pointer;
  }
  insert_q_in_discrete_node(g, current_g_c, &insert_list, &dimension_a,
			    &formula_node);
  (*model)->formula_node = formula_node;
  *dim = myaddi(dim, &dimension_a);
}  /* partitioning_incomplete_table */


Static Void decompose_incomplete_model(model, h_g_c, model_set, constant, dim)
t_model **model;
t_set_list **h_g_c;
long *model_set;
t_long_real *constant;
t_long_integer *dim;
{
  t_vertex_set vertex_set;

  P_setcpy(model_set, empty_set);
  add_union_of_gc(*h_g_c, model_set);
  *dim = 0;
  P_setdiff(vertex_set, delta, model_set);
  *constant = 1 / marginal_dimension_real(vertex_set);
  partitioning_incomplete_table(model, h_g_c, &g_c_q_tables, model_set,
				constant, dim);
}  /* decompose_incomplete_model */


/*@+"dcontin.p"*/

/*

1230:    +++  ++
1231:    +++  ++
1232:    ---  -- p/dconti.p          7      32     449 p/dconti.p
1233: |    4:    procedure sub_insert_cips_item
1234: |   18:    procedure set_list_to_cips_set_list
1235: |   33:    procedure new_c_ips_leaf
1236: |   42:    procedure insert_in_continuous_node
1237: |   64:    procedure decompose_continuous
1238: |  235:    procedure hypergraph_find_formula
1239: |  335:    procedure decompose_decomposable
1240:    +++  ++
1241:    +++  ++

*/

/* Not used:
procedure sub_insert_cips_item(var cips_list : t_link_list_cips_elements;
                                   cips_set_list : t_link_cips_set_list;
                               var a : t_vertex_set);
var
   q: t_link_list_cips_elements;
begin
   new(q);
   q^.pointer := cips_list;
   new(q^.link_cips_element);
   q^.link_cips_element^.generators := cips_set_list;
   cips_list := q
end; */
/* sub_insert_cips_item */

Static Void set_list_to_cips_set_list(set_list, cips_set_list)
t_set_list *set_list;
t_cips_set_list **cips_set_list;
{
  t_cips_set_list *p;

  *cips_set_list = NULL;
  while (set_list != NULL) {
    p = (t_cips_set_list *)Malloc(sizeof(t_cips_set_list));
    if (p == NULL)
      _OutMem();
    p->pointer = *cips_set_list;
    P_setcpy(p->vertex_set, set_list->vertex_set);
    *cips_set_list = p;
    set_list = set_list->pointer;
  }
}  /* set_list_to_cips_set_list */


Static Void new_c_ips_leaf(c_ips_leaf, cips_set_list, a)
t_cips_element **c_ips_leaf;
t_cips_set_list **cips_set_list;
long *a;
{
  *c_ips_leaf = (t_cips_element *)Malloc(sizeof(t_cips_element));
  if (*c_ips_leaf == NULL)
    _OutMem();

  /* c_ips_leaf^.complete := complete;
     c_ips_leaf^.upper := a; */

  (*c_ips_leaf)->fund_ghk = false;
  (*c_ips_leaf)->log_likelihood = _INVALID_REAL;
  (*c_ips_leaf)->min_l = _INVALID_REAL;
  (*c_ips_leaf)->max_l = _INVALID_REAL;
  (*c_ips_leaf)->convergence = false;
  (*c_ips_leaf)->cycles = -1;
  (*c_ips_leaf)->ifail = 0;
  (*c_ips_leaf)->cips_delta = 0.0;

  (*c_ips_leaf)->r_offset = -1;
  (*c_ips_leaf)->r = NULL;
  (*c_ips_leaf)->ss_offset = -1;
  (*c_ips_leaf)->ss = NULL;

  /* c_ips_leaf^.m_ips_leaf:= nil; */

  (*c_ips_leaf)->generators = *cips_set_list;

}  /* new_c_ips_leaf */


Static Void insert_in_continuous_node(a, generating_class, formula_node)
long *a;
t_set_list **generating_class;
t_formula_node **formula_node;
{
  t_cips_set_list *cips_set_list;

  *formula_node = (t_formula_node *)Malloc(sizeof(t_formula_node));
  if (*formula_node == NULL)
    _OutMem();
  (*formula_node)->tmp_m_ips_leaf = NULL;
  (*formula_node)->node_type = null_node;
  if (*generating_class == NULL)
    return;
  if ((*generating_class)->pointer == NULL &&
      P_setequal((*generating_class)->vertex_set, a)) {
    (*formula_node)->node_type = c_complete_node;
    (*formula_node)->UU.c_complete_leaf = insert_in_complete_continuous_leaf(a);
    return;
  }
  set_list_to_cips_set_list(*generating_class, &cips_set_list);
  (*formula_node)->node_type = c_ips_node;
  new_c_ips_leaf(&(*formula_node)->UU.c_ips_leaf, &cips_set_list, a);
}  /* insert_in_continuous_node */


Static Void decompose_continuous(model, graphical, matrix_gc, model_set,
  adj_list, adj_set, invers_order, c, complete, constant, dim)
t_model **model;
boolean *graphical;
t_adjacency_matrix *matrix_gc;
long *model_set;
t_vertex_list **adj_list;
t_vertex_set *adj_set;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
t_long_real *constant;
t_long_integer *dim;
{
  /**/
  /**/
  t_1_max_dimension i = 1;
  t_1_max_dimension j;
  t_long_integer dimension_a, dimension_b;
  t_vertex u, v;
  t_vertex_set a, b, g;
  t_set_list *g_c_a = NULL, *g_c_b = NULL;
  t_adjacency_matrix matrix_separators;
  t_vertex_list *a_list = NULL;
  boolean ok;
  t_formula_node *formula_node;
  t_model *current_model;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DecomposeContinuou ", sizeof(pch20));
  if (trace_flag_set(20L, 1237L, 1L))
    sub_print_invers_order(invers_order, c, complete);
  /*$endif TRACE*/
  current_model = *model;
  new_adjacency_matrix(&matrix_separators);
  *dim = 0;
  /**/
  P_setdiff(b, delta, model_set);
  *constant = 1 / marginal_dimension_real(b);   /**/
  P_setcpy(g, model_set);
  P_setcpy(b, g);
  while (!P_setequal(b, empty_set)) {
    u = invers_order[i-1];
    /*$ifdef TRACE*/
    ntr_vertex_and_set(tzt, 20L, 1237L, 1L, 103L, (long)i, &u, b);
    /*$endif TRACE*/
    while (!(P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) & P_inset(u, g))) {
      i++;
      u = invers_order[i-1];
      /*$ifdef TRACE*/
      ntr_vertex_and_set(tzt, 20L, 1237L, 1L, 103L, (long)i, &u, empty_set);
      /*$endif TRACE*/
    }
    /*$ifdef TRACE*/
    ntr_vertex_and_set(tzt, 20L, 1237L, 1L, 104L, (long)i, &u,
		       c[u - MIN_VERTEX]);
    /*$endif TRACE*/
    if (*graphical)
      ok = true;
    else
      ok = subset_of_an_edge_in_matrix(i, c[u - MIN_VERTEX], invers_order,
				       matrix_gc);
    if (ok || i == dimension) {
      if (*graphical)
	ok = P_subset(c[u - MIN_VERTEX], adj_set[u - MIN_VERTEX]);
      else if (ok) {
	P_setcpy(b, c[u - MIN_VERTEX]);
	P_addset(b, invers_order[i-1]);
	ok = subset_of_an_edge_in_matrix(i, b, invers_order, matrix_gc);
      }
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1237L, 1L, 104L, 0L, ok);
      /*$endif TRACE*/
      if (ok || boolean_option[123]) {
	if (ok) {
	  delete_edges_with_vertex(matrix_gc, &u);
	  delete_edges_with_vertex(&matrix_separators, &u);
	}
	j = i + 1;
	if (j < dimension) {
	  v = invers_order[j-1];
	  P_setcpy(b, c[v - MIN_VERTEX]);
	  P_addset(b, v);
	  while ((P_subset(b, c[u - MIN_VERTEX]) && j < dimension) &
		 P_inset(v, g)) {
	    if (ok) {
	      delete_edges_with_vertex(matrix_gc, &v);
	      delete_edges_with_vertex(&matrix_separators, &v);
	    }
	    j++;
	    v = invers_order[j-1];
	    P_setcpy(b, c[v - MIN_VERTEX]);
	    P_addset(b, v);
	    /*$ifdef TRACE*/
	    /*$endif TRACE*/
	    ntr_vertex_and_set(tzt, 20L, 1237L, 1L, 105L, (long)j, &v, b);
	  }
	}
	P_setcpy(b, c[u - MIN_VERTEX]);
	P_addset(b, u);
	i = j - 1;
	u = invers_order[i-1];
      }
      dimension_a = *dim;
      /*$ifdef TRACE*/
      ntr_vertex_and_set(tzt, 20L, 1237L, 1L, 106L, (long)i, &u, b);
      ntr_boolean(tzt, 20L, 1237L, 1L, 107L, *dim, ok);
      /*$endif TRACE*/
      if (ok) {
	/* Eliminating complete subgraph */
	P_setdiff(a, b, c[u - MIN_VERTEX]);
	g_c_a = NULL;
	insert_clique(b, &g_c_a);
	insert_in_complete_node(b, &formula_node, pure_continuous);
	insert_edge_in_adjacency_matrix(&matrix_separators, c[u - MIN_VERTEX]);
	update_continuous_dimension_set(dim, b, 1L);
      } else {
	find_connected_component_list(g, c[u - MIN_VERTEX], a, &a_list, &u,
				      adj_list);
	return_and_delete_edges_with_vertices_list(matrix_gc, a_list, &g_c_a);
	return_and_delete_edges_with_vertices_list(&matrix_separators, a_list,
						   &g_c_b);
	dispose_vertex_list(&a_list);
	insert_clique(c[u - MIN_VERTEX], &g_c_a);
	add_cliques(g_c_b, &g_c_a);
	dispose_set_list(&g_c_b);
	P_setunion(b, a, c[u - MIN_VERTEX]);
	insert_in_continuous_node(b, &g_c_a, &formula_node);
	insert_edge_in_adjacency_matrix(&matrix_separators, c[u - MIN_VERTEX]);
	update_continuous_dimension_gc(dim, &g_c_a);
	/* dispose_set_list(g_c_a) */
      }
      /*$ifdef TRACE*/
      ntr_4_sets(tzt, 20L, 1237L, 1L, 108L, *dim, g, a, c[u - MIN_VERTEX], b);
      /*$endif TRACE*/
      dimension_a = *dim - dimension_a;
      if (!P_setequal(g, b)) {
	P_setdiff(b, g, a);
	g_c_b = return_edges_from_adjacency_matrix(matrix_gc);
	add_edges_from_adjacency_matrix(&matrix_separators, &g_c_b);
	dimension_b = find_continuous_dimension(g_c_b);
	decompose_model_and_insert_node(a, c[u - MIN_VERTEX], g, &g_c_a,
	  &g_c_b, &dimension_a, &dimension_b, &formula_node, &current_model,
	  NULL, false, pure_continuous);
	update_continuous_dimension_set(dim, c[u - MIN_VERTEX], -1L);
      } else {
	dispose_set_list(&g_c_a);
	current_model->dim = dimension_a;
	current_model->formula_node = formula_node;
      }
      P_setdiff(g, g, a);
      P_setdiff(b, g, c[u - MIN_VERTEX]);
      /*$ifdef TRACE*/
      /*$endif TRACE*/
      ntr_4_sets(tzt, 20L, 1237L, 1L, 999L, *dim, g, a, empty_set, b);
    } else if (i > dimension) {
      note_error_model(stdout, 1237L, 1L, " DecomposeContin.:  ", *model,
		       false);
      P_setcpy(b, empty_set);
    }
    i++;
  }
  delete_edges_with_vertices(&matrix_separators, g);
  trace_nonempty_adjacency_matrix(&matrix_separators);
}  /* decompose_continuous */


Static Void hypergraph_find_formula(model, g_c, model_set, r, constant, dim,
				    model_type)
t_model *model;
t_set_list **g_c;
long *model_set;
t_offset_list **r;
t_long_real *constant;
t_long_integer *dim;
t_model_type model_type;
{
  t_vertex_set a, b, c, d;
  t_offset_list *q;
  t_set_list *p, *g_c_b;
  t_set_list *cliques = NULL, *separators = NULL;
  t_long_integer dimension_a, dimension_b;
  t_formula_node *formula_node;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " HypergraphFindForml", sizeof(pch20));
  ntr(tzt, 20L, 1238L, 1L, 0L, 0L);
  /*$endif TRACE*/
  *dim = 0;
  P_setdiff(b, delta, model_set);
  *constant = 1 / marginal_dimension_real(b);
  q = *r;
  P_setcpy(d, empty_set);
  while (q != NULL) {
    P_setcpy(a, q->vertex_set);
    P_setint(c, d, a);
    P_setunion(d, d, a);
    insert_set_in_set_list(a, &cliques);
    insert_set_in_set_list(c, &separators);
    if (model_type == pure_discrete) {
      update_discrete_dimension_set(dim, a, 1L);
      if (q != *r) {
	/* else update with zero (1 - DISCRETE_DIMENSION_SHIFT) !!! */
	update_discrete_dimension_set(dim, c, -1L);
      }
    } else if (model_type == pure_continuous) {
      update_continuous_dimension_set(dim, a, 1L);
      if (q != *r)
	update_continuous_dimension_set(dim, c, -1L);
    } else
      *dim = _INVALID;
    /* should not be here !!! */
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1238L, 1L, 0L, *dim);
    /*$endif TRACE*/
    q = q->pointer;
  }
  P_setcpy(d, model_set);
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 1238L, 1L, 0L, 21L, &cliques);
  ntr_g_c(tzt, 20L, 1238L, 1L, 0L, 31L, &separators);
  /*$endif TRACE*/
  while (cliques != NULL) {
    P_setcpy(b, cliques->vertex_set);
    insert_in_complete_node(b, &formula_node, model_type);
    P_setcpy(c, separators->vertex_set);
    P_setdiff(a, b, c);
    P_setdiff(d, d, a);
    p = cliques;
    cliques = cliques->pointer;
    p->pointer = NULL;
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 1238L, 1L, 0L, 22L, &cliques);
    ntr_g_c(tzt, 20L, 1238L, 1L, 0L, 32L, &separators);
    /*$endif TRACE*/
    if (model_type == pure_discrete)
      dimension_a = find_discrete_dimension(p);
    else if (model_type == pure_continuous)
      dimension_a = find_continuous_dimension(p);
    else
      dimension_a = _INVALID;
    if (cliques != NULL) {
      copy_set_list(cliques, &g_c_b);
      if (model_type == pure_discrete)
	dimension_b = find_discrete_dimension(g_c_b);
      else if (model_type == pure_continuous)
	dimension_b = find_continuous_dimension(g_c_b);
      else
	dimension_b = _INVALID;
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1238L, 1L, dimension_a, dimension_b);
      ntr_3_sets(tzt, 20L, 1182L, 1L, 1L, 1L, a, c, d);
      ntr_g_c(tzt, 20L, 1238L, 1L, 0L, 13L, &p);
      ntr_g_c(tzt, 20L, 1238L, 1L, 0L, 23L, &g_c_b);
      /*$endif TRACE*/
      decompose_model_and_insert_node(a, c, d, &p, &g_c_b, &dimension_a,
				      &dimension_b, &formula_node, &model,
				      NULL, false, model_type);
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1238L, 1L, dimension_a, -model->dim);
      /*$endif TRACE*/
      model->dim = dimension_a;
      dispose_set_list(&p);
      model->formula_node = formula_node;
    }
    p = separators;
    separators = separators->pointer;
    _Free(p);
  }
}  /* hypergraph_find_formula */


Static Void decompose_decomposable(model, g_c, model_set, adj_list,
  order_found, order, invers_order, constant, dim)
t_model **model;
t_set_list **g_c;
long *model_set;
t_vertex_list **adj_list;
boolean order_found;
short *order;
t_vertex *invers_order;
t_long_real *constant;
t_long_integer *dim;
{
  /* var expression  : t_link_expression; */
  t_adjacency_matrix gc_adjacency_matrix;
  t_offset_list *r;
  t_v_arr_of_order beta;
  boolean decomposable;

  /* expression       : t_link_expression; */
  /*
  if not order_found then
     maximum_cardinality_search(adj_list, order, invers_order);
  expression := nil;
  find_perfect_scheme_expression(model_set, adj_list, order,
                                 invers_order, constant,
                                 expression, dim);
  */
  create_adjacency_matrix(&gc_adjacency_matrix, *g_c);
  restricted_maximim_cardinality_search_on_hypergraph(&gc_adjacency_matrix,
    empty_set, &decomposable, order, beta, invers_order, &r);
  revers_offset_list(&r);
  add_union_of_gc(*g_c, model_set);
  hypergraph_find_formula(*model, g_c, model_set, &r, constant, dim,
			  pure_discrete);
  dispose_offset_list(&r);
  delete_edges_with_vertices(&gc_adjacency_matrix, model_set);
}  /* decompose_decomposable */


/*@+"dmixed.p"*/

/*

1242:    +++  ++
1243:    ---  -- p/dmixed.p         16      61     818 p/dmixed.p
1244:            procedure ntr_decompose_mixed
1245: |    4:    function is_complete_in_mixed
1246: |  120:    function ok_to_decompose_mixed
1247: |  207:    procedure insert_clique_1
1248: |  236:    procedure insert_clique_2
1249: |  265:    procedure insert_clique_3
1250: |  294:    procedure insert_clique_4
1251: |  323:    procedure add_separator
1252: |  391:    function mim_quadratic_g_c
1253: |  418:    function sub_mixed_collapsible
1254: |  458:    function d_collapsible
1255: |  533:    function q_equivalent
1256: |  588:    function sub_return_mixed_characteristics
1257: |  642:    function return_mixed_characteristics
1258: |  651:    procedure new_m_ips_leaf
1259: |  714:    procedure insert_in_mixed_node
1260:            procedure advance_for_eliminate_complete_sg
1261:            procedure eliminate_complete_sg
1262:            procedure eliminate_nondecomposable_sg
1263:            procedure insert_separator
1264: |  732:    procedure decompose_mixed

*/

Static Void ntr_decompose_mixed(t_, w, o, p, n, m, dim, i, u, a, b, c_u, g,
				g_c_d, g_c_l, g_c_q, d_matrix, l_matrix,
				q_matrix, s_matrix)
Char *t_;
t_long_integer w, o, p, n, m, dim;
t_1_max_dimension *i;
t_vertex *u;
long *a, *b, *c_u, *g;
t_set_list **g_c_d, **g_c_l, **g_c_q;
t_adjacency_matrix *d_matrix, *l_matrix, *q_matrix, *s_matrix;
{
  pch20 t;

  memcpy(t, t_, sizeof(pch20));
  if (trace_flag_set(20L, 1244L, 1L))
    ntr_vertex(t, w, o, p, dim, (long)(*i), u);
  if (trace_flag_set(20L, 1244L, 2L))
    ntr_4_sets(t, w, o, p, n, m, g, a, c_u, b);
  if (trace_flag_set(20L, 1244L, 3L))
    ntr_adjacency_matrixs_and_separators(t, w, o, p, n, m, d_matrix, l_matrix,
					 q_matrix, s_matrix);
  if (trace_flag_set(20L, 1244L, 4L))
    ntr_triple_g_c(t, w, o, p, n, m, g_c_d, g_c_l, g_c_q);
}  /* ntr_decompose_mixed */


Static boolean is_complete_in_mixed(a, full_specified, homogeneous, d_matrix,
  l_matrix, q_matrix, s_matrix, invers_order, i)
long *a;
boolean *full_specified, *homogeneous;
t_adjacency_matrix *d_matrix, *l_matrix, *q_matrix, *s_matrix;
t_vertex *invers_order;
t_1_max_dimension *i;
{
  t_vertex v, w;
  boolean ok;
  t_vertex_set b, c, d;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IsCompleteInMixed  ", sizeof(pch20));
  /*$endif TRACE*/
  P_setint(d, a, delta);
  if (P_setequal(d, empty_set))
    ok = true;
  else
    ok = subset_of_an_edge_in_matrix(*i, d, invers_order, d_matrix);
  /*$ifdef TRACE*/
  ntr_2_sets(tzt, 20L, 1245L, 1L, 1L, -1L, a, d);
  ntr_3_booleans(tzt, 20L, 1245L, 1L, 2L, -1L, ok, *full_specified,
		 *homogeneous);
  ntr_adjacency_matrixs(tzt, 20L, 1245L, 1L, 2L, -1L, d_matrix, l_matrix,
			q_matrix);
  /*$endif TRACE*/
  P_setcpy(b, empty_set);
  if (ok) {
    P_setint(b, a, gamma_);
    v = first_vertex;
    while (v <= last_vertex && ok) {
      if (P_inset(v, b)) {
	P_setcpy(c, d);
	P_addset(c, v);
	ok = subset_of_an_edge_in_matrix(*i, c, invers_order, l_matrix);
	/*$ifdef TRACE*/
	ntr_set_and_boolean(tzt, 20L, 1245L, 2L, -1L, -1L, c, ok);
	/*$endif TRACE*/
      }
      v++;
    }
  }
  /*$ifdef TRACE*/
  ntr_set_and_boolean(tzt, 20L, 1245L, 3L, -1L, -1L, b, ok);
  /*$endif TRACE*/
  if (ok) {
    if (*full_specified) {
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1245L, 4L, -1L, -1L, true);
      /*$endif TRACE*/
      v = first_vertex;
      while (v <= last_vertex && ok) {
	if (P_inset(v, b)) {
	  if (*homogeneous)
	    P_setcpy(c, empty_set);
	  else
	    P_setcpy(c, d);
	  P_addset(c, v);
	  P_setunion(c, c, double_vertex_set);
	  ok = subset_of_an_edge_in_matrix(*i, c, invers_order, q_matrix);
	  /*$ifdef TRACE*/
	  ntr_set_and_boolean(tzt, 20L, 1245L, 5L, 1L, -1L, c, ok);
	  /*$endif TRACE*/
	  if (!ok)
	    ok = subset_of_an_edge_in_matrix(*i, c, invers_order, s_matrix);
	  /*$ifdef TRACE*/
	  ntr_set_and_boolean(tzt, 20L, 1245L, 5L, 2L, -1L, c, ok);
	  /*$endif TRACE*/
	  w = v + 1;
	  while (w <= last_vertex && ok) {
	    if (P_inset(w, b)) {
	      if (*homogeneous)
		P_setcpy(c, empty_set);
	      else
		P_setcpy(c, d);
	      P_addset(c, v);
	      P_addset(c, w);
	      ok = subset_of_an_edge_in_matrix(*i, c, invers_order, q_matrix);
	      /*$ifdef TRACE*/
	      ntr_set_and_boolean(tzt, 20L, 1245L, 6L, 1L, -1L, c, ok);
	      /*$endif TRACE*/
	      if (!ok) {
		ok = subset_of_an_edge_in_matrix(*i, c, invers_order, s_matrix);
		/*$ifdef TRACE*/
	      }
	      ntr_set_and_boolean(tzt, 20L, 1245L, 6L, 2L, -1L, c, ok);
	      /*$endif TRACE*/
	    }
	    w++;
	  }
	}
	v++;
      }
    } else {   /* Do this better ? */
      /*$ifdef TRACE*/
      ntr_set_and_boolean(tzt, 20L, 1245L, 7L, -1L, -1L, b, *homogeneous);
      /*$endif TRACE*/
      if (!P_setequal(b, empty_set)) {
	for (v = first_vertex; v <= last_vertex; v++) {
	  if (ok & P_inset(v, b)) {
	    if (*homogeneous)
	      P_setcpy(c, empty_set);
	    else
	      P_setcpy(c, d);
	    P_addset(c, v);
	    ok = subset_of_an_edge_in_matrix(*i, c, invers_order, q_matrix);
	    /*$ifdef TRACE*/
	    ntr_set_and_boolean(tzt, 20L, 1245L, 6L, 1L, -1L, d, ok);
	    /*$endif TRACE*/
	    if (!ok) {
	      ok = subset_of_an_edge_in_matrix(*i, c, invers_order, s_matrix);
	      /*$ifdef TRACE*/
	    }
	    ntr_set_and_boolean(tzt, 20L, 1245L, 6L, 2L, -1L, d, ok);
	    /*$endif TRACE*/
	    for (w = v + 1; w <= last_vertex; w++) {
	      if (ok & P_inset(w, b)) {
		if (*homogeneous)
		  P_setcpy(c, empty_set);
		else
		  P_setcpy(c, d);
		P_addset(c, v);
		P_addset(c, w);
		ok = subset_of_an_edge_in_matrix(*i, c, invers_order, q_matrix);
		/*$ifdef TRACE*/
		ntr_set_and_boolean(tzt, 20L, 1245L, 6L, 1L, -1L, d, ok);
		/*$endif TRACE*/
		if (!ok) {
		  ok = subset_of_an_edge_in_matrix(*i, c, invers_order,
						   s_matrix);
		  /*$ifdef TRACE*/
		}
		ntr_set_and_boolean(tzt, 20L, 1245L, 6L, 2L, -1L, d, ok);
		/*$endif TRACE*/
	      }
	    }
	  }
	}
      }
    }
  }
  /* same as above!!! */
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1245L, 8L, -1L, -1L, ok);
  /*$endif TRACE*/
  return ok;
}  /* is_complete_in_mixed */



Static boolean ok_to_decompose_mixed(graphical, full_specified, homogeneous,
  d_matrix, l_matrix, q_matrix, s_matrix, adj_list, invers_order, g, c_u, u,
  i)
boolean *graphical, *full_specified, *homogeneous;
t_adjacency_matrix *d_matrix, *l_matrix, *q_matrix, *s_matrix;
t_vertex_list **adj_list;
t_vertex *invers_order;
long *g, *c_u;
t_vertex *u;
t_1_max_dimension *i;
{
  /* v: t_vertex; */
  /* , b, d */
  t_vertex_set a;
  t_vertex_list *a_list;
  boolean ok = false;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " OkToDecomposeMixed ", sizeof(pch20));
  ntr_set(tzt, 20L, 1246L, 1L, -1L, -1L, c_u);
  ntr_3_booleans(tzt, 20L, 1246L, 1L, 2L, -1L, *graphical, *full_specified,
		 *homogeneous);
  ntr_adjacency_matrixs(tzt, 20L, 1246L, 1L, 2L, -1L, d_matrix, l_matrix,
			q_matrix);
  /*$endif TRACE*/
  if (P_subset(c_u, delta)) {
    if (*graphical || P_setequal(c_u, empty_set))
      ok = true;
    else
      ok = subset_of_an_edge_in_matrix(*i, c_u, invers_order, d_matrix);
  } else {
    a_list = NULL;
    find_connected_component_list(g, c_u, a, &a_list, u, adj_list);
    dispose_vertex_list(&a_list);
    /*$ifdef TRACE*/
    ntr_set_and_boolean(tzt, 20L, 1246L, 2L, -1L, -1L, a, false);
    /*$endif TRACE*/
    if (P_subset(a, gamma_)) {
      ok = true;
      /*
      else if not boolean_option[122] then
      ok := subset_of_an_edge_in_matrix(i, c_u, invers_order, q_matrix)
      else begin
      a := c_u * delta;
      ok := subset_of_an_edge_in_matrix(i, a, invers_order, d_matrix);
      if ok then begin
         b := c_u * gamma_;
         ok := subset_of_an_edge_in_matrix(i, b, invers_order, q_matrix);
         if ok then begin
            v := first_vertex;
            while (v <= last_vertex) and ok do
               if v in b then begin
                  d := a;
                  d := d + [v];
                  ok := subset_of_an_edge_in_matrix(i, d, invers_order,
                                                    l_matrix);
                  v := succ(v)
               end
         end
      end
      end
       */
    }
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1246L, 7L, -1L, -1L, ok);
  /*$endif TRACE*/
  if (ok)
    ok = is_complete_in_mixed(c_u, full_specified, homogeneous, d_matrix,
			      l_matrix, q_matrix, s_matrix, invers_order, i);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1246L, 8L, -1L, -1L, ok);
  /*$endif TRACE*/
  return ok;
}  /* ok_to_decompose_mixed */



Static Void insert_clique_1(a, list_of_sets)
long *a;
t_set_list **list_of_sets;
{
  t_set_list *p, *q;
  boolean b = true;

  p = *list_of_sets;
  while (p != NULL && b) {
    if (P_subset(a, p->vertex_set))
      b = false;
    else
      p = p->pointer;
  }
  if (!b)
    return;
  p = *list_of_sets;
  insert_set_in_set_list(a, list_of_sets);
  q = *list_of_sets;
  while (p != NULL) {
    if (P_subset(p->vertex_set, a)) {
      q->pointer = p->pointer;
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* insert_clique */


Static Void insert_clique_2(a, list_of_sets)
long *a;
t_set_list **list_of_sets;
{
  t_set_list *p, *q;
  boolean b = true;

  p = *list_of_sets;
  while (p != NULL && b) {
    if (P_subset(a, p->vertex_set))
      b = false;
    else
      p = p->pointer;
  }
  if (!b)
    return;
  p = *list_of_sets;
  insert_set_in_set_list(a, list_of_sets);
  q = *list_of_sets;
  while (p != NULL) {
    if (P_subset(p->vertex_set, a)) {
      q->pointer = p->pointer;
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* insert_clique_2 */


Static Void insert_clique_3(a, list_of_sets)
long *a;
t_set_list **list_of_sets;
{
  t_set_list *p, *q;
  boolean b = true;

  p = *list_of_sets;
  while (p != NULL && b) {
    if (P_subset(a, p->vertex_set))
      b = false;
    else
      p = p->pointer;
  }
  if (!b)
    return;
  p = *list_of_sets;
  insert_set_in_set_list(a, list_of_sets);
  q = *list_of_sets;
  while (p != NULL) {
    if (P_subset(p->vertex_set, a)) {
      q->pointer = p->pointer;
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* insert_clique_3 */


Static Void insert_clique_4(a, list_of_sets)
long *a;
t_set_list **list_of_sets;
{
  t_set_list *p, *q;
  boolean b = true;

  p = *list_of_sets;
  while (p != NULL && b) {
    if (P_subset(a, p->vertex_set))
      b = false;
    else
      p = p->pointer;
  }
  if (!b)
    return;
  p = *list_of_sets;
  insert_set_in_set_list(a, list_of_sets);
  q = *list_of_sets;
  while (p != NULL) {
    if (P_subset(p->vertex_set, a)) {
      q->pointer = p->pointer;
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* insert_clique_4 */


Static Void add_separator(full_specified, homogeneous, separator, g_c_d,
			  g_c_l, g_c_q, i, invers_order, q_matrix)
boolean *full_specified, *homogeneous;
long *separator;
t_set_list **g_c_d, **g_c_l, **g_c_q;
t_1_max_dimension i;
t_vertex *invers_order;
t_adjacency_matrix *q_matrix;
{
  t_vertex_set a, b, c;
  t_vertex u, v;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;
  FILE *TEMP;

  /*$endif TRACE*/
  P_setint(a, delta, separator);
  /*$ifdef TRACE*/
  memcpy(tzt, " AddSeparator       ", sizeof(pch20));
  ntr_2_sets(tzt, 20L, 1251L, 1L, -1L, -1L, separator, a);
  if (trace_flag_set(20L, 1251L, 1L)) {
    write_pch(stdout, " q: ", 4L);
    ntr_adjacency_matrix(q_matrix);
    TEMP = stdout;
    flush_file(&TEMP);
  }
  ntr_triple_g_c(tzt, 20L, 1251L, 1L, -1L, -1L, g_c_d, g_c_l, g_c_q);
  /*$endif TRACE*/
  if (!P_setequal(a, empty_set))
    insert_clique(a, g_c_d);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, gamma_)) {
      if (P_inset(v, separator)) {
	P_setcpy(b, a);
	P_addset(b, v);
	insert_clique_1(b, g_c_l);
	/*$ifdef TRACE*/
	ntr_set_and_boolean(tzt, 20L, 1251L, 2L, -1L, -1L, b, *homogeneous);
	/*$endif TRACE*/
	if (*homogeneous)
	  P_addset(P_expset(b, 0L), v);   /* empty_set + */
	if (true) {   /* not homogeneous */
	  if (*full_specified)
	    P_setunion(b, b, double_vertex_set);
	  /*$ifdef TRACE*/
	  ok = subset_of_an_edge_in_matrix(i, b, invers_order, q_matrix);
	  ntr_set_and_boolean(tzt, 20L, 1251L, 2L, -2L, -1L, b, ok);
	  /*$endif TRACE*/
	  /* Put in comments 2. september 2003 to handle models like
	     [[ab]] / [[aby][ax]] / [[aby][ax][xy]]
	     [[ab]] / [[by][ay][ax]] / [[by][axy]]
	     [[ab]] / [[abx][by]] / [[abx][by][xy]]
	     [[ab]] / [[bx][ax][by]] / [[bxy][ax]]
	    */
	  /* if not subset_of_an_edge_in_matrix(i, b, invers_order,
	                                     q_matrix) then */
	  insert_clique_2(b, g_c_q);
	  P_setint(b, b, delta_gamma);
	  for (u = v + 1; u <= last_vertex; u++) {
	    if (P_inset(u, gamma_)) {
	      if (P_inset(u, separator)) {
		P_setcpy(c, b);
		P_addset(c, u);
		/*$ifdef TRACE*/
		ok = subset_of_an_edge_in_matrix(i, c, invers_order, q_matrix);
		ntr_set_and_boolean(tzt, 20L, 1251L, 3L, -1L, -1L, c, ok);
		/*$endif TRACE*/
		/* if not subset_of_an_edge_in_matrix(i, c, invers_order,
		                                     q_matrix) then */
		insert_clique_3(c, g_c_q);
	      }
	    }
	  }
	}
      }
    }
  }
  P_setint(b, gamma_, separator);
  /*$ifdef TRACE*/
  ntr_triple_g_c(tzt, 20L, 1251L, 8L, -1L, -1L, g_c_d, g_c_l, g_c_q);
  ntr_set(tzt, 20L, 1251L, 8L, -1L, -1L, b);
  /*$endif TRACE*/
  if (!P_setequal(b, empty_set))
    insert_clique_4(b, g_c_q);
}  /* add_separator */



Static boolean mim_quadratic_g_c(g_c)
t_set_list *g_c;
{
  boolean ok = true;
  t_vertex v;
  t_vertex_set a, b, c, d;
  t_set_list *p = g_c;

  while (ok && p != NULL) {
    P_setcpy(a, p->vertex_set);
    P_setint(c, a, gamma_);
    P_setint(d, a, delta);
    P_setunion(d, d, double_vertex_set);
    if (count_continuous(c) > 1) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (ok & P_inset(v, c)) {
	  P_setcpy(b, d);
	  P_addset(b, v);
	  /* b :=  [ v ] + [ double_vertex ] + a * delta */
	  ok = subset_of_an_edge(b, &g_c);
	}
      }
    }
    p = p->pointer;
  }
  return ok;
}  /* mim_quadratic_g_c */


Static boolean sub_mixed_collapsible(d, g_c_d, g_c_l, g_c_q)
long *d;
t_set_list **g_c_d, **g_c_l, **g_c_q;
{
  t_vertex u;
  t_vertex_set a, b, bd, g, rest, comp;
  boolean ok;
  t_set_list *p, *components, *g_c;
  t_v_arr_of_v_lists adj_list;
  t_v_arr_of_v_sets adj_set;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubMixedCollapsibl ", sizeof(pch20));
  ntr_set(tzt, 20L, 1253L, 1L, -1L, -1L, d);
  ntr_triple_g_c(tzt, 20L, 1253L, 1L, -1L, -1L, g_c_d, g_c_l, g_c_q);
  /*$endif TRACE*/
  ok = subset_of_an_edge(d, g_c_d);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1253L, 1L, -1L, -2L, ok);
  /*$endif TRACE*/
  if (!ok) {
    g_c = NULL;
    add_cliques(*g_c_d, &g_c);
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 1253L, 1L, -2L, -1L, &g_c);
    /*$endif TRACE*/
    add_cliques(*g_c_l, &g_c);
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 1253L, 1L, -2L, -2L, &g_c);
    /*$endif TRACE*/
    add_cliques(*g_c_q, &g_c);
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 1253L, 1L, -2L, -3L, &g_c);
    /*$endif TRACE*/
    hypergraph_sets_to_graph_sets(g_c, g, adj_set);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1253L, 1L, -2L, -3L, g);
    /*$endif TRACE*/
    adj_set_to_adj_list(adj_set, adj_list);
    P_setcpy(rest, d);
    P_setdiff(comp, delta_gamma, d);
    /*$ifdef TRACE*/
    ntr_3_sets(tzt, 20L, 1253L, 1L, -2L, -1L, d, rest, comp);
    /*$endif TRACE*/
    u = first_vertex;
    ok = true;
    while (ok && u <= last_vertex) {
      if (P_inset(u, rest)) {
	find_connected_components(g, d, &components, &u, adj_list);
	p = components;
	while (ok && p != NULL) {
	  P_setcpy(a, p->vertex_set);
	  /*$ifdef TRACE*/
	  ntr_vertex_and_set(tzt, 20L, 1253L, 1L, -2L, -2L, &u, a);
	  /*$endif TRACE*/
	  P_setint(a, a, comp);
	  if (!P_setequal(a, empty_set)) {
	    return_boundary(a, bd, &g_c);
	    P_addset(P_expset(b, 0L), u);
	    P_setint(bd, d, bd);
	    P_setunion(bd, bd, b);
	    P_setdiff(rest, rest, bd);
	    if (!P_subset(a, gamma_)) {
	      if (!P_subset(bd, delta))
		ok = false;
	    }
	    if (ok)
	      ok = subset_of_an_edge(bd, &g_c);
	  } else
	    P_setcpy(bd, empty_set);
	  /*$ifdef TRACE*/
	  ntr_3_sets(tzt, 20L, 1253L, 1L, -2L, -3L, a, bd, rest);
	  /*$endif TRACE*/
	  p = p->pointer;
	}
	dispose_set_list(&components);
      }
      u++;
    }
    dispose_adj_list(adj_list);
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 1253L, 1L, -1L, -3L, ok);
    ntr_g_c(tzt, 20L, 1253L, 1L, -1L, -4L, &g_c);
    ntr_g_c(tzt, 20L, 1253L, 1L, -1L, -6L, g_c_d);
    /*$endif TRACE*/
    dispose_set_list(&g_c);
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1253L, 1L, -9L, -9L, ok);
  /*$endif TRACE*/
  return ok;
}  /* sub_mixed_collapsible */


Static boolean d_collapsible(unfolded, graphical, upper, complete,
			     full_specified, homogeneous, g_c_d, g_c_l, g_c_q)
boolean *unfolded, *graphical;
long *upper;
boolean *complete, *full_specified, *homogeneous;
t_set_list **g_c_d, **g_c_l, **g_c_q;
{
  boolean Result, ok;
  t_vertex_set a, r;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " D-collapsible      ", sizeof(pch20));
  if (trace_flag_set(20L, 1254L, 0L)) {
    ntr_set(tzt, 20L, 1254L, 1L, -1L, -1L, upper);
    ntr_3_booleans(tzt, 20L, 1254L, 1L, -1L, -1L, *complete, *full_specified,
		   *homogeneous);
	/*ntr*/
    ntr_triple_g_c(tzt, 20L, 1254L, 1L, -1L, -1L, g_c_d, g_c_l, g_c_q);
  }
  /*$endif TRACE*/
  P_setint(a, delta, upper);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  if (*complete)
    ok = true;
  else if (P_setequal(a, upper))
    ok = true;
  else {
    ok = sub_mixed_collapsible(a, g_c_d, g_c_l, g_c_q);
    /* ? */
    /* ? */
    /* ? */
  }
  /* ? */
  /* ? */
  return_collaps_set_mixed(a, upper, unfolded, graphical, full_specified,
			   homogeneous, g_c_d, g_c_l, g_c_q, r);
  if (ok != P_setequal(a, r))
    note_error_triple_g_c(stdout, 1254L, 1L, " D-Collapsible:     ", *g_c_d,
			  *g_c_l, *g_c_q, a, r, false);
  Result = ok;
  /*$ifdef TRACE*/
  if (!((ok != P_setequal(a, r)) | trace_flag_set(20L, 1254L, 0L)))
    return Result;
  /*$endif TRACE*/
  ntr_3_sets(tzt, 20L, 1254L, 8L, 100L, -1L, upper, a, r);
  ntr_3_booleans(tzt, 20L, 1254L, 8L, 101L, -1L, *complete, *full_specified,
		 *homogeneous);
      /*ntr*/
  ntr_triple_g_c(tzt, 20L, 1254L, 1L, 102L, -1L, g_c_d, g_c_l, g_c_q);
  ntr_boolean(tzt, 20L, 1254L, 8L, 103L, -1L, *graphical);
  ntr_boolean(tzt, 20L, 1254L, 8L, 103L, -1L, ok);
  return Result;
}  /* d_collapsible */



Static boolean q_equivalent(graphical, upper, full_specified, homogeneous,
			    g_c_d, g_c_l, g_c_q)
boolean *graphical;
long *upper;
boolean *full_specified, *homogeneous;
t_set_list **g_c_d, **g_c_l, **g_c_q;
{
  boolean Result;
  boolean ok = true;
  t_vertex_set a;
  t_set_list *p, *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " Q-equivalent       ", sizeof(pch20));
  if (trace_flag_set(20L, 1255L, 0L)) {
    ntr_set(tzt, 20L, 1255L, 1L, -1L, -1L, upper);
    ntr_3_booleans(tzt, 20L, 1255L, 1L, -1L, -1L, *graphical, *full_specified,
		   *homogeneous);
	/*ntr*/
    ntr_triple_g_c(tzt, 20L, 1255L, 1L, -1L, -1L, g_c_d, g_c_l, g_c_q);
  }
  /*$endif TRACE*/
  q = *g_c_q;
  while (q != NULL && ok) {
    p = q->pointer;
    while (p != NULL && ok) {
      P_setcpy(a, q->vertex_set);
      P_setint(a, a, p->vertex_set);
      P_setint(a, a, gamma_);
      if (!P_setequal(a, empty_set))
	ok = false;
      else
	p = p->pointer;
    }
    q = q->pointer;
  }
  Result = ok;
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1255L, 0L))
    return Result;
  /*$endif TRACE*/
  ntr_set_and_boolean(tzt, 20L, 1255L, 8L, 100L, -1L, upper, ok);
  ntr_3_booleans(tzt, 20L, 1255L, 8L, 101L, -1L, *graphical, *full_specified,
		 *homogeneous);
      /*ntr*/
  ntr_triple_g_c(tzt, 20L, 1255L, 8L, 102L, -1L, g_c_d, g_c_l, g_c_q);
  return Result;
}  /* q_equivalent */


Static t_mixed_characteristics *sub_return_mixed_characteristics(unfolded,
  graphical, upper, complete, full_specified, homogeneous, g_c_d, g_c_l,
  g_c_q)
boolean *unfolded, *graphical;
long *upper;
boolean *complete, *full_specified, *homogeneous;
t_set_list **g_c_d, **g_c_l, **g_c_q;
{
  t_mixed_characteristics *p;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubReturnMixedChar ", sizeof(pch20));
  if (trace_flag_set(20L, 1256L, 0L)) {
    ntr_set(tzt, 20L, 1256L, 1L, -1L, -1L, upper);   /*ntr*/
    /* ntr_3_booleans(tzt, 20, 1256, 1, -1, -1,
                     graphical, full_specified, homogeneous); */
    ntr_triple_g_c(tzt, 20L, 1256L, 1L, -1L, -1L, g_c_d, g_c_l, g_c_q);
  }
  /*$endif TRACE*/
  p = (t_mixed_characteristics *)Malloc(sizeof(t_mixed_characteristics));
  if (p == NULL)
    _OutMem();
  if (!*complete && *g_c_d != NULL) {
    if (P_subset(upper, (*g_c_d)->vertex_set))
      *complete = true;
  }

  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1256L, 2L, -2L, -2L);
  /*$endif TRACE*/
  P_setcpy(a, empty_set);
  add_union_of_gc(*g_c_q, a);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1256L, 2L, -3L, -1L);
  /*$endif TRACE*/
  if (P_subset(a, gamma_)) {
    if (subset_of_an_edge(a, g_c_q)) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1256L, 2L, -3L, -2L);
      /*$endif TRACE*/
      *homogeneous = true;
      if (!*complete) {
	*complete = is_complete_in_mixed_gc(upper, unfolded, full_specified,
					    homogeneous, g_c_d, g_c_l, g_c_q);
	/*$ifdef TRACE*/
      }
      ntr(tzt, 20L, 1256L, 2L, -3L, -3L);
      /*$endif TRACE*/
    }
  }
  /* p^.complete := complete;
     p^.homogeneous := homogeneous; */
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1256L, 4L, -4L, -1L, *full_specified);
  ntr_boolean(tzt, 20L, 1256L, 4L, -4L, -2L, *complete);
  /*$endif TRACE*/
  if (*full_specified && !*complete) {
    p->mim_model = mim_quadratic_g_c(*g_c_q);
    p->degenerated = degenerated_g_c(upper, g_c_q);
  } else {
    p->mim_model = true;
    p->degenerated = false;
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1256L, 4L, -5L, -5L, p->mim_model);
  /*$endif TRACE*/
  if (p->mim_model) {
    p->d_collapsible = d_collapsible(unfolded, graphical, upper, complete,
	full_specified, homogeneous, g_c_d, g_c_l, g_c_q);
    p->mean_linear = mean_linear_gc(*g_c_l, *g_c_q);
    p->q_equivalent = q_equivalent(graphical, upper, full_specified,
				   homogeneous, g_c_d, g_c_l, g_c_q);
  } else {
    p->d_collapsible = false;
    p->mean_linear = false;
    p->q_equivalent = false;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1256L, 9L, 9L, 9L);
  /*$endif TRACE*/
  return p;
}  /* sub_return_mixed_characteristics */


Static t_mixed_characteristics *return_mixed_characteristics(model)
t_model **model;
{
  t_mixed_characteristics *Result;
  boolean complete = false, unfolded = true;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnMixedCharact ", sizeof(pch20));
  ntr(tzt, 20L, 1257L, 1L, 0L, 0L);
  /*$endif TRACE*/
  if ((*model)->id->model_type == mixed)
    Result = sub_return_mixed_characteristics(&unfolded, &(*model)->graphical,
	(*model)->id->vertices, &complete,
	&(*model)->id->UU.U1.full_specified, &(*model)->id->UU.U1.homogeneous,
	&(*model)->id->UU.U1.g_c_discrete, &(*model)->id->UU.U1.g_c_linear,
	&(*model)->id->UU.U1.g_c_quadratic);
  else {
    Result = NULL;
    /*$ifdef TRACE*/
  }
  ntr(tzt, 20L, 1257L, 9L, 9L, 9L);
  /*$endif TRACE*/
  return Result;
}  /* return_mixed_characteristics */


/* Local variables for new_m_ips_leaf: */
struct LOC_new_m_ips_leaf {
  boolean complete, homogeneous;
} ;


Static Void new_m_ips_leaf(m_ips_leaf, graphical, upper, lower, complete_,
			   full_specified, homogeneous_, node_homogeneous,
			   g_c_d, g_c_l, g_c_q)
t_mips_element **m_ips_leaf;
boolean *graphical;
long *upper, *lower;
boolean complete_, *full_specified, homogeneous_, *node_homogeneous;
t_set_list **g_c_d, **g_c_l, **g_c_q;
{
  struct LOC_new_m_ips_leaf Local_Var;
  boolean unfolded = true;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.complete = complete_;
  Local_Var.homogeneous = homogeneous_;
  /*$ifdef TRACE*/
  memcpy(tzt, " NewMIpsLeaf        ", sizeof(pch20));
  if (trace_flag_set(20L, 1258L, 0L)) {
    ntr_2_sets(tzt, 20L, 1258L, 1L, -1L, -1L, upper, lower);
    ntr_3_booleans(tzt, 20L, 1258L, 1L, -1L, -1L, Local_Var.complete,
		   *full_specified, Local_Var.homogeneous);
	/*ntr*/
    ntr_triple_g_c(tzt, 20L, 1258L, 1L, -1L, -1L, g_c_d, g_c_l, g_c_q);
  }
  /*$endif TRACE*/

  *m_ips_leaf = (t_mips_element *)Malloc(sizeof(t_mips_element));
  if (*m_ips_leaf == NULL)
    _OutMem();
  (*m_ips_leaf)->fund_ghk = false;
  (*m_ips_leaf)->log_likelihood = _INVALID_REAL;
  (*m_ips_leaf)->min_l = _INVALID_REAL;
  (*m_ips_leaf)->max_l = _INVALID_REAL;
  (*m_ips_leaf)->convergence = false;
  (*m_ips_leaf)->cycles = -1;
  (*m_ips_leaf)->ifail = 0;
  (*m_ips_leaf)->mips_delta = 0.0;

  (*m_ips_leaf)->mixed_characteristics = sub_return_mixed_characteristics(
      &unfolded, graphical, upper, &Local_Var.complete, full_specified,
      &Local_Var.homogeneous, g_c_d, g_c_l, g_c_q);

  (*m_ips_leaf)->complete = Local_Var.complete;

  *node_homogeneous = Local_Var.homogeneous;
  /* m_ips_leaf^.full_specified                   := full_specified; */

  /* m_ips_leaf^.upper:= upper; */
  /* m_ips_leaf^.lower:= lower; */

  copy_set_list(*g_c_d, &(*m_ips_leaf)->discrete_);
  copy_set_list(*g_c_l, &(*m_ips_leaf)->linear);
  copy_set_list(*g_c_q, &(*m_ips_leaf)->quadratic);

  (*m_ips_leaf)->n_offset = -1;
  (*m_ips_leaf)->r_offset = -1;
  (*m_ips_leaf)->r = NULL;
  (*m_ips_leaf)->ss_offset = -1;
  (*m_ips_leaf)->ss = NULL;

  (*m_ips_leaf)->generators = NULL;
  (*m_ips_leaf)->ghk_work = NULL;
}  /* new_m_ips_leaf */


Static Void insert_in_mixed_node(graphical, upper, lower, complete,
  full_specified, homogeneous, node_homogeneous, g_c_d, g_c_l, g_c_q,
  formula_node)
boolean *graphical;
long *upper, *lower;
boolean complete, *full_specified, homogeneous, *node_homogeneous;
t_set_list **g_c_d, **g_c_l, **g_c_q;
t_formula_node **formula_node;
{
  *formula_node = (t_formula_node *)Malloc(sizeof(t_formula_node));
  if (*formula_node == NULL)
    _OutMem();
  (*formula_node)->tmp_m_ips_leaf = NULL;
  (*formula_node)->node_type = m_ips_node;
  new_m_ips_leaf(&(*formula_node)->UU.m_ips_leaf, graphical, upper, lower,
		 complete, full_specified, homogeneous, node_homogeneous,
		 g_c_d, g_c_l, g_c_q);
}  /* insert_in_mixed_node */


Static Void advance_for_eliminate_complete_sg(ok, graphical, i, u, dimension,
  b, g, invers_order, c, g_c_d, g_c_l, g_c_q, d_matrix, l_matrix, q_matrix,
  s_matrix)
boolean *ok, *graphical;
t_1_max_dimension *i;
t_vertex *u;
t_long_integer dimension;
long *b, *g;
t_vertex *invers_order;
t_vertex_set *c;
t_set_list **g_c_d, **g_c_l, **g_c_q;
t_adjacency_matrix *d_matrix, *l_matrix, *q_matrix, *s_matrix;
{
  t_1_max_dimension j;
  t_vertex v;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " AdvanceForComplete ", sizeof(pch20));
  /*$endif TRACE*/
  /* Advance for eliminating complete subgraph */
  if (*ok) {
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 1260L, 1L, 1001L, (long)(*i), *ok);
    /*$endif TRACE*/
    delete_edges_with_vertex(d_matrix, u);
    delete_edges_with_vertex(l_matrix, u);
    delete_edges_with_vertex(q_matrix, u);
    delete_edges_with_vertex(s_matrix, u);   /*ntr*/
    /*$ifdef TRACE*/
    ntr_decompose_mixed(tzt, 20L, 1260L, 1L, 1002L, -1L, -1L, i, u, empty_set,
			b, c[*u - MIN_VERTEX], g, g_c_d, g_c_l, g_c_q,
			d_matrix, l_matrix, q_matrix, s_matrix);
	/*ntr*/
    /*$endif TRACE*/
  }
  j = *i + 1;
  if (j < dimension) {
    v = invers_order[j-1];
    P_setcpy(b, c[v - MIN_VERTEX]);
    P_addset(b, v);
    while ((P_subset(b, c[*u - MIN_VERTEX]) && j < dimension) & P_inset(v, g)) {
      if (*ok) {
	/*$ifdef TRACE*/
	ntr_boolean(tzt, 20L, 1260L, 1L, 1003L, (long)j, *ok);
	/*$endif TRACE*/
	delete_edges_with_vertex(d_matrix, &v);
	delete_edges_with_vertex(l_matrix, &v);
	delete_edges_with_vertex(q_matrix, &v);
	delete_edges_with_vertex(s_matrix, &v);
      }
      j++;
      v = invers_order[j-1];
      P_setcpy(b, c[v - MIN_VERTEX]);
      P_addset(b, v);
      /*$ifdef TRACE*/
      /*$endif TRACE*/
      ntr_vertex_and_set(tzt, 20L, 1260L, 1L, 1004L, (long)j, &v, b);
    }
  }
  P_setcpy(b, c[*u - MIN_VERTEX]);
  P_addset(b, *u);
  *i = j - 1;
  *u = invers_order[*i - 1];
}  /* advance_for_eliminate_complete_sg */


Static Void eliminate_complete_sg(graphical, a, b, c_u, g, full_specified,
				  homogeneous, node_homogeneous, g_c_d, g_c_l,
				  g_c_q, formula_node, s_matrix, dim)
boolean *graphical;
long *a, *b, *c_u, *g;
boolean *full_specified, *homogeneous, *node_homogeneous;
t_set_list **g_c_d, **g_c_l, **g_c_q;
t_formula_node **formula_node;
t_adjacency_matrix *s_matrix;
t_long_integer *dim;
{
  /* a : t_vertex_set; */
  t_set_list *g_c_a = NULL;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " EliminateCompleteS ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1261L, 1L, 2001L, *dim, *graphical);
  ntr_4_sets(tzt, 20L, 1261L, 1L, 2001L, -3L, g, a, c_u, b);
  ntr_3_booleans(tzt, 20L, 1261L, 1L, 2001L, -4L, *full_specified,
		 *homogeneous, *node_homogeneous);
      /*ntr*/
  ntr_triple_g_c(tzt, 20L, 1261L, 1L, 2001L, -5L, g_c_d, g_c_l, g_c_q);
  /*$endif TRACE*/
  insert_clique(b, &g_c_a);
  split_g_c_in_mixed_terms(g_c_a, *full_specified, *homogeneous, g_c_d, g_c_l,
			   g_c_q);
      /**/
  sub_check_mixed_model(g_c_d, g_c_l, g_c_q, b, mixed, tzt, 20L, false);
  dispose_set_list(&g_c_a);
  if (P_setequal(b, g))
    P_setcpy(a, empty_set);
  else
    P_setcpy(a, c_u);
  insert_in_mixed_node(graphical, b, a, true, full_specified, *homogeneous,
		       node_homogeneous, g_c_d, g_c_l, g_c_q, formula_node);
  /* "b" is the vertices of the node to eliminate.
     "a" is computed as the vertices (b \ c[u]) of vertices eliminated. */
  P_setdiff(a, b, c_u);
  /* insert_in_complete_node(b, formula_node, mixed); */
  insert_edge_in_adjacency_matrix(s_matrix, c_u);
  /*$ifdef TRACE*/
  update_mixed_dimension(dim, full_specified, homogeneous, b, c_u, true,
			 g_c_d, g_c_l, g_c_q);
  ntr_4_sets(tzt, 20L, 1261L, 1L, 2009L, -3L, g, a, c_u, b);
  /*$endif TRACE*/
}  /* eliminate_complete_sg */


Static Void eliminate_nondecomposable_sg(graphical, i, u, a, b, c_u, g,
  full_specified, homogeneous, node_homogeneous, invers_order, g_c_d, g_c_l,
  g_c_q, formula_node, adj_list, d_matrix, l_matrix, q_matrix, s_matrix, dim)
boolean *graphical;
t_1_max_dimension *i;
t_vertex *u;
long *a, *b, *c_u, *g;
boolean *full_specified, *homogeneous, *node_homogeneous;
t_vertex *invers_order;
t_set_list **g_c_d, **g_c_l, **g_c_q;
t_formula_node **formula_node;
t_vertex_list **adj_list;
t_adjacency_matrix *d_matrix, *l_matrix, *q_matrix, *s_matrix;
t_long_integer *dim;
{
  t_vertex_list *a_list = NULL;
  t_set_list *g_c_b = NULL;
  t_set_list *p;
  t_vertex v;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_vertex FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " EliminateNonDecomp ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1262L, 1L, 3001L, *dim, *graphical);
  ntr_vertex(tzt, 20L, 1262L, 1L, 3001L, (long)(*i), u);
  ntr_4_sets(tzt, 20L, 1262L, 1L, 3001L, -3L, g, a, c_u, b);
  ntr_3_booleans(tzt, 20L, 1262L, 1L, 3001L, -4L, *full_specified,
		 *homogeneous, *node_homogeneous);
      /*ntr*/
  ntr_triple_g_c(tzt, 20L, 1262L, 1L, 3001L, -5L, g_c_d, g_c_l, g_c_q);
  /*$endif TRACE*/
  /* "a", the vertices (b \ c[u]) of vertices eliminated, and
     "b", the vertices of the node to eliminate, is computed: */
  find_connected_component_list(g, c_u, a, &a_list, u, adj_list);
  P_setunion(b, a, c_u);
  /* Should this have been done in add_separator? */
  /* Put back 1. september 2003 to handle
     [abxy] // [[ab]] / [[aby][abx]] / [[bxy][axy][aby][abx]]: */
  if (P_setequal(b, g)) {   /*ntr*/
    FORLIM = last_vertex;
    for (v = first_vertex; v <= FORLIM; v++) {
      if (P_inset(v, c_u))
	insert_vertex_in_vertex_list(v, &a_list);
    }
  }
  /**/
  /*$ifdef TRACE*/
  ntr_decompose_mixed(tzt, 20L, 1262L, 1L, 3002L, -1L, -1L, i, u, a, b, c_u,
		      g, g_c_d, g_c_l, g_c_q, d_matrix, l_matrix, q_matrix,
		      s_matrix);
      /*ntr*/
  /*$endif TRACE*/
  return_and_delete_edges_with_vertices_list(d_matrix, a_list, g_c_d);
  return_and_delete_edges_with_vertices_list(l_matrix, a_list, g_c_l);
  return_and_delete_edges_with_vertices_list(q_matrix, a_list, g_c_q);
  insert_clique(empty_set, g_c_d);
  return_and_delete_edges_with_vertices_list(s_matrix, a_list, &g_c_b);
      /*ntr*/
  /*$ifdef TRACE*/
  ntr_decompose_mixed(tzt, 20L, 1262L, 1L, 3003L, -1L, -1L, i, u, a, b, c_u,
		      g, g_c_d, g_c_l, g_c_q, d_matrix, l_matrix, q_matrix,
		      s_matrix);
      /*ntr*/
  if (trace_flag_set(20L, 1262L, 0L))
    ntr_g_c(tzt, 20L, 1262L, 1L, 3004L, 2L, &g_c_b);
  /*$endif TRACE*/
  dispose_vertex_list(&a_list);
  add_separator(full_specified, homogeneous, c_u, g_c_d, g_c_l, g_c_q, *i,
		invers_order, q_matrix);
  p = g_c_b;
  while (p != NULL) {
    add_separator(full_specified, homogeneous, p->vertex_set, g_c_d, g_c_l,
		  g_c_q, *i, invers_order, q_matrix);
    p = p->pointer;
  }
  dispose_set_list(&g_c_b);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1262L, 1L, 3004L, (long)(*i), P_setequal(b, g));
      /*ntr*/
  ntr_decompose_mixed(tzt, 20L, 1262L, 1L, 2004L, -1L, -1L, i, u, a, b, c_u,
		      g, g_c_d, g_c_l, g_c_q, d_matrix, l_matrix, q_matrix,
		      s_matrix);
      /*ntr*/
  /*$endif TRACE*/
  /**/
  sub_check_mixed_model(g_c_d, g_c_l, g_c_q, b, mixed, tzt, 20L, false);
  if (P_setequal(b, g))
    insert_in_mixed_node(graphical, b, empty_set, false, full_specified,
			 *homogeneous, node_homogeneous, g_c_d, g_c_l, g_c_q,
			 formula_node);
  else
    insert_in_mixed_node(graphical, b, c_u, false, full_specified,
			 *homogeneous, node_homogeneous, g_c_d, g_c_l, g_c_q,
			 formula_node);
  insert_edge_in_adjacency_matrix(s_matrix, c_u);
  /*$ifdef TRACE*/
  update_mixed_dimension(dim, full_specified, homogeneous, b, c_u, false,
			 g_c_d, g_c_l, g_c_q);
  ntr_4_sets(tzt, 20L, 1262L, 1L, 3009L, -3L, g, a, c_u, b);
  /*$endif TRACE*/
}  /* eliminate_nondecomposable_sg */


Static Void insert_separator(current_model, ok, graphical, i, dim,
  dimension_a, a, b, c_u, g, invers_order, full_specified, homogeneous,
  node_homogeneous, formula_node, g_c_d, g_c_l, g_c_q, d_matrix, l_matrix,
  q_matrix, s_matrix)
t_model **current_model;
boolean *ok, *graphical;
t_1_max_dimension *i;
t_long_integer *dim, *dimension_a;
long *a, *b, *c_u, *g;
t_vertex *invers_order;
boolean *full_specified, *homogeneous, *node_homogeneous;
t_formula_node **formula_node;
t_set_list **g_c_d, **g_c_l, **g_c_q;
t_adjacency_matrix *d_matrix, *l_matrix, *q_matrix, *s_matrix;
{
  t_long_integer dimension_b;
  t_set_list *p;
  t_set_list *g_c_b = NULL, *g_c_d_b = NULL, *g_c_l_b = NULL, *g_c_q_b = NULL;
  /*$ifdef TRACE*/
  pch20 tzt;
  FILE *TEMP;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertSeparator    ", sizeof(pch20));
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  /*ntr*/
  ntr_decompose_mixed(tzt, 20L, 1263L, 1L, 9001L, -1L, -1L, i, &first_vertex,
		      a, b, c_u, g, g_c_d, g_c_l, g_c_q, d_matrix, l_matrix,
		      q_matrix, s_matrix);
      /*ntr*/
  if (trace_flag_set(20L, 1263L, 0L)) {
    write_pch(stdout, " Decomp.: ", 10L);
    if (!P_setequal(g, b))   /* ? */
      write_pch(stdout, " Decompose", 10L);
    else
      write_pch(stdout, " No Decomp", 10L);
    /* ? */
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (*homogeneous)
    *ok = true;   /* homogeneous */
  else
    *ok = false;
  /* homogeneous */
  /* Ok changed to false 2. september 2003 to handle models like
   [[ab]] / [[by][ay][ax]] / [[by][axy]]
   [[ab]] / [[bx][ax][by]] / [[bxy][ax]]
  */
  /* ok := not subset_of_an_edge_in_matrix(i, c_u, invers_order, q_matrix); */
  *dimension_a = mysubi(dim, *dimension_a);
  if (!P_setequal(g, b)) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1263L, 0L)) {
      write_pch(stdout, " Decompose", 10L);
      write_line_text(stdout);
      TEMP = stdout;
      flush_file(&TEMP);
    }
    /*$endif TRACE*/
    g_c_d_b = return_edges_from_adjacency_matrix(d_matrix);
    g_c_l_b = return_edges_from_adjacency_matrix(l_matrix);
    g_c_q_b = return_edges_from_adjacency_matrix(q_matrix);
    g_c_b = return_edges_from_adjacency_matrix(s_matrix);
    insert_clique(empty_set, &g_c_d_b);
    p = g_c_b;
    while (p != NULL) {
      /*$ifdef TRACE*/
      ntr_set(tzt, 20L, 1263L, 7L, 9002L, 1L, p->vertex_set);
      if (trace_flag_set(20L, 1263L, 0L))
	ntr_adjacency_matrixs_and_separators(tzt, 20L, 1263L, 7L, 9002L, -1L,
	  d_matrix, l_matrix, q_matrix, s_matrix);
      /*$endif TRACE*/
      add_separator(full_specified, homogeneous, p->vertex_set, &g_c_d_b,
		    &g_c_l_b, &g_c_q_b, *i, invers_order, q_matrix);
	  /* 2003/01/11 ? */
      p = p->pointer;
    }
    dispose_set_list(&g_c_b);
    P_setdiff(g, g, a);   /**/
    sub_check_mixed_model(&g_c_d_b, &g_c_l_b, &g_c_q_b, g, mixed, tzt, 20L,
			  false);
    dimension_b = find_mixed_dimension(g_c_d_b, g_c_l_b, g_c_q_b,
				       *full_specified, *homogeneous, 0L);
	/* causal_structure */
    decompose_mixed_model_and_insert_node(a, c_u, g, g_c_d, g_c_l, g_c_q,
      &g_c_d_b, &g_c_l_b, &g_c_q_b, dimension_a, &dimension_b, formula_node,
      current_model, NULL, *full_specified, *homogeneous, *node_homogeneous,
      mixed);
    update_mixed_dimension_set(dim, full_specified, ok, c_u, -1L);
  } else {
    dispose_set_list(g_c_d);
    dispose_set_list(g_c_l);
    dispose_set_list(g_c_q);
    (*current_model)->dim = *dimension_a;
    (*current_model)->id->UU.U1.homogeneous = *node_homogeneous;
    (*current_model)->id->UU.U1.full_specified = *full_specified;
    (*current_model)->formula_node = *formula_node;
  }
  P_setdiff(g, g, a);
  P_setdiff(b, g, c_u);
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_4_sets(tzt, 20L, 1263L, 1L, (long)(*i), *dim, g, a, empty_set, b);
}  /* insert_separator */



Static Void decompose_mixed(model, graphical, full_specified, homogeneous,
			    d_matrix, l_matrix, q_matrix, model_set, adj_list,
			    adj_set, invers_order, c, complete, constant, dim)
t_model **model;
boolean *graphical, *full_specified, *homogeneous;
t_adjacency_matrix *d_matrix, *l_matrix, *q_matrix;
long *model_set;
t_vertex_list **adj_list;
t_vertex_set *adj_set;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
t_long_real *constant;
t_long_integer *dim;
{
  t_1_max_dimension i = 1;
  t_long_integer dimension_a, number_remaining;
  t_vertex u;
  t_vertex_set a_, b_, a, b, g;
  t_set_list *g_c_d = NULL, *g_c_l = NULL, *g_c_q = NULL;
  t_adjacency_matrix s_matrix;
  boolean no_dim_limit, node_homogeneous, ok;
  t_formula_node *formula_node;
  t_model *current_model;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  no_dim_limit = !boolean_option[109];
  /*$ifdef TRACE*/
  memcpy(tzt, " DecomposeMixed     ", sizeof(pch20));
  if (trace_flag_set(20L, 1264L, 0L))
    sub_print_invers_order(invers_order, c, complete);
  ntr_3_booleans(tzt, 20L, 1264L, 1L, 101L, 1L, *graphical, *full_specified,
		 *homogeneous);
      /*ntr*/
  /*$endif TRACE*/
  current_model = *model;
  new_adjacency_matrix(&s_matrix);
  *dim = 0;
  P_setdiff(b, delta_gamma, model_set);
  P_setint(b, b, delta);
  *constant = 1 / marginal_dimension_real(b);
  P_setcpy(g, model_set);
  P_setcpy(b, g);
  P_setcpy(a, empty_set);
  while (!P_setequal(b, empty_set) && (no_dim_limit || i <= dimension)) {
    u = invers_order[i-1];   /*ntr*/
    /*$ifdef TRACE*/
    ntr_decompose_mixed(tzt, 20L, 1264L, 1L, 102L, -1L, (long)dimension, &i,
			&u, a, b, c[u - MIN_VERTEX], g, &g_c_d, &g_c_l,
			&g_c_q, d_matrix, l_matrix, q_matrix, &s_matrix);
	/*ntr*/
    /*$endif TRACE*/
    /* (u <= last_vertex) and */
    while (!(P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) & P_inset(u, g)) &&
	   (no_dim_limit || i <= dimension)) {
      /*$ifdef TRACE*/
      ntr_vertex_and_set(tzt, 20L, 1264L, 1L, 103L, (long)i, &u,
			 c[u - MIN_VERTEX]);
      /*$endif TRACE*/
      /* a := a + [ u ]; */
      i++;
      u = invers_order[i-1];
    }
    /*$ifdef TRACE*/
    ntr_vertex_and_set(tzt, 20L, 1264L, 1L, 104L, (long)i, &u,
		       c[u - MIN_VERTEX]);
    /*$endif TRACE*/
    if ((P_getbits_UB(complete, u - MIN_VERTEX, 0, 3) & P_inset(u, g)) &&
	(no_dim_limit || i <= dimension))
      ok = ok_to_decompose_mixed(graphical, full_specified, homogeneous,
	  d_matrix, l_matrix, q_matrix, &s_matrix, adj_list, invers_order, g,
	  c[u - MIN_VERTEX], &u, &i);
    else {
      note_error_model(stdout, 1264L, 1L, " DecomposeMixed-1:  ", *model,
		       false);
      ok = false;
    }
    find_connected_component(g, c[u - MIN_VERTEX], a_, &u, adj_list);
    P_setcpy(b_, c[u - MIN_VERTEX]);
    P_addset(b_, u);
    /*$ifdef TRACE*/
    ntr_vertex_and_set(tzt, 20L, 1264L, 1L, 105L, (long)i, &u, b);
    ntr_vertex_and_set(tzt, 20L, 1264L, 1L, 105L, (long)i, &u, b_);
    ntr_vertex_and_set(tzt, 20L, 1264L, 1L, 105L, (long)i, &u, a_);
    ntr_boolean(tzt, 20L, 1264L, 1L, 105L, (long)i, ok);
    /*$endif TRACE*/
    if (ok || i == dimension) {
      number_remaining = cardinality(b);
      if (i == dimension && number_remaining > 1)
	ok = false;
      else if (*graphical)
	ok = P_subset(c[u - MIN_VERTEX], adj_set[u - MIN_VERTEX]);
      else {
	if (ok) {
	  P_setcpy(b, c[u - MIN_VERTEX]);
	  P_addset(b, invers_order[i-1]);
	  ok = is_complete_in_mixed(b, full_specified, homogeneous, d_matrix,
				    l_matrix, q_matrix, &s_matrix,
				    invers_order, &i);
	}
      }
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1264L, 1L, 106L, (long)i, ok);
      /*$endif TRACE*/
      if (ok || boolean_option[123]) {   /* not ?!?!? */
	/* "b", the vertices of the node to eliminate,
	   [u] + c[u], is computed: */
	advance_for_eliminate_complete_sg(&ok, graphical, &i, &u,
	  (long)dimension, b, g, invers_order, c, &g_c_d, &g_c_l, &g_c_q,
	  d_matrix, l_matrix, q_matrix, &s_matrix);
      }
      /* and (b_ = a_) */
      dimension_a = *dim;
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1264L, 1L, 107L, (long)i, ok);   /*ntr*/
      ntr_decompose_mixed(tzt, 20L, 1264L, 1L, 107L, -1L, (long)dimension, &i,
			  &u, a, b, c[u - MIN_VERTEX], g, &g_c_d, &g_c_l,
			  &g_c_q, d_matrix, l_matrix, q_matrix, &s_matrix);
	  /*ntr*/
      /*$endif TRACE*/
      /* "b" is the vertices of the node to eliminate for
         "eliminate_complete_sg". "a" is computed. */
      if (ok && (i < dimension || number_remaining == 1))
	    /* and (b_ = a_) */
	      eliminate_complete_sg(graphical, a, b, c[u - MIN_VERTEX], g,
				    full_specified, homogeneous,
				    &node_homogeneous, &g_c_d, &g_c_l, &g_c_q,
				    &formula_node, &s_matrix, dim);
      else
	eliminate_nondecomposable_sg(graphical, &i, &u, a, b,
	  c[u - MIN_VERTEX], g, full_specified, homogeneous,
	  &node_homogeneous, invers_order, &g_c_d, &g_c_l, &g_c_q,
	  &formula_node, adj_list, d_matrix, l_matrix, q_matrix, &s_matrix,
	  dim);
      /* "a" is now the vertices (b \ c[u]) of vertices eliminated,
         and "b" is now the vertices of the node to eliminate, for
         "insert_separator". */
      /*$ifdef TRACE*/
      /*ntr*/
      ntr_decompose_mixed(tzt, 20L, 1264L, 1L, 108L, -1L, (long)dimension, &i,
			  &u, a, b, c[u - MIN_VERTEX], g, &g_c_d, &g_c_l,
			  &g_c_q, d_matrix, l_matrix, q_matrix, &s_matrix);
	  /*ntr*/
      /*$endif TRACE*/
      insert_separator(&current_model, &ok, graphical, &i, dim, &dimension_a,
		       a, b, c[u - MIN_VERTEX], g, invers_order,
		       full_specified, homogeneous, &node_homogeneous,
		       &formula_node, &g_c_d, &g_c_l, &g_c_q, d_matrix,
		       l_matrix, q_matrix, &s_matrix);
	  /*ntr*/
      /* "b" is now the remaning vertices. */
      /*$ifdef TRACE*/
      ntr_decompose_mixed(tzt, 20L, 1264L, 1L, 109L, -1L, (long)dimension, &i,
			  &u, a, b, c[u - MIN_VERTEX], g, &g_c_d, &g_c_l,
			  &g_c_q, d_matrix, l_matrix, q_matrix, &s_matrix);
	  /*ntr*/
      /*$endif TRACE*/
      /* a := empty_set */
    } else if (i > dimension) {
      note_error_model(stdout, 1264L, 2L, " DecomposeMixed-2:  ", *model,
		       false);
      P_setcpy(b, empty_set);
    } else {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1264L, 0L)) {
	note_error_model(stdout, 1264L, 3L, " DecomposeMixed-3:  ", *model,
			 false);
	write_pch(stdout, " OkToDecomposeMixed", 19L);
	write_pch(stdout, " failed in DecomposeMixed.", 26L);
	write_line(stdout);
      }
      /*$endif TRACE*/
    }
    i++;
    if (i > dimension && !P_setequal(b, empty_set)) {
      note_error_model(stdout, 1264L, 3L, " DecomposeMixed-3:  ", *model,
		       false);
      P_setcpy(b, empty_set);
    }
  }
  delete_edges_with_vertices(&s_matrix, g);
  /*$ifdef TRACE*/
  trace_nonempty_adjacency_matrix(&s_matrix);
  ntr_vertex_and_set(tzt, 20L, 1264L, 1L, 111L, (long)i, &u, b);
  /*$endif TRACE*/
}  /* decompose_mixed */


/*@+"discrete.p"*/


Static Void identify_discrete_model(model)
t_model **model;
{
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_lists fill_in_adj_list, adj_list;
  t_v_arr_of_v_sets adj_set, c;
  t_v_arr_of_boolean complete;
  t_vertex v;
  t_offset_list *r;
  t_v_arr_of_order beta;
  t_adjacency_matrix gc_adjacency_matrix;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IdentifyDisceModel ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1266L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  dispose_model_but_identification(model);
  WITH = *model;
  if (incomplete_table)
    decompose_incomplete_model(model, &WITH->id->UU.g_c_log_linear,
			       WITH->id->vertices, &WITH->constant,
			       &WITH->dim);
  else {
    create_adjacency_matrix(&gc_adjacency_matrix, WITH->id->UU.g_c_log_linear);
    restricted_maximim_cardinality_search_on_hypergraph(&gc_adjacency_matrix,
      empty_set, &WITH->decomposable, order, beta, invers_order, &r);
    revers_offset_list(&r);
    if (WITH->decomposable)
      WITH->decomposable = test_acyclic_hypergraph(beta, &r);
    WITH->graphical = true;
    if (WITH->decomposable) {
      add_union_of_gc(WITH->id->UU.g_c_log_linear, WITH->id->vertices);
      hypergraph_find_formula(*model, &WITH->id->UU.g_c_log_linear,
			      WITH->id->vertices, &r, &WITH->constant,
			      &WITH->dim, pure_discrete);
    } else {
      for (v = first_vertex; v <= last_vertex; v++) {
	order[v - MIN_VERTEX] = 1;
	fill_in_adj_list[v - MIN_VERTEX] = NULL;
	P_setcpy(c[v - MIN_VERTEX], empty_set);
	P_clrbits_B(complete, v - MIN_VERTEX, 0, 3);
      }
      hypergraph_sets_to_graph_sets(WITH->id->UU.g_c_log_linear,
				    WITH->id->vertices, adj_set);
      adj_set_to_adj_list(adj_set, adj_list);
      WITH->graphical = test_graphical(adj_set, &WITH->id->UU.g_c_log_linear);
      maximum_cardinality_search(adj_list, order, invers_order);
      WITH->decomposable = test_for_zero_fill_in(adj_list, order, invers_order);
      if (WITH->decomposable)
	find_c(adj_set, order, invers_order, adj_list, c, complete);
      else {
	lex_m(adj_list, order, invers_order, fill_in_adj_list);
	find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
	dispose_adj_list(fill_in_adj_list);
      }
      decompose_non_decomposable(model, &WITH->graphical,
	&gc_adjacency_matrix, WITH->id->vertices, adj_list, adj_set,
	invers_order, c, complete, &WITH->constant, &WITH->dim);
      dispose_adj_list(adj_list);
    }
    dispose_offset_list(&r);
    delete_edges_with_vertices(&gc_adjacency_matrix, WITH->id->vertices);
  }
  WITH->dimdec = WITH->dim;
  WITH->found_expression = true;
  /*$ifdef TRACE*/
  ntr_expression(tzt, 20L, 1266L, 8L, -1L, 998L, *model);
  ntr_model_g_c(tzt, 20L, 1266L, 8L, -1L, 999L, model);
  /*$endif TRACE*/
}  /* identify_discrete_model */


/*@+"contin.p"*/


Static Void identify_continuous_model(model)
t_model **model;
{
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_lists fill_in_adj_list, adj_list;
  t_v_arr_of_v_sets adj_set, c;
  t_v_arr_of_boolean complete;
  t_vertex v;
  t_offset_list *r;
  t_v_arr_of_order beta;
  t_adjacency_matrix gc_adjacency_matrix;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IdentifyContiModel ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1272L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  dispose_model_but_identification(model);
  WITH = *model;
  create_adjacency_matrix(&gc_adjacency_matrix, WITH->id->UU.g_c_covariance);
  restricted_maximim_cardinality_search_on_hypergraph(&gc_adjacency_matrix,
    empty_set, &WITH->decomposable, order, beta, invers_order, &r);
  revers_offset_list(&r);
  if (WITH->decomposable)
    WITH->decomposable = test_acyclic_hypergraph(beta, &r);
  WITH->graphical = true;
  if (WITH->decomposable) {
    add_union_of_gc(WITH->id->UU.g_c_covariance, WITH->id->vertices);
    hypergraph_find_formula(*model, &WITH->id->UU.g_c_covariance,
			    WITH->id->vertices, &r, &WITH->constant,
			    &WITH->dim, pure_continuous);
  } else {
    for (v = first_vertex; v <= last_vertex; v++) {
      order[v - MIN_VERTEX] = 1;
      fill_in_adj_list[v - MIN_VERTEX] = NULL;
      P_setcpy(c[v - MIN_VERTEX], empty_set);
      P_clrbits_B(complete, v - MIN_VERTEX, 0, 3);
    }
    hypergraph_sets_to_graph_sets(WITH->id->UU.g_c_covariance,
				  WITH->id->vertices, adj_set);
    adj_set_to_adj_list(adj_set, adj_list);
    WITH->graphical = test_graphical(adj_set, &WITH->id->UU.g_c_covariance);
    maximum_cardinality_search(adj_list, order, invers_order);
    WITH->decomposable = test_for_zero_fill_in(adj_list, order, invers_order);
    if (WITH->decomposable)
      find_c(adj_set, order, invers_order, adj_list, c, complete);
    else {
      lex_m(adj_list, order, invers_order, fill_in_adj_list);
      find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
      dispose_adj_list(fill_in_adj_list);
    }
    /**/
    /**/
    decompose_continuous(model, &WITH->graphical, &gc_adjacency_matrix,
			 WITH->id->vertices, adj_list, adj_set, invers_order,
			 c, complete, &WITH->constant, &WITH->dim);
    dispose_adj_list(adj_list);
  }
  dispose_offset_list(&r);
  delete_edges_with_vertices(&gc_adjacency_matrix, WITH->id->vertices);
  WITH->dimdec = WITH->dim;
  WITH->found_expression = true;
  /*$ifdef TRACE*/
  ntr_expression(tzt, 20L, 1272L, 8L, -1L, 998L, *model);
  ntr_model_g_c(tzt, 20L, 1272L, 8L, -1L, 999L, model);
  /*$endif TRACE*/
}  /* identify_continuous_model */


/*@+"mixed.p"*/

/*

1275:    +++  ++
1276:    +++  ++
1277:    ---  -- p/mixed.p          4      20     241 p/mixed.p
1278: |    4:    procedure print_adj_set
1279: |   20:    - function extended_g_c
1280: |   25:    procedure fix_quadratic_g_c
1281: |   49:    procedure identify_mixed_model
1282:    +++  ++
1283:    +++  ++

*/

Static boolean return_only_in_first_g_c(link_1, link_2, txt_1, txt_2,
					generator_txt)
t_set_list *link_1, **link_2;
Char *txt_1, *txt_2;
Char *generator_txt;
{
  /* , diff */
  t_set_list *diff = NULL;
  t_set_list *q, *p;
  t_set_list *tmp_cs = NULL;
  boolean ok;
  t_vertex_set a, b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnOnlyInFirst  ", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 1273L, 1L, 1L, 1L, &link_1, link_2, &tmp_cs);
  /*$endif TRACE*/
  q = link_1;
  if (*link_2 == NULL) {
    if (link_1 != NULL) {
      copy_set_list(link_1, &diff);
      P_setcpy(a, link_1->vertex_set);
      if (P_setequal(a, empty_set)) {
	if (true) {   /* trace_flag_set(20, 1273, 0) */
	  write_pch(stdout, " (Difference of GC with empty", 29L);
	  write_pch(stdout, " set and empty GC)", 20L);
	  write_line(stdout);
	}
      }
    }
  } else {
    while (q != NULL) {
      P_setcpy(a, q->vertex_set);
      P_setint(a, a, delta_gamma);
      ok = false;
      p = *link_2;
      while (p != NULL && !ok) {
	P_setint(b, p->vertex_set, delta_gamma);
	if (P_setequal(a, b)) {
	  /*  Note: a <= p^.vertex_set */
	  ok = true;
	} else
	  p = p->pointer;
      }
      if (!ok)
	insert_set_in_set_list(a, &diff);
      q = q->pointer;
    }
  }
  ok = (diff == NULL);
  if (!ok) {
    write_pch(stdout, txt_1, 20L);
    write_pch(stdout, txt_2, 20L);
    write_pch(stdout, generator_txt, 10L);
    write_pch(stdout, " Generating classes ", 20L);
    print_g_c(link_1, 0L, line_length);
    write_pch(stdout, " and ", 5L);
    print_g_c(*link_2, 0L, line_length);
    write_pch(stdout, " different", 10L);
    write_pch(stdout, ": ", 2L);
    print_g_c(diff, 0L, line_length);
    write_line(stdout);
  }
  dispose_set_list(&diff);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1273L, 8L, 1L, 1L, ok);
  /*$endif TRACE*/
  return ok;
}  /* return_only_in_first_g_c */


Static Void sub_check_identical_models(model_1, model_2, txt_1, txt_2_)
t_model **model_1, **model_2;
Char *txt_1, *txt_2_;
{
  pch20 txt_2;
  t_set_list *g_c_1_discrete = NULL, *g_c_1_linear = NULL,
	     *g_c_1_quadratic = NULL, *g_c_2_discrete = NULL,
	     *g_c_2_linear = NULL, *g_c_2_quadratic = NULL;
  /* difference : t_link_model; */
  boolean dummy_ok;

  memcpy(txt_2, txt_2_, sizeof(pch20));
  /* erase_model(difference, model_1^.id^.model_type, false); */
  if ((*model_1)->id->model_type == pure_discrete &&
      (*model_2)->id->model_type == pure_discrete) {
    dummy_ok = return_only_in_first_g_c((*model_1)->id->UU.g_c_log_linear,
	&(*model_2)->id->UU.g_c_log_linear, txt_1, txt_2, "LogLinear ");
    /* difference^.id^.g_c_log_linear, */
    return;
  }
  if ((*model_1)->id->model_type == pure_continuous &&
      (*model_2)->id->model_type == pure_continuous) {
    dummy_ok = return_only_in_first_g_c((*model_1)->id->UU.g_c_covariance,
	&(*model_2)->id->UU.g_c_covariance, txt_1, txt_2, "Covariance");
    /* difference^.id^.g_c_covariance, */
    return;
  }
  if (!mixed_data)
    return;
  if ((*model_1)->id->model_type == pure_discrete)
    g_c_1_discrete = (*model_1)->id->UU.g_c_log_linear;
  else {
    if ((*model_1)->id->model_type == pure_continuous)
      g_c_1_quadratic = (*model_1)->id->UU.g_c_covariance;
    else {
      if ((*model_1)->id->model_type == mixed) {
	g_c_1_discrete = (*model_1)->id->UU.U1.g_c_discrete;
	g_c_1_linear = (*model_1)->id->UU.U1.g_c_linear;
	g_c_1_quadratic = (*model_1)->id->UU.U1.g_c_quadratic;
      }
    }
  }
  if ((*model_2)->id->model_type == pure_discrete)
    g_c_2_discrete = (*model_2)->id->UU.g_c_log_linear;
  else {
    if ((*model_2)->id->model_type == pure_continuous) {
      g_c_1_discrete = NULL;
      g_c_1_linear = NULL;
      g_c_2_quadratic = (*model_2)->id->UU.g_c_covariance;
    } else {
      if ((*model_2)->id->model_type == mixed) {
	if ((*model_1)->id->model_type != pure_continuous) {
	  g_c_2_discrete = (*model_2)->id->UU.U1.g_c_discrete;
	  g_c_2_linear = (*model_2)->id->UU.U1.g_c_linear;
	}
	g_c_2_quadratic = (*model_2)->id->UU.U1.g_c_quadratic;
      }
    }
  }
  dummy_ok = return_only_in_first_g_c(g_c_1_discrete, &g_c_2_discrete, txt_1,
				      txt_2, "Discrete  ");
  /* difference^.id^.g_c_discrete, */
  dummy_ok = return_only_in_first_g_c(g_c_1_linear, &g_c_2_linear, txt_1,
				      txt_2, "Linear    ");
  /* difference^.id^.g_c_linear, */
  dummy_ok = return_only_in_first_g_c(g_c_1_quadratic, &g_c_2_quadratic,
				      txt_1, txt_2, "Quadratic ");
  /* difference^.id^.g_c_quadratic, */
}  /* sub_check_identical_models */


Static Void check_identical_models(model_1, model_2, dept, txt_1_)
t_model **model_1, **model_2;
t_long_integer dept;
Char *txt_1_;
{
  pch20 txt_1;

  memcpy(txt_1, txt_1_, sizeof(pch20));
  write_space(stdout, dept);
  write_pch(stdout, "# ", 2L);
  write_pch(stdout, txt_1, 20L);
  write_line(stdout);
  print_model_g_c_and_type(model_1, dept);
  print_model_g_c_and_type(model_2, dept);
  sub_check_identical_models(model_1, model_2, txt_1, " In check  but not  ");
  sub_check_identical_models(model_2, model_1, txt_1, " In result but not  ");
}  /* check_identical_models */


/*Has-forward-1*/

Static Void join_models PP((t_model **new__model, t_model **model_1,
			    t_model **model_2, int identify));

Static Void meet_models PP((t_model **new__model, t_model **model_1,
			    t_model **model_2, int identify));

Static Void restrict_model PP((t_model **new__model, t_model **current_model,
			       int homogeneous, long *a));


/*Has-forward-1*/

Static Void sub_check_decompositions(model, dept, full)
t_model **model;
t_long_integer dept;
boolean *full;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula, *separator;
  t_model *check_model, *left_model, *right_model;
  t_long_integer d_model, d_left, d_right, d_sep, d_check;
  t_vertex_set c;
  boolean full_specified = false, homogeneous = true;
  boolean ok;

  d_model = (*model)->dim;
  if ((*model)->id->model_type == mixed) {
    full_specified = (*model)->id->UU.U1.full_specified;
    homogeneous = (*model)->id->UU.U1.homogeneous;
  }
  write_space(stdout, dept + 2);
  write_pch(stdout, "# ", 2L);
  write_integer(stdout, d_model, 4L);
  write_pch(stdout, "/ ", 2L);
  write_model_type(model);
  write_pch(stdout, ": ", 2L);
  print_vertex_set((*model)->id->vertices);
  write_pch(stdout, " // ", 4L);
  print_model_g_c(model, dept);
  write_line(stdout);
  formula = (*model)->formula_node;
  if (formula == NULL) {
    write_space(stdout, dept + 2);
    write_pch(stdout, "Nil;", 4L);
    write_line(stdout);
    return;
  }
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    decomposition_element = formula->UU.decomposition_node_;
    left_model = decomposition_element->left_model;
    right_model = decomposition_element->right_model;
    separator = decomposition_element->separator;

    new_model(&check_model);
    join_models(&check_model, &left_model, &right_model, false);
    check_identical_models(&check_model, model, dept + 2,
			   " Join of models     ");
    dispose_model_and_link(&check_model);

    new_model(&check_model);
    restrict_model(&check_model, model, homogeneous, left_model->id->vertices);
    check_identical_models(&check_model, &left_model, dept + 2,
			   " Left model         ");
    dispose_model_and_link(&check_model);

    new_model(&check_model);
    restrict_model(&check_model, model, homogeneous,
		   right_model->id->vertices);
    check_identical_models(&check_model, &right_model, dept + 2,
			   " Right model        ");
    dispose_model_and_link(&check_model);

    sub_check_decompositions(&left_model, dept + 1, full);
    sub_check_decompositions(&right_model, dept + 1, full);

    d_left = left_model->dim;
    d_right = right_model->dim;
    d_sep = 0;
    switch (separator->node_type) {

    case d_complete_node:
      /* blank case */
      break;

    case c_complete_node:
      /* blank case */
      break;

    case m_complete_node:
      P_setcpy(c, separator->UU.m_complete_leaf->a);
      update_mixed_dimension_set(&d_sep, &full_specified, &homogeneous, c, 1L);
      write_space(stdout, dept + 3);
      write_pch(stdout, "# ", 2L);
      write_integer(stdout, d_sep, 4L);
      write_pch(stdout, "/  ", 3L);
      write_pch(stdout, "Separator ", 10L);
      write_pch(stdout, ": ", 2L);
      print_vertex_set(c);
      write_line(stdout);
      break;
    }
    d_check = myaddsubi(&d_left, &d_right, &d_sep);
    ok = (d_check == d_model);
    write_space(stdout, dept + 1);
    write_pch(stdout, " | ", 3L);
    write_integer(stdout, d_left, 3L);
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, d_right, 3L);
    write_pch(stdout, " - ", 3L);
    write_integer(stdout, d_sep, 3L);
    write_pch(stdout, " = ", 3L);
    write_integer(stdout, d_check, 3L);
    write_pch(stdout, " / ", 3L);
    write_integer(stdout, d_model, 3L);
    write_pch(stdout, " : ", 3L);
    write_boolean(stdout, ok);
    write_pch(stdout, " / ", 3L);
    if (trace_flag_set(20L, 1203L, 7L))
      print_vertex_set_table(c);

    write_line(stdout);
    break;

  case d_complete_node:
    /* blank case */
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    /* blank case */
    break;

  case r_ips_node:
    /* blank case */
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    /* blank case */
    break;
  }
}  /* sub_check_decompositions */


Static Void check_decompositions(model)
t_model **model;
{
  boolean full;

  sub_check_decompositions(model, 0L, &full);
}  /* check_decompositions */


Static Void print_adj_set(adj_set, a)
t_vertex_set *adj_set;
long *a;
{
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    write_char(stdout, ' ');
    print_vertex(v);
    write_char(stdout, ':');
    if (P_inset(v, a))
      print_vertex_set(adj_set[v - MIN_VERTEX]);
    write_char(stdout, ';');
    write_line(stdout);
  }
}  /* print_adj_set */


/* function extended_g_c(var g_c: t_link_set_list): boolean;
begin
   extended_g_c := boolean_option[85] or
                   subset_of_an_edge(double_vertex_set, g_c)
end; */
/* extended_g_c */

Static Void fix_quadratic_g_c(g_c)
t_set_list **g_c;
{
  t_vertex_set a;
  t_set_list *p;
  t_set_list *q = NULL;

  p = *g_c;
  while (p != NULL) {
    P_setcpy(a, p->vertex_set);
    if (count_continuous(a) == 1) {
      P_setunion(a, a, double_vertex_set);
      insert_clique(a, &q);
    }
    p = p->pointer;
  }
  p = q;
  while (p != NULL) {
    insert_clique(p->vertex_set, g_c);
    q = p->pointer;
    _Free(p);
    p = q;
  }
}  /* fix_quadratic_g_c */


Static boolean quadratic_graphical_wrt_discrete(discrete_g_c, quadratic_g_c,
						full_specified)
t_set_list **discrete_g_c, **quadratic_g_c;
boolean *full_specified;
{
  boolean ok = true;
  t_vertex u, v, w;
  t_vertex_set a, b, c, d, vertex_set;
  t_set_list *p, *q;
  t_v_arr_of_v_sets adj_set;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  hypergraph_sets_to_graph_sets(*quadratic_g_c, vertex_set, adj_set);
  /*$ifdef TRACE*/
  memcpy(tzt, " QuadraticGraphical ", sizeof(pch20));
  if (trace_flag_set(20L, 1277L, 1L)) {
    ntr_g_c(tzt, 20L, 1277L, 1L, 1L, 1L, discrete_g_c);
    ntr_g_c(tzt, 20L, 1277L, 1L, 1L, 2L, quadratic_g_c);
    print_adj_set(adj_set, vertex_set);
  }
  /*$endif TRACE*/
  for (v = first_vertex; v <= last_vertex; v++) {
    if (ok & P_inset(v, gamma_) & P_inset(v, vertex_set)) {
      P_addset(P_expset(a, 0L), v);

      /* 1: Union of a continuous and intersection of neighbors of the
           continuous and a discrete generator subset of quadratic
           generator:*/

      P_setcpy(c, adj_set[v - MIN_VERTEX]);
      P_setint(c, c, delta);
      /*$ifdef TRACE*/
      ntr_set(tzt, 20L, 1277L, 1L, 2L, 1L, a);
      ntr_set(tzt, 20L, 1277L, 1L, 2L, 2L, c);
      /*$endif TRACE*/
      p = *discrete_g_c;
      while (ok && p != NULL) {
	P_setcpy(d, p->vertex_set);
	P_setint(d, d, c);
	P_setunion(d, d, a);
	/*$ifdef TRACE*/
	ntr_set(tzt, 20L, 1277L, 1L, 3L, 1L, p->vertex_set);
	ntr_set(tzt, 20L, 1277L, 1L, 3L, 2L, d);
	ntr_boolean(tzt, 20L, 1277L, 1L, 3L, 3L, true);
	/*$endif TRACE*/
	ok = false;
	q = *quadratic_g_c;
	while (!ok && q != NULL) {
	  ok = P_subset(d, q->vertex_set);
	  /*$ifdef TRACE*/
	  ntr_set(tzt, 20L, 1277L, 1L, 4L, 1L, q->vertex_set);
	  ntr_boolean(tzt, 20L, 1277L, 1L, 4L, 2L, ok);
	  /*$endif TRACE*/
	  q = q->pointer;
	}
	p = p->pointer;
      }

      for (w = v + 1; w <= last_vertex; w++) {
	if (ok & P_inset(w, gamma_) & P_inset(w, adj_set[v - MIN_VERTEX])) {
	  P_addset(P_expset(b, 0L), w);
	  P_setunion(b, b, a);
	  /*$ifdef TRACE*/
	  ntr_set(tzt, 20L, 1277L, 1L, 5L, 1L, b);
	  /*$endif TRACE*/

	  /* 2: Union of two adjacent continuous and intersection of
	       there common neighbors and a discrete generator
	       subset of quadratic generator: */

	  P_setcpy(c, adj_set[v - MIN_VERTEX]);
	  P_setint(c, c, adj_set[w - MIN_VERTEX]);
	  P_setint(c, c, delta);
	  /*$ifdef TRACE*/
	  ntr_set(tzt, 20L, 1277L, 1L, 6L, 1L, c);
	  /*$endif TRACE*/
	  p = *discrete_g_c;
	  while (ok && p != NULL) {
	    P_setcpy(d, p->vertex_set);
	    P_setint(d, d, c);
	    P_setunion(d, d, b);
	    /*$ifdef TRACE*/
	    ntr_set(tzt, 20L, 1277L, 1L, 7L, 1L, p->vertex_set);
	    ntr_set(tzt, 20L, 1277L, 1L, 7L, 2L, d);
	    ntr_boolean(tzt, 20L, 1277L, 1L, 7L, 3L, true);
	    /*$endif TRACE*/
	    ok = false;
	    q = *quadratic_g_c;
	    while (!ok && q != NULL) {
	      ok = P_subset(d, q->vertex_set);
	      /*$ifdef TRACE*/
	      ntr_set(tzt, 20L, 1277L, 1L, 1L, 8L, q->vertex_set);
	      ntr_boolean(tzt, 20L, 1277L, 1L, 8L, 2L, ok);
	      /*$endif TRACE*/
	      q = q->pointer;
	    }
	    p = p->pointer;
	  }

	  /* 3: Clique formed by two continuous neighbors
	       of a discrete a subset of generator: */
	  /*$ifdef TRACE*/
	  ntr_set(tzt, 20L, 1277L, 1L, 10L, 1L, a);
	  /*$endif TRACE*/
	  for (u = first_vertex; u <= last_vertex; u++) {
	    if (ok & P_inset(u, delta)) {
	      if (ok & P_inset(u, adj_set[w - MIN_VERTEX])) {
		if (ok & P_inset(u, adj_set[v - MIN_VERTEX])) {
		  P_addset(P_expset(c, 0L), u);
		  P_setunion(c, c, b);
		  /*$ifdef TRACE*/
		  ntr_set(tzt, 20L, 1277L, 1L, 11L, 1L, c);
		  /*$endif TRACE*/
		  ok = false;
		  p = *quadratic_g_c;
		  while (!ok && p != NULL) {
		    ok = P_subset(c, p->vertex_set);
		    /*$ifdef TRACE*/
		    ntr_set(tzt, 20L, 1277L, 1L, 12L, 1L, p->vertex_set);
		    ntr_boolean(tzt, 20L, 1277L, 1L, 12L, 2L, ok);
		    /*$endif TRACE*/
		    p = p->pointer;
		  }
		}
	      }
	    }
	  }
	}
      }

      /* 4:  Union of continuous and discrete neighbor subset of
            quadratic generator with only the one continuous:*/

      if (*full_specified && ok) {
	for (u = first_vertex; u <= last_vertex; u++) {
	  if (ok & P_inset(u, delta)) {
	    if (ok & P_inset(u, adj_set[v - MIN_VERTEX])) {
	      P_addset(P_expset(b, 0L), u);
	      P_setunion(b, b, a);
	      P_addset(P_expset(c, 0L), double_vertex);
	      P_setunion(c, c, b);
	      /*$ifdef TRACE*/
	      ntr_set(tzt, 20L, 1277L, 1L, 13L, 1L, c);
	      /*$endif TRACE*/
	      ok = false;
	      p = *quadratic_g_c;
	      while (!ok && p != NULL) {
		ok = P_subset(c, p->vertex_set);
		p = p->pointer;
	      }
	    }
	  }
	}
      }
    }
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1277L, 1L, 1L, 14L, ok);
  /*$endif TRACE*/
  return ok;
}  /* quadratic_graphical_wrt_discrete */


Static boolean cliques_subset_of_generators(model, g_c, graphical)
t_model **model;
t_set_list **g_c;
boolean *graphical;
{
  t_set_list *tmp_discrete_g_c, *tmp_linear_g_c, *tmp_quadratic_g_c;
  t_set_list *unfolded_quadratic_g_c = NULL;
  boolean unfold, local_graphical;
  pch20 txt;

  memcpy(txt, " CheckGraphical     ", sizeof(pch20));
  /*$ifdef TRACE*/
  ntr_model_g_c(txt, 20L, 1278L, 1L, 1L, 1L, model);
  ntr_g_c(txt, 20L, 1278L, 1L, 1L, 2L, g_c);
  /*$endif TRACE*/

  /* A simple check that the relevant parts of the cliques
     of the graph are contained in the respectively parts
     of the specification of the model.  (But it is working !!!) */

  local_graphical = *graphical;

  if ((*model)->id->model_type != mixed)
    return local_graphical;

  split_g_c_in_mixed_terms(*g_c, (*model)->id->UU.U1.full_specified,
			   (*model)->id->UU.U1.homogeneous, &tmp_discrete_g_c,
			   &tmp_linear_g_c, &tmp_quadratic_g_c);
  unfold_quadratic(&tmp_quadratic_g_c, &unfolded_quadratic_g_c, &unfold, txt,
		   20L, false, false);
  if (unfold) {
    dispose_set_list(&tmp_quadratic_g_c);
    tmp_quadratic_g_c = unfolded_quadratic_g_c;
  }
  local_graphical = test_sub_g_c(tmp_discrete_g_c,
				 (*model)->id->UU.U1.g_c_discrete);
  /*$ifdef TRACE*/
  ntr_double_g_c(txt, 20L, 1278L, 1L, 2L, 1L,
		 &(*model)->id->UU.U1.g_c_discrete, &tmp_discrete_g_c,
		 local_graphical);
      /*ntr*/
  /*$endif TRACE*/
  if (local_graphical)
    local_graphical = test_sub_g_c(tmp_linear_g_c,
				   (*model)->id->UU.U1.g_c_linear);
  /*$ifdef TRACE*/
  ntr_double_g_c(txt, 20L, 1278L, 1L, 3L, 1L, &(*model)->id->UU.U1.g_c_linear,
		 &tmp_linear_g_c, local_graphical);
      /*ntr*/
  /*$endif TRACE*/
  if (local_graphical)
    local_graphical = test_sub_g_c(tmp_quadratic_g_c,
				   (*model)->id->UU.U1.g_c_quadratic);
  /*$ifdef TRACE*/
  ntr_double_g_c(txt, 20L, 1278L, 1L, 4L, 1L,
		 &(*model)->id->UU.U1.g_c_quadratic, &tmp_quadratic_g_c,
		 local_graphical);
      /*ntr*/
  /*$endif TRACE*/
  if (local_graphical != *graphical &&
      (boolean_option[103] || !boolean_option[101])) {
    begin_error(stdout, 1278L, txt, 20L, false);
    if (dump) {
      write_line_text(dump_file);
      write_pch_20_text(dump_file, " CheckGraphical-1:  ", 20L);
      print_triple_g_c_report(dump_file, &tmp_discrete_g_c, &tmp_linear_g_c,
			      &tmp_quadratic_g_c, 0L);
      write_line_text(dump_file);
      write_pch_20_text(dump_file, " CheckGraphical-2:  ", 20L);
      print_triple_g_c_report(dump_file, &(*model)->id->UU.U1.g_c_discrete,
			      &(*model)->id->UU.U1.g_c_linear,
			      &(*model)->id->UU.U1.g_c_quadratic, 0L);
    }
    write_char(stdout, ':');
    write_line(stdout);
    ntr_boolean(txt, 20L, 1278L, 1L, 5L, 1L, *graphical);
    ntr_boolean(txt, 20L, 1278L, 1L, 5L, 2L, local_graphical);
    write_char(stdout, ' ');
    print_triple_g_c(&tmp_discrete_g_c, &tmp_linear_g_c, &tmp_quadratic_g_c,
		     0L);
    write_line(stdout);
    ntr_model_g_c(txt, 20L, 1278L, 1L, 5L, 3L, model);
    end_error(stdout, 1278L, false);
  }
  dispose_set_list(&tmp_discrete_g_c);
  dispose_set_list(&tmp_linear_g_c);
  dispose_set_list(&tmp_quadratic_g_c);
  return local_graphical;
}  /* cliques_subset_of_generators */


Static Void set_homogeneous_and_graphical(model, g_c, adj_set, mim_model)
t_model **model;
t_set_list **g_c;
t_vertex_set *adj_set;
boolean *mim_model;
{
  t_set_list *g_c_tmp;
  boolean graphical;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " CheckGraphical     ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1279L, 1L, 1L, 0L, model);
  ntr_g_c(tzt, 20L, 1279L, 1L, 1L, 1L, g_c);
  ntr_boolean(tzt, 20L, 1279L, 1L, 1L, 2L, *mim_model);
  /*$endif TRACE*/
  graphical = *mim_model;
  if (graphical)
    graphical = test_graphical(adj_set, g_c);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1279L, 1L, 2L, 1L, graphical);
  /*$endif TRACE*/
  P_setcpy(a, empty_set);
  add_union_of_gc((*model)->id->UU.U1.g_c_quadratic, a);
  P_setdiff(a, a, gamma_);
  P_setdiff(a, a, double_vertex_set);
  (*model)->id->UU.U1.homogeneous = P_setequal(a, empty_set);
  if (graphical) {
    if ((*model)->id->UU.U1.homogeneous) {
      P_setcpy(a, empty_set);
      if ((*model)->id->UU.U1.full_specified || !*mim_model) {
	g_c_tmp = NULL;
	/* 'unfold_quadratic' has formed 2-section egdes! */
	if (false) {
	  add_delta_gamma_cliques((*model)->id->UU.U1.g_c_quadratic, &g_c_tmp);
	  hypergraph_sets_to_graph_sets(g_c_tmp, a, adj_set);
	  /*$ifdef TRACE*/
	  if (trace_flag_set(20L, 1279L, 1L)) {
	    ntr_set_and_g_c(tzt, 20L, 1279L, 1L, 3L, 1L, a, &g_c_tmp);
	    print_adj_set(adj_set, a);
	  }
	  /*$endif TRACE*/
	  graphical = test_graphical(adj_set, &g_c_tmp);
	}
	dispose_set_list(&g_c_tmp);
      } else {
	/* 'unfold_quadratic' has formed 2-section egdes! */
	if (false) {
	  hypergraph_sets_to_graph_sets((*model)->id->UU.U1.g_c_quadratic, a,
					adj_set);
	  /*$ifdef TRACE*/
	  ntr_g_c(tzt, 20L, 1279L, 1L, 4L, 1L,
		  &(*model)->id->UU.U1.g_c_quadratic);
	  /*$endif TRACE*/
	  graphical = test_graphical(adj_set,
				     &(*model)->id->UU.U1.g_c_quadratic);
	}
      }
    } else {
      /* model^.id^.full_specified or not mim_model */
      graphical = test_sub_g_c((*model)->id->UU.U1.g_c_linear,
			       (*model)->id->UU.U1.g_c_quadratic);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1279L, 1L, 5L, -1L, graphical);
      /*$endif TRACE*/
      if (graphical)
	graphical = quadratic_graphical_wrt_discrete(
	    &(*model)->id->UU.U1.g_c_discrete,
	    &(*model)->id->UU.U1.g_c_quadratic,
	    &(*model)->id->UU.U1.full_specified);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1279L, 1L, 5L, -2L, graphical);
      /*$endif TRACE*/
      if (graphical) {
	g_c_tmp = NULL;
	/* 'unfold_quadratic' has formed 2-section egdes! */
	if (false) {
	  if ((*model)->id->UU.U1.full_specified || !*mim_model)
	    add_delta_gamma_cliques((*model)->id->UU.U1.g_c_quadratic,
				    &g_c_tmp);
	  else
	    add_cliques((*model)->id->UU.U1.g_c_quadratic, &g_c_tmp);
	  hypergraph_sets_to_graph_sets(g_c_tmp, a, adj_set);
	  /*$ifdef TRACE*/
	  if (trace_flag_set(20L, 1279L, 1L)) {
	    ntr_g_c(tzt, 20L, 1279L, 1L, 5L, 1L, &g_c_tmp);
	    ntr_g_c(tzt, 20L, 1279L, 1L, 5L, 2L, g_c);
	    ntr_set(tzt, 20L, 1279L, 1L, 5L, 3L, a);
	    print_adj_set(adj_set, a);
	  }
	  /*$endif TRACE*/
	  add_cliques(g_c_tmp, g_c);
	  hypergraph_sets_to_graph_sets(*g_c, a, adj_set);
	  /*$ifdef TRACE*/
	  ntr_g_c(tzt, 20L, 1279L, 1L, 5L, 7L, g_c);
	  /*$endif TRACE*/
	  graphical = test_graphical(adj_set, g_c);
	}
	dispose_set_list(&g_c_tmp);
      }
    }
  }
  /* model^.id^.homogeneous */
  /* if graphical then
  graphical := test_graphical(adj_set, SETS_G_C_TMP) */
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1279L, 1L, 6L, 1L, model);
  ntr_boolean(tzt, 20L, 1279L, 1L, 6L, 2L, graphical);
  /*$endif TRACE*/
  (*model)->graphical = graphical;
}  /* set_homogeneous_and_graphical */


Static Void model_class_mixed(model, adj_set)
t_model **model;
t_vertex_set *adj_set;
{
  t_set_list *g_c = NULL;
  t_vertex_set a;
  boolean mim_model, graphical_check;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ModelClassMixed    ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1280L, 1L, 1L, 1L, model);
  /*$endif TRACE*/
  if ((*model)->id->UU.U1.full_specified)
    mim_model = mim_quadratic_g_c((*model)->id->UU.U1.g_c_quadratic);
  else
    mim_model = true;
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1280L, 1L, 2L, 1L, mim_model);
  /*$endif TRACE*/

  /* Use "test_mixed_model"  from CountMixedModels instead !!! */

  add_cliques((*model)->id->UU.U1.g_c_discrete, &g_c);
  add_cliques((*model)->id->UU.U1.g_c_linear, &g_c);
  hypergraph_sets_to_graph_sets(g_c, a, adj_set);
  set_homogeneous_and_graphical(model, &g_c, adj_set, &mim_model);

  if (true) {
    /* if model^.id^.homogeneous then */
    add_cliques((*model)->id->UU.U1.g_c_quadratic, &g_c);   /* Tjek this ! */
    hypergraph_sets_to_graph_sets(g_c, a, adj_set);
    dispose_set_list(&g_c);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1280L, 1L)) {
      ntr_set(tzt, 20L, 1280L, 1L, 3L, 1L, a);
      ntr_g_c(tzt, 20L, 1280L, 1L, 3L, 2L, &g_c);
      print_adj_set(adj_set, a);
    }
    /*$endif TRACE*/
    if (!P_setequal(a, empty_set))
      find_cliques(adj_set, a, &g_c);
    else
      g_c = NULL;
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 1280L, 1L, 4L, 1L, &g_c);
    /*$endif TRACE*/
    graphical_check = cliques_subset_of_generators(model, &g_c,
						   &(*model)->graphical);
    if (graphical_check != (*model)->graphical)
      (*model)->graphical = graphical_check;
  }
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1280L, 1L, 5L, 1L, model);
  /*$endif TRACE*/
  dispose_set_list(&g_c);
}  /* model_class_mixed */


Static Void identify_mixed_model(model)
t_model **model;
{
  t_vertex v;
  t_vertex_set a;
  t_long_integer dim_0;
  boolean check_decomposable;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_lists fill_in_adj_list, adj_list;
  t_v_arr_of_v_sets adj_set, c;
  t_v_arr_of_boolean complete;
  t_adjacency_matrix discrete_adjacency_matrix, linear_adjacency_matrix,
		     quadratic_adjacency_matrix;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  if ((*model)->id->UU.U1.g_c_discrete == NULL)
    insert_clique(empty_set, &(*model)->id->UU.U1.g_c_discrete);
  /*$ifdef TRACE*/
  memcpy(tzt, " IdentifyMixedModel ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1281L, 1L, 1L, 1L, model);
  /*$endif TRACE*/
  dispose_model_but_identification(model);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1281L, 1L, 2L, 1L, (*model)->id->UU.U1.full_specified);
  /*$endif TRACE*/
  if (!(*model)->id->UU.U1.full_specified)
    (*model)->id->UU.U1.full_specified = subset_of_an_edge(double_vertex_set,
	&(*model)->id->UU.U1.g_c_quadratic);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1281L, 1L, 2L, 2L, (*model)->id->UU.U1.full_specified);
  /*$endif TRACE*/
  if ((*model)->id->UU.U1.full_specified &
      (!subset_of_an_edge(double_vertex_set,
			  &(*model)->id->UU.U1.g_c_quadratic))) {
    fix_quadratic_g_c(&(*model)->id->UU.U1.g_c_quadratic);   /* Hack !!! */
    ntr_model_g_c(tzt, 20L, 1281L, 1L, 3L, 1L, model);
  }
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1281L, 1L, 4L, 1L, model);
  /*$endif TRACE*/
  P_setcpy(a, empty_set);
  add_union_of_gc((*model)->id->UU.U1.g_c_discrete, a);
  add_union_of_gc((*model)->id->UU.U1.g_c_linear, a);
  add_union_of_gc((*model)->id->UU.U1.g_c_quadratic, a);
  P_setdiff(a, a, double_vertex_set);
  if (!P_setequal(a, (*model)->id->vertices))
    note_error_triple_g_c(stdout, 1281L, 1L, " IdentifyMixedMod.: ",
      (*model)->id->UU.U1.g_c_discrete, (*model)->id->UU.U1.g_c_linear,
      (*model)->id->UU.U1.g_c_quadratic, (*model)->id->vertices, a, false);
  if (!incomplete_table) {   /* !!!!!! */
    for (v = first_vertex; v <= last_vertex; v++) {
      order[v - MIN_VERTEX] = 1;
      fill_in_adj_list[v - MIN_VERTEX] = NULL;
      P_setcpy(c[v - MIN_VERTEX], empty_set);
      P_clrbits_B(complete, v - MIN_VERTEX, 0, 3);
    }
    model_class_mixed(model, adj_set);
    adj_set_to_adj_list(adj_set, adj_list);
    marked_lex_m(delta, adj_list, order, invers_order, fill_in_adj_list);
    find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
    dispose_adj_list(fill_in_adj_list);
    (*model)->decomposable = test_for_zero_fill_in(adj_list, order,
						   invers_order);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1281L, 1L, 5L, 1L);
    /*$endif TRACE*/
    if (!(*model)->id->UU.U1.decompose ||
	P_setequal((*model)->id->vertices, empty_set))
    {   /**/
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1281L, 1L, 6L, 1L);
      /*$endif TRACE*/
      insert_in_mixed_node(&(*model)->graphical, (*model)->id->vertices,
	empty_set, false, &(*model)->id->UU.U1.full_specified,
	(*model)->id->UU.U1.homogeneous, &(*model)->id->UU.U1.homogeneous,
	&(*model)->id->UU.U1.g_c_discrete, &(*model)->id->UU.U1.g_c_linear,
	&(*model)->id->UU.U1.g_c_quadratic, &(*model)->formula_node);
      (*model)->dim = find_mixed_dimension((*model)->id->UU.U1.g_c_discrete,
	  (*model)->id->UU.U1.g_c_linear, (*model)->id->UU.U1.g_c_quadratic,
	  (*model)->id->UU.U1.full_specified, (*model)->id->UU.U1.homogeneous,
	  1L);
      P_setdiff(a, delta_gamma, (*model)->id->vertices);
      P_setint(a, a, delta);
      (*model)->constant = 1 / marginal_dimension_real(a);
    }
    /**/
    else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1281L, 1L, 7L, 1L);
      /*$endif TRACE*/
      create_adjacency_matrix(&discrete_adjacency_matrix,
			      (*model)->id->UU.U1.g_c_discrete);
      create_adjacency_matrix(&linear_adjacency_matrix,
			      (*model)->id->UU.U1.g_c_linear);
      create_adjacency_matrix(&quadratic_adjacency_matrix,
			      (*model)->id->UU.U1.g_c_quadratic);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1281L, 1L, 7L, 2L);
      /*$endif TRACE*/
      dim_0 = (*model)->dim;
      (*model)->dimdec = (*model)->dim;
      if (!P_setequal((*model)->id->vertices, empty_set) &&
	  !boolean_option[122]) {
	/*$ifdef TRACE*/
	ntr_model_g_c(tzt, 20L, 1281L, 1L, 8L, 1L, model);
	/*$endif TRACE*/
	decompose_mixed(model, &(*model)->graphical,
	  &(*model)->id->UU.U1.full_specified,
	  &(*model)->id->UU.U1.homogeneous, &discrete_adjacency_matrix,
	  &linear_adjacency_matrix, &quadratic_adjacency_matrix,
	  (*model)->id->vertices, adj_list, adj_set, invers_order, c,
	  complete, &(*model)->constant, &(*model)->dim);
	dim_0 = (*model)->dim;
	(*model)->dimdec = (*model)->dim;
	/*$ifdef TRACE*/
	ntr_model_g_c(tzt, 20L, 1281L, 1L, 8L, 2L, model);
	/*$endif TRACE*/
	(*model)->dim = find_mixed_dimension((*model)->id->UU.U1.g_c_discrete,
	    (*model)->id->UU.U1.g_c_linear, (*model)->id->UU.U1.g_c_quadratic,
	    (*model)->id->UU.U1.full_specified,
	    (*model)->id->UU.U1.homogeneous, 1L);
	if (dim_0 != (*model)->dim) {
	  begin_error(stdout, 1281L, " Dimensioncheck:    ", 20L, false);
	  if (dump)
	    print_triple_g_c_report(dump_file,
	      &(*model)->id->UU.U1.g_c_discrete,
	      &(*model)->id->UU.U1.g_c_linear,
	      &(*model)->id->UU.U1.g_c_quadratic, 0L);
	  write_char(stdout, ' ');
	  print_triple_g_c(&(*model)->id->UU.U1.g_c_discrete,
			   &(*model)->id->UU.U1.g_c_linear,
			   &(*model)->id->UU.U1.g_c_quadratic, 0L);
	  write_line(stdout);
	  write_pch(stdout, " Dimension(raw):      ", 22L);
	  write_integer(stdout, (*model)->dim, 10L);
	  write_line(stdout);
	  write_pch(stdout, " Dimension(decompose):", 22L);
	  write_integer(stdout, dim_0, 10L);
	  write_line(stdout);
	  write_pch(stdout, " Invalid model:   Empty/nested sets?", 36L);
	  write_line(stdout);
	  write_pch(stdout, " DecomposeMixed:  Lost a generator?", 35L);
	  write_line(stdout);
	  write_pch(stdout, " DecomposeMixed:  Submodels homogeneous?", 40L);
	  write_line(stdout);
	  write_pch(stdout, " FindDimension:   Overflow on integers?", 39L);
	  end_error(stdout, 1281L, false);
	  (*model)->found_expression = true;
	  check_decompositions(model);
	  /*$ifdef TRACE*/
	  ntr(tzt, 20L, 1281L, 6L, dim_0, (*model)->dim);
	  ntr_model(tzt, 20L, 1281L, 1L, 9L, -1L, *model);
	  /*$endif TRACE*/
	} else {
	  if (trace_flag_set(20L, 1281L, 7L))
	    check_decompositions(model);
	}
      }
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1281L, 1L, 10L, 1L);
      ntr(tzt, 20L, 1281L, 1L, dim_0, (*model)->dim);
      /*$endif TRACE*/
      delete_edges_with_vertices(&discrete_adjacency_matrix,
				 (*model)->id->vertices);
      delete_edges_with_vertices(&linear_adjacency_matrix,
				 (*model)->id->vertices);
      delete_edges_with_vertices(&quadratic_adjacency_matrix,
				 (*model)->id->vertices);
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1281L, 1L, 12L, 1L);
    /*$endif TRACE*/
    marked_maximum_cardinality_search(delta, adj_list, order, invers_order);
    check_decomposable = marked_test_for_zero_fill_in(delta, adj_list, order,
						      invers_order);
    if (check_decomposable != (*model)->decomposable) {
      note_error_model(stdout, 1281L, 2L, " IdentifyMixedMod.: ", *model,
		       false);
      fill_in_computation(adj_list, order, invers_order, fill_in_adj_list);
      find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
      dispose_adj_list(fill_in_adj_list);
      sub_print_invers_order(invers_order, c, complete);
      write_line(stdout);
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1281L, 1L, 13L, 1L);
    /*$endif TRACE*/
    dispose_adj_list(adj_list);
  }
  (*model)->found_expression = true;
  /*$ifdef TRACE*/
  ntr_expression(tzt, 20L, 1281L, 1L, 14L, 998L, *model);
  /*$endif TRACE*/
  ntr_model_g_c(tzt, 20L, 1281L, 1L, 14L, 999L, model);
}  /* identify_mixed_model */


/*@+"identify.p"*/

/*

1284:    +++  ++
1285:    +++  ++
1286:    ---  -- p/identify.p         3      15     182 p/identify.p
1287: |    5:    procedure sub_join_model
1288: |  167:    procedure join_model_g_c_and_dimension
1289: |  180:    procedure identify_model
1290:    +++  ++
1291:    +++  ++

*/

Static Void sub_join_model(model, model_set, g_c, causal_structure,
			   full_specified, homogeneous, model_type, dimension)
t_model **model;
long *model_set;
t_set_list **g_c, **causal_structure;
boolean *full_specified, *homogeneous;
t_model_type *model_type;
t_long_integer *dimension;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula, *separator;
  t_vertex_set model_set_a, model_set_b;
  t_set_list *g_c_a, *g_c_b, *causal_structure_a, *causal_structure_b;
  boolean full_specified_a, full_specified_b, homogeneous_a, homogeneous_b;
  t_model_type model_type_a, model_type_b;
  t_long_integer dimension_a, dimension_b, dimension_c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubJoinModel       ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1287L, 1L, 0L, 0L, model);
  ntr_model_numbers(tzt, 20L, 1287L, 1L, 0L, 1L, model);
  /*$endif TRACE*/
  formula = (*model)->formula_node;
  if (formula != NULL) {
    if (formula->node_type == decomposition_node) {
      decomposition_element = formula->UU.decomposition_node_;
      separator = decomposition_element->separator;
      g_c_a = NULL;
      sub_join_model(&decomposition_element->left_model, model_set_a, &g_c_a,
		     &causal_structure_a, &full_specified_a, &homogeneous_a,
		     &model_type_a, &dimension_a);
      g_c_b = NULL;
      sub_join_model(&decomposition_element->right_model, model_set_b, &g_c_b,
		     &causal_structure_b, &full_specified_b, &homogeneous_b,
		     &model_type_b, &dimension_b);

      P_setunion(model_set, model_set_a, model_set_b);

      add_cliques(g_c_b, &g_c_a);
      *g_c = g_c_a;
      dispose_set_list(&g_c_b);

      /*$ifdef TRACE*/
      ntr_set_and_g_c(tzt, 20L, 1287L, 1L, 10L, 1L, model_set, g_c);
      /*$endif TRACE*/

      /* *** ToDo: Causal structure *** */
      /* *** ToDo: End. *** */

      *full_specified = (full_specified_a || full_specified_b);
      *homogeneous = (homogeneous_a && homogeneous_b);
      dimension_c = 0;

      if (model_type_a == model_type_b) {
	if (model_type_a == pure_discrete)
	  *model_type = pure_discrete;
	else
	  *model_type = pure_continuous;
      } else
	*model_type = mixed;
      switch (separator->node_type) {

      case null_node:
	write_warning(stdout, " ?: Error in SubJoinModel: NullNode.", 36L);
	break;

      case decomposition_node:
	write_warning(stdout, " ?: Error in SubJoinModel: Decomposition", 40L);
	break;

      case d_complete_node:
	update_discrete_dimension_set(&dimension_c,
				      separator->UU.d_complete_leaf->a, 1L);
	break;

      case c_complete_node:
	update_continuous_dimension_set(&dimension_c,
					separator->UU.c_complete_leaf->a, 1L);
	break;

      case m_complete_node:
	update_mixed_dimension_set(&dimension_c, full_specified, homogeneous,
				   separator->UU.m_complete_leaf->a, 1L);
	break;

      case d_ips_node:
	write_warning(stdout, " ?: Error in SubJoinModel: D-IpsNode.", 37L);
	break;

      case r_ips_node:
	write_warning(stdout, " ?: Error in SubJoinModel: R-IpsNode.", 37L);
	break;

      case c_ips_node:
	write_warning(stdout, " ?: Error in SubJoinModel: C-IpsNode.", 37L);
	break;

      case m_ips_node:
	write_warning(stdout, " ?: Error in SubJoinModel: M-IpsNode.", 37L);
	break;
      }

      *dimension = _INFINITY;
      if (dimension_a < _INFINITY && dimension_b < _INFINITY) {
	*dimension = dimension_a - dimension_c;
	if (dimension_b < _INFINITY - *dimension)
	  *dimension += dimension_b;
	else {
	  warning_begin(stdout, false);
	  write_pch(stdout, " Warning: Dimension to big!!!", 29L);
	  write_line(stdout);
	  write_integer(stdout, dimension_a, 3L);
	  write_pch(stdout, " + ", 3L);
	  write_integer(stdout, dimension_b, 3L);
	  write_pch(stdout, " - ", 3L);
	  write_integer(stdout, dimension_c, 3L);
	  write_pch(stdout, " = ", 3L);
	  write_integer(stdout,
			myaddsubi(&dimension_a, &dimension_b, &dimension_c),
			3L);
	  write_pch(stdout, " ? ", 3L);
	  warning_end(stdout, false);
	}
      }

      /* model^.dim := dimension; */

      /*$ifdef TRACE*/
      ntr_4(tzt, 20L, 1287L, 1L, *dimension, dimension_a, dimension_b,
	    dimension_c);
      /*$endif TRACE*/

      P_setcpy((*model)->id->vertices, model_set);

      /* *** ToDo: Use insert_g_c_in_model ? *** */

      /* if model_type = pure_discrete then begin
         model^.id^.g_c_log_linear := g_c
      end else if (model_type = pure_continuous) and
         not boolean_option[104] then
      begin
         model^.id^.g_c_covariance := g_c
      end else begin
         copy_g_c_to_mixed_graphical_model(g_c, false, homogeneous, model)
      end;
      dispose_g_c_copy_for_mixed_model(model, g_c); */

      /* *** ToDo: End. *** */

    } else {
      P_setcpy(model_set, (*model)->id->vertices);
      *g_c = return_g_c_copy(model);

      /*$ifdef TRACE*/
      ntr_set_and_g_c(tzt, 20L, 1287L, 1L, 20L, 1L, model_set, g_c);
      /*$endif TRACE*/

      /* *** ToDo: Causal structure *** */
      /* *** ToDo: End. *** */

      *full_specified = false;
      *homogeneous = true;
      if ((*model)->id->model_type == mixed) {
	*full_specified = (*model)->id->UU.U1.full_specified;
	*homogeneous = (*model)->id->UU.U1.homogeneous;
      }

      *dimension = _INVALID;
      if ((*model)->dim == _INVALID) {   /* ?!?!?! */
	if ((*model)->id->model_type == pure_discrete)
	  (*model)->dim = find_discrete_dimension(*g_c);
	else if ((*model)->id->model_type == pure_continuous)
	  (*model)->dim = find_continuous_dimension(*g_c);
	else
	  (*model)->dim = _INVALID;
      }
      if ((*model)->dim <= 0 && (*model)->dim != _INVALID) {
	note_error_model(stdout, 1287L, (*model)->dim, " SubJoinModel       ",
			 *model, false);
	ntr(tzt, 20L, 1287L, 7L, 0L, (*model)->dim);
      } else
	*dimension = (*model)->dim;


      dispose_set_list(g_c);
    }
  } else
    *g_c = NULL;

  /*$ifdef TRACE*/
  ntr_set_and_g_c(tzt, 20L, 1287L, 1L, 99L, 1L, model_set, g_c);
  /*$endif TRACE*/


  check_model_constant(model, " ConstantSubJoinM.  ");
}  /* sub_join_model */


Static Void join_model_g_c_and_dimension(model)
t_model **model;
{
  t_vertex_set model_set;
  t_set_list *g_c, *causal_structure;
  boolean full_specified, homogeneous;
  t_model_type model_type;
  t_long_integer dimension;

  sub_join_model(model, model_set, &g_c, &causal_structure, &full_specified,
		 &homogeneous, &model_type, &dimension);
}  /* join_model_g_c_and_dimension */


Static Void identify_model(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IdentifyModel      ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1289L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  if ((*model)->id->model_type == pure_discrete)
    identify_discrete_model(model);
  else if ((*model)->id->model_type == pure_continuous)
    identify_continuous_model(model);
  else if ((*model)->id->model_type == mixed)
    identify_mixed_model(model);
  join_model_g_c_and_dimension(model);
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_model_g_c(tzt, 20L, 1289L, 8L, -1L, 999L, model);
}  /* identify_model */


/*@-"ips.c"*/
/*@+"restrict.p"*/


/*


1292:    +++  ++
1293:    +++  ++
1294:    ---  -- p/restrict.p        16      66     913 p/restrict.p
1295: |    4:    procedure sub_return_atoms_from_formula
1296: |   47:    function return_atoms_from_formula
1297: |   57:    procedure sub_find_node_in_model
1298: |   78:    procedure find_node_in_model
1299: |   88:    procedure sub_do_collapsed_model_from_model
1300: |  143:    procedure do_collapsed_model_from_model
1301: |  168:    procedure return_restricted_discrete_model
1302: |  188:    function collaps_discrete_model
1303: |  210:    procedure return_restricted_mixed_model
1304: |  267:    function collaps_continuous_model
1305: |  292:    function collaps_mixed_model
1306: |  317:    function collaps_model
1307: |  330:    function return_connected_component
1308: |  354:    function return_connected_components
1309: |  377:    procedure return_boundary
1310: |  397:    function marginalize_model
1311:    +++  ++
1312:    +++  ++

*/

Static Void sub_return_atoms_from_formula(link_model, atoms)
t_model **link_model;
t_set_list **atoms;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;

  formula = (*link_model)->formula_node;
  if (formula == NULL)
    return;
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    decomposition_element = formula->UU.decomposition_node_;
    sub_return_atoms_from_formula(&decomposition_element->left_model, atoms);
    sub_return_atoms_from_formula(&decomposition_element->right_model, atoms);
    break;

  case d_complete_node:
    if (formula->UU.d_complete_leaf->factor > 0)   /* vertex_set */
      insert_set_in_set_list(formula->UU.d_complete_leaf->a, atoms);
    break;

  case c_complete_node:
    if (formula->UU.d_complete_leaf->factor > 0)   /* vertex_set */
      insert_set_in_set_list(formula->UU.c_complete_leaf->a, atoms);
    break;

  case m_complete_node:
    if (formula->UU.d_complete_leaf->factor > 0)   /* vertex_set */
      insert_set_in_set_list(formula->UU.m_complete_leaf->a, atoms);
    break;

  case d_ips_node:
    if (!formula->UU.d_ips_leaf->radim_part)
      insert_set_in_set_list(formula->UU.d_ips_leaf->a, atoms);
    break;

  case r_ips_node:
    insert_set_in_set_list(formula->UU.r_ips_leaf->a, atoms);
    break;

  case c_ips_node:
    /* formula^.c_ips_leaf^.upper */
    insert_set_in_set_list((*link_model)->id->vertices, atoms);
    break;

  case m_ips_node:
    /* formula^.m_ips_leaf^.upper */
    insert_set_in_set_list((*link_model)->id->vertices, atoms);
    break;
  }
}  /* sub_return_atoms_from_formula */


/* Not used:
function return_atoms_from_formula
(var link_model : t_link_model): t_link_set_list;
var
   atoms : t_link_set_list;
begin
   atoms := nil;
   sub_return_atoms_from_formula(link_model, atoms);
   return_atoms_from_formula := atoms;
end; */
/* return_atoms_from_formula */

Static Void sub_find_node_in_model(link_model, a, node, found)
t_model **link_model;
long *a;
t_model **node;
boolean *found;
{
  t_decomposition_element *decomposition_element;

  if ((*link_model)->formula_node->node_type == decomposition_node) {
    decomposition_element = (*link_model)->formula_node->UU.decomposition_node_;
    sub_find_node_in_model(&decomposition_element->left_model, a, node, found);
    if (!*found)
      sub_find_node_in_model(&decomposition_element->right_model, a, node,
			     found);
    return;
  }
  if (P_setequal(a, (*link_model)->id->vertices)) {
    *found = true;
    *node = *link_model;
  }
}  /* sub_find_node_in_model */


Static Void find_node_in_model(link_model, a, node, found)
t_model **link_model;
long *a;
t_model **node;
boolean *found;
{
  *node = NULL;
  *found = false;
  sub_find_node_in_model(link_model, a, node, found);
}  /* find_node_in_model */


Static Void sub_do_collapsed_model_from_model(new_model, old_model)
t_model **new_model, **old_model;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;
  t_model *node;
  boolean found, ok;

  if (em)
    write_warning_em(stdout, 1299L, " SubDocollapsedMo.  ");
  formula = (*new_model)->formula_node;
  if (formula == NULL)
    return;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    sub_do_collapsed_model_from_model(&decomposition_element->left_model,
				      old_model);
    sub_do_collapsed_model_from_model(&decomposition_element->right_model,
				      old_model);
    return;
  }
  find_node_in_model(old_model, (*new_model)->id->vertices, &node, &found);
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    if (found)
      formula->UU.d_complete_leaf->offset = node->formula_node->
					    UU.d_complete_leaf->offset;
    else
      formula->UU.d_complete_leaf->offset = return_offset(
	  formula->UU.d_complete_leaf->a, &ok);
	  /* vertex_set */
    break;

  case c_complete_node:   /* ?!?!? */
    break;

  case m_complete_node:   /* ?!?!? */
    break;

  case d_ips_node:
    dispose_d_ips_element(formula->UU.d_ips_leaf);
    _Free(formula->UU.d_ips_leaf);
    formula->UU.d_ips_leaf = node->formula_node->UU.d_ips_leaf;
    break;

  case r_ips_node:
    dispose_r_ips_element(formula->UU.r_ips_leaf);
    _Free(formula->UU.r_ips_leaf);
    formula->UU.r_ips_leaf = node->formula_node->UU.r_ips_leaf;
    break;

  case c_ips_node:
    dispose_c_ips_element(formula->UU.c_ips_leaf);
    _Free(formula->UU.c_ips_leaf);
    formula->UU.c_ips_leaf = node->formula_node->UU.c_ips_leaf;
    break;

  case m_ips_node:
    dispose_m_ips_element(formula->UU.m_ips_leaf);
    _Free(formula->UU.m_ips_leaf);
    formula->UU.m_ips_leaf = node->formula_node->UU.m_ips_leaf;
    break;
  }
}  /* sub_do_collapsed_model_from_model */


Static Void do_collapsed_model_from_model(new_model, old_model)
t_model **new_model, **old_model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DoCollapsedModelFro", sizeof(pch20));
  ntr_model_formula(tzt, 20L, 1300L, 1L, -1L, 1L, *new_model);
  ntr_model_formula(tzt, 20L, 1300L, 1L, -1L, 2L, *old_model);
  /*$endif TRACE*/
  if (!(*new_model)->found_expression)
    identify_model(new_model);
  (*new_model)->found_expression = true;
  (*new_model)->found_ps = (*old_model)->found_ps;
  /*$ifdef TRACE*/
  sub_do_collapsed_model_from_model(new_model, old_model);
  ntr_model_formula(tzt, 20L, 1300L, 8L, -1L, 1L, *new_model);
  ntr_model_formula(tzt, 20L, 1300L, 8L, -1L, 2L, *old_model);
  /*$endif TRACE*/
}  /* do_collapsed_model_from_model */


Static Void return_restricted_discrete_model(new_model, old_model, a)
t_model **new_model, **old_model;
long *a;
{
  t_set_list *p;
  t_vertex_set vertex_set;

  if (mixed_data)
    note_mixed(stdout, " ReturnRestrictedMo.", 20L);
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new_model)->id->causal_structure);
  P_setint((*new_model)->id->vertices, (*old_model)->id->vertices, a);
  p = (*old_model)->id->UU.g_c_log_linear;
  while (p != NULL) {
    P_setint(vertex_set, p->vertex_set, a);
    insert_clique(vertex_set, &(*new_model)->id->UU.g_c_log_linear);
    p = p->pointer;
  }
}  /* return_restricted_discrete_model */


Static boolean collaps_discrete_model(a, model, new_model)
long *a;
t_model **model, **new_model;
{
  t_vertex_set r;

  return_collaps_set(a, model, r);
  if (!P_setequal(r, (*model)->id->vertices)) {
    erase_model(new_model, pure_discrete, true);
    /* copy_ordered_set_list(model^.id^.causal_structure,
                            new_model^.id^.causal_structure); */
    return_restricted_discrete_model(new_model, model, r);
    if (!large)
      do_collapsed_model_from_model(new_model, model);
    return true;
  } else
    return false;
}  /* collaps_discrete_model */


Static Void return_restricted_mixed_model(new_model, old_model, a)
t_model **new_model, **old_model;
long *a;
{
  t_set_list *p;
  t_vertex_set vertex_set, b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnRestMixedMdl ", sizeof(pch20));
  ntr_set(tzt, 20L, 1303L, 1L, -1L, -1L, a);
  /*$endif TRACE*/
  P_setint((*new_model)->id->vertices, (*old_model)->id->vertices, a);
  p = (*old_model)->id->UU.U1.g_c_discrete;
  while (p != NULL) {
    P_setint(vertex_set, p->vertex_set, a);
    insert_clique(vertex_set, &(*new_model)->id->UU.U1.g_c_discrete);
    p = p->pointer;
  }
  p = (*old_model)->id->UU.U1.g_c_linear;
  while (p != NULL) {
    P_setint(vertex_set, p->vertex_set, a);
    P_setint(b, vertex_set, gamma_);
    if (!P_setequal(b, empty_set))
      insert_clique(vertex_set, &(*new_model)->id->UU.U1.g_c_linear);
    p = p->pointer;
  }
  p = (*old_model)->id->UU.U1.g_c_quadratic;
  while (p != NULL) {
    P_setint(vertex_set, p->vertex_set, a);
    P_setint(b, vertex_set, gamma_);
    if (!P_setequal(b, empty_set))
      insert_clique(vertex_set, &(*new_model)->id->UU.U1.g_c_quadratic);
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  ntr_triple_g_c(tzt, 20L, 1303L, 8L, -1L, -1L,
		 &(*new_model)->id->UU.U1.g_c_discrete,
		 &(*new_model)->id->UU.U1.g_c_linear,
		 &(*new_model)->id->UU.U1.g_c_quadratic);
      /*ntr*/
  /*$endif TRACE*/
}  /* return_restricted_mixed_model */


Static boolean collaps_mixed_model(a, model, new_model)
long *a;
t_model **model, **new_model;
{
  t_vertex_set r;

  return_collaps_set(a, model, r);   /* true or */
  if (!P_setequal(r, (*model)->id->vertices)) {
    erase_mixed_model(new_model);
    /* copy_ordered_set_list(model^.id^.causal_structure,
                            new_model^.id^.causal_structure); */
    return_restricted_mixed_model(new_model, model, r);
    /* do_collapsed_model_from_mixed_model(new_model, model) */
    return true;
  } else {
    erase_mixed_model(new_model);
    return_restricted_mixed_model(new_model, model, r);
    return false;
  }
}  /* collaps_mixed_model */


Static boolean collaps_model(a, model, new_model)
long *a;
t_model **model, **new_model;
{
  if (mixed_data && (*model)->id->model_type != pure_discrete) {
    note_mixed(stdout, " CollapsModel", 13L);
    return false;
  } else
    return (collaps_discrete_model(a, model, new_model));
}  /* collaps_model */


Static boolean return_connected_component(b, g_c, components)
long *b;
t_set_list **g_c, **components;
{
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_v_lists adj_list;
  t_vertex_set g, d, a, c;
  t_vertex u;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " RConnectedComponent", sizeof(pch20));
  ntr_set(tzt, 20L, 1307L, 1L, -1L, -1L, b);
  /*$endif TRACE*/
  hypergraph_sets_to_graph_sets(*g_c, g, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  u = first_vertex;
  P_setint(d, b, g);
  P_setcpy(c, empty_set);
  while (u <= last_vertex) {
    while (!P_inset(u, d) && u < last_vertex)
      u++;
    P_setcpy(a, empty_set);
    if (P_inset(u, d)) {
      find_connected_component(g, empty_set, a, &u, adj_list);
      P_addset(a, u);
    }
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1307L, 2L, -1L, -1L, a);
    /*$endif TRACE*/
    P_setunion(c, c, a);
    u++;
  }
  *components = NULL;
  insert_set_in_set_list(c, components);
  dispose_adj_list(adj_list);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1307L, 8L, -1L, -1L, c);
  /*$endif TRACE*/
  return P_subset(b, c);
}  /* return_connected_component */


Static boolean return_connected_components(g_c, components)
t_set_list **g_c, **components;
{
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_v_lists adj_list;
  t_vertex_set g, a;
  t_vertex u;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ConnectedComponents", sizeof(pch20));
  ntr(tzt, 20L, 1308L, 1L, -1L, -1L);
  /*$endif TRACE*/
  hypergraph_sets_to_graph_sets(*g_c, g, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  *components = NULL;
  while (!P_setequal(g, empty_set)) {
    u = first_vertex;
    while (!P_inset(u, g))
      u++;
    P_setcpy(a, empty_set);
    find_connected_component(g, empty_set, a, &u, adj_list);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1308L, 2L, -1L, -1L, a);
    /*$endif TRACE*/
    insert_set_in_set_list(a, components);
    P_setdiff(g, g, a);
  }
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  dispose_adj_list(adj_list);
  return true;
}  /* return_connected_components */


Static boolean marginalize_model(r, old_g_c, a, new_g_c)
long *r;
t_set_list **old_g_c;
long *a;
t_set_list **new_g_c;
{
  t_set_list *p;
  t_set_list *g_c_b = NULL;
  t_set_list *cc;
  t_vertex_set b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  P_setdiff(b, r, a);
  /*$ifdef TRACE*/
  memcpy(tzt, " MarginalizeModel   ", sizeof(pch20));
  ntr_set_and_g_c(tzt, 20L, 1310L, 1L, -1L, -1L, a, old_g_c);
  /*$endif TRACE*/
  *new_g_c = NULL;
  /* return_restricted_gc(new_g_c, old_g_c, a); */
  /* return_restricted_gc(g_c_b, old_g_c, b); */
  return_connected_components(&g_c_b, &cc);
  /*$ifdef TRACE*/
  ntr_triple_g_c(tzt, 20L, 1310L, 2L, -1L, -1L, new_g_c, &g_c_b, &cc);
  /*$endif TRACE*/
  p = cc;
  while (p != NULL) {
    return_boundary(p->vertex_set, b, old_g_c);
    P_setdiff(b, b, p->vertex_set);
    /*$ifdef TRACE*/
    ntr_2_sets(tzt, 20L, 1310L, 3L, -1L, -1L, p->vertex_set, b);
    /*$endif TRACE*/
    insert_clique(b, new_g_c);
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 1310L, 8L, -1L, -1L, new_g_c);
  /*$endif TRACE*/
  dispose_set_list(&g_c_b);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  dispose_set_list(&cc);
  return true;
}  /* marginalize_model */


/*@-"ips.c"*/
/*@+"ips.p"*/


/*

1313:    +++  ++
1314:    +++  ++
1315:    ---  -- p/ips.p         14      58     822 p/ips.p
1316: |    4:    procedure clear_p
1317: |   27:    procedure marginalize_p
1318: |   63:    procedure adjust_from_n
1319: |  107:    procedure adjust_from_p
1320: |  150:    procedure mean_adjust_from_n
1321: |  203:    procedure mean_adjust_from_p
1322: |  255:    procedure clear_estimates
1323: |  278:    procedure update_estimates
1324: |  318:    procedure copy_estimates
1325: |  341:    function find_change
1326: |  357:    procedure ips_em
1327: |  369:    procedure init_table
1328: |  404:    function find_deviance
1329: |  432:    procedure iterate
1330:    +++  ++
1331:    +++  ++

*/

Static Void clear_p(from, size)
t_e_cell_index from, size;
{
  t_e_cell_index index;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1316L, 0L)) {
    write_pch_20_text(stdout, " ClearP:        ", 16L);
    write_e_cell_index_text(stdout, &from, 7L);
    write_e_cell_index_text(stdout, &size, 7L);
    write_line_stdout();
  }
  /*$endif TRACE*/
  for (index = from; index <= from + size - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1316L, 0L)) {
      write_e_cell_index_text(stdout, &index, 5L);
      write_short_real_text(stdout, &p[index], 15L, 10L);
    }
    /*$endif TRACE*/
    p[index] = 0.0;
  }
}  /* clear_p */


Static Void marginalize_p(a, c, c_in_a, from_offset, workspace_offset, m, i)
long *a, *c;
t_fast_next_offset_pack *c_in_a;
t_offset *from_offset;
t_long_integer *workspace_offset;
t_e_cell_index *m;
t_level *i;
{
  t_cell_index index, FORLIM;
  t_long_integer c_index;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1317L, 0L)) {
    write_pch_20_text(stdout, " MarginalizeP:  ", 16L);
    write_offset_text(stdout, from_offset, 7L);
    write_integer_text(stdout, *workspace_offset, 7L);
    write_e_cell_index_text(stdout, m, 5L);
    write_line_stdout();
  }
  /*$endif TRACE*/
  clear_p(*workspace_offset, marginal_dimension(c));
  fast_find_products(a, c, c_in_a);
  c_index = *workspace_offset;
  FORLIM = *from_offset + *m;
  for (index = *from_offset; index <= FORLIM - 1; index++) {
    p[c_index] += p[index];
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1317L, 0L)) {
      write_integer_text(stdout, c_index, 5L);
      write_short_real_text(stdout, &p[c_index], 15L, 10L);
      write_short_real_text(stdout, &p[index], 15L, 10L);
      write_line_stdout();
    }
    /*$endif TRACE*/
    fast_next_offset(c_in_a, &c_index, i);
  }
}  /* marginalize_p */


Static Void adjust_from_n(c_in_a, n_total, atom_offset, index_1, m, delta, i)
t_fast_next_offset_pack *c_in_a;
t_cell_count *n_total;
t_offset *atom_offset;
t_long_integer *index_1;
t_e_cell_index *m, delta;
t_level *i;
{
  t_cell_index index, FORLIM;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1318L, 0L)) {
    write_pch_20_text(stdout, " Adjust from N: ", 16L);
    write_offset_text(stdout, atom_offset, 10L);
    write_integer_text(stdout, *index_1, 7L);
    write_e_cell_index_text(stdout, m, 5L);
    write_e_cell_index_text(stdout, &delta, 7L);
    write_line_stdout();
  }
  FORLIM = *atom_offset + *m;
  /*$endif TRACE*/
  for (index = *atom_offset; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1318L, 0L)) {
      write_short_real_text(stdout, &p[index], 15L, 10L);
      write_short_real_text(stdout, &p[*index_1], 15L, 10L);
      write_cell_count_text(stdout, &n[delta + *index_1], 10L);
      write_real_text(stdout, (double)n[delta + *index_1] / *n_total, 15L,
		      10L);
    }
    /*$endif TRACE*/
    if (p[*index_1] != 0)
      p[index] *= (double)n[delta + *index_1] / *n_total / p[*index_1];
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1318L, 0L)) {
      write_short_real_text(stdout, &p[index], 15L, 10L);
      write_line_stdout();
    }
    /*$endif TRACE*/
    fast_next_offset(c_in_a, index_1, i);
  }
  *index_1 -= FIRST_INDEX;
}  /* adjust_from_n */


Static Void adjust_from_p(c_in_a, n_total, atom_offset, index_1, m, delta, i)
t_fast_next_offset_pack *c_in_a;
t_cell_count n_total;
t_offset *atom_offset;
t_long_integer *index_1;
t_e_cell_index *m, delta;
t_level *i;
{
  t_cell_index index, FORLIM;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1319L, 0L)) {
    write_pch_20_text(stdout, " Adjust from P: ", 16L);
    write_offset_text(stdout, atom_offset, 10L);
    write_integer_text(stdout, *index_1, 7L);
    write_e_cell_index_text(stdout, m, 5L);
    write_e_cell_index_text(stdout, &delta, 7L);
    write_line_stdout();
  }
  FORLIM = *atom_offset + *m;
  /*$endif TRACE*/
  for (index = *atom_offset; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1319L, 0L)) {
      write_short_real_text(stdout, &p[index], 15L, 10L);
      write_short_real_text(stdout, &p[*index_1], 15L, 10L);
      write_real_text(stdout, p[delta + *index_1] / n_total, 15L, 10L);
    }
    /*$endif TRACE*/
    if (p[*index_1] != 0)
      p[index] *= p[delta + *index_1] / n_total / p[*index_1];
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1319L, 0L)) {
      write_short_real_text(stdout, &p[index], 15L, 10L);
      write_line_stdout();
    }
    /*$endif TRACE*/
    fast_next_offset(c_in_a, index_1, i);
  }
  *index_1 -= FIRST_INDEX;
}  /* adjust_from_p */


Static Void mean_adjust_from_n(c_in_a, n_total, atom_offset, index_1,
			       mean_offset, m, delta, i)
t_fast_next_offset_pack *c_in_a;
t_cell_count *n_total;
t_offset *atom_offset;
t_long_integer *index_1;
t_e_cell_index *mean_offset, *m, delta;
t_level *i;
{
  t_cell_index index, mean_index, FORLIM;
  t_long_real x;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1320L, 0L)) {
    write_pch_20_text(stdout, " Adjust from N: ", 16L);
    write_line_stdout();
  }
  FORLIM = *atom_offset + *m;
  /*$endif TRACE*/
  for (index = *atom_offset; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1320L, 0L)) {
      write_short_real_text(stdout, &p[index], 15L, 10L);
      write_short_real_text(stdout, &p[*index_1], 15L, 10L);
      write_cell_count_text(stdout, &n[delta + *index_1], 10L);
      write_real_text(stdout, (double)n[delta + *index_1] / *n_total, 15L,
		      10L);
    }
    /*$endif TRACE*/
    if (p[*index_1] != 0) {
      x = p[index] * ((double)n[delta + *index_1] / *n_total / p[*index_1]);
      mean_index = *mean_offset + index - *atom_offset;
      switch (mean_ips_in_use) {

      case arithmetic:
	p[mean_index] += x;
	break;

      case geometric:
	p[mean_index] *= x;
	break;

      case harmonic:
	if (x == 0)
	  p[mean_index] = 0.0;
	else
	  p[mean_index] += 1 / x;
	break;
      }
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1320L, 0L))
      write_short_real_text(stdout, &p[mean_index], 15L, 10L);
    /*$endif TRACE*/
    fast_next_offset(c_in_a, index_1, i);
  }
  *index_1 -= FIRST_INDEX;
}  /* mean_adjust_from_n */


Static Void mean_adjust_from_p(c_in_a, n_total, atom_offset, index_1,
			       mean_offset, m, delta, i)
t_fast_next_offset_pack *c_in_a;
t_cell_count n_total;
t_offset *atom_offset;
t_long_integer *index_1;
t_e_cell_index *mean_offset, *m, delta;
t_level *i;
{
  t_cell_index index, mean_index, FORLIM;
  t_long_real x;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1321L, 0L)) {
    write_pch_20_text(stdout, " Adjust from P: ", 16L);
    write_line_stdout();
  }
  FORLIM = *atom_offset + *m;
  /*$endif TRACE*/
  for (index = *atom_offset; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1321L, 0L)) {
      write_short_real_text(stdout, &p[index], 15L, 10L);
      write_short_real_text(stdout, &p[*index_1], 15L, 10L);
      write_real_text(stdout, p[delta + *index_1] / n_total, 15L, 10L);
    }
    /*$endif TRACE*/
    if (p[*index_1] != 0) {
      x = p[index] * (p[delta + *index_1] / n_total / p[*index_1]);
      mean_index = *mean_offset + index - *atom_offset;
      switch (mean_ips_in_use) {

      case arithmetic:
	p[mean_index] += x;
	break;

      case geometric:
	p[mean_index] *= x;
	break;

      case harmonic:
	if (x == 0)
	  p[mean_index] = 0.0;
	else
	  p[mean_index] += 1 / x;
	break;
      }
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1321L, 0L))
      write_short_real_text(stdout, &p[mean_index], 15L, 10L);
    /*$endif TRACE*/
    fast_next_offset(c_in_a, index_1, i);
  }
  *index_1 -= FIRST_INDEX;
}  /* mean_adjust_from_p */


Static Void clear_estimates(mean_offset, m)
t_e_cell_index *mean_offset, *m;
{
  t_e_cell_index index, FORLIM;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1322L, 0L)) {
    write_pch_20_text(stdout, " ClearEstimates:", 16L);
    write_line_stdout();
  }
  FORLIM = *m;
  /*$endif TRACE*/
  for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1322L, 0L))
      write_short_real_text(stdout, &p[index], 15L, 10L);
    /*$endif TRACE*/
    if (mean_ips_in_use == geometric)
      p[*mean_offset + index] = 1.0;
    else
      p[*mean_offset + index] = 0.0;
  }
}  /* clear_estimates */


Static Void update_estimates(count, atom_offset, mean_offset, m)
t_long_integer *count;
t_offset *atom_offset;
t_e_cell_index *mean_offset, *m;
{
  t_e_cell_index index, FORLIM;
  t_long_real x;
  t_long_real sum = 0.0;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1323L, 0L)) {
    write_pch_20_text(stdout, " UpdateEstimates: ", 18L);
    write_line_stdout();
  }
  FORLIM = *m;
  /*$endif TRACE*/
  for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1323L, 0L)) {
      write_short_real_text(stdout, &p[*mean_offset + index], 15L, 10L);
      write_short_real_text(stdout, &p[*atom_offset + index], 15L, 10L);
    }
  }
  /*$endif TRACE*/
  if (p[*mean_offset + index] == 0)
    p[*atom_offset + index] = 0.0;
  else {
    switch (mean_ips_in_use) {

    case arithmetic:
      x = p[*mean_offset + index] / *count;
      break;

    case geometric:
      x = exp(log(p[*mean_offset + index]) / *count);
      break;

    case harmonic:
      x = *count / p[*mean_offset + index];
      break;
    }
    p[*atom_offset + index] = x;
    sum += x;
  }
  FORLIM = *atom_offset + *m;
  for (index = *atom_offset; index <= FORLIM - 1; index++)
    p[index] /= sum;
}  /* update_estimates */


Static Void copy_estimates(atom_offset, copy_offset, m)
t_offset *atom_offset;
t_e_cell_index *copy_offset, *m;
{
  t_e_cell_index index, FORLIM;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1324L, 0L))
    write_pch_20_text(stdout, " CopyEstimates: ", 16L);
  FORLIM = *m;
  /*$endif TRACE*/
  for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1324L, 0L)) {
      write_integer_text(stdout, *copy_offset + index, 5L);
      write_short_real_text(stdout, &p[*copy_offset + index], 15L, 10L);
      write_integer_text(stdout, *atom_offset + index, 5L);
      write_short_real_text(stdout, &p[*atom_offset + index], 15L, 10L);
    }
    /*$endif TRACE*/
    p[*copy_offset + index] = p[*atom_offset + index];
  }
}  /* copy_estimates */


Static t_long_real find_change(atom_offset, copy_offset, m)
t_offset *atom_offset;
t_e_cell_index *copy_offset, *m;
{
  t_long_real d = 0.0;
  t_e_cell_index index, FORLIM;
  t_long_real cell_d;

  FORLIM = *m;
  for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
    cell_d = fabs(p[*atom_offset + index] - p[*copy_offset + index]);
    if (cell_d > d)
      d = cell_d;
  }
  return d;
}  /* find_change */


Local Void init_table(atom_offset, m, a, link_q_tables)
t_offset *atom_offset;
t_e_cell_index *m;
long *a;
t_offset_list **link_q_tables;
{
  t_cell i;
  t_e_cell_index index, FORLIM;

  if (!incomplete_table) {
    FORLIM = *m;
    for (index = FIRST_INDEX; index <= FORLIM - 1; index++)
      p[*atom_offset + index] = 1.0 / *m;
    return;
  }
  if (initial_values_for_ips) {
    memcpy(i, first_cell, sizeof(t_cell));
    FORLIM = *m;
    for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
      p[*atom_offset + index] = (double)return_marginal_q_cell(a, i,
				  *link_q_tables) / *m;
      write_short_real_text(report_file, &p[*atom_offset + index], 10L, 5L);
      if (index % 10 == 0)
	write_line_text(report_file);
      next_marginal_cell(a, i);
    }
    write_line_text(report_file);
    return;
  }
  memcpy(i, first_cell, sizeof(t_cell));
  FORLIM = *m;
  for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
    if (marginal_zero_cell(a, i, *link_q_tables))
      p[*atom_offset + index] = 0.0;
    else
      p[*atom_offset + index] = 1.0 / *m;
    next_marginal_cell(a, i);
  }
}  /* init_table */

Local t_long_real find_deviance(atom_offset, m, n_offset)
t_offset *atom_offset;
t_e_cell_index *m;
t_offset *n_offset;
{
  double Result;
  t_long_real l1 = 0.0;
  t_e_cell_index n_m_p_off, index, FORLIM;

  n_m_p_off = *n_offset - *atom_offset;
  if (em) {
    FORLIM = *atom_offset + *m;
    for (index = *atom_offset; index <= FORLIM - 1; index++) {
      if (p[index] != 0)
	l1 += p[n_m_p_off + index] * log(p[index]);
    }
  } else {
    FORLIM = *atom_offset + *m;
    for (index = *atom_offset; index <= FORLIM - 1; index++) {
      if (p[index] != 0)
	l1 += n[n_m_p_off + index] * log(p[index]);
    }
  }
  Result = l1;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1328L, 0L)) {
    /*$endif TRACE*/
    write_real_text(stdout, l1, 15L, 7L);
  }
  return Result;
}  /* find_deviance */

Local Void iterate(atom_offset, m, workspace_offset, copy_offset, mean_offset,
		   n_offset, gc, a, n_total, cycle_number, d, l1, l2)
t_offset *atom_offset;
t_e_cell_index *m;
t_long_integer *workspace_offset;
t_e_cell_index *copy_offset, *mean_offset;
t_offset *n_offset;
t_ips_set_list *gc;
long *a;
t_cell_count *n_total;
t_long_integer *cycle_number;
t_long_real *d, *l1, *l2;
{
  t_fast_next_offset_pack c_in_a;
  t_cell i;
  t_long_integer count = 0;

  memcpy(i, first_cell, sizeof(t_cell));
  (*cycle_number)++;
  if (ips_in_use == 1)
    copy_estimates(atom_offset, copy_offset, m);
  else
    *l2 = *l1;
  if (mean_ips_in_use != normal_ips)
    clear_estimates(mean_offset, m);
  while (gc != NULL) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1329L, 0L)) {
      write_pch_20_text(stdout, " Generator:     ", 16L);
      write_integer_text(stdout, *atom_offset, 10L);
      write_e_cell_index_text(stdout, m, 5L);
      write_integer_text(stdout, *workspace_offset, 7L);
      write_e_cell_index_text(stdout, copy_offset, 7L);
      print_vertex_set_on_report(stdout, gc->vertex_set);
      write_line_stdout();
    }
    /*$endif TRACE*/
    marginalize_p(a, gc->vertex_set, &c_in_a, atom_offset, workspace_offset,
		  m, i);
    if (mean_ips_in_use == normal_ips) {
      if (em)
	adjust_from_p(&c_in_a, *n_total, atom_offset, workspace_offset, m,
		      gc->n_offset - *workspace_offset, i);
      else
	adjust_from_n(&c_in_a, n_total, atom_offset, workspace_offset, m,
		      gc->n_offset - *workspace_offset, i);
    } else if (em)
      mean_adjust_from_p(&c_in_a, *n_total, atom_offset, workspace_offset,
			 mean_offset, m, gc->n_offset - *workspace_offset, i);
    else
      mean_adjust_from_n(&c_in_a, n_total, atom_offset, workspace_offset,
			 mean_offset, m, gc->n_offset - *workspace_offset, i);
    count++;
    gc = gc->pointer;
  }
  if (mean_ips_in_use != normal_ips)
    update_estimates(&count, atom_offset, mean_offset, m);
  if (ips_in_use == 1)
    *d = find_change(atom_offset, copy_offset, m);
  else {
    *l1 = find_deviance(atom_offset, m, n_offset);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1329L, 0L)) {
      write_pch_20_text(stdout, " Likelihood: ", 13L);
      write_real_text(stdout, *l1, 20L, 10L);
    }
    /*$endif TRACE*/
    *d = *l2 - *l1;
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1329L, 0L))
    return;
  /*$endif TRACE*/
  write_pch_10_text(stdout, " Delta: ", 8L);
  write_real_text(stdout, *d, 20L, 10L);
  write_line_stdout();
}  /* iterate */


Static Void ips_em(ips_element, n_total, ips_epsilon, max_cycle_number, init)
t_ips_element *ips_element;
t_cell_count *n_total;
t_long_real ips_epsilon;
t_long_integer *max_cycle_number;
boolean init;
{
  t_offset atom_offset;
  t_long_integer workspace_offset;
  t_e_cell_index m, copy_offset, mean_offset;
  t_long_integer cycle_number = 0;
  t_long_real start_clock, d, l1, l2;

  start_clock = my_clock()/1;
  atom_offset = ips_element->p_offset;
  if (*max_cycle_number <= 0) {
    warning_ips(ips_element->gen_class);
    return;
  }
  m = marginal_dimension(ips_element->a);
  if (init)
    init_table(&atom_offset, &m, ips_element->a, &ips_element->link_q_tables);
  if (em) {
    workspace_offset = fpa;
    copy_offset = max_p_cell_number - m;
    mean_offset = max_p_cell_number - m - m;
  } else {
    if (ips_in_use == 1) {
      copy_offset = atom_offset + m;
      workspace_offset = atom_offset + m + m;
    } else
      workspace_offset = atom_offset + m;
    mean_offset = max_p_cell_number - m;
  }
  d = 2 * ips_epsilon;
  if (ips_in_use != 1)
    l1 = find_deviance(&atom_offset, &m, &ips_element->n_offset);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1329L, 0L))
    write_line_stdout();
  /*$endif TRACE*/
  while (fabs(d) > ips_epsilon && cycle_number < *max_cycle_number &&
	 !interrupt_1)
    iterate(&atom_offset, &m, &workspace_offset, &copy_offset, &mean_offset,
	    &ips_element->n_offset, ips_element->gen_class, ips_element->a,
	    n_total, &cycle_number, &d, &l1, &l2);
  if (fabs(d) > ips_epsilon)
    no_ips_convergence(ips_element->gen_class, &cycle_number, &d);
  report_ips(ips_element->gen_class, ips_element->a, &cycle_number,
	     &start_clock, &d, &ips_epsilon);
}  /* ips_em */


Local t_long_real find_deviance_(radim_element, workspace_offset)
t_radim_element *radim_element;
t_long_integer *workspace_offset;
{
  double Result;
  t_fast_next_offset_pack c_in_a;
  t_cell i;
  t_long_real l1 = 0.0;
  t_e_cell_index p_offset, n_offset, index;
  t_vertex_set a;
  t_offset_list *upper, *lower;
  t_integer_list *lower_n;
  t_e_cell_index m;
  boolean ok = false;
  t_e_cell_index FORLIM;

  memcpy(i, first_cell, sizeof(t_cell));
  upper = radim_element->radim_parts->upper;
  lower = radim_element->radim_parts->lower;
  lower_n = radim_element->lower_n_offsets;
  while (upper != NULL) {
    P_setunion(a, upper->vertex_set, lower->vertex_set);
    p_offset = upper->offset;
    n_offset = lower->offset;
    m = marginal_dimension(a);
    if (em) {
      for (index = p_offset; index <= p_offset + m - 1; index++) {
	if (p[index] != 0)
	  l1 += p[n_offset - p_offset + index] * log(p[index]);
      }
    } else {
      for (index = p_offset; index <= p_offset + m - 1; index++) {
	if (p[index] != 0)
	  l1 += n[n_offset - p_offset + index] * log(p[index]);
      }
    }
    if (ok && !fast) {
      marginalize_p(a, lower->vertex_set, &c_in_a, &upper->offset,
		    workspace_offset, &m, i);
      m = marginal_dimension(lower->vertex_set);
      n_offset = lower_n->x;
      if (em) {
	FORLIM = *workspace_offset + m;
	for (index = *workspace_offset; index <= FORLIM - 1; index++) {
	  if (p[index] != 0)
	    l1 -= p[n_offset - *workspace_offset + index] * log(p[index]);
	}
      } else {
	FORLIM = *workspace_offset + m;
	for (index = *workspace_offset; index <= FORLIM - 1; index++) {
	  if (p[index] != 0)
	    l1 -= n[n_offset - *workspace_offset + index] * log(p[index]);
	}
      }
    } else
      ok = true;
    upper = upper->pointer;
    lower = lower->pointer;
    lower_n = lower_n->pointer;
  }
  Result = l1;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1336L, 0L)) {
    write_real_text(stdout, l1, 20L, 10L);
    write_char_text(stdout, '.');
  }
  /*$endif TRACE*/
  return Result;
}  /* find_deviance */

Local Void iterate_(radim_element, first_offset, total_size, workspace_offset,
		    copy_offset, n_total, cycle_number, d, l1, l2)
t_radim_element *radim_element;
t_offset *first_offset;
t_e_cell_index *total_size;
t_long_integer *workspace_offset;
t_e_cell_index *copy_offset;
t_cell_count *n_total;
t_long_integer *cycle_number;
t_long_real *d, *l1, *l2;
{
  t_fast_next_offset_pack c_in_a;
  t_radim_part *radim_part;
  t_offset_list *link_clique, *upper, *lower, *from;
  t_vertex_set a;
  t_e_cell_index m;
  t_long_integer q_hat_offset;
  t_cell i;

  memcpy(i, first_cell, sizeof(t_cell));
  (*cycle_number)++;
  if (ips_in_use == 1)
    copy_estimates(first_offset, copy_offset, total_size);
  else
    *l2 = *l1;
  radim_part = radim_element->radim_parts;
  while (radim_part != NULL) {
    link_clique = radim_part->generators;
    while (link_clique != NULL) {
      upper = radim_part->upper;
      lower = radim_part->lower;
      from = radim_part->from;
      P_setunion(a, upper->vertex_set, lower->vertex_set);
      m = marginal_dimension(a);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1337L, 0L)) {
	write_pch_20_text(stdout, " Generator: @@@@@@@ ", 13L);
	print_vertex_set_on_report(stdout, link_clique->vertex_set);
	write_pch_20_text(stdout, "    Upper( @@@@@@@@ ", 12L);
	write_integer(stdout, upper->offset, 7L);
	write_pch_10_text(stdout, "):@@@@@@@ ", 3L);
	print_vertex_set_on_report(stdout, upper->vertex_set);
	write_pch_10_text(stdout, "  Lower:  ", 10L);
	print_vertex_set_on_report(stdout, lower->vertex_set);
	write_line_text(stdout);
      }
      /*$endif TRACE*/
      marginalize_p(a, link_clique->vertex_set, &c_in_a, &upper->offset,
		    workspace_offset, &m, i);
      if (em)
	adjust_from_p(&c_in_a, *n_total, &upper->offset, workspace_offset, &m,
		      link_clique->offset - *workspace_offset, i);
      else
	adjust_from_n(&c_in_a, n_total, &upper->offset, workspace_offset, &m,
		      link_clique->offset - *workspace_offset, i);
      from = from->pointer;
      upper = upper->pointer;
      lower = lower->pointer;
      while (upper != NULL) {
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1337L, 0L)) {
	  write_pch_10_text(stdout, " Upper(@@ ", 8L);
	  write_integer(stdout, upper->offset, 7L);
	  write_pch_10_text(stdout, "):@@@@@@@ ", 3L);
	  print_vertex_set_on_report(stdout, upper->vertex_set);
	  write_pch_10_text(stdout, " Lower(@@ ", 8L);
	  write_integer(stdout, from->offset, 7L);
	  write_pch_10_text(stdout, "):@@@@@@@ ", 3L);
	  print_vertex_set_on_report(stdout, lower->vertex_set);
	  write_pch_10_text(stdout, "  From: ", 8L);
	  print_vertex_set_on_report(stdout, from->vertex_set);
	  write_line_text(stdout);
	}
	/*$endif TRACE*/
	P_setcpy(a, from->vertex_set);
	m = marginal_dimension(a);
	q_hat_offset = *workspace_offset + marginal_dimension(lower->vertex_set);
	marginalize_p(a, lower->vertex_set, &c_in_a, &from->offset,
		      &q_hat_offset, &m, i);
	P_setunion(a, upper->vertex_set, lower->vertex_set);
	m = marginal_dimension(a);
	marginalize_p(a, lower->vertex_set, &c_in_a, &upper->offset,
		      workspace_offset, &m, i);
	adjust_from_p(&c_in_a, 1L, &upper->offset, workspace_offset, &m,
		      q_hat_offset - *workspace_offset, i);
	from = from->pointer;
	upper = upper->pointer;
	lower = lower->pointer;
      }
      link_clique = link_clique->pointer;
    }
    radim_part = radim_part->pointer;
  }
  if (ips_in_use == 1)
    *d = find_change(first_offset, copy_offset, total_size);
  else {
    *l1 = find_deviance_(radim_element, workspace_offset);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1337L, 0L)) {
      write_pch_20_text(stdout, " Likelihood: ", 13L);
      write_real_text(stdout, *l1, 20L, 10L);
    }
    /*$endif TRACE*/
    *d = *l2 - *l1;
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1337L, 0L))
    return;
  /*$endif TRACE*/
  write_pch_10_text(stdout, " Delta: ", 8L);
  write_real_text(stdout, *d, 20L, 10L);
  write_line_text(stdout);
}  /* iterate */

Local Void adjust_by_denominator(c_in_a, atom_offset, index_1, m, i)
t_fast_next_offset_pack *c_in_a;
t_offset *atom_offset;
t_long_integer index_1;
t_e_cell_index m;
t_level *i;
{
  t_cell_index index, FORLIM;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1338L, 0L)) {
    write_pch_30_text(stdout, " Adjust by Denominator: ", 24L);
    write_line_text(stdout);
  }
  FORLIM = *atom_offset + m;
  /*$endif TRACE*/
  for (index = *atom_offset; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1338L, 0L)) {
      write_short_real_text(stdout, &p[index_1], 15L, 10L);
      write_short_real_text(stdout, &p[index], 15L, 10L);
    }
    /*$endif TRACE*/
    if (p[index_1] != 0)
      p[index] /= p[index_1];
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1338L, 0L)) {
      write_short_real_text(stdout, &p[index], 15L, 10L);
      write_line_text(stdout);
    }
    /*$endif TRACE*/
    fast_next_offset(c_in_a, &index_1, i);
  }
}  /* adjust_by_denominator */

Local Void final_adjustment(radim_element, workspace_offset)
t_radim_element *radim_element;
t_long_integer *workspace_offset;
{
  t_fast_next_offset_pack c_in_a;
  t_offset_list *upper, *lower;
  t_vertex_set a;
  t_e_cell_index m;
  t_cell i;

  memcpy(i, first_cell, sizeof(t_cell));
  if (radim_element->radim_parts == NULL)
    return;
  upper = radim_element->radim_parts->upper->pointer;
  lower = radim_element->radim_parts->lower->pointer;
  while (upper != NULL) {
    P_setunion(a, upper->vertex_set, lower->vertex_set);
    m = marginal_dimension(a);
    marginalize_p(a, lower->vertex_set, &c_in_a, &upper->offset,
		  workspace_offset, &m, i);
    adjust_by_denominator(&c_in_a, &upper->offset, *workspace_offset, m, i);
    upper = upper->pointer;
    lower = lower->pointer;
  }
}  /* final_adjustment */

Local Void init_tables(radim_element, first_offset, total_size, link_q_tables)
t_radim_element *radim_element;
t_offset *first_offset;
t_e_cell_index *total_size;
t_offset_list **link_q_tables;
{
  t_cell i;
  t_e_cell_index p_offset, index;
  t_vertex_set a;
  t_offset_list *upper, *lower;
  t_offset m;

  *total_size = 0;
  upper = radim_element->radim_parts->upper;
  lower = radim_element->radim_parts->lower;
  *first_offset = upper->offset;
  while (upper != NULL) {
    P_setunion(a, upper->vertex_set, lower->vertex_set);
    p_offset = upper->offset;
    if (p_offset < *first_offset)
      *first_offset = p_offset;
    m = marginal_dimension(a);
    *total_size += m;
    if (incomplete_table) {
      if (initial_values_for_ips) {
	memcpy(i, first_cell, sizeof(t_cell));
	for (index = FIRST_INDEX; index <= m - 1; index++) {
	  p[p_offset + index] = (double)return_marginal_q_cell(a, i,
				  *link_q_tables) / m;
	  write_short_real_text(report_file, &p[p_offset + index], 10L, 5L);
	  if (index % 10 == 0)
	    write_line_text(report_file);
	  next_marginal_cell(a, i);
	}
	write_line_text(report_file);
      } else {
	memcpy(i, first_cell, sizeof(t_cell));
	for (index = FIRST_INDEX; index <= m - 1; index++) {
	  if (marginal_zero_cell(a, i, *link_q_tables))
	    p[p_offset + index] = 0.0;
	  else
	    p[p_offset + index] = 1.0 / m;
	  next_marginal_cell(a, i);
	}
      }
    } else {
      for (index = FIRST_INDEX; index <= m - 1; index++)
	p[p_offset + index] = 1.0 / m;
    }
    upper = upper->pointer;
    lower = lower->pointer;
  }
}  /* init_tables */


/*@+"dips.p"*/


/*

1332:    +++  ++
1333:    +++  ++
1334:    ---  -- p/dips.p          6      24     393 p/dips.p
1335: |    4:    procedure decomposed_ips_em
1336: |   16:    function find_deviance
1337: |   86:    procedure iterate
1338: |  200:    procedure adjust_by_denominator
1339: |  234:    procedure final_adjustment
1340: |  260:    procedure init_tables
1341:    +++  ++
1342:    +++  ++

*/

Static Void decomposed_ips_em(radim_element, n_total, ips_epsilon,
			      max_cycle_number, init)
t_radim_element *radim_element;
t_cell_count *n_total;
t_long_real *ips_epsilon;
t_long_integer *max_cycle_number;
boolean init;
{
  t_offset first_offset;
  t_e_cell_index total_size, copy_offset;
  t_long_integer workspace_offset;
  t_long_integer cycle_number = 0;
  t_long_real start_clock, d, l1, l2;

  start_clock = my_clock()/1;
  if (*max_cycle_number <= 0) {
    warning_ips(radim_element->gen_class);
    return;
  }
  if (init)
    init_tables(radim_element, &first_offset, &total_size,
		&radim_element->link_q_tables);
  workspace_offset = fpa;
  copy_offset = max_p_cell_number - total_size;
  if (ips_in_use != 1)
    l1 = find_deviance_(radim_element, &workspace_offset);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1335L, 0L))
    write_line_stdout();
  /*$endif TRACE*/
  d = 2 * *ips_epsilon;
  while (fabs(d) > *ips_epsilon && cycle_number < *max_cycle_number &&
	 !interrupt_1)
    iterate_(radim_element, &first_offset, &total_size, &workspace_offset,
	     &copy_offset, n_total, &cycle_number, &d, &l1, &l2);
  final_adjustment(radim_element, &workspace_offset);
  if (fabs(d) > *ips_epsilon)
    no_ips_convergence(radim_element->gen_class, &cycle_number, &d);
  report_ips(radim_element->gen_class, radim_element->a, &cycle_number,
	     &start_clock, &d, ips_epsilon);
}  /* decomposed_ips_em */


/*@-"deviance.c"*/
/*@+"mipsbas.p"*/


/*

1343:    +++  ++
1344:    +++  ++
1343: |   42:    procedure ok_cholesky_plus
1344: |   42:    procedure clear_t_array
1345:    ---  -- p/mipsbas.p         32     145    1733 p/mipsbas.p
1346: |    4:    procedure note_number_of_observations
1347: |   20:    procedure note_t_array
1348: |   33:    function nor
1349: |   42:    procedure malloc_workspace
1350: |   53:    function g_adjustment
1351: |   61:    procedure marginalize_in_r
1352: |   87:    procedure find_one_cholesky_k_inverse
1353: |  124:    procedure find_one_k_inverse
1354: |  149:    function find_one_product
1355: |  183:    procedure find_determinants_and_products
1356: |  241:    procedure cholesky_plus
1357: |  280:    procedure make_ks_invertible
1358: |  319:    function find_g_from_p
1359: |  347:    function find_p_from_g
1360: |  374:    procedure p_to_gs
1361: |  413:    procedure g_to_ps
1362: |  451:    procedure normalise_ps
1363: |  506:    function both_continuous_index
1364: |  523:    function continuous_index
1365: |  537:    procedure copy_mips_estimates
1366: |  549:    procedure init_mips_estimates
1367: |  591:    function trace_of_multiplum_of_symmetric
1368: |  635:    function sub_find_mips_deviance
1369: |  697:    function find_mips_deviance
1370: |  765:    function find_mips_change
1371: |  783:    procedure change_after_update
1372: |  823:    procedure save_before_update
1373: |  836:    function init_iterate_pack
1374: |  861:    procedure find_differences
1375: |  879:    procedure report_differences
1376: |  919:    function trace_iteration
1377: |  946:    function do_mips_iteration
1378:    +++  ++
1379:    +++  ++

*/

Static Void note_number_of_observations(n_offset, i)
t_offset *n_offset;
t_integer i;
{
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1346L, 0L))
    return;
  /*$endif TRACE*/
  write_pch(stdout, " Offsets: ", 10L);
  write_space(stdout, 10L);
  write_integer(stdout, *n_offset, 4L);
  write_integer(stdout, i, 4L);
  write_integer(stdout, *n_offset + i, 4L);
  write_integer(stdout, n[*n_offset + i], 4L);
  write_line(stdout);
}  /* note_number_of_observations */


/* Not used:
procedure note_t_array(var r    : t_t;
                       var r_offset : t_t_offset);
begin
   if trace_flag_set(20, 1347, 0) then begin
      write_pch(output, ' T-array: ', 10);
      write_integer(output, r_offset, 5);
      write_real(output, r^.z^[r_offset], 10, 5);
      write_line(output)
   end
end; */
/* note_t_array */


Static t_integer nor()
{
  if (boolean_option[93])
    return 2;
  else
    return 1;
}  /* nor */



Static Void clear_t_invalid(t, t_offset_, size)
t_t_r **t;
t_t_offset *t_offset_;
t_integer *size;
{
  t_e_cell_index index, FORLIM;

  FORLIM = *t_offset_ + *size;
  for (index = *t_offset_; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ass(t, t_offset_, index, _INVALID_REAL, " ClearTInvalid      ", 20L,
	      1344L, 1L);
    /*$endif TRACE-ARRAY*/
    (*t)->z[index] = _INVALID_REAL;
  }
}  /* clear_t_invalid */


Static Void malloc_workspace(workspace, tmp_offset, r, r_offset, size)
t_t_r **workspace;
t_t_offset *tmp_offset;
t_t_r **r;
t_t_offset *r_offset;
t_integer size;
{
  *r = *workspace;
  *r_offset = *tmp_offset;
  *tmp_offset += size;
  clear_t_invalid(r, r_offset, &size);
}  /* malloc_workspace */


Static t_long_real g_adjustment(n_obs, n_exp, factor)
t_long_real n_obs, n_exp, factor;
{
  if (boolean_option[118])
    return (log(n_obs) - log(n_exp));
  else
    return ((n_obs - n_exp) * factor);
}  /* g_adjustment */


Static Void marginalize_in_r(a, c, c_in_a, s, s_offset, t, t_offset_, m, i)
long *a, *c;
t_fast_next_offset_pack *c_in_a;
t_t_r **s;
t_t_offset *s_offset;
t_t_r **t;
t_t_offset *t_offset_;
t_integer *m;
t_level *i;
{
  t_t_offset mc;
  t_cell_index index;
  t_integer c_index;
  t_vertex_set a_delta;
  t_cell_index FORLIM;

  mc = marginal_dimension(c);
  clear_t_array(t, t_offset_, &mc);
  P_setint(a_delta, a, delta);
  fast_find_products(a_delta, c, c_in_a);
  c_index = *t_offset_;
  FORLIM = *s_offset + *m;
  for (index = *s_offset; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_upd(t, t_offset_, c_index, (*s)->z[index], 1L,
	      " MarginalizeInR     ", 20L, 1351L, 1L);
    ntr_t_ref(s, s_offset, index, " MarginalizeInR     ", 20L, 1351L, 1L);
    /*$endif TRACE-ARRAY*/
    (*t)->z[c_index] += (*s)->z[index];
    fast_next_offset(c_in_a, &c_index, i);
  }
}  /* marginalize_in_r */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

Static Void find_one_cholesky_k_inverse(x, l, m, x_offset, l_offset, m_offset,
					n, force, silent, ok)
t_t_r **x, **l, **m;
t_t_offset *x_offset, *l_offset, *m_offset;
t_integer *n;
boolean force, silent, *ok;
{
  t_integer ifail = 0;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1352L, 0L))
    write_headed_matrix_t(" Input(1):                              ", 10L, x,
			  *x_offset, n);
  /*$endif TRACE*/
  if (*ok)
    *ok = test_positive_diag_t(x, x_offset, n);
  if (*ok)
    cholesky_t_t(x, l, x_offset, l_offset, force, silent, ok, n, &ifail);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1352L, 0L) || ifail > 0 && boolean_option[63]) {
    write_headed_matrix_t(" Input:                                 ", 10L, x,
			  *x_offset, n);
    write_headed_matrix_t(" Cholesky:                              ", 10L, l,
			  *l_offset, n);
    write_headed_mult_lower_t(" Cholesky * Cholesky':                  ", 30L,
			      l, l_offset, n);
  }
  /*$endif TRACE*/
  if (*ok || force) {
    invert_t_t(l, m, l_offset, m_offset, n);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1352L, 0L)) {
      write_headed_matrix_t(" Inverse(Cholesky):                     ", 20L,
			    m, *m_offset, n);
      write_headed_mult_upper_t(" Inverse(Cholesky) * Inverse(Cholesky)':",
				40L, m, m_offset, n);
    }
    /*$endif TRACE*/
    return;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1352L, 1L))
    write_headed_matrix_t(" Input(1):                              ", 10L, x,
			  *x_offset, n);
  /*$endif TRACE*/
  if (!(note_warnings && boolean_option[63]))
    return;
  write_pch(stdout, " Note-4 (FindOneCholeskyKInverse):", 34L);
  write_pch(stdout, " Cholesky not succeeded. Table", 25L);
  /* write_pch(output, ' has @@@@@', 5);
     write_integer(output, n[0], 3);
     write_pch(output, ' cases / @', 9); */
  /* if n < n[0] - 1 then
       write_pch(output,
                   ' Cholesky/Determinnt', 20)
    else
       write_pch(output,
                   ' Non-positive matrix', 20); */
  if (!test_positive_diag_t(x, x_offset, n))
    write_pch(stdout, " Non-positive diagonal.", 23L);
  write_line(stdout);
}  /* find_one_cholesky_k_inverse */



Static Void find_one_k_inverse(x, y, l, m, x_offset, y_offset, l_offset,
			       m_offset, n, silent, ok)
t_t_r **x, **y, **l, **m;
t_t_offset *x_offset, *y_offset, *l_offset, *m_offset;
t_integer *n;
boolean silent, *ok;
{
  find_one_cholesky_k_inverse(x, l, m, x_offset, l_offset, m_offset, n, false,
			      silent, ok);
  if (*ok) {
    mult_upper_t_t(m, y, m_offset, y_offset, n);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1353L, 0L)) {
      write_headed_matrix_t(" Inverse:                               ", 10L,
			    y, *y_offset, n);
      write_headed_mult_sym_t_t(" Input * Inverse:                       ",
				20L, x, y, x_offset, y_offset, n);
    }
    /*$endif TRACE*/
    return;
  }
  if (!(note_warnings && boolean_option[63]))
    return;
  write_pch(stdout, " Note-4 (FindOneKInverse):", 26L);
  write_pch(stdout, " Cholesky not succeeded. Table", 25L);
  if (!test_positive_diag_t(x, x_offset, n))
    write_pch(stdout, " Non-positive diagonal.", 23L);
  write_line(stdout);
}  /* find_one_k_inverse */


Static t_long_real find_one_product(h, m, h_offset, m_offset, n)
t_t_r **h, **m;
t_t_offset *h_offset, *m_offset;
t_integer *n;
{
  double Result;
  t_integer i, j;
  t_long_real t;
  t_long_real s = 0.0;

  for (j = 0; j < *n; j++) {
    t = 0.0;
    for (i = 0; i <= j; i++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(h, h_offset, *h_offset + i, " FindOneProdukt     ", 20L,
		1354L, 1L);
      ntr_t_ref(m, m_offset, *m_offset + sm_index(i, j, *n),
		" FindOneProdukt     ", 20L, 1354L, 1L);
      /*$endif TRACE-ARRAY*/
      t += (*h)->z[*h_offset + i] * (*m)->z[*m_offset + sm_index(i, j, *n)];
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1354L, 0L))
	trace_1(" FindOneProduct: ", 17L, *h_offset, i, *h_offset + i,
		*m_offset, sm_index(i, j, *n), *m_offset + sm_index(i, j, *n),
		(*h)->z[*h_offset + i],
		(*m)->z[*m_offset + sm_index(i, j, *n)], t);
      /*$endif TRACE*/
    }
    s += t * t;
  }
  Result = s;
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1354L, 0L))
    return Result;
  /*$endif TRACE*/
  write_real(stdout, s, print_width, print_dec);
  write_line(stdout);
  write_headed_matrix_t(" X:@@@@@@@                              ", 3L, m,
			*m_offset, n);
  write_headed_vector_t(" y:@@@@@@@                              ", 3L, h,
			h_offset, n);
  return Result;
}  /* find_one_product */



Static Void find_determinants_and_products(m0, m1, m2, n_offset, r, r_offset,
  workspace, workspace_offset, determinants, determinants_offset, products,
  products_offset, force, invertible)
t_integer *m0, *m1, *m2;
t_offset *n_offset;
t_t_r **r;
t_t_offset *r_offset;
t_t_r **workspace;
t_t_offset workspace_offset;
t_t_r **determinants;
t_t_offset *determinants_offset;
t_t_r **products;
t_t_offset *products_offset;
boolean force, *invertible;
{
  boolean ok = true;
  t_t_r *h, *k, *l, *m;   /* T_T, arguments */
  t_t_offset k_offset, h_offset, l_offset, m_offset;
  t_integer i = FIRST_INDEX;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindDeterminantsAnd", sizeof(pch20));
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1355L, 0L)) {
    write_pch(stdout, " [ FindDeterminats  ", 20L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  h = *r;
  k = *r;
  l = *workspace;
  m = *workspace;
  h_offset = *r_offset;
  k_offset = *r_offset + *m1;
  l_offset = workspace_offset;
  m_offset = workspace_offset + *m2;
  *invertible = true;
  while (i < FIRST_INDEX + *m0 && (force || *invertible)) {
    note_number_of_observations(n_offset, i);
    if (true)
      find_one_cholesky_k_inverse(&k, &l, &m, &k_offset, &l_offset, &m_offset,
				  m1, force, !boolean_option[63], &ok);
    *invertible = (*invertible && ok);
    if (force || ok) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(determinants, determinants_offset, *determinants_offset + i,
		_INVALID_REAL, " FindDeterminants   ", 20L, 1355L, -2L);
      ntr_t_ass(products, products_offset, *products_offset + i,
		_INVALID_REAL, " FindDeterminants   ", 20L, 1355L, -2L);
      /*$endif TRACE-ARRAY*/
      (*determinants)->z[*determinants_offset + i] =
	find_determinant_from_cholesky_t(&l, &l_offset, m1);
      (*products)->z[*products_offset + i] = find_one_product(&h, &m,
	  &h_offset, &m_offset, m1);
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(determinants, determinants_offset, *determinants_offset + i,
		_INVALID_REAL, " FindDeterminants   ", 20L, 1355L, 2L);
      ntr_t_ass(products, products_offset, *products_offset + i,
		_INVALID_REAL, " FindDeterminants   ", 20L, 1355L, 2L);
      /*$endif TRACE-ARRAY*/
    } else {
      if (!ok) {
	if (note_warnings && boolean_option[63]) {
	  write_pch(stdout, " Note-4 (FindDeterminantsAndProducts):", 38L);
	  write_pch(stdout, " Cholesky not succeeded.", 24L);
	  if (!test_positive_diag_t(&k, &k_offset, m1))
	    write_pch(stdout, " Non-positive diagonal.", 23L);
	  write_line(stdout);
	}
      }
    }
    h_offset += *m2;
    k_offset += *m2;
    i++;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1355L, 0L)) {
    write_pch(stdout, " FindDeterminats ]  ", 20L);
    write_line(stdout);
  }
  /*$endif TRACE*/
}  /* find_determinants_and_products */



Static Void ok_cholesky_plus(x, x_offset, g, t, force, silent, ok, ifail)
t_t_r **x;
t_t_offset *x_offset;
t_integer *g;
t_long_real *t;
boolean *force, *silent, *ok;
t_integer *ifail;
{   /* force and */
  if (*t <= 0) {
    if (!*silent) {
      warning_begin(stdout, false);
      write_pch(stdout, " Singular matrix in Cholesky+.", 30L);
      if (*force) {
	write_line(stdout);
	write_pch(stdout, " ``Forcing'' decomposition!!!", 29L);
      }
      warning_end(stdout, false);
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_t_upd(x, x_offset, *x_offset + *g, cholesky_epsilon - *t, 1L,
	      " ok_cholesky_plus   ", 20L, 1353L, 1L);
	/*ntr*/
    /*$endif TRACE-ARRAY*/
    (*x)->z[*x_offset + *g] += cholesky_epsilon - *t;
    *t = cholesky_epsilon;
    *ok = false;
    *ifail = 8;
  }
  if (0 < *t && *t < ROUND_ERROR) {
    if (!*silent) {
      warning_begin(stdout, false);
      write_pch(stdout, " Almost singular matrix in Cholesky+.", 37L);
      write_line(stdout);
      write_pch(stdout, " Expect instables estimates.", 28L);
      warning_end(stdout, false);
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_t_upd(x, x_offset, *x_offset + *g, ROUND_ERROR - *t, 1L,
	      " ok_cholesky_plus   ", 20L, 1353L, 1L);
	/*ntr*/
    /*$endif TRACE-ARRAY*/
    (*x)->z[*x_offset + *g] += ROUND_ERROR - *t;
    *t = ROUND_ERROR;
    *ifail = 5;
  }
  if (0 >= *t || *t >= cholesky_epsilon)
    return;
  if (!*silent) {
    warning_begin(stdout, false);
    write_pch(stdout, " Ill-conditioned matrix in Cholesky+.", 37L);
    write_line(stdout);
    write_pch(stdout, " Estimates may variate.", 23L);
    warning_end(stdout, false);
  }
  /*$ifdef TRACE-ARRAY*/
  ntr_t_upd(x, x_offset, *x_offset + *g, cholesky_epsilon - *t, 1L,
	    " ok_cholesky_plus   ", 20L, 1353L, 1L);
      /*ntr*/
  /*$endif TRACE-ARRAY*/
  (*x)->z[*x_offset + *g] += cholesky_epsilon - *t;
  *t = cholesky_epsilon;
  *ifail = 2;
}  /* ok_cholesky_plus */


/* Local variables for cholesky_plus: */
struct LOC_cholesky_plus {
  boolean force, silent;
} ;


Static Void cholesky_plus(x, l, x_offset, l_offset, force_, silent_, ok, n,
			  ifail)
t_t_r **x, **l;
t_t_offset *x_offset, *l_offset;
boolean force_, silent_, *ok;
t_integer *n, *ifail;
{
  struct LOC_cholesky_plus Local_Var;
  t_integer g, h, i, j;
  t_integer k = 0;
  t_long_real t;
  double TEMP;

  Local_Var.force = force_;
  Local_Var.silent = silent_;
  *ok = true;
  while ((*ok || Local_Var.force) && k < *n) {
    g = sm_index(k, k, *n);
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(x, x_offset, *x_offset + g, " CholeskyPlus       ", 20L, 1356L,
	      1L);
    /*$endif TRACE-ARRAY*/
    t = (*x)->z[*x_offset + g];
    for (j = 0; j < k; j++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(l, l_offset, *l_offset + sm_index(j, k, *n),
		" CholeskyPlus       ", 20L, 1356L, 1L);
      TEMP = (*l)->z[*l_offset + sm_index(j, k, *n)];
      /*$endif TRACE-ARRAY*/
      t -= TEMP * TEMP;
    }
    ok_cholesky_plus(x, x_offset, &g, &t, &Local_Var.force, &Local_Var.silent,
		     ok, ifail);
    /*
    if force and (t < 0) then begin
       x^.z^[x_offset + g] := x^.z^[x_offset + g] - t + cholesky_epsilon;
       t := cholesky_epsilon;
       ok := false
    end;
     */
    if (t >= 0) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(l, l_offset, *l_offset + g, sqrt(t), " CholeskyPlus       ",
		20L, 1356L, 1L);
      /*$endif TRACE-ARRAY*/
      (*l)->z[*l_offset + g] = sqrt(t);
      for (i = k + 1; i < *n; i++) {
	h = sm_index(k, i, *n);
	t = (*x)->z[*x_offset + h];
	for (j = 0; j < k; j++) {
	  /*$ifdef TRACE-ARRAY*/
	  ntr_t_ref(l, l_offset, *l_offset + sm_index(j, i, *n),
		    " CholeskyPlus       ", 20L, 1356L, 1L);
	  ntr_t_ref(l, l_offset, *l_offset + sm_index(j, k, *n),
		    " CholeskyPlus       ", 20L, 1356L, 1L);
	  /*$endif TRACE-ARRAY*/
	  t -= (*l)->z[*l_offset + sm_index(j, i, *n)] *
	       (*l)->z[*l_offset + sm_index(j, k, *n)];
	}
	/*$ifdef TRACE-ARRAY*/
	ntr_t_ref(l, l_offset, *l_offset + g, " CholeskyPlus       ", 20L,
		  1356L, 1L);
	ntr_t_ass(l, l_offset, *l_offset + h, t / (*l)->z[*l_offset + g],
		  " CholeskyPlus       ", 20L, 1356L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*l)->z[*l_offset + h] = t / (*l)->z[*l_offset + g];
      }
    } else
      *ok = false;
    k++;
  }
}  /* cholesky_plus */



Static Void make_ks_invertible(m0, m1, m2, r, r_offset, workspace,
			       workspace_offset, invertible)
t_integer *m0, *m1, *m2;
t_t_r **r;
t_t_offset *r_offset;
t_t_r **workspace;
t_t_offset workspace_offset;
boolean *invertible;
{
  boolean ok, silent;
  t_t_r *k, *l;   /* T_T, arguments */
  t_t_offset k_offset, l_offset;
  t_integer i;
  t_integer ifail = 0;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1357L, 0L)) {
    write_pch(stdout, " [ MakeKsInvertible ", 20L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  k = *r;
  l = *workspace;
  k_offset = *r_offset + *m1;
  l_offset = workspace_offset;
  *invertible = true;
  silent = !boolean_option[63];
  for (i = FIRST_INDEX; i < FIRST_INDEX + *m0; i++) {
    cholesky_plus(&k, &l, &k_offset, &l_offset, true, silent, &ok, m1, &ifail);
    *invertible = (*invertible && ok);
    k_offset += *m2;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1357L, 0L)) {
    write_pch(stdout, " MakeKsInvertible ] ", 20L);
    write_line(stdout);
  }
  /*$endif TRACE*/
}  /* make_ks_invertible */



Static t_long_real find_g_from_p(gamma_constant, p, determinant, product)
t_long_real gamma_constant, p, determinant, product;
{  /* SLL(1995): 6.4 */
  t_long_real x;

  x = -gamma_constant;
  x += log(p);
  x += log(determinant) / 2;   /* Det(K) */
  x -= product / 2;
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1358L, 0L))
    return x;
  write_pch(stdout, " FindG..:           ", 10L);
  write_real(stdout, gamma_constant, print_width, print_dec);
  write_real(stdout, p, print_width, print_dec);
  write_real(stdout, determinant, print_width, print_dec);
  write_real(stdout, product, print_width, print_dec);
  write_real(stdout, -gamma_constant, print_width, print_dec);
  write_real(stdout, log(p), print_width, print_dec);
  write_real(stdout, log(determinant) / 2, print_width, print_dec);
  write_real(stdout, product / -2, print_width, print_dec);
  write_real(stdout, x, print_width, print_dec);
  write_line(stdout);
  /*$endif TRACE*/
  return x;
}  /* find_g_from_p */


Static t_long_real find_p_from_g(gamma_constant, g, determinant, product)
t_long_real gamma_constant, g, determinant, product;
{  /* SLL(1995): 6.4 */
  t_long_real x = gamma_constant;

  x += g;
  x -= log(determinant) / 2;   /* Det(K) */
  x += product / 2;
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1359L, 0L))
    return exp(x);
  write_pch(stdout, " FindP..:           ", 10L);
  write_real(stdout, gamma_constant, print_width, print_dec);
  write_real(stdout, g, print_width, print_dec);
  write_real(stdout, determinant, print_width, print_dec);
  write_real(stdout, product, print_width, print_dec);
  write_real(stdout, log(determinant) / -2, print_width, print_dec);
  write_real(stdout, product / 2, print_width, print_dec);
  write_real(stdout, x, print_width, print_dec);
  write_real(stdout, exp(x), print_width, print_dec);
  write_line(stdout);
  /*$endif TRACE*/
  return exp(x);
}



Static Void p_to_gs(p, gamma_constant, m, m2, n_offset, r, r_offset, ps,
		    ps_offset, determinants, determinants_offset, products,
		    products_offset)
t_long_real p, *gamma_constant;
t_integer *m, *m2;
t_offset *n_offset;
t_t_r **r;
t_t_offset *r_offset;
t_t_r **ps;
t_t_offset *ps_offset;
t_t_r **determinants;
t_t_offset *determinants_offset;
t_t_r **products;
t_t_offset *products_offset;
{
  /* m1, */
  t_integer i;
  t_t_offset index;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1360L, 0L)) {
    write_pch(stdout, " [ P -> G ", 10L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  index = *r_offset + *m2 - 1;
  for (i = FIRST_INDEX; i < FIRST_INDEX + *m; i++) {
    note_number_of_observations(n_offset, i);
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(ps, ps_offset, *ps_offset + i, " PtoGs              ", 20L,
	      1360L, 1L);
    ntr_t_ref(determinants, determinants_offset, *determinants_offset + i,
	      " PtoGs              ", 20L, 1360L, 1L);
    ntr_t_ref(products, products_offset, *products_offset + i,
	      " PtoGs              ", 20L, 1360L, 1L);
    ntr_t_ass(r, r_offset, index, _INVALID_REAL, " PtoGs              ", 20L,
	      1360L, -2L);
    /*$endif TRACE-ARRAY*/
    (*r)->z[index] = find_g_from_p(*gamma_constant,
	(*ps)->z[*ps_offset + i] / p,
	(*determinants)->z[*determinants_offset + i],
	(*products)->z[*products_offset + i]);
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ass(r, r_offset, index, _INVALID_REAL, " PtoGs              ", 20L,
	      1360L, 2L);
    /*$endif TRACE-ARRAY*/
    index += *m2;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1360L, 0L)) {
    write_pch(stdout, " P -> G ] ", 10L);
    write_line(stdout);
  }
  /*$endif TRACE*/
}  /* p_to_gs */



Static Void g_to_ps(gamma_constant, m, m2, n_offset, r, r_offset, ps,
		    ps_offset, determinants, determinants_offset, products,
		    products_offset)
t_long_real *gamma_constant;
t_integer *m, *m2;
t_offset *n_offset;
t_t_r **r;
t_t_offset *r_offset;
t_t_r **ps;
t_t_offset *ps_offset;
t_t_r **determinants;
t_t_offset *determinants_offset;
t_t_r **products;
t_t_offset *products_offset;
{
  /* m1, */
  t_integer i;
  t_t_offset index;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1361L, 0L)) {
    write_pch(stdout, " [ G -> P ", 10L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  index = *r_offset + *m2 - 1;
  for (i = FIRST_INDEX; i < FIRST_INDEX + *m; i++) {
    note_number_of_observations(n_offset, i);
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(r, r_offset, index, " GtoPs              ", 20L, 1361L, 1L);
    ntr_t_ref(determinants, determinants_offset, *determinants_offset + i,
	      " GtoPs              ", 20L, 1361L, 1L);
    ntr_t_ref(products, products_offset, *products_offset + i,
	      " GtoPs              ", 20L, 1361L, 1L);
    ntr_t_ass(ps, ps_offset, *ps_offset + i, _INVALID_REAL,
	      " GtoPs              ", 20L, 1361L, -2L);
    /*$endif TRACE-ARRAY*/
    (*ps)->z[*ps_offset + i] = find_p_from_g(*gamma_constant, (*r)->z[index],
	(*determinants)->z[*determinants_offset + i],
	(*products)->z[*products_offset + i]);
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ass(ps, ps_offset, *ps_offset + i, _INVALID_REAL,
	      " GtoPs              ", 20L, 1361L, 2L);
    /*$endif TRACE-ARRAY*/
    index += *m2;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1361L, 0L)) {
    write_pch(stdout, " G -> P ] ", 10L);
    write_line(stdout);
  }
  /*$endif TRACE*/
}  /* g_to_ps */



Static Void normalise_ps(r, r_offset, n_offset, workspace, workspace_offset,
			 m, m1, m2, ok)
t_t_r **r;
t_t_offset *r_offset;
t_offset *n_offset;
t_t_r **workspace;
t_t_offset workspace_offset;
t_integer *m, *m1, *m2;
boolean *ok;
{
  /* var a    : t_vertex_set; */
  /* var n_total    : t_cell_count; */
  t_integer i;
  t_long_real p = 0.0;
  t_long_real gamma_constant;
  t_t_r *ps = NULL, *determinants = NULL, *products = NULL;
      /* T_T, malloc_workspace */
  t_t_offset tmp_offset, ps_offset, determinants_offset, products_offset;
  long FORLIM;

  gamma_constant = *m1 * LN_2_PI_HALF;
  tmp_offset = workspace_offset;
  malloc_workspace(workspace, &tmp_offset, &ps, &ps_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &determinants,
		   &determinants_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &products, &products_offset, *m);
  /* -> m * (3) */
  find_determinants_and_products(m, m1, m2, n_offset, r, r_offset, workspace,
    tmp_offset, &determinants, &determinants_offset, &products,
    &products_offset, false, ok);
  if (!*ok)   /* m1, */
    return;
  g_to_ps(&gamma_constant, m, m2, n_offset, r, r_offset, &ps, &ps_offset,
	  &determinants, &determinants_offset, &products, &products_offset);
  FORLIM = FIRST_INDEX + *m;
  for (i = FIRST_INDEX; i < FORLIM; i++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(&ps, &ps_offset, ps_offset + i, " NormalisePs        ", 20L,
	      1362L, 1L);
    /*$endif TRACE-ARRAY*/
    p += ps->z[ps_offset + i];
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1362L, 0L)) {
      write_pch(stdout, " NormalisePs (1): ", 18L);
      write_real(stdout, p, print_width + 4, print_dec + 2);
      write_line(stdout);
    }
    /*$endif TRACE*/
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1362L, 0L)) {   /* m1, */
    write_pch(stdout, " NormalisePs: ", 14L);
    write_real(stdout, p, print_width + 4, print_dec + 2);
    write_line(stdout);
  }
  /*$endif TRACE*/
  /* Consider add `-log(p)' to each `g' instead: */
  p_to_gs(p, &gamma_constant, m, m2, n_offset, r, r_offset, &ps, &ps_offset,
	  &determinants, &determinants_offset, &products, &products_offset);
  /* Catch ? */
}  /* normalise_ps */



Static t_integer both_continuous_index(u, a_)
t_vertex *u;
long *a_;
{
  t_vertex_set a;
  t_vertex v;
  t_integer index = -1;

  P_setcpy(a, a_);
  v = first_vertex;
  P_setint(a, a, gamma_);
  while (v <= last_vertex && v <= *u) {
    if (P_inset(v, a))
      index++;
    v++;
  }
  return index;
}  /* both_continuous_index */


/* Not used:
function continuous_index(var a : t_continuous_vertex): t_integer;
var
   v : t_vertex;
   index : t_integer;
begin
   index := -1;
   v := first_vertex;
   while (v <= a) do begin
      index := index + 1;
      v := succ(v)
   end;
   continuous_index := index
end; */
/* continuous_index */

Static Void copy_mips_estimates(r, r_offset, copy, copy_offset, m, m2)
t_t_r **r;
t_t_offset *r_offset;
t_t_r **copy;
t_t_offset *copy_offset;
t_integer *m, *m2;
{
  /* m1, */
  t_e_r_cell_index index, FORLIM;

  FORLIM = FIRST_INDEX + *m * *m2;
  for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(r, r_offset, *r_offset + index, " CopyMipsEstimates  ", 20L,
	      1365L, 1L);
    ntr_t_ass(copy, copy_offset, *copy_offset + index,
	      (*r)->z[*r_offset + index], " CopyMipsEstimates  ", 20L, 1365L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*copy)->z[*copy_offset + index] = (*r)->z[*r_offset + index];
  }
}  /* copy_mips_estimates */


Static Void init_mips_estimates(r, r_offset, s, s_offset, m, m1, m2)
t_t_r **r;
t_t_offset *r_offset;
t_s_r **s;
t_s_offset *s_offset;
t_integer *m, *m1, *m2;
{
  /* ;
  var a    : t_vertex_set */
  t_e_r_cell_index i, j, l, offset, FORLIM, FORLIM1;
  t_long_real sum, g, h;

  g = log(1.0 / *m) - *m1 * LN_2_PI_HALF;
  FORLIM = *m;
  for (l = 0; l <= FORLIM - 1; l++) {
    offset = *r_offset + l * *m2;
    sum = 0.0;
    FORLIM1 = *m1;
    for (i = 0; i <= FORLIM1 - 1; i++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(s, s_offset, *s_offset + i, " InitMipsEstimates  ", 20L,
		1366L, 1L);
      /*$endif TRACE-ARRAY*/
      h = (*s)->z[*s_offset + i];
      sum += h * h;
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(r, r_offset, offset + i, h, " InitMipsEstimates  ", 20L,
		1366L, 1L);
      /*$endif TRACE-ARRAY*/
      (*r)->z[offset + i] = h;
    }
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ass(r, r_offset, offset + *m2 - 1, g - sum / 2,
	      " InitMipsEstimates  ", 20L, 1366L, 1L);
    /*$endif TRACE-ARRAY*/
    (*r)->z[offset + *m2 - 1] = g - sum / 2;
    offset += *m1;
    FORLIM1 = *m1;
    for (i = 0; i <= FORLIM1 - 1; i++) {
      for (j = 0; j <= i - 1; j++) {
	/*$ifdef TRACE-ARRAY*/
	if (boolean_option[106])   /* ntr */
	  ntr_t_ass(r, r_offset, offset + sm_index(i, j, *m1),
		    mips_init_epsilon, " InitMipsEstimates  ", 20L, 1366L,
		    1L);
	else
	  ntr_t_ass(r, r_offset, offset + sm_index(i, j, *m1), 0.0,
		    " InitMipsEstimates  ", 20L, 1366L, 1L);
	/* ntr */
	/*$endif TRACE-ARRAY*/
	if (boolean_option[106])
	  (*r)->z[offset + sm_index(i, j, *m1)] = mips_init_epsilon;
	else
	  (*r)->z[offset + sm_index(i, j, *m1)] = 0.0;
      }
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(r, r_offset, offset + sm_index(i, i, *m1), 1.0,
		" InitMipsEstimates  ", 20L, 1366L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*r)->z[offset + sm_index(i, i, *m1)] = 1.0;
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1366L, 0L)) {
      write_pch(stdout, " InitMipsEstimates.", 19L);
      FORLIM1 = *m2;
      for (i = 0; i <= FORLIM1 - 1; i++)
	write_real(stdout, (*r)->z[offset - *m1 + i], print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/
  }
}  /* init_mips_estimates */



Static t_long_real trace_of_multiplum_of_symmetric(x, y, x_offset, y_offset, n)
t_ss_r **x;
t_t_r **y;
t_ss_offset x_offset;
t_t_offset y_offset;
t_integer *n;
{
  t_integer k, l, index;
  t_long_real s = 0.0;
  t_long_real t;

  for (l = 0; l < *n; l++) {
    t = 0.0;
    for (k = l + 1; k < *n; k++) {   /* 0 */
      index = sm_index(k, l, *n);
      /*$ifdef TRACE-ARRAY*/
      ntr_ss_ref(x, &x_offset, x_offset + index, " TraceOfMultiplumS  ", 20L,
		 1367L, 1L);
      ntr_t_ref(y, &y_offset, y_offset + index, " TraceOfMultiplumS  ", 20L,
		1367L, 1L);
      /*$endif TRACE-ARRAY*/
      t += (*x)->z[x_offset + index] * (*y)->z[y_offset + index];
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1367L, 0L))
	trace_1(" TraceOfMultiplumOf.", 20L, index, -1L, l, k,
		x_offset + index, y_offset + index, (*x)->z[x_offset + index],
		(*y)->z[y_offset + index], t);
      /*$endif TRACE*/
    }
    /**/
    index = sm_index(l, l, *n);
    /*$ifdef TRACE-ARRAY*/
    ntr_ss_ref(x, &x_offset, x_offset + index, " TraceOfMultiplumS  ", 20L,
	       1367L, 1L);
    ntr_t_ref(y, &y_offset, y_offset + index, " TraceOfMultiplumS  ", 20L,
	      1367L, 1L);
    /*$endif TRACE-ARRAY*/
    /**/
    t = 2 * t + (*x)->z[x_offset + index] * (*y)->z[y_offset + index];
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1367L, 0L))
      trace_1(" TraceOfMultiplumOf.", 20L, index, l, x_offset, y_offset,
	      x_offset + index, y_offset + index, (*x)->z[x_offset + index],
	      (*y)->z[y_offset + index], t);
    /*$endif TRACE*/
    s += t;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1367L, 0L)) {
      write_pch(stdout, " TraceOfMultiplumOf.", 20L);
      write_real(stdout, s, print_width + 4, print_dec + 2);
      write_line(stdout);
    }
    /*$endif TRACE*/
  }
  return s;
}  /* write_mult_sym */



Static t_long_real sub_find_mips_deviance(r, r_offset, s, s_offset, n_offset,
					  m, m1, m2)
t_t_r **r;
t_t_offset *r_offset;
t_ss_r **s;
t_ss_offset *s_offset;
t_offset *n_offset;
t_integer *m, *m1, *m2;
{  /* In SLL 6.13 the initial value of `l1', the constant, is zero ??? */
  t_long_real a, b, c, d, l0, l1;
  t_cell_index n_index;
  t_t_offset r_index;
  t_ss_offset s_index;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_cell_index FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubFindMipsDev.    ", sizeof(pch20));
  ntr_4(tzt, 20L, 1368L, 1L, *m, *m1, *m2, -1L);
  ntr_4(tzt, 20L, 1368L, 1L, *r_offset, *s_offset, *n_offset, -2L);
  ntr_n_ref(n, *n_offset, 0L, tzt, 20L, 1368L, 1L);
  /*$endif TRACE*/
  l1 = (n[0] - 1) * *m1 * LN_2_PI_HALF - n[0] * log((double)n[0]);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1368L, 0L))
    trace_1(" MIPS-Log-L: ", 13L, *r_offset, *s_offset, *n_offset, *m,
	    *m1, *m2, (double)n[0], log(10.0), l1);
  /*$endif TRACE*/
  r_index = *r_offset;
  s_index = *s_offset;
  FORLIM = *n_offset + *m;
  for (n_index = *n_offset; n_index <= FORLIM - 1; n_index++) {
    a = find_scalar_product_ss_t(s, r, &s_index, &r_index, m1);
    b = trace_of_multiplum_of_symmetric(s, r, s_index + *m1, r_index + *m1, m1);
    if (is_invalid_real(b))
      d = _INVALID_REAL;
    else
      d = b / -2;
    l0 = l1;
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(r, r_offset, r_index + *m2 - 1, tzt, 20L, 1368L, 1L);
    ntr_n_ref(n, *n_offset, n_index, tzt, 20L, 1368L, 1L);
    /*$endif TRACE-ARRAY*/
    c = (*r)->z[r_index + *m2 - 1];
    if (is_invalid_real(c))
      l1 = _INVALID_REAL;
    else
      l1 += c * n[n_index];
    l1 = my_add_long_real(&l1, &a);
    l1 = my_add_long_real(&l1, &d);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1368L, 0L)) {
      write_pch(stdout, " Mips-Log-L: ", 13L);
      write_integer(stdout, r_index, 5L);
      write_integer(stdout, s_index, 5L);
      write_integer(stdout, n[n_index], 5L);
      write_line(stdout);
      write_real(stdout, _INVALID_REAL, print_width, print_dec);
      write_real(stdout, c, print_width, print_dec);
      write_real(stdout, a, print_width, print_dec);
      write_real(stdout, b, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, l0, print_width, print_dec);
      write_real(stdout, c * n[n_index], print_width, print_dec);
      write_real(stdout, a, print_width, print_dec);
      write_real(stdout, d, print_width, print_dec);
      write_real(stdout, l1, print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/
    r_index += *m2;
    s_index += *m2;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1368L, 0L)) {
    write_pch(stdout, " Mips-Log-L: ", 13L);
    write_real(stdout, l1, print_width + 4, print_dec + 2);
    write_line(stdout);
  }
  ntr_real(tzt, 20L, 1368L, 1L, -9L, -9L, &l1);
  /*$endif TRACE*/
  return l1;
}  /* sub_find_mips_deviance */



Static t_long_real find_mips_deviance(model_set, r, r_offset, ss, ss_offset,
  n_offset, r_old, r_old_offset, workspace, workspace_offset, m, m1, m2,
  ifail)
long *model_set;
t_t_r **r;
t_t_offset *r_offset;
t_ss_r **ss;
t_ss_offset *ss_offset;
t_offset *n_offset;
t_t_r **r_old;
t_t_offset *r_old_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m, *m1, *m2, *ifail;
{
  /**/
  /**/
  /* var n_total : t_cell_count; */
  double Result = _INVALID_REAL;
  t_e_r_cell_index index;
  boolean ok = true;
  boolean report;
  t_long_real x;
  t_e_r_cell_index FORLIM;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1369L, 1L)) {
    report = false;
    FORLIM = FIRST_INDEX + *m * *m2;
    for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
      x = (*r)->z[*r_offset + index] - (*r_old)->z[*r_old_offset + index];
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(r, r_offset, *r_offset + index, " FindMipsDeviance   ", 20L,
		1369L, 1L);
	  /* ntr */
      ntr_t_ref(r_old, r_old_offset, *r_old_offset + index,
		" FindMipsDeviance   ", 20L, 1369L, 1L);
	  /* ntr */
      ntr_t_ass(workspace, workspace_offset, *workspace_offset + index, x,
		" FindMipsDeviance   ", 20L, 1369L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*workspace)->z[*workspace_offset + index] = x;
      if (fabs(x) > 0)
	report = true;
    }
    if (report)
      write_headed_ssd_t(" Change, FMD:      @                    ", 19L,
			 model_set, *n_offset, *workspace_offset, workspace,
			 *m1, *m2, NULL, false, 2L, false);
  }
  if (trace_flag_set(20L, 1369L, 2L))
    write_headed_ssd_t(" FindMipsDeviance: @                    ", 19L,
		       model_set, *n_offset, *r_offset, r, *m1, *m2, NULL,
		       false, 2L, false);
  /*$endif TRACE*/
  if (boolean_option[114]) {   /* mixed_item, */
    normalise_ps(r, r_offset, n_offset, workspace, *workspace_offset, m, m1,
		 m2, &ok);
    if (ok)   /* mixed_item, */
      normalise_ps(r, r_offset, n_offset, workspace, *workspace_offset, m, m1,
		   m2, &ok);
    /* model_set, */
    /* n_total, */
  }
  /* model_set, */
  /* n_total, */
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1369L, 2L))
    write_headed_ssd_ss(" SS:@@@@@@@@@@@@@@@@                    ", 4L,
			model_set, *n_offset, *ss_offset, ss, *m1, *m2, NULL,
			false, 1L, false);
  if (trace_flag_set(20L, 1369L, 8L))
    write_headed_ssd_t(" FindMipsDeviance: @                    ", 19L,
		       model_set, *n_offset, *r_offset, r, *m1, *m2, NULL,
		       false, 2L, false);
  /*$endif TRACE*/
  if (ok)
    return (sub_find_mips_deviance(r, r_offset, ss, ss_offset, n_offset, m,
				   m1, m2));
  *ifail = 16;
  return Result;
}  /* find_mips_deviance */


Static t_long_real find_mips_change(r, r_offset, copy, copy_offset, m, m2)
t_t_r **r;
t_t_offset *r_offset;
t_t_r **copy;
t_t_offset *copy_offset;
t_integer *m, *m2;
{
  /* m1, */
  t_e_r_cell_index index, FORLIM;
  t_long_real d = 0.0;
  t_long_real cell_d;

  FORLIM = FIRST_INDEX + *m * *m2;
  for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(r, r_offset, *r_offset + index, " FindMipsChange     ", 20L,
	      1370L, 1L);
    ntr_t_ref(copy, copy_offset, *copy_offset + index, " FindMipsChange     ",
	      20L, 1370L, 1L);
    /*$endif TRACE-ARRAY*/
    cell_d = fabs((*r)->z[*r_offset + index] - (*copy)->z[*copy_offset + index]);
    if (cell_d > d)
      d = cell_d;
  }
  return d;
}  /* find_mips_change */


Static Void change_after_update(model_set, r, r_offset, ss, ss_offset,
  n_offset, copy, copy_offset, workspace, workspace_offset, m, m1, m2, ifail,
  max_suff, d, l1, l2)
long *model_set;
t_t_r **r;
t_t_offset *r_offset;
t_ss_r **ss;
t_ss_offset *ss_offset;
t_offset *n_offset;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m, *m1, *m2, *ifail;
t_long_real *max_suff, *d, *l1, *l2;
{
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1371L, 7L))
    write_headed_ssd_t(" Estimates: @@@@@@@@                    ", 12L,
		       model_set, *n_offset, *r_offset, r, *m1, *m2, NULL,
		       false, 2L, false);
  /*$endif TRACE*/
  if (mips_in_use == 4 || mips_in_use == 3)
    *d = *max_suff;
  else if (mips_in_use == 1)
    *d = find_mips_change(r, r_offset, copy, copy_offset, m, m2);   /* m1, */
  else {
    *l1 = find_mips_deviance(model_set, r, r_offset, ss, ss_offset, n_offset,
			     copy, copy_offset, workspace, workspace_offset,
			     m, m1, m2, ifail);
    /* n[0], */
    /* This can result in "nan"! */
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1371L, 1L))
      write_headed_ssd_t(" Estimates: @@@@@@@@                    ", 12L,
			 model_set, *n_offset, *r_offset, r, *m1, *m2, NULL,
			 false, 2L, false);
    if (trace_flag_set(20L, 1371L, 8L)) {
      write_pch(stdout, " Likelihood: ", 13L);
      write_real(stdout, *l1, 20L, 10L);
      write_real(stdout, *l2, 20L, 10L);
    }
    /*$endif TRACE*/
    *d = my_sub_long_real(l2, l1);
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1371L, 8L))
    return;
  /*$endif TRACE*/
  write_pch(stdout, " Delta: ", 8L);
  write_real(stdout, *d, 20L, 10L);
  write_line(stdout);
}  /* change_after_update */


Static Void change_sufficient(exp, obs, delta_suff, max_suff)
t_long_real *exp, *obs, *delta_suff, *max_suff;
{
  *delta_suff = *exp - *obs;
  if (mips_in_use == 4 && fabs(*delta_suff) > 0)
    *delta_suff /= fabs(*exp + *obs);
  if (fabs(*delta_suff) > *max_suff)
    *max_suff = fabs(*delta_suff);
}  /* change_sufficient */



Static Void save_before_update(r, r_offset, copy, copy_offset, m, m2, l1, l2)
t_t_r **r;
t_t_offset *r_offset;
t_t_r **copy;
t_t_offset *copy_offset;
t_integer *m, *m2;
t_long_real *l1, *l2;
{
  /* m1, */
  if (mips_in_use == 1)   /* m1, */
    copy_mips_estimates(r, r_offset, copy, copy_offset, m, m2);
  else
    *l2 = *l1;
}


Static t_iterate_pack *init_iterate_pack(epsilon, max_cycle_number, iterate,
					 outer, differences)
t_long_real *epsilon;
t_integer *max_cycle_number;
boolean iterate, outer, differences;
{
  t_iterate_pack *iterate_pack;
  t_integer i;

  iterate_pack = (t_iterate_pack *)Malloc(sizeof(t_iterate_pack));
  if (iterate_pack == NULL)
    _OutMem();
  iterate_pack->start_clock = my_clock()/1;
  iterate_pack->old_l = _INVALID_REAL;
  iterate_pack->max_suff = 0.0;
  iterate_pack->min_d = fabs(_INVALID_REAL);
  iterate_pack->epsilon = *epsilon;
  iterate_pack->cycle_number = 0;
  iterate_pack->bad_count = 0;
  iterate_pack->max_cycle_number = *max_cycle_number;
  iterate_pack->iterate = iterate;
  iterate_pack->outer = outer;
  iterate_pack->differences = NULL;
  if (!differences)
    return iterate_pack;
  iterate_pack->differences = (double *)Malloc(sizeof(t_double_array));
  if (iterate_pack->differences == NULL)
    _OutMem();
  for (i = 1; i <= 10; i++)
    iterate_pack->differences[i] = 0.0;
  return iterate_pack;
}  /* init_iterate_pack */


Static Void find_differences(old_l, l, epsilon, cycle, delta)
t_long_real *old_l, *l, *epsilon;
t_integer *cycle;
double *delta;
{
  /* ;
  bad_count : t_integer */
  t_integer i;
  t_integer n = 10;

  if (*l == -_INFINITY)
    *old_l = *l - 2 * *epsilon;
  delta[1] = *l - *old_l;
  for (i = 1; i < n; i++) {
    if (i < *cycle)
      delta[i+1] = delta[i] - delta[n + i];
  }
  for (i = 1; i < n; i++)
    delta[n + i] = delta[i];
}  /* find_differences */



Static Void report_differences(min_l, max_l, old_l, l, epsilon, cycle, delta,
			       bad_count)
t_long_real min_l, max_l, *old_l, *l, *epsilon;
t_integer *cycle;
double *delta;
t_integer bad_count;
{
  t_integer i;
  t_integer n = 10;

  write_dump_pch10(" @: ", 4L);
  write_dump_integer(*cycle, print_width - print_dec);
  write_dump_integer(bad_count, 4L);
  if (bad_count > 4)
    write_dump_pch10("%", 1L);
  else
    write_dump_pch10(" ", 1L);
  write_dump_real(min_l, print_width, print_dec);
  write_dump_real(max_l, print_width, print_dec);
  write_dump_real(*old_l, print_width, print_dec);
  if (*l < min_l)
    write_dump_pch10(" >%", 3L);
  else
    write_dump_pch10("   ", 3L);
  write_dump_real(*l, print_width, print_dec);
  if (max_l < *l)
    write_dump_pch10("%<", 2L);
  else
    write_dump_pch10("  ", 2L);
  for (i = 1; i <= n; i++) {
    if (i <= *cycle) {
      if (fabs(delta[i]) < *epsilon) {
	write_dump_pch20("                    ", print_width - 1);
	write_dump_pch10(".", 1L);
      } else
	write_dump_real(delta[i], print_width, print_dec);
    } else
      write_dump_real(_INFINITY_REAL, print_width, print_dec);
  }
  write_line_dump();
}  /* report_differences */


Static boolean trace_iteration(delta, iterate_pack)
t_long_real *delta;
t_iterate_pack **iterate_pack;
{
  boolean ok;
  t_iterate_pack *WITH;

  if (!(boolean_option[61] || boolean_option[62]))
    return false;
  WITH = *iterate_pack;
  if (boolean_option[61] &&
      (boolean_option[30] || WITH->iterate && WITH->cycle_number > 0))
    return true;
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  if (boolean_option[62] && WITH->iterate && WITH->cycle_number > 0 &&
      (WITH->outer || WITH->cycle_number > 1) &&
      (WITH->cycle_number < 10 ||
       WITH->cycle_number % 10 == 0 && WITH->cycle_number < 100 ||
       WITH->cycle_number % 100 == 0 && WITH->cycle_number < 1000 ||
       WITH->cycle_number % 1000 == 0 || fabs(*delta) < 1.05 * WITH->epsilon))
    ok = true;
  else
    ok = false;
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  return ok;
}  /* trace_iteration */


Static boolean do_mips_iteration(mixed_item, mips_g_c, model_set, c, copy,
  copy_offset, workspace, workspace_offset, m, m1, m2, iterate_pack)
t_mips_element **mixed_item;
t_set_list **mips_g_c;
long *model_set;
Char *c;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m, *m1, *m2;
t_iterate_pack **iterate_pack;
{
  boolean continue_;
  t_long_real l = _INVALID_REAL, d = _INVALID_REAL;
  t_iterate_pack *WITH;
  FILE *TEMP;

  WITH = *iterate_pack;
  if (WITH->cycle_number > 0) {
    /* ... -> l, old_l - l -> d */
    change_after_update(model_set, &(*mixed_item)->r,
      &(*mixed_item)->r_offset, &(*mixed_item)->ss, &(*mixed_item)->ss_offset,
      &(*mixed_item)->n_offset, copy, copy_offset, workspace,
      workspace_offset, m, m1, m2, &(*mixed_item)->ifail, &WITH->max_suff, &d,
      &l, &WITH->old_l);
  } else {
    WITH->old_l = _INVALID_REAL;
    if (WITH->iterate && mips_in_use == 2) {
      l = find_mips_deviance(model_set, &(*mixed_item)->r,
	  &(*mixed_item)->r_offset, &(*mixed_item)->ss,
	  &(*mixed_item)->ss_offset, &(*mixed_item)->n_offset,
	  &(*mixed_item)->r, &(*mixed_item)->r_offset, workspace,
	  workspace_offset, m, m1, m2, &(*mixed_item)->ifail);
      /* n[0], */
    }
  }
  (*mixed_item)->log_likelihood = l;
  /*$ifdef TRACE*/
  if (WITH->differences != NULL && boolean_option[64])   /* , bad_count */
    find_differences(&WITH->old_l, &l, &mips_epsilon, &WITH->cycle_number,
		     WITH->differences);
  if (trace_iteration(&d, iterate_pack)) {
    if (WITH->differences != NULL && boolean_option[64])
      report_differences((*mixed_item)->min_l, (*mixed_item)->max_l,
			 &WITH->old_l, &l, &mips_epsilon, &WITH->cycle_number,
			 WITH->differences, WITH->bad_count);
    else {
      write_pch(stdout, " Mips-cycle; ", 13L);
      write_pch(stdout, c, 10L);
      write_integer(stdout, WITH->cycle_number, print_width - print_dec);
      write_real(stdout, l, print_width + 4, print_dec + 2);
      write_real(stdout, WITH->old_l, print_width + 4, print_dec + 2);
      write_real(stdout, d, print_width + 8, print_dec + 6);
      write_real(stdout, WITH->min_d, print_width + 8, print_dec + 6);
      write_line(stdout);
    }
  }
  /*$endif TRACE*/
  if (fabs(d) < WITH->min_d)
    WITH->min_d = fabs(d);
  continue_ = (((fabs(d) > mips_epsilon &&
		 WITH->cycle_number < WITH->max_cycle_number &&
		 (*mixed_item)->ifail == 0 &&
		 WITH->iterate) || WITH->cycle_number == 0) && !interrupt_1);
      /* (d > 0) or */
  if (WITH->old_l - mips_epsilon <= l)
    WITH->bad_count = 0;
  else
    WITH->bad_count++;
  if (continue_) {
    if (WITH->bad_count > WITH->max_cycle_number / 200.0 &&
	WITH->bad_count > 5)
	/* As option to set mips .... ; !!! */
	{  /* As option to set mips .... ; !!! */
      (*mixed_item)->ifail = 15;
      continue_ = false;
    }
  }
  if ((!is_invalid_real((*mixed_item)->min_l)) &
      (!is_invalid_real((*mixed_item)->max_l))) {
    if (WITH->cycle_number > WITH->max_cycle_number / 1.0 &&
	WITH->cycle_number > 10 &&
	(l < (*mixed_item)->min_l || (*mixed_item)->max_l < l))
    {   /* As option to set mips .... ; !!! */
      (*mixed_item)->ifail = 10;
      continue_ = false;
    }
  }
  if (WITH->cycle_number >= WITH->max_cycle_number)
    (*mixed_item)->ifail = 11;
  WITH->cycle_number++;
  WITH->old_l = l;
  if (WITH->iterate) {
    if (continue_) {   /* m1, */
      /* l -> old_l */
      save_before_update(&(*mixed_item)->r, &(*mixed_item)->r_offset, copy,
			 copy_offset, m, m2, &l, &WITH->old_l);
    } else {
      (*mixed_item)->cycles = WITH->cycle_number;
      (*mixed_item)->mips_delta = d;
      (*mixed_item)->convergence = (fabs(d) < mips_epsilon);
      if (fabs(d) > mips_epsilon || (*mixed_item)->ifail > 0)
	no_convergence(*mips_g_c, "MIPS", 4L, &(*mixed_item)->ifail,
		       &WITH->cycle_number, &d);
      if (fabs(d) > 0 && WITH->cycle_number > 2) {
	/* 'MIPS@@@@@@', */
	report_convergence_mips(mixed_item, *mips_g_c, c, 4L, model_set,
				&WITH->cycle_number, &WITH->start_clock, &d,
				&mips_epsilon);
      }
    }
  }
  TEMP = stdout;
  flush_file(&TEMP);
  TEMP = stdout;
  flush_file(&TEMP);
  flush_file(&diary_file);
  flush_file(&log_file);
  return continue_;
}  /* do_mips_iteration */


/*

  ghknec.p:   1: Ill-conditioned matrix in Cholesky / 3
  mipsbas.p:  2: Ill-conditioned matrix in Cholesky / 6

  ghknec.p:   4: Almost singular matrix in Cholesky / 2
  mipsbas.p:  5: Almost singular matrix in Cholesky / 5

  ghknec.p:   7: Singular matrix in Cholesky        / 1
  mipsbas.p:  8: Singular matrix in Cholesky        / 4

  mipsbas.p: 10: range
  mipsbas.p: 11: to many iterations

  mipsbas.p: 15: bad count
  mipsbas.p: 16: find_mips_deviance: normalise_ps

  mipsdis.p: 18: adjust_g

  mips.p:    20: degenerated

  mips.p:    21: prepare_mixed ...

  mips.p:    22: return_tmp_t_space ...
  mips.p:    23: find_ssd ...

  mipsini.p: 24: find_ss
  mipsini.p: 25: return_t_space


  mipsini.p: 31: prepare_discrete_generator_list(discrete_generators);
  mipsini.p: 32: prepare_linear_generator_list(linear_generators);
  mipsini.p: 33: prepare_linear_and_quadratic_generator_list(
                                       linear_and_quadratic_generators);
  mipsini.p: 34: prepare_single_quadratic_generator_list(
                                       single_quadratic_generators);
  mipsini.p: 35: prepare_quadratic_pair_generator_list(
                                       quadratic_pair_generators);

  mipsini.p: 36: prepare_linear_generator_list(linear_generators);
  mipsini.p: 37: prepare_linear_and_quadratic_generator_list(
                                       linear_and_quadratic_generators);
  mipsini.p: 38: prepare_single_quadratic_generator_list(
                                       single_quadratic_generators);
  mipsini.p: 39: prepare_quadratic_pair_generator_list(
                                       quadratic_pair_generators);


  mipsdis.p: 41: iterate_discrete_generators:
  mipslin.p: 42: iterate_linear_generators:
  mipslaq.p: 43: iterate_linear_and_quadratic_generators:
  mipssin.p: 44: iterate_single_quadratic_generators:
  mipspar.p: 45: iterate_quadratic_pair_generators:

  mips.p:    46: mips: normalise_ps

  */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/*@+"mipsdis.p"*/


/*

1380:    +++  ++
1381:    +++  ++
1382:    ---  -- p/mipsdis.p          6      29     422 p/mipsdis.p
1383: |    4:    procedure adjust_by_discrete
1384: |   55:    procedure update_discrete_generator
1385: |   85:    procedure adjust_g
1386: |  156:    procedure report_step_halving
1387: |  230:    function do_step_halving
1388: |  314:    procedure iterate_discrete_generators
1389:    +++  ++
1390:    +++  ++

*/

Static Void adjust_by_discrete(c_in_a, n_total, ps, ps_offset, marginal_p,
			       marginal_p_offset, m, n_offset, i, max_suff)
t_fast_next_offset_pack *c_in_a;
t_cell_count *n_total;
t_t_r **ps;
t_t_offset *ps_offset;
t_t_r **marginal_p;
t_t_offset *marginal_p_offset;
t_integer *m;
t_offset *n_offset;
t_level *i;
t_long_real *max_suff;
{
  t_cell_index index;
  t_t_offset delta;
  t_integer m_i;
  t_long_real delta_suff, n_obs, n_exp;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;
  double TEMP;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " AdjustByDescrete   ", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  delta = *n_offset - *marginal_p_offset;
  m_i = *marginal_p_offset;
  FORLIM = *ps_offset + *m;
  for (index = *ps_offset; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1383L, 1L)) {
      write_pch(stdout, " Adjust from N: ", 16L);
      write_real(stdout, (*ps)->z[index], print_width, print_dec);
      write_real(stdout, (*marginal_p)->z[m_i], print_width, print_dec);
      write_integer(stdout, n[delta + m_i], print_width);
      write_real(stdout, (double)n[delta + m_i] / *n_total, print_width,
		 print_dec);
      if ((*marginal_p)->z[m_i] != 0)
	write_real(stdout,
	  log((double)n[delta + m_i] / *n_total / (*marginal_p)->z[m_i]),
	  print_width, print_dec);
    }
    /*$endif TRACE*/
    /*$ifdef TRACE-ARRAY*/
    ntr_n_ref(n, *n_offset, delta + m_i, tzt, 20L, 1384L, 1L);
    ntr_t_ref(marginal_p, marginal_p_offset, m_i, tzt, 20L, 1384L, 1L);
	/* ntr */
    ntr_t_upd(ps, ps_offset, index,
	      (double)n[delta + m_i] / *n_total / (*marginal_p)->z[m_i], 3L,
	      tzt, 20L, 1384L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    n_obs = n[delta + m_i];
    n_exp = (*marginal_p)->z[m_i] * *n_total;
    change_sufficient(&n_exp, &n_obs, &delta_suff, max_suff);
    TEMP = (*marginal_p)->z[m_i] * *n_total;
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1384L, 2L, 0L, 1L, &TEMP, (double)n[delta + m_i],
		&delta_suff, max_suff);
	/* ntr */
    /*$endif TRACE*/
    if ((*marginal_p)->z[m_i] != 0)
      (*ps)->z[index] *= (double)n[delta + m_i] / *n_total / (*marginal_p)->z[m_i];
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1383L, 1L)) {
      write_real(stdout, (*ps)->z[index], print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/
    fast_next_offset(c_in_a, &m_i, i);
  }
  m_i -= FIRST_INDEX;
}  /* adjust_by_discrete */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

Static Void update_discrete_generator(d, n_d_offset, ps, ps_offset,
  marginal_p, marginal_p_offset, a, m, n_total, max_suff)
long *d;
t_offset *n_d_offset;
t_t_r **ps;
t_t_offset *ps_offset;
t_t_r **marginal_p;
t_t_offset *marginal_p_offset;
long *a;
t_integer *m;
t_cell_count *n_total;
t_long_real *max_suff;
{
  /* , m1, m2*/
  t_fast_next_offset_pack c_in_a;
  t_cell i;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1384L, 1L)) {
    write_pch(stdout, " Discrete generator:          ", 30L);
    print_vertex_set(d);
    write_line(stdout);
  }
  /*$endif TRACE*/
  memcpy(i, first_cell, sizeof(t_cell));
  marginalize_in_r(a, d, &c_in_a, ps, ps_offset, marginal_p,
		   marginal_p_offset, m, i);

  adjust_by_discrete(&c_in_a, n_total, ps, ps_offset, marginal_p,
		     marginal_p_offset, m, n_d_offset, i, max_suff);
}  /* update_discrete_generator */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

Static Void adjust_g(mixed_item, all_discrete, model_set, d_set, n_d_offset,
		     n_offset, r, r_offset, workspace, workspace_offset, a, m,
		     m1, m2, n_total, ok, max_suff)
t_mips_element **mixed_item;
boolean *all_discrete;
long *model_set, *d_set;
t_offset *n_d_offset, *n_offset;
t_t_r **r;
t_t_offset *r_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
long *a;
t_integer *m, *m1, *m2;
t_cell_count *n_total;
boolean *ok;
t_long_real *max_suff;
{
  t_discrete_generator *p;
  t_long_real gamma_constant, dummy;
  t_t_r *ps = NULL, *determinants = NULL, *products = NULL;
      /* T_T, malloc_workspace */
  t_integer index;
  boolean ok_invertible;
  t_t_offset tmp_offset, ps_offset, determinants_offset, products_offset;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " AdjustG            ", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  if ((trace_flag_set(20L, 1369L, 1L) | trace_flag_set(20L, 1371L, 1L) |
       trace_flag_set(20L, 1383L, 1L)) || boolean_option[60]) {
    dummy = find_mips_deviance(model_set, r, r_offset, &(*mixed_item)->ss,
	&(*mixed_item)->ss_offset, &(*mixed_item)->n_offset,
	&(*mixed_item)->r, &(*mixed_item)->r_offset, workspace,
	workspace_offset, m, m1, m2, &(*mixed_item)->ifail);
    /*  n_total, */
  }
  gamma_constant = *m1 * LN_2_PI_HALF;
  tmp_offset = *workspace_offset;
  malloc_workspace(workspace, &tmp_offset, &ps, &ps_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &determinants,
		   &determinants_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &products, &products_offset, *m);
  /* -> m * (3) */
  find_determinants_and_products(m, m1, m2, n_offset, r, r_offset, workspace,
    tmp_offset, &determinants, &determinants_offset, &products,
    &products_offset, boolean_option[105], &ok_invertible);
  if (!(ok_invertible || boolean_option[105])) {   /* m1, */
    *ok = false;
    (*mixed_item)->ifail = 18;
    return;
  }
  g_to_ps(&gamma_constant, m, m2, n_offset, r, r_offset, &ps, &ps_offset,
	  &determinants, &determinants_offset, &products, &products_offset);
  /* Consider replacing `adjust_by_discrete' and `p_to_gs'
     by direct update of 'g': */
  index = ps_offset;
  *ok = true;
  while (*ok && index < ps_offset + *m) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(&ps, &ps_offset, index, tzt, 20L, 1385L, 1L);
    /*$endif TRACE-ARRAY*/
    *ok = !is_invalid_real(ps->z[index]);
    if (*ok && boolean_option[107])
      *ok = (log(ps->z[index]) / log(10.0) < 1);
    index++;
  }
  if (!*ok)
    return;
  if (!ok_invertible)
    make_ks_invertible(m, m1, m2, r, r_offset, workspace, tmp_offset,
		       &ok_invertible);
  if (*all_discrete) {
    p = (*mixed_item)->generators->discrete_generators;
    while (p != NULL) {   /* m1, m2, */
      update_discrete_generator(p->d, &p->n_d_offset, &ps, &ps_offset,
				workspace, &tmp_offset, a, m, n_total,
				max_suff);
      p = p->pointer;
    }
  } else
    update_discrete_generator(d_set, n_d_offset, &ps, &ps_offset, workspace,
			      &tmp_offset, a, m, n_total, max_suff);
  /* m1, m2, */

  /* m1, */
  p_to_gs(1.0, &gamma_constant, m, m2, n_offset, r, r_offset, &ps, &ps_offset,
	  &determinants, &determinants_offset, &products, &products_offset);
}  /* adjust_g */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

Static Void report_step_halving(set_list, c, w, ifail, old_ifail, d)
t_set_list *set_list;
Char *c;
t_integer w, *ifail, *old_ifail;
t_long_real *d;
{
  /* var
     cc: t_integer; */
  if (!(note_warnings &&
	(boolean_option[61] || boolean_option[62] || boolean_option[63] ||
	 boolean_option[64])))
    return;
  /*
  cc := char_count;
  write_pch(output, '/ *@@@@@@@@', 2);
  if cc > 30 then
     write_line(output)
  else
     write_space(output, 2);
  write_pch(output, ' *** WARNING *** @@@', 17);
  if interrupt_1 then begin
     write_pch(output, '  Interrupt in @@@@@', 15);
     interrupt_1 := false
  end else
  if ifail > 0 then
     write_pch(output, ' Iteration aborted, ', 20)
  else
     write_pch(output, ' Max Cycles in @@@@@', 15);
   */
  write_char(stdout, ' ');
  write_pch(stdout, c, w);
  write_char(stdout, ':');
  /*
  write_char(output, ' ');
  while set_list <> nil do begin
     print_vertex_set(set_list^.vertex_set);
     set_list := set_list^.pointer
  end;
   */
  /* write_line(output); */
  write_space(stdout, 2L);
  write_space(stdout, 19L);
  write_pch(stdout, " Previous:", 10L);
  write_integer(stdout, *old_ifail, 5L);
  write_space(stdout, 2L);
  if (true) {   /* ifail > 0 */
    write_pch(stdout, " Ifail:", 7L);
    write_integer(stdout, *ifail, 5L);
    write_space(stdout, 2L);
  }
  write_pch(stdout, " Lambda:", 8L);
  write_real(stdout, *d, print_width, print_dec);

  write_char(stdout, ':');
  write_char(stdout, ' ');
  while (set_list != NULL) {
    print_vertex_set(set_list->vertex_set);
    set_list = set_list->pointer;
  }

  /*
  write_space(output, 2);
  write_pch(output, ' *** WARNING *** @@@', 17);
  if cc > 2 then begin
     write_line(output);
     write_space(output, cc - 2);
     write_pch(output, '%/@@@@@@@@', 2)*/
/* p2c: coco_d_p2c.p, line 34850:
 * Note: Changed "* /" to "% /" in comment [140]
end else begin
   write_space(output, 2);
   write_pch(output, '%/@@@@@@@@', 2);*/
/* p2c: coco_d_p2c.p, line 34853:
 * Note: Changed "* /" to "% /" in comment [140]
   write_line(output)
end
 */
  write_line(stdout);
}  /* report_step_halving */


/* Local variables for do_step_halving: */
struct LOC_do_step_halving {
  boolean adjust_all_discrete;
} ;


Static boolean do_step_halving(mixed_item, adjust_all_discrete_, mips_g_c,
  model_set, a, d, n_d_offset, r_new, r_new_offset, r_old, r_old_offset,
  workspace, workspace_offset, n_total, m, m1, m2, lambda, l, mips_min_lambda)
t_mips_element **mixed_item;
boolean adjust_all_discrete_;
t_set_list **mips_g_c;
long *model_set, *a, *d;
t_offset *n_d_offset;
t_t_r **r_new;
t_t_offset *r_new_offset;
t_t_r **r_old;
t_t_offset *r_old_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_cell_count *n_total;
t_integer *m, *m1, *m2;
t_long_real *lambda, *l, mips_min_lambda;
{
  struct LOC_do_step_halving Local_Var;
  boolean ok;
  boolean continue_ = true;
  t_integer ifail;
  t_long_real max_suff = 0.0;

  Local_Var.adjust_all_discrete = adjust_all_discrete_;
  ifail = (*mixed_item)->ifail;
  *l = _INVALID_REAL;
  if (*lambda > 1 + ROUND_ERROR || *lambda == 0) {
    if (is_invalid_real((*mixed_item)->log_likelihood)) {
      *l = find_mips_deviance(model_set, r_old, r_old_offset,
	  &(*mixed_item)->ss, &(*mixed_item)->ss_offset,
	  &(*mixed_item)->n_offset, r_old, r_old_offset, workspace,
	  workspace_offset, m, m1, m2, &(*mixed_item)->ifail);
      /* n_total, */

      (*mixed_item)->log_likelihood = *l;
      if ((*mixed_item)->ifail != 0) {
	report_step_halving(*mips_g_c, "STEP 1", 6L,
			    &(*mixed_item)->ifail, &ifail, lambda);
	(*mixed_item)->ifail = ifail;
      }
    } else
      *l = (*mixed_item)->log_likelihood;
  } else {
    ok = true;
    if (!boolean_option[100])
      adjust_g(mixed_item, &Local_Var.adjust_all_discrete, model_set, d,
	       n_d_offset, &(*mixed_item)->n_offset, r_new, r_new_offset,
	       workspace, workspace_offset, a, m, m1, m2, n_total, &ok,
	       &max_suff);
    if (*lambda < mips_min_lambda)
      continue_ = false;
    else if (ok) {
      *l = find_mips_deviance(model_set, r_new, r_new_offset,
	  &(*mixed_item)->ss, &(*mixed_item)->ss_offset,
	  &(*mixed_item)->n_offset, r_old, r_old_offset, workspace,
	  workspace_offset, m, m1, m2, &(*mixed_item)->ifail);
      /* n_total, */
      continue_ = (*l < (*mixed_item)->log_likelihood -
	    fabs((*mixed_item)->log_likelihood) * mips_log_l_round_error);
    } else {
      report_step_halving(*mips_g_c, "STEP 2", 6L, &(*mixed_item)->ifail,
			  &ifail, lambda);
      (*mixed_item)->ifail = ifail;
      continue_ = true;
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1387L, 1L)) {
      write_pch(stdout, " Lambda:  ", 10L);
      write_real(stdout, *lambda, 20L, 10L);
      write_real(stdout, *l, 20L, 10L);
      if (ok)
	write_real(stdout, *l - (*mixed_item)->log_likelihood, 20L, 10L);
      write_line(stdout);
    }
    /*$endif TRACE*/
  }
  *lambda /= 2;
  if (interrupt_1)
    continue_ = false;
  return continue_;
}  /* do_step_halving */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

Static Void iterate_discrete_generators(mixed_item, mips_g_c, model_set, copy,
  copy_offset, workspace, workspace_offset, a, m, m1, m2, n_total,
  mips_epsilon, max_cycle_number, max_suff, ok, iterate_discrete)
t_mips_element **mixed_item;
t_set_list **mips_g_c;
long *model_set;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
long *a;
t_integer *m, *m1, *m2;
t_cell_count *n_total;
t_long_real *mips_epsilon;
t_integer *max_cycle_number;
t_long_real *max_suff;
boolean *ok, *iterate_discrete;
{
  t_discrete_generator *p;
  t_long_real gamma_constant;
  t_t_r *ps = NULL, *determinants = NULL, *products = NULL;
      /* T_T, malloc_workspace */
  t_t_offset tmp_offset, ps_offset, determinants_offset, products_offset;
  t_iterate_pack *iterate_pack;

  iterate_pack = init_iterate_pack(mips_epsilon, max_cycle_number,
				   *iterate_discrete, false, false);
  gamma_constant = *m1 * LN_2_PI_HALF;
  tmp_offset = *workspace_offset;
  malloc_workspace(workspace, &tmp_offset, &ps, &ps_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &determinants,
		   &determinants_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &products, &products_offset, *m);
  /* -> m * (3) */
  find_determinants_and_products(m, m1, m2, &(*mixed_item)->n_offset,
    &(*mixed_item)->r, &(*mixed_item)->r_offset, workspace, tmp_offset,
    &determinants, &determinants_offset, &products, &products_offset, false,
    ok);
  if (*ok) {   /* m1, */
    g_to_ps(&gamma_constant, m, m2, &(*mixed_item)->n_offset,
	    &(*mixed_item)->r, &(*mixed_item)->r_offset, &ps, &ps_offset,
	    &determinants, &determinants_offset, &products, &products_offset);
    while (do_mips_iteration(mixed_item, mips_g_c, model_set, " Discrete:",
			     copy, copy_offset, workspace, &tmp_offset, m, m1,
			     m2, &iterate_pack))
    {   /* m1, */
      iterate_pack->max_suff = 0.0;
      p = (*mixed_item)->generators->discrete_generators;
      while (p != NULL) {   /* m1, m2, */
	update_discrete_generator(p->d, &p->n_d_offset, &ps, &ps_offset,
				  workspace, &tmp_offset, a, m, n_total,
				  &iterate_pack->max_suff);
	p = p->pointer;
      }
    }
    p_to_gs(1.0, &gamma_constant, m, m2, &(*mixed_item)->n_offset,
	    &(*mixed_item)->r, &(*mixed_item)->r_offset, &ps, &ps_offset,
	    &determinants, &determinants_offset, &products, &products_offset);
  } else
    (*mixed_item)->ifail = 41;
  if (iterate_pack->max_suff > *max_suff)
    *max_suff = iterate_pack->max_suff;
  _Free(iterate_pack);
}  /* iterate_discrete_generators */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/*@+"mipslin.p"*/


/*

1391:    +++  ++
1392:    +++  ++
1393:    ---  -- p/mipslin.p          8      38     456 p/mipslin.p
1394: |    4:    procedure find_expected_ns_and_khis
1395: |   76:    procedure find_marginal_expected_n_and_s
1396: |  129:    procedure adjust_by_linear
1397: |  245:    procedure step_half
1398: |  254:    procedure half_difference
1399: |  259:    procedure step_half_linear
1400: |  313:    procedure update_linear_generator
1401: |  377:    procedure iterate_linear_generators
1402:    +++  ++
1403:    +++  ++

*/

Static Void find_expected_ns_and_khis(m0, m1, m2, n_offset, r, r_offset,
  workspace, workspace_offset, ns, ns_offset, khis, khis_offset, n_total, ok)
t_integer *m0, *m1, *m2;
t_offset *n_offset;
t_t_r **r;
t_t_offset *r_offset;
t_t_r **workspace;
t_t_offset workspace_offset;
t_t_r **ns;
t_t_offset *ns_offset;
t_t_r **khis;
t_t_offset *khis_offset;
t_cell_count *n_total;
boolean *ok;
{
  t_integer i;
  t_t_r *g, *h, *k, *l, *m, *k_invers;   /* T_T, arguments */
  t_t_offset k_index, h_index, g_index, l_index, m_index, k_invers_index,
	     local_ns_index, local_khis_index;
  t_long_real gamma_constant, determinant, product;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ExpectedNsAndKhis  ", sizeof(pch20));
  /*$endif TRACE*/
  gamma_constant = *m1 * LN_2_PI_HALF;
  h = *r;
  h_index = *r_offset;
  k = *r;
  k_index = *r_offset + *m1;
  g = *r;
  g_index = *r_offset + *m2 - 1;
  l = *workspace;
  m = *workspace;
  k_invers = *workspace;
  l_index = workspace_offset;
  m_index = workspace_offset + *m2;
  k_invers_index = workspace_offset + *m2 * 2;
  local_ns_index = *ns_offset;
  local_khis_index = *khis_offset;
  for (i = 0; i < *m0; i++) {
    note_number_of_observations(n_offset, i);
    if (true)
      find_one_k_inverse(&k, &k_invers, &l, &m, &k_index, &k_invers_index,
			 &l_index, &m_index, m1, !boolean_option[63], ok);
    else
      *ok = false;
    if (*ok) {
      determinant = find_determinant_from_cholesky_t(&l, &l_index, m1);
      product = find_one_product(&h, &m, &h_index, &m_index, m1);
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(&g, r_offset, g_index, tzt, 20L, 1394L, 1L);   /* ntr */
      ntr_t_ass(ns, ns_offset, local_ns_index, _INVALID_REAL, tzt, 20L, 1394L,
		-2L);
      /*$endif TRACE-ARRAY*/
      (*ns)->z[local_ns_index] = find_p_from_g(gamma_constant, g->z[g_index],
				   determinant, product) * *n_total;
	  /* ntr */
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(ns, ns_offset, local_ns_index, _INVALID_REAL, tzt, 20L, 1394L,
		2L);
      /*$endif TRACE-ARRAY*/
      mult_symmetric_matrix_and_vector_t_t_t(&h, &k_invers, khis, &h_index,
	&k_invers_index, &local_khis_index, m1);
    }

    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1394L, 1L)) {
      write_pch(stdout, tzt, 20L);
      write_integer(stdout, local_ns_index, 5L);
      write_integer(stdout, local_khis_index, 5L);
      write_real(stdout, (*ns)->z[local_ns_index], print_width, print_dec);
      write_real(stdout, (*khis)->z[local_khis_index], print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/

    local_ns_index++;
    local_khis_index += *m1;
    g_index += *m2;
    h_index += *m2;
    k_index += *m2;
  }
}  /* find_expected_ns_and_khis */


Static Void find_marginal_expected_n_and_s(a, d, c, d_in_a, E_n, E_n_offset,
  khi, khi_offset, n_step, khi_step, E_n_d, E_n_d_offset, E_s_d, E_s_d_offset,
  m, i)
long *a, *d, *c;
t_fast_next_offset_pack *d_in_a;
t_t_r **E_n;
t_t_offset *E_n_offset;
t_t_r **khi;
t_t_offset *khi_offset;
t_long_integer n_step, khi_step;
t_t_r **E_n_d;
t_t_offset *E_n_d_offset;
t_t_r **E_s_d;
t_t_offset *E_s_d_offset;
t_integer *m;
t_level *i;
{
  t_cell_index index, ii;
  t_t_offset md, n_index, khi_index;
  t_integer m_i = 0;
  t_integer m1_c, m2_c, k, l;
  t_vertex v;
  t_vertex_set a_gamma, a_delta;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " FindMargExpeNandS. ", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  P_setint(a_gamma, a, gamma_);
  md = marginal_dimension(d);
  clear_t_array(E_n_d, E_n_d_offset, &md);
  return_ghk_size(c, &m1_c, &m2_c);
  md *= m1_c;
  clear_t_array(E_s_d, E_s_d_offset, &md);
  memcpy(i, first_cell, sizeof(t_cell));
  P_setint(a_delta, a, delta);
  fast_find_products(a_delta, d, d_in_a);
  n_index = *E_n_offset;
  khi_index = *khi_offset;
  FORLIM = *m;
  for (ii = 0; ii <= FORLIM - 1; ii++) {
    index = *E_n_d_offset + m_i;
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(E_n, E_n_offset, n_index, tzt, 20L, 1395L, 1L);
    ntr_t_upd(E_n_d, E_n_d_offset, index, (*E_n)->z[n_index], 1L, tzt, 20L,
	      1395L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*E_n_d)->z[index] += (*E_n)->z[n_index];
    k = 0;
    l = 0;
    index = *E_s_d_offset + m1_c * m_i;
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, a_gamma)) {  /* Was gamma ?!?!  */
	if (P_inset(v, c)) {
	  /*$ifdef TRACE-ARRAY*/
	  ntr_t_ref(E_n, E_n_offset, n_index, tzt, 20L, 1395L, 1L);
	  ntr_t_ref(khi, khi_offset, khi_index + k, tzt, 20L, 1395L, 1L);
	  ntr_t_upd(E_n_d, E_n_d_offset, index + l,
		    (*khi)->z[khi_index + k] * (*E_n)->z[n_index], 1L, tzt,
		    20L, 1395L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  (*E_s_d)->z[index + l] += (*khi)->z[khi_index + k] * (*E_n)->z[n_index];
	  l++;
	}
	k++;
      }
    }
    n_index += n_step;
    khi_index += khi_step;
    fast_next_offset(d_in_a, &m_i, i);
  }
}  /* find_marginal_expected_n_and_s */



Static Void adjust_by_linear(d_in_a, a_, c, d, n_offset, n_total, s, s_offset,
			     t, t_offset_, O_s, O_s_offset, E_s, E_s_offset,
			     E_n, E_n_offset, m, m1, m2, n_d_offset, i,
			     lambda, max_suff, update_discrete, update_linear)
t_fast_next_offset_pack *d_in_a;
long *a_, *c, *d;
t_offset *n_offset;
t_cell_count *n_total;
t_t_r **s;
t_t_offset *s_offset;
t_t_r **t;
t_t_offset *t_offset_;
t_s_r **O_s;
t_s_offset *O_s_offset;
t_t_r **E_s;
t_t_offset *E_s_offset;
t_t_r **E_n;
t_t_offset *E_n_offset;
t_integer *m, *m1, *m2, n_d_offset;
t_level *i;
t_long_real *lambda, *max_suff;
boolean *update_discrete, *update_linear;
{
  t_vertex v;
  t_vertex_set a_gamma, a_d;
  t_cell_index s_index, t_index, index;
  t_integer m_i = 0;
  t_integer l, k, m1_c, m2_c;
  t_long_real g_change, h_change, x, z, a, b, delta_suff, sum, n_obs, n_exp,
	      s_obs, s_exp;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " AdjustByLinear     ", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  P_setint(a_gamma, a_, gamma_);
  if (boolean_option[119])
    z = *n_total * marginal_dimension(d);
  else {
    P_setdiff(a_d, a_, d);
    z = *n_total * marginal_dimension(a_d);
  }
  z = 1 / z;
  return_ghk_size(c, &m1_c, &m2_c);
  t_index = *t_offset_;
  s_index = *s_offset;
  FORLIM = *m2 * *m;
  for (index = 0; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(s, s_offset, s_index + index, tzt, 20L, 1396L, 1L);
    ntr_t_ass(t, t_offset_, t_index + index, (*s)->z[s_index + index], tzt,
	      20L, 1396L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*t)->z[t_index + index] = (*s)->z[s_index + index];
  }

  FORLIM = *m;
  for (index = 0; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(E_n, E_n_offset, *E_n_offset + m_i, tzt, 20L, 1396L, 1L);
    ntr_n_ref(n, n_d_offset, n_d_offset + m_i, tzt, 20L, 1396L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    n_obs = n[n_d_offset + m_i];
    n_exp = (*E_n)->z[*E_n_offset + m_i];   /* * n_total */
    change_sufficient(&n_exp, &n_obs, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1396L, 2L, 0L, 1L, &n_exp, n_obs, &delta_suff,
		max_suff);
    /*$endif TRACE*/
    k = 0;
    l = 0;
    sum = 0.0;

    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1396L, 1L)) {
      write_pch(stdout, " AdjustByLinear: ", 17L);
      write_space(stdout, print_width * 3 - 27);
      write_integer(stdout, t_index, 5L);
      write_integer(stdout, s_index, 5L);
      write_integer(stdout, n_d_offset, 5L);
      write_real(stdout, n_obs, print_width, print_dec);
      write_real(stdout, n_exp, print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/

    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, a_gamma)) {
	if (P_inset(v, c)) {   /* ntr */
	  ntr_s_ref(O_s, O_s_offset, *O_s_offset + m2_c * m_i + l, tzt, 20L,
		    1396L, 1L);
	      /* ntr */
	  /* ntr */
	  ntr_t_ref(E_s, E_s_offset, *E_s_offset + m1_c * m_i + l, tzt, 20L,
		    1396L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  s_obs = n_obs * (*O_s)->z[*O_s_offset + m2_c * m_i + l];   /**/
	  /**/
	  a = s_obs / n_obs;
	  s_exp = (*E_s)->z[*E_s_offset + m1_c * m_i + l];
	  b = s_exp / n_exp;
	  g_change = 0.0;
	  h_change = a - b;
	  change_sufficient(&s_exp, &s_obs, &delta_suff, max_suff);
	  /*$ifdef TRACE*/
	  ntr_4_reals(tzt, 20L, 1396L, 2L, 0L, 2L, &s_exp, s_obs, &delta_suff,
		      max_suff);
	  /*$endif TRACE*/
	  /*$ifdef TRACE-ARRAY*/
	  ntr_t_ref(s, s_offset, s_index + k, tzt, 20L, 1396L, 1L);
	      /* ntr */
	  ntr_t_ass(t, t_offset_, t_index + k,
		    (*s)->z[s_index + k] + *lambda * h_change, tzt, 20L,
		    1396L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  (*t)->z[t_index + k] = (*s)->z[s_index + k] + *lambda * h_change;
	      /* h */
	  sum += b * b - a * a;

	  /*$ifdef TRACE*/
	  ntr_4_reals(tzt, 20L, 1396L, 3L, 9L, 8L, &g_change, g_change,
		      &h_change, &g_change);
	  /*$endif TRACE*/
	  /*$ifdef TRACE*/
	  if (trace_flag_set(20L, 1396L, 1L)) {
	    write_space(stdout, 3L);
	    print_vertex(v);
	    write_real(stdout, s_obs, print_width, print_dec);
	    write_real(stdout, s_exp, print_width, print_dec);
	    write_real(stdout, a, print_width, print_dec);
	    write_real(stdout, b, print_width, print_dec);
	    write_real(stdout, a - b, print_width, print_dec);
	    write_real(stdout, sum, print_width, print_dec);
	    write_line(stdout);
	  }
	  /*$endif TRACE*/

	  l++;
	}
	/*$ifdef TRACE-ARRAY*/
	k++;
      }
    }

    x = g_adjustment(n_obs, n_exp, z) + sum / 2;   /* (n_obs - n_exp) * z */

    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1396L, 1L)) {
      write_real(stdout, x, print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/

    if (*update_discrete) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(s, s_offset, s_index + *m2 - 1, tzt, 20L, 1396L, 1L);
	  /* ntr */
      ntr_t_ass(t, t_offset_, t_index + *m2 - 1,
		(*s)->z[s_index + *m2 - 1] + *lambda * x, tzt, 20L, 1396L,
		1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      /*$ifdef TRACE*/
      ntr_4_reals(tzt, 20L, 1396L, 3L, 9L, 9L, &x, g_change, &g_change,
		  &g_change);
      /*$endif TRACE*/
      (*t)->z[t_index + *m2 - 1] = (*s)->z[s_index + *m2 - 1] + *lambda * x;
    }

    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1396L, 8L))
      write_headed_ssd_t(" New estimates: @@@@                    ", 16L, a_,
			 *n_offset, *t_offset_, t, *m1, *m2, NULL, false, 2L,
			 false);
    /*$endif TRACE*/

    t_index += *m2;
    s_index += *m2;
    fast_next_offset(d_in_a, &m_i, i);
  }
}  /* adjust_by_linear */



/* Not used:
procedure step_half(var s: t_t;
                    var s_index: t_t_offset;
                    var t: t_t;
                    var t_index: t_t_offset;
                    var index: t_integer);
begin
   t^.z^[t_index + index] := (s^.z^[s_index + index] + t^.z^[t_index + index]) / 2;
end; */
/* step_half */

Static Void half_difference(a, b)
t_long_real *a, *b;
{
  *a = (*b + *a) / 2;
}  /* half_difference */


Static Void step_half_linear(a, c, s, s_offset, t, t_offset_, m, m2,
			     update_discrete, update_linear)
long *a, *c;
t_t_r **s;
t_t_offset *s_offset;
t_t_r **t;
t_t_offset *t_offset_;
t_integer *m, *m2;
boolean *update_discrete, *update_linear;
{
  t_cell_index s_index, t_index, index;
  t_integer k;
  t_vertex v;
  t_vertex_set b;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " StepHalfLinear     ", sizeof(pch20));
  FORLIM = *m;
  /*$endif TRACE-ARRAY*/
  for (index = 0; index <= FORLIM - 1; index++) {
    t_index = *t_offset_ + *m2 * index;
    s_index = *s_offset + *m2 * index;
    if (*update_discrete) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(s, s_offset, s_index + *m2 - 1, tzt, 20L, 1399L, 1L);
      ntr_t_ref(t, t_offset_, t_index + *m2 - 1, tzt, 20L, 1399L, 1L);
      /*$endif TRACE-ARRAY*/
      half_difference(&(*t)->z[t_index + *m2 - 1],
		      &(*s)->z[s_index + *m2 - 1]);
    }
    if (*update_linear) {
      k = 0;
      P_setint(b, a, gamma_);
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, b)) {
	  if (P_inset(v, c)) {
	    /*$ifdef TRACE-ARRAY*/
	    ntr_t_ref(s, s_offset, s_index + k, tzt, 20L, 1399L, 1L);
	    ntr_t_ref(t, t_offset_, t_index + *m2 - 1, tzt, 20L, 1399L, 1L);
	    /*$endif TRACE-ARRAY*/
	    half_difference(&(*t)->z[t_index + k], &(*s)->z[s_index + k]);
	  }
	  k++;
	}
      }
    }
  }
}  /* step_half_linear */


/* Local variables for update_linear_generator: */
struct LOC_update_linear_generator {
  t_mips_element **mixed_item;
  t_set_list **mips_g_c;
  long *model_set;
  t_linear_generator *generator;
  long *a;
  t_offset *n_offset;
  t_t_r **r_old, **r_new;
  t_t_offset r_old_offset, r_new_offset, E_s_d_offset, E_n_d_offset,
	     workspace_offset;
  t_s_r **O_s_d;
  t_s_offset O_s_d_offset;
  t_t_r **E_s_d, **E_n_d, **workspace;
  t_integer m, m1, m2;
  t_cell_count n_total;
  boolean update_discrete, update_linear;
  t_cell i;
  t_fast_next_offset_pack d_in_a;
} ;

/*$endif TRACE*/

Local t_long_real line_linear(lambda, max_suff, LINK)
t_long_real lambda, *max_suff;
struct LOC_update_linear_generator *LINK;
{
  boolean ok;
  t_long_real log_l;

  if (lambda > 0)
    adjust_by_linear(&LINK->d_in_a, LINK->a, LINK->generator->c,
		     LINK->generator->d, LINK->n_offset, &LINK->n_total,
		     LINK->r_old, &LINK->r_old_offset, LINK->r_new,
		     &LINK->r_new_offset, LINK->O_s_d, &LINK->O_s_d_offset,
		     LINK->E_s_d, &LINK->E_s_d_offset, LINK->E_n_d,
		     &LINK->E_n_d_offset, &LINK->m, &LINK->m1, &LINK->m2,
		     LINK->generator->n_d_offset, LINK->i, &lambda, max_suff,
		     &LINK->update_discrete, &LINK->update_linear);
  ok = do_step_halving(LINK->mixed_item, false, LINK->mips_g_c,
      LINK->model_set, LINK->a, LINK->generator->d,
      &LINK->generator->n_d_offset, LINK->r_new, &LINK->r_new_offset,
      LINK->r_old, &LINK->r_old_offset, LINK->workspace,
      &LINK->workspace_offset, &LINK->n_total, &LINK->m, &LINK->m1, &LINK->m2,
      &lambda, &log_l, 0.0);
  /* if is_invalid_real(log_l) then
     line_linear := log_l
  else */
  return log_l;
}


/*
position: t_v_arr_of_integer;
l_c_vertex: t_vertex;

k := 0;
l := 0;
l_c_vertex := first_vertex;
for v := first_vertex to last_vertex */
/* do
      if v in gamma_ then begin
         if v in c then begin
            position[l_c_vertex] := k;
            l_c_vertex := succ(l_c_vertex);
            l := l + 1;
         end;
         k := k + 1
      end;
   l_c_vertex := pred(l_c_vertex);
   */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

Static Void update_linear_generator(mixed_item_, mips_g_c_, model_set_,
  generator_, a_, n_offset_, r_old_, r_old_offset_, r_new_, r_new_offset_,
  O_s_d_, O_s_d_offset_, khi, khi_offset, E_s_d_, E_s_d_offset_, E_n,
  E_n_offset, E_n_d_, E_n_d_offset_, workspace_, workspace_offset_, m_, m1_,
  m2_, n_total_, max_suff, line_search, update_discrete_, update_linear_)
t_mips_element **mixed_item_;
t_set_list **mips_g_c_;
long *model_set_;
t_linear_generator *generator_;
long *a_;
t_offset *n_offset_;
t_t_r **r_old_;
t_t_offset r_old_offset_;
t_t_r **r_new_;
t_t_offset r_new_offset_;
t_s_r **O_s_d_;
t_s_offset O_s_d_offset_;
t_t_r **khi;
t_t_offset khi_offset;
t_t_r **E_s_d_;
t_t_offset E_s_d_offset_;
t_t_r **E_n;
t_t_offset E_n_offset;
t_t_r **E_n_d_;
t_t_offset E_n_d_offset_;
t_t_r **workspace_;
t_t_offset workspace_offset_;
t_integer m_, m1_, m2_;
t_cell_count n_total_;
t_long_real *max_suff;
boolean line_search, update_discrete_, update_linear_;
{
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  struct LOC_update_linear_generator Local_Var;
  t_integer j;
  t_long_real lambda, l, u, alpha, w, t_1, t_2, f_1, f_2;
  /*$ifdef TRACE*/
  pch20 tzt;

  Local_Var.mixed_item = mixed_item_;
  Local_Var.mips_g_c = mips_g_c_;
  Local_Var.model_set = model_set_;
  Local_Var.generator = generator_;
  Local_Var.a = a_;
  Local_Var.n_offset = n_offset_;
  Local_Var.r_old = r_old_;
  Local_Var.r_old_offset = r_old_offset_;
  Local_Var.r_new = r_new_;
  Local_Var.r_new_offset = r_new_offset_;
  Local_Var.O_s_d = O_s_d_;
  Local_Var.O_s_d_offset = O_s_d_offset_;
  Local_Var.E_s_d = E_s_d_;
  Local_Var.E_s_d_offset = E_s_d_offset_;
  Local_Var.E_n_d = E_n_d_;
  Local_Var.E_n_d_offset = E_n_d_offset_;
  Local_Var.workspace = workspace_;
  Local_Var.workspace_offset = workspace_offset_;
  Local_Var.m = m_;
  Local_Var.m1 = m1_;
  Local_Var.m2 = m2_;
  Local_Var.n_total = n_total_;
  Local_Var.update_discrete = update_discrete_;
  Local_Var.update_linear = update_linear_;
  /*$ifdef TRACE*/
  memcpy(tzt, " Linear generator:  ", sizeof(pch20));
  if (trace_flag_set(20L, 1400L, 1L)) {
    write_pch(stdout, tzt, 20L);
    print_vertex_set(Local_Var.generator->d);
    print_vertex_set(Local_Var.generator->c);
    write_line(stdout);
  }
  /*$endif TRACE*/
  find_marginal_expected_n_and_s(Local_Var.a, Local_Var.generator->d,
    Local_Var.generator->c, &Local_Var.d_in_a, E_n, &E_n_offset, khi,
    &khi_offset, 1L, Local_Var.m1, Local_Var.E_n_d, &Local_Var.E_n_d_offset,
    Local_Var.E_s_d, &Local_Var.E_s_d_offset, &Local_Var.m, Local_Var.i);
  if (line_search) {
    l = 0.0;
    u = 1.0;
    alpha = (3 - sqrt(5.0)) / 2;
    w = u - l;
    t_1 = l;
    f_1 = line_linear(t_1, max_suff, &Local_Var);
    t_2 = u + w * exp(20 * log(1 - alpha));
    f_2 = line_linear(t_2, max_suff, &Local_Var);
    /*$ifdef TRACE*/
    ntr_6_reals(tzt, 20L, 1400L, 2L, 0L, 0L, &l, &u, &t_1, &t_2, &f_1, &f_2);
    /*$endif TRACE*/
    if (f_1 < f_2) {
      t_1 = u;
      f_1 = line_linear(t_1, max_suff, &Local_Var);
      /*$ifdef TRACE*/
      ntr_6_reals(tzt, 20L, 1400L, 2L, 0L, 0L, &l, &u, &t_1, &t_2, &f_1, &f_2);
      /*$endif TRACE*/
      if (f_1 < f_2) {
	l = u;
	w = 0.0;
      }
    }
    if (w > 0) {
      t_1 = l + alpha * w;
      f_1 = line_linear(t_1, max_suff, &Local_Var);
      t_2 = u - alpha * w;
      f_2 = line_linear(t_2, max_suff, &Local_Var);
    }
    if (w > 0) {
      for (j = 1; j <= 20; j++) {
	/*$ifdef TRACE*/
	ntr_6_reals(tzt, 20L, 1400L, 2L, 0L, j, &l, &u, &t_1, &t_2, &f_1,
		    &f_2);
	/*$endif TRACE*/
	if (f_1 < f_2) {
	  l = t_1;
	  t_1 = t_2;
	  f_1 = f_2;
	  w = u - l;
	  t_2 = u - alpha * w;
	  f_2 = line_linear(t_2, max_suff, &Local_Var);
	} else {
	  u = t_2;
	  t_2 = t_1;
	  f_2 = f_1;
	  w = u - l;
	  t_1 = l + alpha * w;
	  f_1 = line_linear(t_1, max_suff, &Local_Var);
	}
      }
    }
  } else {
    lambda = 2.0;
    while (do_step_halving(Local_Var.mixed_item, false, Local_Var.mips_g_c,
	     Local_Var.model_set, Local_Var.a, Local_Var.generator->d,
	     &Local_Var.generator->n_d_offset, Local_Var.r_new,
	     &Local_Var.r_new_offset, Local_Var.r_old,
	     &Local_Var.r_old_offset, Local_Var.workspace,
	     &Local_Var.workspace_offset, &Local_Var.n_total, &Local_Var.m,
	     &Local_Var.m1, &Local_Var.m2, &lambda, &l, mips_min_lambda)) {
      if (lambda < 1 - ROUND_ERROR)
	step_half_linear(Local_Var.a, Local_Var.generator->c, Local_Var.r_old,
			 &Local_Var.r_old_offset, Local_Var.r_new,
			 &Local_Var.r_new_offset, &Local_Var.m, &Local_Var.m2,
			 &Local_Var.update_discrete,
			 &Local_Var.update_linear);
      else
	adjust_by_linear(&Local_Var.d_in_a, Local_Var.a,
	  Local_Var.generator->c, Local_Var.generator->d, Local_Var.n_offset,
	  &Local_Var.n_total, Local_Var.r_old, &Local_Var.r_old_offset,
	  Local_Var.r_new, &Local_Var.r_new_offset, Local_Var.O_s_d,
	  &Local_Var.O_s_d_offset, Local_Var.E_s_d, &Local_Var.E_s_d_offset,
	  Local_Var.E_n_d, &Local_Var.E_n_d_offset, &Local_Var.m,
	  &Local_Var.m1, &Local_Var.m2, Local_Var.generator->n_d_offset,
	  Local_Var.i, &lambda, max_suff, &Local_Var.update_discrete,
	  &Local_Var.update_linear);
    }
  }
  /* m1, */
  copy_mips_estimates(Local_Var.r_new, &Local_Var.r_new_offset,
		      Local_Var.r_old, &Local_Var.r_old_offset, &Local_Var.m,
		      &Local_Var.m2);
}  /* update_linear_generator */



Static Void iterate_linear_generators(mixed_item, mips_g_c, model_set, copy,
  copy_offset, workspace, workspace_offset, a, m, m1, m2, n_total,
  mips_epsilon, max_cycle_number, max_suff, update_discrete, update_linear,
  ok, iterate_linear)
t_mips_element **mixed_item;
t_set_list **mips_g_c;
long *model_set;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
long *a;
t_integer *m, *m1, *m2;
t_cell_count *n_total;
t_long_real *mips_epsilon;
t_integer *max_cycle_number;
t_long_real *max_suff;
boolean *update_discrete, *update_linear, *ok, *iterate_linear;
{
  /* var line_search      : boolean; */
  t_linear_generator *p;
  t_long_integer count, i;
  t_t_r *r_new = NULL, *khi = NULL, *E_s_d = NULL, *E_n = NULL, *E_n_d = NULL;
      /* T_T, malloc_workspace */
  t_t_offset r_new_offset, khi_offset, E_s_d_offset, E_n_offset, E_n_d_offset,
	     tmp_offset;
  t_iterate_pack *iterate_pack;
  long FORLIM;

  iterate_pack = init_iterate_pack(mips_epsilon, max_cycle_number,
				   *iterate_linear, false, false);
  tmp_offset = *workspace_offset;
  malloc_workspace(workspace, &tmp_offset, &r_new, &r_new_offset, *m * *m2);
  malloc_workspace(workspace, &tmp_offset, &khi, &khi_offset, *m * *m1);
  malloc_workspace(workspace, &tmp_offset, &E_s_d, &E_s_d_offset, *m * *m1);
  malloc_workspace(workspace, &tmp_offset, &E_n, &E_n_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &E_n_d, &E_n_d_offset, *m);
  /* -> m * (m2 + 2 * m1 + 2) + 3 * m2*/
  *ok = true;
  while (do_mips_iteration(mixed_item, mips_g_c, model_set, " Linear:  ",
			   copy, copy_offset, workspace, &tmp_offset, m, m1,
			   m2, &iterate_pack) && *ok) {
    iterate_pack->max_suff = 0.0;
    count = 0;
    p = (*mixed_item)->generators->linear_generators;
    while (p != NULL) {
      FORLIM = nor();
      for (i = 1; i <= FORLIM; i++) {
	if (count == 0 || !boolean_option[94])
	  find_expected_ns_and_khis(m, m1, m2, &(*mixed_item)->n_offset,
	    &(*mixed_item)->r, &(*mixed_item)->r_offset, workspace,
	    tmp_offset, &E_n, &E_n_offset, &khi, &khi_offset, n_total, ok);
	if (*ok)
	  update_linear_generator(mixed_item, mips_g_c, model_set, p, a,
	    &(*mixed_item)->n_offset, &(*mixed_item)->r,
	    (*mixed_item)->r_offset, &r_new, r_new_offset, &p->O_s_d,
	    p->O_s_d_offset, &khi, khi_offset, &E_s_d, E_s_d_offset, &E_n,
	    E_n_offset, &E_n_d, E_n_d_offset, workspace, tmp_offset, *m, *m1,
	    *m2, *n_total, &iterate_pack->max_suff, p->line_search,
	    *update_discrete, *update_linear);
	else
	  (*mixed_item)->ifail = 42;
      }
      /* count := count + 1; */
      /* ?!?!? */
      p = p->pointer;
    }
  }

  *max_suff = iterate_pack->max_suff;
  _Free(iterate_pack);
}  /* iterate_linear_generators */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/*@+"mipslaq.p"*/

/*
1404:    +++  ++
1405:    +++  ++
1406:    ---  -- p/mipslaq.p          6      24     365 p/mipslaq.p
1407: |    4:    procedure find_expected_ns_khis_and_sigmas
1408: |   88:    procedure find_marginal_expected_n_s_and_ss
1409: |  170:    procedure adjust_by_linear_and_quadratic
1410: |  291:    procedure step_half_quadratic_single
1411: |  318:    procedure update_linear_and_quadratic_generator
1412: |  414:    procedure iterate_linear_and_quadratic_generators
1413:    +++  ++
1414:    +++  ++

*/

Static Void find_expected_ns_khis_and_sigmas(m0, m1, m2, n_offset, r,
  r_offset, workspace, workspace_offset, ns, ns_offset, khis, khis_offset,
  sigma, sigma_offset, n_total, ok)
t_integer *m0, *m1, *m2;
t_offset *n_offset;
t_t_r **r;
t_t_offset *r_offset;
t_t_r **workspace;
t_t_offset workspace_offset;
t_t_r **ns;
t_t_offset *ns_offset;
t_t_r **khis;
t_t_offset *khis_offset;
t_t_r **sigma;
t_t_offset *sigma_offset;
t_cell_count *n_total;
boolean *ok;
{
  t_integer i;
  t_t_r *g, *h, *k, *l, *m;   /* T_T, arguments */
  t_t_offset k_index, h_index, g_index, l_index, m_index, ns_index,
	     khis_index, sigmas_index;
  t_long_real gamma_constant, determinant, product;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindExpectedNsKhisS", sizeof(pch20));
  if (trace_flag_set(20L, 1407L, 1L))
    trace_1(tzt, 20L, *n_offset, *r_offset, workspace_offset, *ns_offset,
	    *khis_offset, *sigma_offset, -1.0, -1.0, -1.0);
  /*$endif TRACE*/
  gamma_constant = *m1 * LN_2_PI_HALF;
  k = *r;
  h = *r;
  g = *r;
  h_index = *r_offset;
  k_index = *r_offset + *m1;
  g_index = *r_offset + *m2 - 1;

  l = *workspace;
  m = *workspace;
  l_index = workspace_offset;
  m_index = workspace_offset + *m2;

  ns_index = *ns_offset;   /* nks_offset + m2 - 1 */
  khis_index = *khis_offset;   /* nks_offset + 0 */
  sigmas_index = *sigma_offset;   /* nks_offset + m1 */

  for (i = 0; i < *m0; i++) {
    note_number_of_observations(n_offset, i);
    if (true)
      find_one_k_inverse(&k, sigma, &l, &m, &k_index, &sigmas_index, &l_index,
			 &m_index, m1, !boolean_option[63], ok);
    else
      *ok = false;
    if (*ok) {
      determinant = find_determinant_from_cholesky_t(&l, &l_index, m1);
      product = find_one_product(&h, &m, &h_index, &m_index, m1);
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(&g, r_offset, g_index, tzt, 20L, 1407L, 1L);   /* ntr */
      ntr_t_ass(ns, ns_offset, ns_index, _INVALID_REAL, tzt, 20L, 1407L, -2L);
      /*$endif TRACE-ARRAY*/
      (*ns)->z[ns_index] = find_p_from_g(gamma_constant, g->z[g_index],
					 determinant, product) * *n_total;
	  /* ntr */
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(ns, ns_offset, ns_index, _INVALID_REAL, tzt, 20L, 1407L, 2L);
      /*$endif TRACE-ARRAY*/
      mult_symmetric_matrix_and_vector_t_t_t(&h, sigma, khis, &h_index,
					     &sigmas_index, &khis_index, m1);
    }

    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1407L, 1L)) {
      write_pch(stdout, " ExpectedNsKhisAndS:", 20L);
      write_integer(stdout, ns_index, 5L);
      write_integer(stdout, khis_index, 5L);
      write_integer(stdout, sigmas_index, 5L);
      write_real(stdout, (*ns)->z[ns_index], print_width, print_dec);
      write_vector_(khis, &khis_index, m1);
      write_matrix_t(sigma, &sigmas_index, m1);
    }
    /*$endif TRACE*/

    ns_index += *m2;   /* 1 */
    khis_index += *m2;   /* m1 */
    sigmas_index += *m2;   /* m2 */
    g_index += *m2;
    h_index += *m2;
    k_index += *m2;
  }
}  /* find_expected_ns_khis_and_sigmas */



Static Void find_marginal_expected_n_s_and_ss(a, b, b_in_a, E_n, E_n_offset,
  khi, khi_offset, sigma, sigma_offset, E_n_b, E_n_b_offset, E_s_b,
  E_s_b_offset, E_ss_b, E_ss_b_offset, m, m1, m2, gamma_1_index,
  gamma_2_index, i)
long *a, *b;
t_fast_next_offset_pack *b_in_a;
t_t_r **E_n;
t_t_offset *E_n_offset;
t_t_r **khi;
t_t_offset *khi_offset;
t_t_r **sigma;
t_t_offset *sigma_offset;
t_t_r **E_n_b;
t_t_offset *E_n_b_offset;
t_t_r **E_s_b;
t_t_offset *E_s_b_offset;
t_t_r **E_ss_b;
t_t_offset *E_ss_b_offset;
t_integer *m, *m1, *m2, *gamma_1_index, *gamma_2_index;
t_level *i;
{
  t_t_offset mb;
  t_cell_index index, n_index, khi_index, sigma_index;
  t_integer m_i = FIRST_INDEX;
  t_long_real n_expected, khi_, sigma_;
  t_vertex_set a_delta;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;
  double TEMP;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " FindMargExpectedNS.", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  mb = marginal_dimension(b);
  clear_t_array(E_n_b, E_n_b_offset, &mb);
  clear_t_array(E_s_b, E_s_b_offset, &mb);
  clear_t_array(E_ss_b, E_ss_b_offset, &mb);
  memcpy(i, first_cell, sizeof(t_cell));
  P_setint(a_delta, a, delta);
  fast_find_products(a_delta, b, b_in_a);
  n_index = *E_n_offset;
  khi_index = *khi_offset + *gamma_1_index;
  sigma_index = *sigma_offset + *gamma_2_index - *m1;
  FORLIM = *m;
  for (index = 0; index <= FORLIM - 1; index++) {   /*  1 */
    ntr_t_ref(E_n, E_n_offset, n_index + *m2 * index, tzt, 20L, 1408L, 1L);
	/* ntr */
    /*  1 */
    ntr_t_ref(khi, E_n_offset, khi_index + *m2 * index, tzt, 20L, 1408L, 1L);
	/* ntr */
    /*  1 */
    ntr_t_ref(sigma, E_n_offset, sigma_index + *m2 * index, tzt, 20L, 1408L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    n_expected = (*E_n)->z[n_index + *m2 * index];   /*  1 */
    khi_ = (*khi)->z[khi_index + *m2 * index];   /* m1 */
    sigma_ = (*sigma)->z[sigma_index + *m2 * index];   /* m2 */
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1408L, 1L)) {
      write_pch(stdout, tzt, 20L);
      write_integer(stdout, index, 5L);
      write_real(stdout, n_expected, print_width, print_dec);
      write_real(stdout, khi_, print_width, print_dec);
      write_real(stdout, sigma_, print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/
    /*$ifdef TRACE-ARRAY*/
    ntr_t_upd(E_n_b, E_n_b_offset, *E_n_b_offset + m_i, n_expected, 1L, tzt,
	      20L, 1408L, 1L);
	/* ntr */
    ntr_t_upd(E_s_b, E_s_b_offset, *E_s_b_offset + m_i, khi_ * n_expected, 1L,
	      tzt, 20L, 1408L, 1L);
	/* ntr */
    /* ntr */
    ntr_t_upd(E_ss_b, E_ss_b_offset, *E_ss_b_offset + m_i,
	      (sigma_ + khi_ * khi_) * n_expected, 1L, tzt, 20L, 1408L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*E_n_b)->z[*E_n_b_offset + m_i] += n_expected;
    (*E_s_b)->z[*E_s_b_offset + m_i] += khi_ * n_expected;
    (*E_ss_b)->z[*E_ss_b_offset + m_i] += (sigma_ + khi_ * khi_) * n_expected;
    fast_next_offset(b_in_a, &m_i, i);
  }
  /*$ifdef TRACE-ARRAY*/
  for (index = FIRST_INDEX; index <= FIRST_INDEX + mb - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1408L, 1L)) {
      write_pch(stdout, tzt, 20L);
      write_integer(stdout, index, 5L);
      write_real(stdout, (*E_ss_b)->z[*E_ss_b_offset + index], print_width,
		 print_dec);
      write_real(stdout, (*E_s_b)->z[*E_s_b_offset + index], print_width,
		 print_dec);
      write_real(stdout, (*E_n_b)->z[*E_n_b_offset + index], print_width,
		 print_dec);
    }
    /*$endif TRACE*/
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(E_n_b, E_n_b_offset, *E_n_b_offset + index, tzt, 20L, 1408L, 1L);
	/* ntr */
    ntr_t_ref(E_s_b, E_s_b_offset, *E_s_b_offset + index, tzt, 20L, 1408L, 1L);
	/* ntr */
    /* ntr */
    TEMP = (*E_s_b)->z[*E_s_b_offset + index];
    ntr_t_upd(E_ss_b, E_ss_b_offset, *E_ss_b_offset + index,
	      TEMP * TEMP / (*E_n_b)->z[*E_n_b_offset + index], -1L, tzt, 20L,
	      1408L, 1L);
	/* ntr */
    TEMP = (*E_s_b)->z[*E_s_b_offset + index];
    /*$endif TRACE-ARRAY*/
    (*E_ss_b)->z[*E_ss_b_offset + index] -=
      TEMP * TEMP / (*E_n_b)->z[*E_n_b_offset + index];
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1408L, 1L)) {
      write_real(stdout, (*E_ss_b)->z[*E_ss_b_offset + index], print_width,
		 print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/
  }
}  /* find_marginal_expected_n_s_and_ss */



Static Void adjust_by_linear_and_quadratic(a_, d, b_in_a, d_in_a, n_total, s,
  s_offset, t, t_offset_, O_ssd_b, O_ssd_b_offset, E_ssd_b, E_ssd_b_offset,
  E_n_b, E_n_b_offset, O_s_d, O_s_d_offset, E_s_d, E_s_d_offset, E_n_d,
  E_n_d_offset, m, m1, m2, n_b_offset, n_d_offset, gamma_1_index,
  gamma_2_index, i_b, i_d, lambda, max_suff, update_discrete, update_linear)
long *a_, *d;
t_fast_next_offset_pack *b_in_a, *d_in_a;
t_cell_count *n_total;
t_t_r **s;
t_t_offset *s_offset;
t_t_r **t;
t_t_offset *t_offset_;
t_s_r **O_ssd_b;
t_s_offset *O_ssd_b_offset;
t_t_r **E_ssd_b;
t_t_offset *E_ssd_b_offset;
t_t_r **E_n_b;
t_t_offset *E_n_b_offset;
t_s_r **O_s_d;
t_s_offset *O_s_d_offset;
t_t_r **E_s_d;
t_t_offset *E_s_d_offset;
t_t_r **E_n_d;
t_t_offset *E_n_d_offset;
t_integer *m, *m1, *m2, n_b_offset, n_d_offset, *gamma_1_index,
	  *gamma_2_index;
t_level *i_b, *i_d;
t_long_real *lambda, *max_suff;
boolean *update_discrete, *update_linear;
{
  /* b, */
  /* var n_offset  : t_offset; */
  t_cell_index s_index, t_index, index;
  t_integer m_i_b = FIRST_INDEX, m_i_d = FIRST_INDEX;
  t_long_real z, n_obs_b, n_obs_d, n_exp_b, n_exp_d, s_obs_d, s_exp_d,
	      n_ssd_b_obs, n_ssd_b_exp, ssd_obs_b, ssd_exp_b, s_n_d_obs,
	      s_n_d_exp, g_change_1, g_change_2, h_change, k_change,
	      delta_suff;
  t_vertex_set a_d;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " AdjustByMatch      ", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  if (boolean_option[119])
    z = *n_total * marginal_dimension(d);
  else {
    P_setdiff(a_d, a_, d);
    z = *n_total * marginal_dimension(a_d);
  }
  z = 1 / z;
  t_index = *t_offset_;
  s_index = *s_offset;
  FORLIM = *m2 * *m;
  for (index = 0; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(s, s_offset, s_index + index, tzt, 20L, 1409L, 1L);
    ntr_t_ass(t, t_offset_, t_index + index, (*s)->z[s_index + index], tzt,
	      20L, 1409L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*t)->z[t_index + index] = (*s)->z[s_index + index];
  }
  FORLIM = *m - 2;
  for (index = -1; index <= FORLIM; index++) {
    t_index = *t_offset_ + *m2 * (index + 1);
    s_index = *s_offset + *m2 * (index + 1);
    /*$ifdef TRACE-ARRAY*/
    ntr_n_ref(n, n_b_offset, n_b_offset + m_i_b, tzt, 20L, 1409L, 1L);
    ntr_t_ref(E_n_b, E_n_b_offset, *E_n_b_offset + m_i_b, tzt, 20L, 1409L, 1L);
	/* ntr */
    ntr_n_ref(n, n_d_offset, n_d_offset + m_i_d, tzt, 20L, 1409L, 1L);
    ntr_t_ref(E_n_d, E_n_d_offset, *E_n_d_offset + m_i_d, tzt, 20L, 1409L, 1L);
	/* ntr */
    ntr_s_ref(O_s_d, O_s_d_offset, *O_s_d_offset + m_i_d * 3, tzt, 20L, 1409L,
	      1L);
	/* ntr */
    ntr_t_ref(E_s_d, E_s_d_offset, *E_s_d_offset + m_i_d, tzt, 20L, 1409L, 1L);
	/* ntr */
    ntr_s_ref(O_ssd_b, O_ssd_b_offset, *O_ssd_b_offset + m_i_b * 3 + 1, tzt,
	      20L, 1409L, 1L);
	/* ntr */
    ntr_t_ref(E_ssd_b, E_ssd_b_offset, *E_ssd_b_offset + m_i_b, tzt, 20L,
	      1409L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    n_obs_b = n[n_b_offset + m_i_b];
    n_exp_b = (*E_n_b)->z[*E_n_b_offset + m_i_b];
    change_sufficient(&n_exp_b, &n_obs_b, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1409L, 2L, 0L, 1L, &n_exp_b, n_obs_b, &delta_suff,
		max_suff);
    /*$endif TRACE*/
    n_obs_d = n[n_d_offset + m_i_d];
    n_exp_d = (*E_n_d)->z[*E_n_d_offset + m_i_d];
    change_sufficient(&n_exp_d, &n_obs_d, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1409L, 2L, 0L, 2L, &n_exp_d, n_obs_d, &delta_suff,
		max_suff);
    /*$endif TRACE*/
    s_obs_d = n_obs_d * (*O_s_d)->z[*O_s_d_offset + m_i_d * 3];
    s_exp_d = (*E_s_d)->z[*E_s_d_offset + m_i_d];
    change_sufficient(&s_exp_d, &s_obs_d, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1409L, 2L, 0L, 3L, &s_exp_d, s_obs_d, &delta_suff,
		max_suff);
    /*$endif TRACE*/
    ssd_obs_b = (*O_ssd_b)->z[*O_ssd_b_offset + m_i_b * 3 + 1];
    ssd_exp_b = (*E_ssd_b)->z[*E_ssd_b_offset + m_i_b];
    change_sufficient(&ssd_exp_b, &ssd_obs_b, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1409L, 2L, 0L, 4L, &ssd_exp_b, ssd_obs_b,
		&delta_suff, max_suff);
    /*$endif TRACE*/
    n_ssd_b_obs = n_obs_b / ssd_obs_b;
    n_ssd_b_exp = n_exp_b / ssd_exp_b;
    s_n_d_obs = s_obs_d / n_obs_d;
    s_n_d_exp = s_exp_d / n_exp_d;
    g_change_1 = g_adjustment(n_obs_d, n_exp_d, z);
	/* (n_obs_d - n_exp_d ) * z */
    g_change_2 = (s_n_d_exp * s_n_d_exp * n_ssd_b_exp -
		  s_n_d_obs * s_n_d_obs * n_ssd_b_obs) / 2;
    h_change = s_n_d_obs * n_ssd_b_obs - s_n_d_exp * n_ssd_b_exp;
    if (boolean_option[89])
      k_change = (n_ssd_b_obs - n_ssd_b_exp) / 2;
    else
      k_change = n_ssd_b_obs - n_ssd_b_exp;
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1409L, 3L, 9L, 9L, &g_change_1, g_change_2,
		&h_change, &k_change);
    /*$endif TRACE*/
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1409L, 1L)) {
      write_pch(stdout, " AdjustByMatch:  ", 17L);
      write_space(stdout, print_width * 3 - 27);
      write_integer(stdout, t_index, 5L);
      write_integer(stdout, s_index, 5L);
      write_real(stdout, n_obs_b, print_width, print_dec);
      write_real(stdout, n_exp_b, print_width, print_dec);
      write_real(stdout, n_obs_d, print_width, print_dec);
      write_real(stdout, n_exp_d, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, s_obs_d, print_width, print_dec);
      write_real(stdout, s_exp_d, print_width, print_dec);
      write_real(stdout, ssd_obs_b, print_width, print_dec);
      write_real(stdout, ssd_exp_b, print_width, print_dec);
      write_real(stdout, n_ssd_b_obs, print_width, print_dec);
      write_real(stdout, n_ssd_b_exp, print_width, print_dec);
      write_real(stdout, s_n_d_obs, print_width, print_dec);
      write_real(stdout, s_n_d_exp, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, g_change_1, print_width, print_dec);
      write_real(stdout, g_change_2, print_width, print_dec);
      write_real(stdout, h_change, print_width, print_dec);
      write_real(stdout, k_change, print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (!boolean_option[90]) {
      if (*update_discrete) {
	/*$ifdef TRACE-ARRAY*/
	ntr_t_ref(s, s_offset, s_index + index + *m2, tzt, 20L, 1409L, 1L);
	    /* ntr */
	/* ntr */
	/* ntr */
	ntr_t_ass(t, t_offset_, t_index + index + *m2,
	  (*s)->z[s_index + *m2 - 1] + *lambda * (g_change_1 + g_change_2),
	  tzt, 20L, 1409L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*t)->z[t_index + *m2 - 1] = (*s)->z[s_index + *m2 - 1] +
				     *lambda * (g_change_1 + g_change_2);
      }
    }

    if (*update_linear) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(s, s_offset, s_index + *gamma_1_index, tzt, 20L, 1409L, 1L);
	  /* ntr */
      /* ntr */
      ntr_t_ass(t, t_offset_, t_index + *gamma_1_index,
		(*s)->z[s_index + *gamma_1_index] + *lambda * h_change, tzt,
		20L, 1409L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*t)->z[t_index + *gamma_1_index] =
	(*s)->z[s_index + *gamma_1_index] + *lambda * h_change;
    }

    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(s, s_offset, s_index + *gamma_2_index, tzt, 20L, 1409L, 1L);
	/* ntr */
    /* ntr */
    ntr_t_ass(t, t_offset_, t_index + *gamma_2_index,
	      (*s)->z[s_index + *gamma_2_index] + *lambda * k_change, tzt,
	      20L, 1409L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*t)->z[t_index + *gamma_2_index] =
      (*s)->z[s_index + *gamma_2_index] + *lambda * k_change;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1409L, 8L))
      write_headed_ssd_t(" New estimates: @@@@                    ", 16L, a_,
			 -1L, *t_offset_, t, *m1, *m2, NULL, false, 2L,
			 false);
    /*$endif TRACE*/
    fast_next_offset(b_in_a, &m_i_b, i_b);
    fast_next_offset(d_in_a, &m_i_d, i_d);
  }
}  /* adjust_by_linear_and_quadratic */



Static Void step_half_quadratic_single(s, s_offset, t, t_offset_, m, m2,
  gamma_1_index, gamma_2_index, update_discrete, update_linear)
t_t_r **s;
t_t_offset *s_offset;
t_t_r **t;
t_t_offset *t_offset_;
t_integer *m, *m2, *gamma_1_index, *gamma_2_index;
boolean *update_discrete, *update_linear;
{
  t_cell_index s_index, t_index, index;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " StepHalfQuadSingle ", sizeof(pch20));
  FORLIM = *m;
  /*$endif TRACE-ARRAY*/
  for (index = 0; index <= FORLIM - 1; index++) {
    t_index = *t_offset_ + *m2 * index;
    s_index = *s_offset + *m2 * index;
    /*$ifdef TRACE-ARRAY*/
    if (*update_discrete) {
      ntr_t_ref(s, s_offset, s_index + *m2 - 1, tzt, 20L, 1410L, 1L);
      ntr_t_ref(t, t_offset_, t_index + *m2 - 1, tzt, 20L, 1410L, 1L);
    }
    if (*update_linear) {
      ntr_t_ref(s, s_offset, s_index + *gamma_1_index, tzt, 20L, 1410L, 1L);
      ntr_t_ref(t, t_offset_, t_index + *gamma_1_index, tzt, 20L, 1410L, 1L);
    }
    ntr_t_ref(s, s_offset, s_index + *gamma_2_index, tzt, 20L, 1410L, 1L);
    ntr_t_ref(t, t_offset_, t_index + *gamma_2_index, tzt, 20L, 1410L, 1L);
    /*$endif TRACE-ARRAY*/
    if (*update_discrete)
      half_difference(&(*t)->z[t_index + *m2 - 1],
		      &(*s)->z[s_index + *m2 - 1]);
    if (*update_linear)
      half_difference(&(*t)->z[t_index + *gamma_1_index],
		      &(*s)->z[s_index + *gamma_1_index]);
    half_difference(&(*t)->z[t_index + *gamma_2_index],
		    &(*s)->z[s_index + *gamma_2_index]);
  }
}  /* step_half_quadratic_single */


/* Local variables for update_linear_and_quadratic_generator: */
struct LOC_update_linear_and_quadratic_generator {
  t_mips_element **mixed_item;
  t_set_list **mips_g_c;
  long *model_set;
  t_linear_and_quadratic_generator *generator;
  long *a;
  t_t_r **r_old, **r_new;
  t_t_offset r_old_offset, r_new_offset, E_ssd_b_offset, E_n_b_offset,
	     E_s_d_offset, E_n_d_offset, workspace_offset;
  t_s_r **O_ssd_b;
  t_s_offset O_ssd_b_offset, O_s_d_offset;
  t_t_r **E_ssd_b, **E_n_b;
  t_s_r **O_s_d;
  t_t_r **E_s_d, **E_n_d, **workspace;
  t_integer m, m1, m2, gamma_1_index, gamma_2_index;
  t_cell_count n_total;
  boolean update_discrete, update_linear;
  t_cell i_b, i_d;
  t_fast_next_offset_pack b_in_a, d_in_a;
} ;

/*$endif TRACE*/

Local t_long_real line_match(lambda, max_suff, LINK)
t_long_real lambda, *max_suff;
struct LOC_update_linear_and_quadratic_generator *LINK;
{
  boolean ok;
  t_long_real log_l;

  if (lambda > 0)   /* generator.b, */
    adjust_by_linear_and_quadratic(LINK->a, LINK->generator->d, &LINK->b_in_a,
      &LINK->d_in_a, &LINK->n_total, LINK->r_old, &LINK->r_old_offset,
      LINK->r_new, &LINK->r_new_offset, LINK->O_ssd_b, &LINK->O_ssd_b_offset,
      LINK->E_ssd_b, &LINK->E_ssd_b_offset, LINK->E_n_b, &LINK->E_n_b_offset,
      LINK->O_s_d, &LINK->O_s_d_offset, LINK->E_s_d, &LINK->E_s_d_offset,
      LINK->E_n_d, &LINK->E_n_d_offset, &LINK->m, &LINK->m1, &LINK->m2,
      LINK->generator->n_b_offset, LINK->generator->n_d_offset,
      &LINK->gamma_1_index, &LINK->gamma_2_index, LINK->i_b, LINK->i_d,
      &lambda, max_suff, &LINK->update_discrete, &LINK->update_linear);
  /* n_offset, */
  ok = do_step_halving(LINK->mixed_item, false, LINK->mips_g_c,
      LINK->model_set, LINK->a, LINK->generator->d,
      &LINK->generator->n_d_offset, LINK->r_new, &LINK->r_new_offset,
      LINK->r_old, &LINK->r_old_offset, LINK->workspace,
      &LINK->workspace_offset, &LINK->n_total, &LINK->m, &LINK->m1, &LINK->m2,
      &lambda, &log_l, 0.0);
  /* if is_invalid_real(log_l) then
     line_match := log_l
  else */
  return log_l;
}  /* line_match */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

Static Void update_linear_and_quadratic_generator(mixed_item_, mips_g_c_,
  model_set_, generator_, a_, r_old_, r_old_offset_, r_new_, r_new_offset_,
  khi, khi_offset, sigma, sigma_offset, E_n, E_n_offset, O_ssd_b_,
  O_ssd_b_offset_, E_s_b, E_s_b_offset, E_ssd_b_, E_ssd_b_offset_, E_n_b_,
  E_n_b_offset_, O_s_d_, O_s_d_offset_, E_s_d_, E_s_d_offset_, E_n_d_,
  E_n_d_offset_, workspace_, workspace_offset_, m_, m1_, m2_, n_total_,
  max_suff, line_search, update_discrete_, update_linear_)
t_mips_element **mixed_item_;
t_set_list **mips_g_c_;
long *model_set_;
t_linear_and_quadratic_generator *generator_;
long *a_;
t_t_r **r_old_;
t_t_offset r_old_offset_;
t_t_r **r_new_;
t_t_offset r_new_offset_;
t_t_r **khi;
t_t_offset khi_offset;
t_t_r **sigma;
t_t_offset sigma_offset;
t_t_r **E_n;
t_t_offset E_n_offset;
t_s_r **O_ssd_b_;
t_s_offset O_ssd_b_offset_;
t_t_r **E_s_b;
t_t_offset E_s_b_offset;
t_t_r **E_ssd_b_;
t_t_offset E_ssd_b_offset_;
t_t_r **E_n_b_;
t_t_offset E_n_b_offset_;
t_s_r **O_s_d_;
t_s_offset O_s_d_offset_;
t_t_r **E_s_d_;
t_t_offset E_s_d_offset_;
t_t_r **E_n_d_;
t_t_offset E_n_d_offset_;
t_t_r **workspace_;
t_t_offset workspace_offset_;
t_integer m_, m1_, m2_;
t_cell_count n_total_;
t_long_real *max_suff;
boolean line_search, update_discrete_, update_linear_;
{
  /* var n_offset      : t_offset; */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  struct LOC_update_linear_and_quadratic_generator Local_Var;
  t_integer j;
  t_long_real lambda, l, u, alpha, w, t_1, t_2, f_1, f_2;
  /*$ifdef TRACE*/
  pch20 tzt;

  Local_Var.mixed_item = mixed_item_;
  Local_Var.mips_g_c = mips_g_c_;
  Local_Var.model_set = model_set_;
  Local_Var.generator = generator_;
  Local_Var.a = a_;
  Local_Var.r_old = r_old_;
  Local_Var.r_old_offset = r_old_offset_;
  Local_Var.r_new = r_new_;
  Local_Var.r_new_offset = r_new_offset_;
  Local_Var.O_ssd_b = O_ssd_b_;
  Local_Var.O_ssd_b_offset = O_ssd_b_offset_;
  Local_Var.E_ssd_b = E_ssd_b_;
  Local_Var.E_ssd_b_offset = E_ssd_b_offset_;
  Local_Var.E_n_b = E_n_b_;
  Local_Var.E_n_b_offset = E_n_b_offset_;
  Local_Var.O_s_d = O_s_d_;
  Local_Var.O_s_d_offset = O_s_d_offset_;
  Local_Var.E_s_d = E_s_d_;
  Local_Var.E_s_d_offset = E_s_d_offset_;
  Local_Var.E_n_d = E_n_d_;
  Local_Var.E_n_d_offset = E_n_d_offset_;
  Local_Var.workspace = workspace_;
  Local_Var.workspace_offset = workspace_offset_;
  Local_Var.m = m_;
  Local_Var.m1 = m1_;
  Local_Var.m2 = m2_;
  Local_Var.n_total = n_total_;
  Local_Var.update_discrete = update_discrete_;
  Local_Var.update_linear = update_linear_;
  Local_Var.gamma_1_index = both_continuous_index(&Local_Var.generator->lambda,
						  Local_Var.model_set);
  Local_Var.gamma_2_index = Local_Var.m1 + sm_index(Local_Var.gamma_1_index,
			      Local_Var.gamma_1_index, Local_Var.m1);
  memcpy(tzt, " Match generator:   ", sizeof(pch20));
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1411L, 1L)) {
    write_pch(stdout, tzt, 20L);
    print_vertex_set(Local_Var.generator->d);
    print_vertex_set(Local_Var.generator->b);
    print_vertex_set(Local_Var.generator->c);
    print_vertex(Local_Var.generator->lambda);
    write_integer(stdout, Local_Var.gamma_1_index, 4L);
    write_integer(stdout, Local_Var.gamma_2_index, 4L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  find_marginal_expected_n_and_s(Local_Var.a, Local_Var.generator->d,
    Local_Var.generator->c, &Local_Var.d_in_a, E_n, &E_n_offset, khi,
    &khi_offset, Local_Var.m2, Local_Var.m2, Local_Var.E_n_d,
    &Local_Var.E_n_d_offset, Local_Var.E_s_d, &Local_Var.E_s_d_offset,
    &Local_Var.m, Local_Var.i_d);
  find_marginal_expected_n_s_and_ss(Local_Var.a, Local_Var.generator->b,
    &Local_Var.b_in_a, E_n, &E_n_offset, khi, &khi_offset, sigma,
    &sigma_offset, Local_Var.E_n_b, &Local_Var.E_n_b_offset, E_s_b,
    &E_s_b_offset, Local_Var.E_ssd_b, &Local_Var.E_ssd_b_offset, &Local_Var.m,
    &Local_Var.m1, &Local_Var.m2, &Local_Var.gamma_1_index,
    &Local_Var.gamma_2_index, Local_Var.i_b);
  if (line_search) {
    l = 0.0;
    u = 1.0;
    alpha = (3 - sqrt(5.0)) / 2;
    w = u - l;
    t_1 = l;
    f_1 = line_match(t_1, max_suff, &Local_Var);
    t_2 = u + w * exp(20 * log(1 - alpha));
    f_2 = line_match(t_2, max_suff, &Local_Var);
    /*$ifdef TRACE*/
    ntr_6_reals(tzt, 20L, 1411L, 2L, 0L, 0L, &l, &u, &t_1, &t_2, &f_1, &f_2);
    /*$endif TRACE*/
    if (f_1 < f_2) {
      t_1 = u;
      f_1 = line_match(t_1, max_suff, &Local_Var);
      /*$ifdef TRACE*/
      ntr_6_reals(tzt, 20L, 1411L, 2L, 0L, 0L, &l, &u, &t_1, &t_2, &f_1, &f_2);
      /*$endif TRACE*/
      if (f_1 < f_2) {
	l = u;
	w = 0.0;
      }
    }
    if (w > 0) {
      t_1 = l + alpha * w;
      f_1 = line_match(t_1, max_suff, &Local_Var);
      t_2 = u - alpha * w;
      f_2 = line_match(t_2, max_suff, &Local_Var);
    }
    if (w > 0) {
      for (j = 1; j <= 20; j++) {
	/*$ifdef TRACE*/
	ntr_6_reals(tzt, 20L, 1411L, 2L, 0L, j, &l, &u, &t_1, &t_2, &f_1,
		    &f_2);
	/*$endif TRACE*/
	if (f_1 < f_2) {
	  l = t_1;
	  t_1 = t_2;
	  f_1 = f_2;
	  w = u - l;
	  t_2 = u - alpha * w;
	  f_2 = line_match(t_2, max_suff, &Local_Var);
	} else {
	  u = t_2;
	  t_2 = t_1;
	  f_2 = f_1;
	  w = u - l;
	  t_1 = l + alpha * w;
	  f_1 = line_match(t_1, max_suff, &Local_Var);
	}
      }
    }
  } else {
    lambda = 2.0;
    while (do_step_halving(Local_Var.mixed_item, false, Local_Var.mips_g_c,
	     Local_Var.model_set, Local_Var.a, Local_Var.generator->d,
	     &Local_Var.generator->n_d_offset, Local_Var.r_new,
	     &Local_Var.r_new_offset, Local_Var.r_old,
	     &Local_Var.r_old_offset, Local_Var.workspace,
	     &Local_Var.workspace_offset, &Local_Var.n_total, &Local_Var.m,
	     &Local_Var.m1, &Local_Var.m2, &lambda, &l, mips_min_lambda)) {
      if (lambda < 1 - ROUND_ERROR)
	step_half_quadratic_single(Local_Var.r_old, &Local_Var.r_old_offset,
	  Local_Var.r_new, &Local_Var.r_new_offset, &Local_Var.m,
	  &Local_Var.m2, &Local_Var.gamma_1_index, &Local_Var.gamma_2_index,
	  &Local_Var.update_discrete, &Local_Var.update_linear);
      else {
	adjust_by_linear_and_quadratic(Local_Var.a, Local_Var.generator->d,
	  &Local_Var.b_in_a, &Local_Var.d_in_a, &Local_Var.n_total, Local_Var.
	    r_old, &Local_Var.r_old_offset, Local_Var.r_new,
	  &Local_Var.r_new_offset, Local_Var.O_ssd_b,
	  &Local_Var.O_ssd_b_offset, Local_Var.E_ssd_b,
	  &Local_Var.E_ssd_b_offset, Local_Var.E_n_b, &Local_Var.E_n_b_offset,
	  Local_Var.O_s_d, &Local_Var.O_s_d_offset, Local_Var.E_s_d,
	  &Local_Var.E_s_d_offset, Local_Var.E_n_d, &Local_Var.E_n_d_offset,
	  &Local_Var.m, &Local_Var.m1, &Local_Var.m2,
	  Local_Var.generator->n_b_offset, Local_Var.generator->n_d_offset,
	  &Local_Var.gamma_1_index, &Local_Var.gamma_2_index, Local_Var.i_b,
	  Local_Var.i_d, &lambda, max_suff, &Local_Var.update_discrete,
	  &Local_Var.update_linear);
	/* generator.b, */
	/* n_offset, */
      }
    }
  }
  /* m1, */
  copy_mips_estimates(Local_Var.r_new, &Local_Var.r_new_offset,
		      Local_Var.r_old, &Local_Var.r_old_offset, &Local_Var.m,
		      &Local_Var.m2);
}  /* update_linear_and_quadratic_generator */



Static Void iterate_linear_and_quadratic_generators(mixed_item, mips_g_c,
  model_set, copy, copy_offset, workspace, workspace_offset, a, m, m1, m2,
  n_total, mips_epsilon, max_cycle_number, max_suff, update_discrete,
  update_linear, ok, iterate_match)
t_mips_element **mixed_item;
t_set_list **mips_g_c;
long *model_set;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
long *a;
t_integer *m, *m1, *m2;
t_cell_count *n_total;
t_long_real *mips_epsilon;
t_integer *max_cycle_number;
t_long_real *max_suff;
boolean *update_discrete, *update_linear, *ok, *iterate_match;
{
  /* var line_search      : boolean; */
  t_integer count, i;
  t_linear_and_quadratic_generator *p;
  t_t_r *r_new, *khi, *sigma, *E_n;
  t_t_r *E_s_b = NULL, *E_ssd_b = NULL, *E_n_b = NULL, *E_s_d = NULL,
	*E_n_d = NULL;
      /* T_T, malloc_workspace */
  t_t_offset r_new_offset, khi_offset, sigma_offset, E_n_offset, E_s_b_offset,
	     E_ssd_b_offset, E_n_b_offset, E_s_d_offset, E_n_d_offset,
	     tmp_offset;
  t_iterate_pack *iterate_pack;
  long FORLIM;

  iterate_pack = init_iterate_pack(mips_epsilon, max_cycle_number,
				   *iterate_match, false, false);
  tmp_offset = *workspace_offset;
  malloc_workspace(workspace, &tmp_offset, &r_new, &r_new_offset, *m * *m2);
  sigma = *workspace;
  sigma_offset = tmp_offset + *m1;
  E_n = *workspace;
  E_n_offset = tmp_offset + *m2 - 1;
  malloc_workspace(workspace, &tmp_offset, &khi, &khi_offset, *m * *m2);
  malloc_workspace(workspace, &tmp_offset, &E_s_b, &E_s_b_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &E_ssd_b, &E_ssd_b_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &E_n_b, &E_n_b_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &E_s_d, &E_s_d_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &E_n_d, &E_n_d_offset, *m);
  /* -> m * (2 * m2 + 5) + 2 * m2 */
  *ok = true;
  while (do_mips_iteration(mixed_item, mips_g_c, model_set, " Match:   ",
			   copy, copy_offset, workspace, &tmp_offset, m, m1,
			   m2, &iterate_pack) && *ok) {
    iterate_pack->max_suff = 0.0;
    count = 0;
    p = (*mixed_item)->generators->linear_and_quadratic_generators;
    while (p != NULL) {
      FORLIM = nor();
      for (i = 1; i <= FORLIM; i++) {
	if (count == 0 || !boolean_option[94])
	  find_expected_ns_khis_and_sigmas(m, m1, m2,
	    &(*mixed_item)->n_offset, &(*mixed_item)->r,
	    &(*mixed_item)->r_offset, workspace, tmp_offset, &E_n,
	    &E_n_offset, &khi, &khi_offset, &sigma, &sigma_offset, n_total,
	    ok);
	if (*ok) {
	  /* mixed_item^.n_offset, */
	  update_linear_and_quadratic_generator(mixed_item, mips_g_c,
	    model_set, p, a, &(*mixed_item)->r, (*mixed_item)->r_offset,
	    &r_new, r_new_offset, &khi, khi_offset, &sigma, sigma_offset,
	    &E_n, E_n_offset, &p->O_ssd_b, p->O_ssd_b_offset, &E_s_b,
	    E_s_b_offset, &E_ssd_b, E_ssd_b_offset, &E_n_b, E_n_b_offset,
	    &p->O_s_d, p->O_s_d_offset, &E_s_d, E_s_d_offset, &E_n_d,
	    E_n_d_offset, workspace, tmp_offset, *m, *m1, *m2, *n_total,
	    &iterate_pack->max_suff, p->line_search, *update_discrete,
	    *update_linear);
	} else
	  (*mixed_item)->ifail = 43;
      }
      count++;
      p = p->pointer;
    }
  }
  if (iterate_pack->max_suff > *max_suff)
    *max_suff = iterate_pack->max_suff;
  _Free(iterate_pack);
}  /* iterate_linear_and_quadratic_generators */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/*@+"mipssin.p"*/


/*

1415:    +++  ++
1416:    +++  ++
1417:    ---  -- p/mipssin.p          3      10     159 p/mipssin.p
1418: |    4:    procedure adjust_by_single
1419: |  117:    procedure update_single_quadratic_generator
1420: |  200:    procedure iterate_single_quadratic_generators
1421:    +++  ++
1422:    +++  ++

*/

Static Void adjust_by_single(a_, d, d_in_a, n_total, s, s_offset, t,
  t_offset_, O_ssd_d, O_ssd_d_offset, E_ssd_d, E_ssd_d_offset, E_s_d,
  E_s_d_offset, E_n_d, E_n_d_offset, m, m1, m2, n_d_offset, gamma_1_index,
  gamma_2_index, i, lambda, max_suff, update_discrete, update_linear)
long *a_, *d;
t_fast_next_offset_pack *d_in_a;
t_cell_count *n_total;
t_t_r **s;
t_t_offset *s_offset;
t_t_r **t;
t_t_offset *t_offset_;
t_s_r **O_ssd_d;
t_s_offset *O_ssd_d_offset;
t_t_r **E_ssd_d;
t_t_offset *E_ssd_d_offset;
t_t_r **E_s_d;
t_t_offset *E_s_d_offset;
t_t_r **E_n_d;
t_t_offset *E_n_d_offset;
t_integer *m, *m1, *m2, n_d_offset, *gamma_1_index, *gamma_2_index;
t_level *i;
t_long_real *lambda, *max_suff;
boolean *update_discrete, *update_linear;
{
  /* var n_offset  : t_offset; */
  /* var O_s_d  : t_s;
  var O_s_d_offset  : t_s_offset; */
  t_cell_index s_index, t_index, index;
  t_integer m_i = FIRST_INDEX;
  t_long_real n_obs, n_exp, s_obs, s_exp, ssd_obs, ssd_exp, n_ssd_obs,
	      n_ssd_exp, s_n_obs, s_n_exp, delta_suff, z, g_change_1,
	      g_change_2, h_change, k_change;
  t_vertex_set a_d;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " AdjustBySingle     ", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  if (boolean_option[119])
    z = *n_total * marginal_dimension(d);
  else {
    P_setdiff(a_d, a_, d);
    z = *n_total * marginal_dimension(a_d);
  }
  z = 1 / z;
  t_index = *t_offset_;
  s_index = *s_offset;
  FORLIM = *m2 * *m;
  for (index = 0; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(s, s_offset, s_index + index, tzt, 20L, 1418L, 1L);
    ntr_t_ass(t, t_offset_, t_index + index, (*s)->z[s_index + index], tzt,
	      20L, 1418L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*t)->z[t_index + index] = (*s)->z[s_index + index];
  }
  FORLIM = *m - 2;
  for (index = -1; index <= FORLIM; index++) {
    t_index = *t_offset_ + *m2 * (index + 1);
    s_index = *s_offset + *m2 * (index + 1);
    /*$ifdef TRACE-ARRAY*/
    ntr_n_ref(n, n_d_offset, n_d_offset + m_i, tzt, 20L, 1418L, 1L);
    ntr_t_ref(E_n_d, E_n_d_offset, *E_n_d_offset + m_i, tzt, 20L, 1418L, 1L);
    ntr_s_ref(O_ssd_d, O_ssd_d_offset, *O_ssd_d_offset + m_i * 3, tzt, 20L,
	      1418L, 1L);
	/* ntr */
    ntr_t_ref(E_s_d, E_s_d_offset, *E_s_d_offset + m_i, tzt, 20L, 1418L, 1L);
	/* ntr */
    ntr_s_ref(O_ssd_d, O_ssd_d_offset, *O_ssd_d_offset + m_i * 3 + 1, tzt,
	      20L, 1418L, 1L);
	/* ntr */
    ntr_t_ref(E_ssd_d, E_ssd_d_offset, *E_ssd_d_offset + m_i, tzt, 20L, 1418L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    n_obs = n[n_d_offset + m_i];
    n_exp = (*E_n_d)->z[*E_n_d_offset + m_i];
    change_sufficient(&n_exp, &n_obs, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1418L, 2L, 0L, 1L, &n_exp, n_obs, &delta_suff,
		max_suff);
    /*$endif TRACE*/
    s_obs = n_obs * (*O_ssd_d)->z[*O_ssd_d_offset + m_i * 3];
    /* s_obs := n_obs * O_ssd_d^.z^[O_ssd_d_offset + 3 * m_i]; */
    /* s_obs := n_obs * O_s_d^.z^[O_s_d_offset + 3 * m_i]; */
    s_exp = (*E_s_d)->z[*E_s_d_offset + m_i];
    change_sufficient(&s_exp, &s_obs, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1418L, 2L, 0L, 2L, &s_exp, s_obs, &delta_suff,
		max_suff);
    /*$endif TRACE*/
    ssd_obs = (*O_ssd_d)->z[*O_ssd_d_offset + m_i * 3 + 1];
    ssd_exp = (*E_ssd_d)->z[*E_ssd_d_offset + m_i];
    change_sufficient(&ssd_exp, &ssd_obs, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1418L, 2L, 0L, 3L, &ssd_exp, ssd_obs, &delta_suff,
		max_suff);
    /*$endif TRACE*/
    n_ssd_obs = n_obs / ssd_obs;
    n_ssd_exp = n_exp / ssd_exp;
    s_n_obs = s_obs / n_obs;
    s_n_exp = s_exp / n_exp;

    g_change_1 = g_adjustment(n_obs, n_exp, z);   /* (n_obs - n_exp ) * z */
    g_change_2 = (s_n_exp * s_n_exp * n_ssd_exp - s_n_obs * s_n_obs * n_ssd_obs) / 2;
    h_change = s_n_obs * n_ssd_obs - s_n_exp * n_ssd_exp;
    if (boolean_option[89])
      k_change = (n_ssd_obs - n_ssd_exp) / 2;
    else
      k_change = n_ssd_obs - n_ssd_exp;

    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1418L, 3L, 9L, 9L, &g_change_1, g_change_2,
		&h_change, &k_change);
    /*$endif TRACE*/
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1418L, 1L)) {
      write_pch(stdout, " AdjustBySingle: ", 17L);
      write_space(stdout, print_width * 3 - 27);
      write_integer(stdout, t_index, 5L);
      write_integer(stdout, s_index, 5L);
      write_real(stdout, n_obs, print_width, print_dec);
      write_real(stdout, n_exp, print_width, print_dec);
      write_real(stdout, s_obs, print_width, print_dec);
      write_real(stdout, s_exp, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, ssd_obs, print_width, print_dec);
      write_real(stdout, ssd_exp, print_width, print_dec);
      write_real(stdout, n_ssd_obs, print_width, print_dec);
      write_real(stdout, n_ssd_exp, print_width, print_dec);
      write_real(stdout, s_n_obs, print_width, print_dec);
      write_real(stdout, s_n_exp, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, g_change_1, print_width, print_dec);
      write_real(stdout, g_change_2, print_width, print_dec);
      write_real(stdout, h_change, print_width, print_dec);
      write_real(stdout, k_change, print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/

    if (!boolean_option[90]) {
      if (*update_discrete) {
	/*$ifdef TRACE-ARRAY*/
	ntr_t_ref(s, s_offset, s_index + index + *m2, tzt, 20L, 1418L, 1L);
	    /* ntr */
	/* ntr */
	/* ntr */
	ntr_t_ass(t, t_offset_, t_index + index + *m2,
	  (*s)->z[s_index + *m2 - 1] + *lambda * (g_change_1 + g_change_2),
	  tzt, 20L, 1418L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*t)->z[t_index + *m2 - 1] = (*s)->z[s_index + *m2 - 1] +
				     *lambda * (g_change_1 + g_change_2);
      }
    }

    if (*update_linear) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(s, s_offset, s_index + *gamma_1_index, tzt, 20L, 1418L, 1L);
	  /* ntr */
      ntr_t_ass(t, t_offset_, t_index + *gamma_1_index,
		(*s)->z[s_index + *gamma_1_index] + *lambda * h_change, tzt,
		20L, 1418L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*t)->z[t_index + *gamma_1_index] =
	(*s)->z[s_index + *gamma_1_index] + *lambda * h_change;
    }

    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(s, s_offset, s_index + *gamma_2_index, tzt, 20L, 1418L, 1L);
	/* ntr */
    ntr_t_ass(t, t_offset_, t_index + *gamma_2_index,
	      (*s)->z[s_index + *gamma_2_index] + *lambda * k_change, tzt,
	      20L, 1418L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*t)->z[t_index + *gamma_2_index] =
      (*s)->z[s_index + *gamma_2_index] + *lambda * k_change;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1418L, 8L))
      write_headed_ssd_t(" New estimates: @@@@                    ", 16L, a_,
			 -1L, *t_offset_, t, *m1, *m2, NULL, false, 2L,
			 false);
    /*$endif TRACE*/
    fast_next_offset(d_in_a, &m_i, i);
  }
}  /* adjust_by_single */


/* Local variables for update_single_quadratic_generator: */
struct LOC_update_single_quadratic_generator {
  t_mips_element **mixed_item;
  t_set_list **mips_g_c;
  long *model_set;
  t_single_quadratic_generator *generator;
  long *a;
  t_t_r **r_old, **r_new;
  t_t_offset r_old_offset, r_new_offset, E_s_d_offset, E_ssd_d_offset,
	     E_n_d_offset, workspace_offset;
  t_s_r **O_ssd_d;
  t_s_offset O_ssd_d_offset;
  t_t_r **E_s_d, **E_ssd_d, **E_n_d, **workspace;
  t_integer m, m1, m2, gamma_1_index, gamma_2_index;
  t_cell_count n_total;
  boolean update_discrete, update_linear;
  t_cell i_d;
  t_fast_next_offset_pack d_in_a;
} ;

/*$endif TRACE*/

Local t_long_real line_single(lambda, max_suff, LINK)
t_long_real lambda, *max_suff;
struct LOC_update_single_quadratic_generator *LINK;
{
  boolean ok;
  t_long_real log_l;

  if (lambda > 0) {   /* n_offset, */
    /* O_s_d, O_s_d_offset, */
    adjust_by_single(LINK->a, LINK->generator->d, &LINK->d_in_a,
		     &LINK->n_total, LINK->r_old, &LINK->r_old_offset,
		     LINK->r_new, &LINK->r_new_offset, LINK->O_ssd_d,
		     &LINK->O_ssd_d_offset, LINK->E_ssd_d,
		     &LINK->E_ssd_d_offset, LINK->E_s_d, &LINK->E_s_d_offset,
		     LINK->E_n_d, &LINK->E_n_d_offset, &LINK->m, &LINK->m1,
		     &LINK->m2, LINK->generator->n_d_offset,
		     &LINK->gamma_1_index, &LINK->gamma_2_index, LINK->i_d,
		     &lambda, max_suff, &LINK->update_discrete,
		     &LINK->update_linear);
  }
  ok = do_step_halving(LINK->mixed_item, false, LINK->mips_g_c,
      LINK->model_set, LINK->a, LINK->generator->d,
      &LINK->generator->n_d_offset, LINK->r_new, &LINK->r_new_offset,
      LINK->r_old, &LINK->r_old_offset, LINK->workspace,
      &LINK->workspace_offset, &LINK->n_total, &LINK->m, &LINK->m1, &LINK->m2,
      &lambda, &log_l, 0.0);
  /* if is_invalid_real(log_l) then
     line_single := log_l
  else */
  return log_l;
}  /* line_single */



Static Void update_single_quadratic_generator(mixed_item_, mips_g_c_,
  model_set_, generator_, a_, r_old_, r_old_offset_, r_new_, r_new_offset_,
  khi, khi_offset, sigma, sigma_offset, E_n, E_n_offset, O_ssd_d_,
  O_ssd_d_offset_, E_s_d_, E_s_d_offset_, E_ssd_d_, E_ssd_d_offset_, E_n_d_,
  E_n_d_offset_, workspace_, workspace_offset_, m_, m1_, m2_, n_total_,
  max_suff, line_search, update_discrete_, update_linear_)
t_mips_element **mixed_item_;
t_set_list **mips_g_c_;
long *model_set_;
t_single_quadratic_generator *generator_;
long *a_;
t_t_r **r_old_;
t_t_offset r_old_offset_;
t_t_r **r_new_;
t_t_offset r_new_offset_;
t_t_r **khi;
t_t_offset khi_offset;
t_t_r **sigma;
t_t_offset sigma_offset;
t_t_r **E_n;
t_t_offset E_n_offset;
t_s_r **O_ssd_d_;
t_s_offset O_ssd_d_offset_;
t_t_r **E_s_d_;
t_t_offset E_s_d_offset_;
t_t_r **E_ssd_d_;
t_t_offset E_ssd_d_offset_;
t_t_r **E_n_d_;
t_t_offset E_n_d_offset_;
t_t_r **workspace_;
t_t_offset workspace_offset_;
t_integer m_, m1_, m2_;
t_cell_count n_total_;
t_long_real *max_suff;
boolean line_search, update_discrete_, update_linear_;
{
  /* var n_offset      : t_offset; */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var O_s_d      : t_s;
  var O_s_d_offset      : t_s_offset; */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  struct LOC_update_single_quadratic_generator Local_Var;
  t_integer j;
  t_long_real lambda, l, u, alpha, w, t_1, t_2, f_1, f_2;
  /*$ifdef TRACE*/
  pch20 tzt;

  Local_Var.mixed_item = mixed_item_;
  Local_Var.mips_g_c = mips_g_c_;
  Local_Var.model_set = model_set_;
  Local_Var.generator = generator_;
  Local_Var.a = a_;
  Local_Var.r_old = r_old_;
  Local_Var.r_old_offset = r_old_offset_;
  Local_Var.r_new = r_new_;
  Local_Var.r_new_offset = r_new_offset_;
  Local_Var.O_ssd_d = O_ssd_d_;
  Local_Var.O_ssd_d_offset = O_ssd_d_offset_;
  Local_Var.E_s_d = E_s_d_;
  Local_Var.E_s_d_offset = E_s_d_offset_;
  Local_Var.E_ssd_d = E_ssd_d_;
  Local_Var.E_ssd_d_offset = E_ssd_d_offset_;
  Local_Var.E_n_d = E_n_d_;
  Local_Var.E_n_d_offset = E_n_d_offset_;
  Local_Var.workspace = workspace_;
  Local_Var.workspace_offset = workspace_offset_;
  Local_Var.m = m_;
  Local_Var.m1 = m1_;
  Local_Var.m2 = m2_;
  Local_Var.n_total = n_total_;
  Local_Var.update_discrete = update_discrete_;
  Local_Var.update_linear = update_linear_;
  Local_Var.gamma_1_index = both_continuous_index(&Local_Var.generator->lambda,
						  Local_Var.model_set);
  Local_Var.gamma_2_index = Local_Var.m1 + sm_index(Local_Var.gamma_1_index,
			      Local_Var.gamma_1_index, Local_Var.m1);
  memcpy(tzt, " Single generator:  ", sizeof(pch20));
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1419L, 1L)) {
    write_pch(stdout, tzt, 20L);
    print_vertex_set(Local_Var.generator->d);
    print_vertex(Local_Var.generator->lambda);
    write_integer(stdout, Local_Var.gamma_1_index, 4L);
    write_integer(stdout, Local_Var.gamma_2_index, 4L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  find_marginal_expected_n_s_and_ss(Local_Var.a, Local_Var.generator->d,
    &Local_Var.d_in_a, E_n, &E_n_offset, khi, &khi_offset, sigma,
    &sigma_offset, Local_Var.E_n_d, &Local_Var.E_n_d_offset, Local_Var.E_s_d,
    &Local_Var.E_s_d_offset, Local_Var.E_ssd_d, &Local_Var.E_ssd_d_offset,
    &Local_Var.m, &Local_Var.m1, &Local_Var.m2, &Local_Var.gamma_1_index,
    &Local_Var.gamma_2_index, Local_Var.i_d);
  if (line_search) {
    l = 0.0;
    u = 1.0;
    alpha = (3 - sqrt(5.0)) / 2;
    w = u - l;
    t_1 = l;
    f_1 = line_single(t_1, max_suff, &Local_Var);
    t_2 = u + w * exp(20 * log(1 - alpha));
    f_2 = line_single(t_2, max_suff, &Local_Var);
    /*$ifdef TRACE*/
    ntr_6_reals(tzt, 20L, 1419L, 2L, 0L, 0L, &l, &u, &t_1, &t_2, &f_1, &f_2);
    /*$endif TRACE*/
    if (f_1 < f_2) {
      t_1 = u;
      f_1 = line_single(t_1, max_suff, &Local_Var);
      /*$ifdef TRACE*/
      ntr_6_reals(tzt, 20L, 1419L, 2L, 0L, 0L, &l, &u, &t_1, &t_2, &f_1, &f_2);
      /*$endif TRACE*/
      if (f_1 < f_2) {
	l = u;
	w = 0.0;
      }
    }
    if (w > 0) {
      t_1 = l + alpha * w;
      f_1 = line_single(t_1, max_suff, &Local_Var);
      t_2 = u - alpha * w;
      f_2 = line_single(t_2, max_suff, &Local_Var);
    }
    if (w > 0) {
      for (j = 1; j <= 20; j++) {
	/*$ifdef TRACE*/
	ntr_6_reals(tzt, 20L, 1419L, 2L, 0L, j, &l, &u, &t_1, &t_2, &f_1,
		    &f_2);
	/*$endif TRACE*/
	if (f_1 < f_2) {
	  l = t_1;
	  t_1 = t_2;
	  f_1 = f_2;
	  w = u - l;
	  t_2 = u - alpha * w;
	  f_2 = line_single(t_2, max_suff, &Local_Var);
	} else {
	  u = t_2;
	  t_2 = t_1;
	  f_2 = f_1;
	  w = u - l;
	  t_1 = l + alpha * w;
	  f_1 = line_single(t_1, max_suff, &Local_Var);
	}
      }
    }
  } else {
    lambda = 2.0;
    while (do_step_halving(Local_Var.mixed_item, false, Local_Var.mips_g_c,
	     Local_Var.model_set, Local_Var.a, Local_Var.generator->d,
	     &Local_Var.generator->n_d_offset, Local_Var.r_new,
	     &Local_Var.r_new_offset, Local_Var.r_old,
	     &Local_Var.r_old_offset, Local_Var.workspace,
	     &Local_Var.workspace_offset, &Local_Var.n_total, &Local_Var.m,
	     &Local_Var.m1, &Local_Var.m2, &lambda, &l, mips_min_lambda)) {
      if (lambda < 1 - ROUND_ERROR)
	step_half_quadratic_single(Local_Var.r_old, &Local_Var.r_old_offset,
	  Local_Var.r_new, &Local_Var.r_new_offset, &Local_Var.m,
	  &Local_Var.m2, &Local_Var.gamma_1_index, &Local_Var.gamma_2_index,
	  &Local_Var.update_discrete, &Local_Var.update_linear);
      else {
	/* O_s_d, O_s_d_offset, */
	adjust_by_single(Local_Var.a, Local_Var.generator->d,
	  &Local_Var.d_in_a, &Local_Var.n_total, Local_Var.r_old,
	  &Local_Var.r_old_offset, Local_Var.r_new, &Local_Var.r_new_offset,
	  Local_Var.O_ssd_d, &Local_Var.O_ssd_d_offset, Local_Var.E_ssd_d,
	  &Local_Var.E_ssd_d_offset, Local_Var.E_s_d, &Local_Var.E_s_d_offset,
	  Local_Var.E_n_d, &Local_Var.E_n_d_offset, &Local_Var.m,
	  &Local_Var.m1, &Local_Var.m2, Local_Var.generator->n_d_offset,
	  &Local_Var.gamma_1_index, &Local_Var.gamma_2_index, Local_Var.i_d,
	  &lambda, max_suff, &Local_Var.update_discrete,
	  &Local_Var.update_linear);
	/* n_offset, */
      }
    }
  }
  /* m1, */
  copy_mips_estimates(Local_Var.r_new, &Local_Var.r_new_offset,
		      Local_Var.r_old, &Local_Var.r_old_offset, &Local_Var.m,
		      &Local_Var.m2);
}  /* update_single_quadratic_generator */



Static Void iterate_single_quadratic_generators(mixed_item, mips_g_c,
  model_set, copy, copy_offset, workspace, workspace_offset, a, m, m1, m2,
  n_total, mips_epsilon, max_cycle_number, max_suff, update_discrete,
  update_linear, ok)
t_mips_element **mixed_item;
t_set_list **mips_g_c;
long *model_set;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
long *a;
t_integer *m, *m1, *m2;
t_cell_count *n_total;
t_long_real *mips_epsilon;
t_integer *max_cycle_number;
t_long_real *max_suff;
boolean *update_discrete, *update_linear, *ok;
{
  /* var line_search      : boolean; */
  t_long_integer count, i;
  t_single_quadratic_generator *p;
  t_t_r *r_new = NULL, *khi = NULL, *sigma = NULL, *E_n = NULL, *E_s_d = NULL,
	*E_ssd_d = NULL, *E_n_d = NULL;
      /* T_T, malloc_workspace */
  t_t_offset r_new_offset, khi_offset, sigma_offset, E_n_offset, E_s_d_offset,
	     E_ssd_d_offset, E_n_d_offset, tmp_offset;
  t_iterate_pack *iterate_pack;
  long FORLIM;

  iterate_pack = init_iterate_pack(mips_epsilon, max_cycle_number,
				   boolean_option[98], false, false);
  tmp_offset = *workspace_offset;
  malloc_workspace(workspace, &tmp_offset, &r_new, &r_new_offset, *m * *m2);
  sigma = *workspace;
  sigma_offset = tmp_offset + *m1;
  E_n = *workspace;
  E_n_offset = tmp_offset + *m2 - 1;
  malloc_workspace(workspace, &tmp_offset, &khi, &khi_offset, *m * *m2);
  malloc_workspace(workspace, &tmp_offset, &E_s_d, &E_s_d_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &E_ssd_d, &E_ssd_d_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &E_n_d, &E_n_d_offset, *m);
  /* -> m * (2 * m2 + 3) + 3 * m2 */
  *ok = true;
  while (do_mips_iteration(mixed_item, mips_g_c, model_set, " Single:  ",
			   copy, copy_offset, workspace, &tmp_offset, m, m1,
			   m2, &iterate_pack) && *ok) {
    iterate_pack->max_suff = 0.0;
    count = 0;
    p = (*mixed_item)->generators->single_quadratic_generators;
    while (p != NULL) {
      FORLIM = nor();
      for (i = 1; i <= FORLIM; i++) {
	if (count == 0 || !boolean_option[94])
	  find_expected_ns_khis_and_sigmas(m, m1, m2,
	    &(*mixed_item)->n_offset, &(*mixed_item)->r,
	    &(*mixed_item)->r_offset, workspace, tmp_offset, &E_n,
	    &E_n_offset, &khi, &khi_offset, &sigma, &sigma_offset, n_total,
	    ok);
	if (*ok) {
	  /* mixed_item^.n_offset, */
	  /* p^.O_s_d,
	   p^.O_s_d_offset, */
	  update_single_quadratic_generator(mixed_item, mips_g_c, model_set,
	    p, a, &(*mixed_item)->r, (*mixed_item)->r_offset, &r_new,
	    r_new_offset, &khi, khi_offset, &sigma, sigma_offset, &E_n,
	    E_n_offset, &p->O_ssd_d, p->O_ssd_d_offset, &E_s_d, E_s_d_offset,
	    &E_ssd_d, E_ssd_d_offset, &E_n_d, E_n_d_offset, workspace,
	    tmp_offset, *m, *m1, *m2, *n_total, &iterate_pack->max_suff,
	    p->line_search, *update_discrete, *update_linear);
	} else
	  (*mixed_item)->ifail = 44;
      }
      count++;
      p = p->pointer;
    }
  }
  if (iterate_pack->max_suff > *max_suff)
    *max_suff = iterate_pack->max_suff;
  _Free(iterate_pack);
}  /* iterate_single_quadratic_generators */


/* Local variables for find_marginal_expected_n_s_and_ss_pair: */
struct LOC_find_marginal_expected_n_s_and_ss_pair {
  t_t_r **E_n_b, **E_s_b, **E_ss_b;
  t_offset *E_n_b_offset, *E_s_b_offset, *E_ss_b_offset;
  t_cell_index index;
} ;

/*$endif TRACE-ARRAY*/

Local Void to_ssd(i, j, LINK)
t_integer i, j;
struct LOC_find_marginal_expected_n_s_and_ss_pair *LINK;
{
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " ToSsd              ", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1426L, 1L)) {
    write_pch(stdout, " FindMargExpectedNS.", 20L);
    write_integer(stdout, LINK->index, 5L);
    write_integer(stdout, i, 5L);
    write_integer(stdout, j, 5L);
    write_real(stdout, (*LINK->E_ss_b)->z[*LINK->E_ss_b_offset + LINK->index],
	       print_width, print_dec);
    write_real(stdout,
	       (*LINK->E_s_b)->z[*LINK->E_s_b_offset + LINK->index * 2 + i],
	       print_width, print_dec);
    write_real(stdout,
	       (*LINK->E_s_b)->z[*LINK->E_s_b_offset + LINK->index * 2 + j],
	       print_width, print_dec);
    write_real(stdout, (*LINK->E_n_b)->z[*LINK->E_n_b_offset + LINK->index],
	       print_width, print_dec);
  }
  /*$endif TRACE*/
  /*$ifdef TRACE-ARRAY*/
  ntr_t_ref(LINK->E_s_b, LINK->E_s_b_offset,
	    *LINK->E_s_b_offset + LINK->index * 2 + i, tzt, 20L, 1427L, 1L);
  ntr_t_ref(LINK->E_s_b, LINK->E_s_b_offset,
	    *LINK->E_s_b_offset + LINK->index * 2 + j, tzt, 20L, 1427L, 1L);
  ntr_t_ref(LINK->E_n_b, LINK->E_n_b_offset,
	    *LINK->E_n_b_offset + LINK->index, tzt, 20L, 1427L, 1L);
      /* ntr */
  /* ntr */
  /* 3 * */
  /* + i + j */
  ntr_t_ass(LINK->E_ss_b, LINK->E_ss_b_offset,
	    *LINK->E_ss_b_offset + LINK->index, _INVALID_REAL, tzt, 20L,
	    1427L, 1L);
  /*$endif TRACE-ARRAY*/
  (*LINK->E_ss_b)->z[*LINK->E_ss_b_offset + LINK->index] -=
    (*LINK->E_s_b)->z[*LINK->E_s_b_offset + LINK->index * 2 + i] *
    (*LINK->E_s_b)->z[*LINK->E_s_b_offset + LINK->index * 2 + j] /
    (*LINK->E_n_b)->z[*LINK->E_n_b_offset + LINK->index];
      /* 3 * */
  /* + i + j */
  /* 3 * */
  /* + i + j */
  /*$ifdef TRACE-ARRAY*/
  /* ntr */
  /* 3 * */
  /* + i + j */
  ntr_t_ass(LINK->E_ss_b, LINK->E_ss_b_offset,
	    *LINK->E_ss_b_offset + LINK->index, _INVALID_REAL, tzt, 20L,
	    1427L, 1L);
  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1426L, 1L)) {
    write_real(stdout, (*LINK->E_ss_b)->z[*LINK->E_ss_b_offset + LINK->index],
	       print_width, print_dec);
    write_line(stdout);
  }
  /*$endif TRACE*/
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/*@+"mipspar.p"*/


/*

1423:    +++  ++
1424:    +++  ++
1425:    ---  -- p/mipspar.p          6      22     304 p/mipspar.p
1426: |    4:    procedure find_marginal_expected_n_s_and_ss_pair
1427: |   33:    procedure to_ssd
1428: |  116:    procedure adjust_by_pair
1429: |  291:    procedure step_half_quadratic_pair
1430: |  322:    procedure update_quadratic_pair_generator
1431: |  408:    procedure iterate_quadratic_pair_generators
1432:    +++  ++
1433:    +++  ++

*/

Static Void find_marginal_expected_n_s_and_ss_pair(a, b, b_in_a, E_n,
  E_n_offset, khi, khi_offset, sigma, sigma_offset, E_n_b_, E_n_b_offset_,
  E_s_b_, E_s_b_offset_, E_ss_b_, E_ss_b_offset_, m, m1, m2, ig, im, igm, i)
long *a, *b;
t_fast_next_offset_pack *b_in_a;
t_t_r **E_n;
t_t_offset *E_n_offset;
t_t_r **khi;
t_t_offset *khi_offset;
t_t_r **sigma;
t_t_offset *sigma_offset;
t_t_r **E_n_b_;
t_t_offset *E_n_b_offset_;
t_t_r **E_s_b_;
t_t_offset *E_s_b_offset_;
t_t_r **E_ss_b_;
t_t_offset *E_ss_b_offset_;
t_integer *m, *m1, *m2, *ig, *im, *igm;
t_level *i;
{
  struct LOC_find_marginal_expected_n_s_and_ss_pair Local_Var;
  t_cell_index s_b_index, ss_b_index;
  /* i_, j_, */
  t_integer m_i = 0;
  t_t_offset mb, n_index, khi_gamma_index, khi_my_index;
  /* sigma_gamma_gamma_index, */
  /* , sigma_my_my_index */
  t_t_offset sigma_gamma_my_index;
  t_long_real n_expected, khi_gamma, khi_my;
  /* sigma_gamma_gamma, */
  /* , sigma_my_my */
  t_long_real sigma_gamma_my;
  t_vertex_set a_delta;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;

  Local_Var.E_n_b = E_n_b_;
  Local_Var.E_n_b_offset = E_n_b_offset_;
  Local_Var.E_s_b = E_s_b_;
  Local_Var.E_s_b_offset = E_s_b_offset_;
  Local_Var.E_ss_b = E_ss_b_;
  Local_Var.E_ss_b_offset = E_ss_b_offset_;
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " FindMargExpctNSSSP.", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  mb = marginal_dimension(b);
  clear_t_array(Local_Var.E_n_b, Local_Var.E_n_b_offset, &mb);
  n_index = mb * 2;
  clear_t_array(Local_Var.E_s_b, Local_Var.E_s_b_offset, &n_index);
  n_index = mb;   /* 3 * */
  clear_t_array(Local_Var.E_ss_b, Local_Var.E_ss_b_offset, &n_index);
  memcpy(i, first_cell, sizeof(t_cell));
  P_setint(a_delta, a, delta);
  fast_find_products(a_delta, b, b_in_a);
  n_index = *E_n_offset;
  khi_gamma_index = *khi_offset + *ig;
  khi_my_index = *khi_offset + *im;
  /* sigma_gamma_gamma_index := sigma_offset + first_index + igg - m1; */
  sigma_gamma_my_index = *sigma_offset + *igm - *m1;
  FORLIM = *m;
  /* sigma_my_my_index       := sigma_offset + first_index + imm - m1; */
  for (Local_Var.index = 0; Local_Var.index <= FORLIM - 1; Local_Var.index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(E_n, E_n_offset, n_index + *m2 * Local_Var.index, tzt, 20L,
	      1426L, 1L);
    ntr_t_ref(khi, khi_offset, khi_gamma_index + *m2 * Local_Var.index, tzt,
	      20L, 1426L, 1L);
	/* ntr */
    ntr_t_ref(khi, khi_offset, khi_my_index + *m2 * Local_Var.index, tzt, 20L,
	      1426L, 1L);
	/* ntr */
    ntr_t_ref(sigma, sigma_offset,
	      sigma_gamma_my_index + *m2 * Local_Var.index, tzt, 20L, 1426L,
	      1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    n_expected = (*E_n)->z[n_index + *m2 * Local_Var.index];
    khi_gamma = (*khi)->z[khi_gamma_index + *m2 * Local_Var.index];
    khi_my = (*khi)->z[khi_my_index + *m2 * Local_Var.index];
    /* sigma_gamma_gamma := sigma^.z^[sigma_gamma_gamma_index + m2 * index]; */
    sigma_gamma_my = (*sigma)->z[sigma_gamma_my_index + *m2 * Local_Var.index];
    /* sigma_my_my       := sigma^.z^[sigma_my_my_index       + m2 * index]; */

    s_b_index = *Local_Var.E_s_b_offset + m_i * 2;
    ss_b_index = *Local_Var.E_ss_b_offset + m_i;   /* 3 * */

    /*$ifdef TRACE-ARRAY*/
    /* ntr */
    ntr_t_upd(Local_Var.E_n_b, Local_Var.E_n_b_offset,
	      *Local_Var.E_n_b_offset + m_i, n_expected, 1L, tzt, 20L, 1426L,
	      1L);
	/* ntr */
    ntr_t_upd(Local_Var.E_s_b, Local_Var.E_s_b_offset,
	      *Local_Var.E_s_b_offset, khi_gamma * n_expected, 1L, tzt, 20L,
	      1426L, 1L);
    ntr_t_upd(Local_Var.E_s_b, Local_Var.E_s_b_offset,
	      *Local_Var.E_s_b_offset + 1, khi_my * n_expected, 1L, tzt, 20L,
	      1426L, 1L);
	/* ntr */
    ntr_t_upd(Local_Var.E_ss_b, Local_Var.E_ss_b_offset, ss_b_index,
	      (sigma_gamma_my + khi_gamma * khi_my) * n_expected, 1L, tzt,
	      20L, 1426L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/

    (*Local_Var.E_n_b)->z[*Local_Var.E_n_b_offset + m_i] += n_expected;
    (*Local_Var.E_s_b)->z[s_b_index] += khi_gamma * n_expected;
    (*Local_Var.E_s_b)->z[s_b_index+1] += khi_my * n_expected;

    /* E_ss_b^.z^[ss_b_index + 0] := E_ss_b^.z^[ss_b_index + 0] +
                (sigma_gamma_gamma + sqr(khi_gamma)) * n_expected; */
    (*Local_Var.E_ss_b)->z[ss_b_index] +=
      (sigma_gamma_my + khi_gamma * khi_my) * n_expected;
	/* + 1 */
    /* + 1 */
    /* E_ss_b^.z^[ss_b_index + 2] := E_ss_b^.z^[ss_b_index + 2] +
                (sigma_my_my + sqr(khi_my)) * n_expected; */
    fast_next_offset(b_in_a, &m_i, i);
  }
  for (Local_Var.index = 0; Local_Var.index <= mb - 1; Local_Var.index++) {
    /* for i_ := 0 to 1 do
         for j_ := i_ to 1 do
            to_ssd(i_, j_) */
    to_ssd(0L, 1L, &Local_Var);
  }
}  /* find_marginal_expected_n_s_and_ss_pair */



Static Void adjust_by_pair(a_, d, d_in_a, n_total, s, s_offset, t, t_offset_,
			   O_ssd_d, O_ssd_d_offset, E_ssd_d, E_ssd_d_offset,
			   E_s_d, E_s_d_offset, E_n_d, E_n_d_offset, m, m1,
			   m2, n_d_offset, gamma_index, my_index,
			   gamma_my_index, i, lambda, max_suff,
			   update_discrete, update_linear)
long *a_, *d;
t_fast_next_offset_pack *d_in_a;
t_cell_count *n_total;
t_t_r **s;
t_t_offset *s_offset;
t_t_r **t;
t_t_offset *t_offset_;
t_s_r **O_ssd_d;
t_s_offset *O_ssd_d_offset;
t_t_r **E_ssd_d;
t_t_offset *E_ssd_d_offset;
t_t_r **E_s_d;
t_t_offset *E_s_d_offset;
t_t_r **E_n_d;
t_t_offset *E_n_d_offset;
t_integer *m, *m1, *m2, n_d_offset, *gamma_index, *my_index, *gamma_my_index;
t_level *i;
t_long_real *lambda, *max_suff;
boolean *update_discrete, *update_linear;
{
  /* var n_offset      : t_offset; */
  /* var O_s_d      : t_s;
     var O_s_d_offset     : t_s_offset; */
  t_cell_index s_index, t_index, index;
  t_integer m_i = 0;
  t_long_real delta_suff, z, n_obs, n_exp, s_obs_gamma, s_exp_gamma, s_obs_my,
	      s_exp_my, ssd_obs_gamma_gamma, ssd_obs_gamma_my,
	      ssd_exp_gamma_my, ssd_obs_my_my, n_ssd_obs_gamma, s_n_obs_gamma,
	      s_n_exp_gamma, n_ssd_obs_my, s_n_obs_my, s_n_exp_my,
	      r_sqrt_prod_ssd_obs, r_obs, r_exp, rho_obs, rho_exp,
	      fraction_obs, fraction_exp, g_change_1, g_change_2, g_change_3,
	      g_change_4, h_change_gamma_1, h_change_gamma_2, h_change_my_1,
	      h_change_my_2, g_change, h_change_gamma, h_change_my, k_change;
  t_vertex_set a_d;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " AdjustByPair       ", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  if (boolean_option[119])
    z = *n_total * marginal_dimension(d);
  else {
    P_setdiff(a_d, a_, d);
    z = *n_total * marginal_dimension(a_d);
  }
  z = 1 / z;
  t_index = *t_offset_;
  s_index = *s_offset;
  FORLIM = *m2 * *m;
  for (index = 0; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(s, s_offset, s_index + index, tzt, 20L, 1428L, 1L);
    ntr_t_ass(t, t_offset_, t_index + index, (*s)->z[s_index + index], tzt,
	      20L, 1428L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*t)->z[t_index + index] = (*s)->z[s_index + index];
  }
  FORLIM = *m - 2;
  for (index = -1; index <= FORLIM; index++) {
    t_index = *t_offset_ + *m2 * (index + 1);
    s_index = *s_offset + *m2 * (index + 1);

    /*$ifdef TRACE-ARRAY*/
    ntr_n_ref(n, n_d_offset, n_d_offset + m_i, tzt, 20L, 1428L, 1L);
	/* ntr */
    ntr_t_ref(E_n_d, E_n_d_offset, *E_n_d_offset + m_i, tzt, 20L, 1428L, 1L);
	/* ntr */
    /* ntr */
    ntr_s_ref(O_ssd_d, O_ssd_d_offset, *O_ssd_d_offset + m_i * 6, tzt, 20L,
	      1428L, 1L);
	/* ntr */
    /* ntr */
    ntr_t_ref(E_s_d, E_s_d_offset, *E_s_d_offset + m_i * 2, tzt, 20L, 1428L,
	      1L);
	/* ntr */
    /* ntr */
    ntr_s_ref(O_ssd_d, O_ssd_d_offset, *O_ssd_d_offset + m_i * 6 + 1, tzt,
	      20L, 1428L, 1L);
	/* ntr */
    /* ntr */
    ntr_t_ref(E_s_d, E_s_d_offset, *E_s_d_offset + m_i * 2 + 1, tzt, 20L,
	      1428L, 1L);
	/* ntr */
    /* ntr */
    ntr_s_ref(O_ssd_d, O_ssd_d_offset, *O_ssd_d_offset + m_i * 6 + 2, tzt,
	      20L, 1428L, 1L);
	/* ntr */
    /* ntr */
    ntr_s_ref(O_ssd_d, O_ssd_d_offset, *O_ssd_d_offset + m_i * 6 + 3, tzt,
	      20L, 1428L, 1L);
	/* ntr */
    /* 3 * */
    /* + 1 */
    /* ntr */
    ntr_t_ref(E_ssd_d, E_ssd_d_offset, *E_ssd_d_offset + m_i, tzt, 20L, 1428L,
	      1L);
	/* ntr */
    /* ntr */
    ntr_s_ref(O_ssd_d, O_ssd_d_offset, *O_ssd_d_offset + m_i * 6 + 4, tzt,
	      20L, 1428L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/

    n_obs = n[n_d_offset + m_i];
    n_exp = (*E_n_d)->z[*E_n_d_offset + m_i];   /* * n_total */
    change_sufficient(&n_exp, &n_obs, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1428L, 2L, 0L, 1L, &n_exp, n_obs, &delta_suff,
		max_suff);
    /*$endif TRACE*/
    s_obs_gamma = (*O_ssd_d)->z[*O_ssd_d_offset + m_i * 6] * n_obs;
    s_exp_gamma = (*E_s_d)->z[*E_s_d_offset + m_i * 2];
    change_sufficient(&s_exp_gamma, &s_obs_gamma, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1428L, 2L, 0L, 2L, &s_exp_gamma, s_obs_gamma,
		&delta_suff, max_suff);
    /*$endif TRACE*/
    s_obs_my = (*O_ssd_d)->z[*O_ssd_d_offset + m_i * 6 + 1] * n_obs;
    s_exp_my = (*E_s_d)->z[*E_s_d_offset + m_i * 2 + 1];
    change_sufficient(&s_exp_my, &s_obs_my, &delta_suff, max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1428L, 2L, 0L, 3L, &s_exp_my, s_obs_my, &delta_suff,
		max_suff);
    /*$endif TRACE*/
    ssd_obs_gamma_gamma = (*O_ssd_d)->z[*O_ssd_d_offset + m_i * 6 + 2];
    ssd_obs_gamma_my = (*O_ssd_d)->z[*O_ssd_d_offset + m_i * 6 + 3];
    ssd_exp_gamma_my = (*E_ssd_d)->z[*E_ssd_d_offset + m_i];   /* 3 * */
    /* + 1 */
    ssd_obs_my_my = (*O_ssd_d)->z[*O_ssd_d_offset + m_i * 6 + 4];
    change_sufficient(&ssd_exp_gamma_my, &ssd_obs_gamma_my, &delta_suff,
		      max_suff);
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1428L, 2L, 0L, 4L, &ssd_exp_gamma_my,
		ssd_obs_gamma_my, &delta_suff, max_suff);
    /*$endif TRACE*/
    n_ssd_obs_gamma = n_obs / ssd_obs_gamma_gamma;
    s_n_obs_gamma = s_obs_gamma / n_obs;
    s_n_exp_gamma = s_exp_gamma / n_exp;
    n_ssd_obs_my = n_obs / ssd_obs_my_my;
    s_n_obs_my = s_obs_my / n_obs;
    s_n_exp_my = s_exp_my / n_exp;
    r_sqrt_prod_ssd_obs = 1 / sqrt(ssd_obs_gamma_gamma * ssd_obs_my_my);
    r_obs = ssd_obs_gamma_my * r_sqrt_prod_ssd_obs;
    r_exp = ssd_exp_gamma_my * r_sqrt_prod_ssd_obs;
    rho_obs = (1 - sqrt(1 + 4 * r_obs * r_obs)) / 2 / r_obs;
    if (ssd_exp_gamma_my == 0)
      rho_exp = 0.0;
    else
      rho_exp = (1 - sqrt(1 + 4 * r_exp * r_exp)) / 2 / r_exp;
    fraction_obs = rho_obs * r_sqrt_prod_ssd_obs;
    fraction_exp = rho_exp * r_sqrt_prod_ssd_obs;
    g_change_1 = g_adjustment(n_obs, n_exp, z);   /* (n_obs - n_exp ) * z */
    g_change_2 = (s_n_exp_my * s_n_exp_gamma * fraction_exp -
		  s_n_obs_my * s_n_obs_gamma * fraction_obs) * n_obs;
    g_change_3 = (s_n_exp_my * s_n_exp_my - s_n_obs_my * s_n_obs_my) * n_ssd_obs_my;
    g_change_4 = (s_n_exp_gamma * s_n_exp_gamma -
		  s_n_obs_gamma * s_n_obs_gamma) * n_ssd_obs_gamma;
    g_change = g_change_1 + g_change_2 + (g_change_3 + g_change_4) / 2;
    h_change_gamma_1 =
      s_obs_gamma / ssd_obs_gamma_gamma - n_ssd_obs_gamma * s_n_exp_gamma;
    h_change_gamma_2 = s_obs_my * fraction_obs - s_n_exp_my * n_obs * fraction_exp;
    h_change_my_1 = s_obs_my / ssd_obs_my_my - n_ssd_obs_my * s_n_exp_my;
    h_change_my_2 =
      s_obs_gamma * fraction_obs - s_n_exp_gamma * n_obs * fraction_exp;
    h_change_gamma = h_change_gamma_1 + h_change_gamma_2;
    h_change_my = h_change_my_1 + h_change_my_2;
    if (boolean_option[88])
      k_change = n_obs * 2 * (fraction_obs - fraction_exp);
    else
      k_change = n_obs * (fraction_obs - fraction_exp);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1428L, 1L)) {
      write_pch(stdout, " AdjustByPair:   ", 17L);
      write_space(stdout, print_width * 3 - 27);
      write_integer(stdout, t_index, 5L);
      write_integer(stdout, s_index, 5L);
      write_real(stdout, n_obs, print_width, print_dec);
      write_real(stdout, n_exp, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, s_obs_gamma, print_width, print_dec);
      write_real(stdout, s_exp_gamma, print_width, print_dec);
      write_real(stdout, s_obs_my, print_width, print_dec);
      write_real(stdout, s_exp_my, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, ssd_obs_gamma_gamma, print_width, print_dec);
      write_real(stdout, ssd_obs_my_my, print_width, print_dec);
      write_real(stdout, ssd_obs_gamma_my, print_width, print_dec);
      write_real(stdout, ssd_exp_gamma_my, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, n_ssd_obs_gamma, print_width, print_dec);
      write_real(stdout, s_n_obs_gamma, print_width, print_dec);
      write_real(stdout, s_n_exp_gamma, print_width, print_dec);
      write_real(stdout, n_ssd_obs_my, print_width, print_dec);
      write_real(stdout, s_n_obs_my, print_width, print_dec);
      write_real(stdout, s_n_exp_my, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, r_obs, print_width, print_dec);
      write_real(stdout, r_exp, print_width, print_dec);
      write_real(stdout, rho_obs, print_width, print_dec);
      write_real(stdout, rho_exp, print_width, print_dec);
      write_real(stdout, fraction_obs, print_width, print_dec);
      write_real(stdout, fraction_exp, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, g_change_1, print_width, print_dec);
      write_real(stdout, g_change_2, print_width, print_dec);
      write_real(stdout, g_change_3, print_width, print_dec);
      write_real(stdout, g_change_4, print_width, print_dec);
      write_line(stdout);
      write_real(stdout, h_change_gamma_1, print_width, print_dec);
      write_real(stdout, h_change_gamma_2, print_width, print_dec);
      write_real(stdout, h_change_my_1, print_width, print_dec);
      write_real(stdout, h_change_my_2, print_width, print_dec);
      write_real(stdout, k_change, print_width, print_dec);
      write_line(stdout);
    }
    /*$endif TRACE*/
    /*$ifdef TRACE*/
    ntr_4_reals(tzt, 20L, 1428L, 3L, 9L, 7L, &g_change_1, g_change_2,
		&g_change_3, &g_change_4);
    ntr_4_reals(tzt, 20L, 1428L, 3L, 9L, 8L, &h_change_gamma_1,
		h_change_gamma_2, &h_change_my_1, &h_change_my_2);
    ntr_4_reals(tzt, 20L, 1428L, 3L, 9L, 9L, &g_change, h_change_gamma,
		&h_change_my, &k_change);
    /*$endif TRACE*/

    if (!boolean_option[90]) {
      if (*update_discrete) {
	/*$ifdef TRACE-ARRAY*/
	ntr_t_ref(s, s_offset, s_index + index + *m2, tzt, 20L, 1428L, 1L);
	    /* ntr */
	/* ntr */
	ntr_t_ass(t, t_offset_, t_index + index + *m2,
		  (*s)->z[s_index + *m2 - 1] + *lambda * g_change, tzt, 20L,
		  1428L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*t)->z[t_index + *m2 - 1] = (*s)->z[s_index + *m2 - 1] + *lambda * g_change;
      }
    }

    if (*update_linear) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(s, s_offset, s_index + *gamma_index, tzt, 20L, 1428L, 1L);
	  /* ntr */
      /* ntr */
      /* ntr */
      ntr_t_ass(t, t_offset_, t_index + *gamma_index,
		(*s)->z[s_index + *gamma_index] +
		*lambda * (h_change_gamma_1 + h_change_gamma_2), tzt, 20L,
		1428L, 1L);
	  /* ntr */
      ntr_t_ref(s, s_offset, s_index + *my_index, tzt, 20L, 1428L, 1L);
	  /* ntr */
      /* ntr */
      ntr_t_ass(t, t_offset_, t_index + *my_index,
	(*s)->z[s_index + *my_index] + *lambda * (h_change_my_1 + h_change_my_2),
	tzt, 20L, 1428L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*t)->z[t_index + *gamma_index] = (*s)->z[s_index + *gamma_index] +
	  *lambda * (h_change_gamma_1 + h_change_gamma_2);
      (*t)->z[t_index + *my_index] = (*s)->z[s_index + *my_index] +
	  *lambda * (h_change_my_1 + h_change_my_2);
    }

    /*$ifdef TRACE-ARRAY*/
    ntr_t_ref(s, s_offset, s_index + *gamma_my_index, tzt, 20L, 1428L, 1L);
	/* ntr */
    ntr_t_ass(t, t_offset_, t_index + *gamma_my_index,
	      (*s)->z[s_index + *gamma_my_index] + *lambda * k_change, tzt,
	      20L, 1428L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    (*t)->z[t_index + *gamma_my_index] =
      (*s)->z[s_index + *gamma_my_index] + *lambda * k_change;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1428L, 8L))
      write_headed_ssd_t(" New estimates: @@@@                    ", 16L, a_,
			 -1L, *t_offset_, t, *m1, *m2, NULL, false, 2L,
			 false);
    /*$endif TRACE*/
    fast_next_offset(d_in_a, &m_i, i);
  }
}  /* adjust_by_pair */



Static Void step_half_quadratic_pair(s, s_offset, t, t_offset_, m, m1, m2,
  gamma_index, my_index, gamma_my_index, update_discrete, update_linear)
t_t_r **s;
t_t_offset *s_offset;
t_t_r **t;
t_t_offset *t_offset_;
t_integer *m, *m1, *m2, *gamma_index, *my_index, *gamma_my_index;
boolean *update_discrete, *update_linear;
{
  t_cell_index s_index, t_index, index, i, g;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_cell_index FORLIM, FORLIM1;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " StepHalfQuadtcPair ", sizeof(pch20));
  FORLIM = *m;
  /*$endif TRACE-ARRAY*/
  for (index = 0; index <= FORLIM - 1; index++) {
    t_index = *t_offset_ + *m2 * index;
    s_index = *s_offset + *m2 * index;
    /*$ifdef TRACE-ARRAY*/
    if (*update_discrete) {
      ntr_t_ref(s, s_offset, s_index + *m2 - 1, tzt, 20L, 1429L, 1L);
      ntr_t_ref(t, t_offset_, t_index + *m2 - 1, tzt, 20L, 1429L, 1L);
    }
    if (*update_linear) {
      ntr_t_ref(s, s_offset, s_index + *gamma_index, tzt, 20L, 1429L, 1L);
      ntr_t_ref(t, t_offset_, t_index + *gamma_index, tzt, 20L, 1429L, 1L);
      ntr_t_ref(s, s_offset, s_index + *my_index, tzt, 20L, 1429L, 1L);
      ntr_t_ref(t, t_offset_, t_index + *my_index, tzt, 20L, 1429L, 1L);
    }
    ntr_t_ref(s, s_offset, s_index + *gamma_my_index, tzt, 20L, 1429L, 1L);
    ntr_t_ref(t, t_offset_, t_index + *gamma_my_index, tzt, 20L, 1429L, 1L);
    /*$endif TRACE-ARRAY*/
    if (*update_discrete)
      half_difference(&(*t)->z[t_index + *m2 - 1],
		      &(*s)->z[s_index + *m2 - 1]);
    if (*update_linear) {
      half_difference(&(*t)->z[t_index + *gamma_index],
		      &(*s)->z[s_index + *gamma_index]);
      half_difference(&(*t)->z[t_index + *my_index],
		      &(*s)->z[s_index + *my_index]);
    }
    if (boolean_option[105]) {
      FORLIM1 = *m1;
      for (i = 0; i <= FORLIM1 - 1; i++) {
	g = *m1 + sm_index(i, i, *m1);
	(*t)->z[t_index + g] = (*s)->z[s_index + g];
      }
    }
    half_difference(&(*t)->z[t_index + *gamma_my_index],
		    &(*s)->z[s_index + *gamma_my_index]);
  }
}  /* step_half_quadratic_pair */


/* Local variables for update_quadratic_pair_generator: */
struct LOC_update_quadratic_pair_generator {
  t_mips_element **mixed_item;
  t_set_list **mips_g_c;
  long *model_set;
  t_quadratic_pair_generator *generator;
  long *a;
  t_t_r **r_old, **r_new;
  t_t_offset r_old_offset, r_new_offset, E_s_d_offset, E_ssd_d_offset,
	     E_n_d_offset, workspace_offset;
  t_s_r **O_ssd_d;
  t_s_offset O_ssd_d_offset;
  t_t_r **E_s_d, **E_ssd_d, **E_n_d, **workspace;
  t_integer m, m1, m2, ig, im, igm;
  t_cell_count n_total;
  boolean update_discrete, update_linear;
  t_cell i_d;
  t_fast_next_offset_pack d_in_a;
} ;

/*$endif TRACE*/

Local t_long_real line_pair(lambda, max_suff, LINK)
t_long_real lambda, *max_suff;
struct LOC_update_quadratic_pair_generator *LINK;
{
  boolean ok;
  t_long_real log_l;

  if (lambda > 0) {   /* n_offset, */
    /* O_s_d, O_s_d_offset, */
    adjust_by_pair(LINK->a, LINK->generator->d, &LINK->d_in_a, &LINK->n_total,
		   LINK->r_old, &LINK->r_old_offset, LINK->r_new,
		   &LINK->r_new_offset, LINK->O_ssd_d, &LINK->O_ssd_d_offset,
		   LINK->E_ssd_d, &LINK->E_ssd_d_offset, LINK->E_s_d,
		   &LINK->E_s_d_offset, LINK->E_n_d, &LINK->E_n_d_offset,
		   &LINK->m, &LINK->m1, &LINK->m2,
		   LINK->generator->n_d_offset, &LINK->ig, &LINK->im,
		   &LINK->igm, LINK->i_d, &lambda, max_suff,
		   &LINK->update_discrete, &LINK->update_linear);
  }
  ok = do_step_halving(LINK->mixed_item, false, LINK->mips_g_c,
      LINK->model_set, LINK->a, LINK->generator->d,
      &LINK->generator->n_d_offset, LINK->r_new, &LINK->r_new_offset,
      LINK->r_old, &LINK->r_old_offset, LINK->workspace,
      &LINK->workspace_offset, &LINK->n_total, &LINK->m, &LINK->m1, &LINK->m2,
      &lambda, &log_l, 0.0);
  /* if is_invalid_real(log_l) then
     line_pair := log_l
  else */
  return log_l;
}  /* line_pair */



Static Void update_quadratic_pair_generator(mixed_item_, mips_g_c_,
  model_set_, generator_, a_, r_old_, r_old_offset_, r_new_, r_new_offset_,
  khi, khi_offset, sigma, sigma_offset, E_n, E_n_offset, O_ssd_d_,
  O_ssd_d_offset_, E_s_d_, E_s_d_offset_, E_ssd_d_, E_ssd_d_offset_, E_n_d_,
  E_n_d_offset_, workspace_, workspace_offset_, m_, m1_, m2_, n_total_,
  max_suff, line_search, update_discrete_, update_linear_)
t_mips_element **mixed_item_;
t_set_list **mips_g_c_;
long *model_set_;
t_quadratic_pair_generator *generator_;
long *a_;
t_t_r **r_old_;
t_t_offset r_old_offset_;
t_t_r **r_new_;
t_t_offset r_new_offset_;
t_t_r **khi;
t_t_offset khi_offset;
t_t_r **sigma;
t_t_offset sigma_offset;
t_t_r **E_n;
t_t_offset E_n_offset;
t_s_r **O_ssd_d_;
t_s_offset O_ssd_d_offset_;
t_t_r **E_s_d_;
t_t_offset E_s_d_offset_;
t_t_r **E_ssd_d_;
t_t_offset E_ssd_d_offset_;
t_t_r **E_n_d_;
t_t_offset E_n_d_offset_;
t_t_r **workspace_;
t_t_offset workspace_offset_;
t_integer m_, m1_, m2_;
t_cell_count n_total_;
t_long_real *max_suff;
boolean line_search, update_discrete_, update_linear_;
{
  /* var n_offset      : t_offset; */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var O_s_d  : t_s;
   var O_s_d_offset  : t_s_offset; */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  /* var */
  struct LOC_update_quadratic_pair_generator Local_Var;
  t_integer j;
  t_long_real lambda, l, u, alpha, w, t_1, t_2, f_1, f_2;
  /*$ifdef TRACE*/
  pch20 tzt;

  Local_Var.mixed_item = mixed_item_;
  Local_Var.mips_g_c = mips_g_c_;
  Local_Var.model_set = model_set_;
  Local_Var.generator = generator_;
  Local_Var.a = a_;
  Local_Var.r_old = r_old_;
  Local_Var.r_old_offset = r_old_offset_;
  Local_Var.r_new = r_new_;
  Local_Var.r_new_offset = r_new_offset_;
  Local_Var.O_ssd_d = O_ssd_d_;
  Local_Var.O_ssd_d_offset = O_ssd_d_offset_;
  Local_Var.E_s_d = E_s_d_;
  Local_Var.E_s_d_offset = E_s_d_offset_;
  Local_Var.E_ssd_d = E_ssd_d_;
  Local_Var.E_ssd_d_offset = E_ssd_d_offset_;
  Local_Var.E_n_d = E_n_d_;
  Local_Var.E_n_d_offset = E_n_d_offset_;
  Local_Var.workspace = workspace_;
  Local_Var.workspace_offset = workspace_offset_;
  Local_Var.m = m_;
  Local_Var.m1 = m1_;
  Local_Var.m2 = m2_;
  Local_Var.n_total = n_total_;
  Local_Var.update_discrete = update_discrete_;
  Local_Var.update_linear = update_linear_;
  Local_Var.ig = both_continuous_index(&Local_Var.generator->lambda,
				       Local_Var.model_set);
  Local_Var.im = both_continuous_index(&Local_Var.generator->my,
				       Local_Var.model_set);
  Local_Var.igm = Local_Var.m1 + sm_index(Local_Var.ig, Local_Var.im,
					  Local_Var.m1);
  memcpy(tzt, " Pair generator:    ", sizeof(pch20));
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1430L, 1L)) {
    write_pch(stdout, tzt, 20L);
    print_vertex_set(Local_Var.generator->d);
    print_vertex(Local_Var.generator->lambda);
    print_vertex(Local_Var.generator->my);
    write_integer(stdout, Local_Var.ig, 4L);
    write_integer(stdout, Local_Var.im, 4L);
    write_integer(stdout, Local_Var.igm, 4L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  find_marginal_expected_n_s_and_ss_pair(Local_Var.a, Local_Var.generator->d,
    &Local_Var.d_in_a, E_n, &E_n_offset, khi, &khi_offset, sigma,
    &sigma_offset, Local_Var.E_n_d, &Local_Var.E_n_d_offset, Local_Var.E_s_d,
    &Local_Var.E_s_d_offset, Local_Var.E_ssd_d, &Local_Var.E_ssd_d_offset,
    &Local_Var.m, &Local_Var.m1, &Local_Var.m2, &Local_Var.ig, &Local_Var.im,
    &Local_Var.igm, Local_Var.i_d);
  if (line_search) {
    l = 0.0;
    u = 1.0;
    alpha = (3 - sqrt(5.0)) / 2;
    w = u - l;
    t_1 = l;
    f_1 = line_pair(t_1, max_suff, &Local_Var);
    t_2 = u + w * exp(20 * log(1 - alpha));
    f_2 = line_pair(t_2, max_suff, &Local_Var);
    /*$ifdef TRACE*/
    ntr_6_reals(tzt, 20L, 1430L, 2L, 0L, 0L, &l, &u, &t_1, &t_2, &f_1, &f_2);
    /*$endif TRACE*/
    if (f_1 < f_2) {
      t_1 = u;
      f_1 = line_pair(t_1, max_suff, &Local_Var);
      /*$ifdef TRACE*/
      ntr_6_reals(tzt, 20L, 1430L, 2L, 0L, 0L, &l, &u, &t_1, &t_2, &f_1, &f_2);
      /*$endif TRACE*/
      if (f_1 < f_2) {
	l = u;
	w = 0.0;
      }
    }
    if (w > 0) {
      t_1 = l + alpha * w;
      f_1 = line_pair(t_1, max_suff, &Local_Var);
      t_2 = u - alpha * w;
      f_2 = line_pair(t_2, max_suff, &Local_Var);
    }
    if (w > 0) {
      for (j = 1; j <= 20; j++) {
	/*$ifdef TRACE*/
	ntr_6_reals(tzt, 20L, 1430L, 2L, 0L, j, &l, &u, &t_1, &t_2, &f_1,
		    &f_2);
	/*$endif TRACE*/
	if (f_1 < f_2) {
	  l = t_1;
	  t_1 = t_2;
	  f_1 = f_2;
	  w = u - l;
	  t_2 = u - alpha * w;
	  f_2 = line_pair(t_2, max_suff, &Local_Var);
	} else {
	  u = t_2;
	  t_2 = t_1;
	  f_2 = f_1;
	  w = u - l;
	  t_1 = l + alpha * w;
	  f_1 = line_pair(t_1, max_suff, &Local_Var);
	}
      }
    }
  } else {
    lambda = 2.0;
    while (do_step_halving(Local_Var.mixed_item, false, Local_Var.mips_g_c,
	     Local_Var.model_set, Local_Var.a, Local_Var.generator->d,
	     &Local_Var.generator->n_d_offset, Local_Var.r_new,
	     &Local_Var.r_new_offset, Local_Var.r_old,
	     &Local_Var.r_old_offset, Local_Var.workspace,
	     &Local_Var.workspace_offset, &Local_Var.n_total, &Local_Var.m,
	     &Local_Var.m1, &Local_Var.m2, &lambda, &l, mips_min_lambda)) {
      if (lambda < 1 - ROUND_ERROR)
	step_half_quadratic_pair(Local_Var.r_old, &Local_Var.r_old_offset,
	  Local_Var.r_new, &Local_Var.r_new_offset, &Local_Var.m,
	  &Local_Var.m1, &Local_Var.m2, &Local_Var.ig, &Local_Var.im,
	  &Local_Var.igm, &Local_Var.update_discrete,
	  &Local_Var.update_linear);
      else {
	/* O_s_d, O_s_d_offset, */
	adjust_by_pair(Local_Var.a, Local_Var.generator->d, &Local_Var.d_in_a,
		       &Local_Var.n_total, Local_Var.r_old,
		       &Local_Var.r_old_offset, Local_Var.r_new,
		       &Local_Var.r_new_offset, Local_Var.O_ssd_d,
		       &Local_Var.O_ssd_d_offset, Local_Var.E_ssd_d,
		       &Local_Var.E_ssd_d_offset, Local_Var.E_s_d,
		       &Local_Var.E_s_d_offset, Local_Var.E_n_d,
		       &Local_Var.E_n_d_offset, &Local_Var.m, &Local_Var.m1,
		       &Local_Var.m2, Local_Var.generator->n_d_offset,
		       &Local_Var.ig, &Local_Var.im, &Local_Var.igm,
		       Local_Var.i_d, &lambda, max_suff,
		       &Local_Var.update_discrete, &Local_Var.update_linear);
	/* n_offset, */
      }
    }
  }
  /* m1, */
  copy_mips_estimates(Local_Var.r_new, &Local_Var.r_new_offset,
		      Local_Var.r_old, &Local_Var.r_old_offset, &Local_Var.m,
		      &Local_Var.m2);
}  /* update_quadratic_pair_generator */



Static Void iterate_quadratic_pair_generators(mixed_item, mips_g_c, model_set,
  copy, copy_offset, workspace, workspace_offset, a, m, m1, m2, n_total,
  mips_epsilon, max_cycle_number, max_suff, update_discrete, update_linear,
  ok)
t_mips_element **mixed_item;
t_set_list **mips_g_c;
long *model_set;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
long *a;
t_integer *m, *m1, *m2;
t_cell_count *n_total;
t_long_real *mips_epsilon;
t_integer *max_cycle_number;
t_long_real *max_suff;
boolean *update_discrete, *update_linear, *ok;
{
  /* var line_search      : boolean; */
  t_long_integer count, i;
  t_quadratic_pair_generator *p;
  t_t_r *r_new = NULL, *khi = NULL, *sigma = NULL, *E_n = NULL, *E_s_d = NULL,
	*E_ssd_d = NULL, *E_n_d = NULL;
      /* T_T, malloc_workspace */
  t_t_offset r_new_offset, khi_offset, sigma_offset, E_n_offset, E_s_d_offset,
	     E_ssd_d_offset, E_n_d_offset, tmp_offset;
  t_iterate_pack *iterate_pack;
  long FORLIM;

  iterate_pack = init_iterate_pack(mips_epsilon, max_cycle_number,
				   boolean_option[99], false, false);
  tmp_offset = *workspace_offset;
  malloc_workspace(workspace, &tmp_offset, &r_new, &r_new_offset, *m * *m2);
  sigma = *workspace;
  sigma_offset = tmp_offset + *m1;
  E_n = *workspace;
  E_n_offset = tmp_offset + *m2 - 1;
  malloc_workspace(workspace, &tmp_offset, &khi, &khi_offset, *m * *m2);
  malloc_workspace(workspace, &tmp_offset, &E_s_d, &E_s_d_offset, *m * 2);
      /* * 3*/
  malloc_workspace(workspace, &tmp_offset, &E_ssd_d, &E_ssd_d_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &E_n_d, &E_n_d_offset, *m);
  /* -> m * (2 * m2 + [ 6 ] 4) + 3 * m2 */
  *ok = true;
  while (do_mips_iteration(mixed_item, mips_g_c, model_set, " Pair:    ",
			   copy, copy_offset, workspace, &tmp_offset, m, m1,
			   m2, &iterate_pack) && *ok) {
    iterate_pack->max_suff = 0.0;
    count = 0;
    p = (*mixed_item)->generators->quadratic_pair_generators;
    while (p != NULL) {
      FORLIM = nor();
      for (i = 1; i <= FORLIM; i++) {
	if (count == 0 || !boolean_option[94])
	  find_expected_ns_khis_and_sigmas(m, m1, m2,
	    &(*mixed_item)->n_offset, &(*mixed_item)->r,
	    &(*mixed_item)->r_offset, workspace, tmp_offset, &E_n,
	    &E_n_offset, &khi, &khi_offset, &sigma, &sigma_offset, n_total,
	    ok);
	if (*ok) {
	  /* mixed_item^.n_offset, */
	  /* p^.O_s_d, p^.O_s_d_offset, */
	  update_quadratic_pair_generator(mixed_item, mips_g_c, model_set, p,
	    a, &(*mixed_item)->r, (*mixed_item)->r_offset, &r_new,
	    r_new_offset, &khi, khi_offset, &sigma, sigma_offset, &E_n,
	    E_n_offset, &p->O_ssd_d, p->O_ssd_d_offset, &E_s_d, E_s_d_offset,
	    &E_ssd_d, E_ssd_d_offset, &E_n_d, E_n_d_offset, workspace,
	    tmp_offset, *m, *m1, *m2, *n_total, &iterate_pack->max_suff,
	    p->line_search, *update_discrete, *update_linear);
	} else
	  (*mixed_item)->ifail = 45;
      }
      count++;
      p = p->pointer;
    }
  }
  if (iterate_pack->max_suff > *max_suff)
    *max_suff = iterate_pack->max_suff;
  _Free(iterate_pack);
}  /* iterate_quadratic_pair_generators */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/*@+"mipsini.p"*/


/*

1434:    +++  ++
1435:    +++  ++
1436:    ---  -- p/mipsini.p         29     114    1845 p/mipsini.p
1437: |    4:    function prepare_discrete_generator_list
1438: |   27:    function prepare_linear_generator_list
1439: |   62:    function prepare_linear_and_quadratic_generator_list
1440: |  115:    function prepare_single_quadratic_generator_list
1441: |  157:    function prepare_quadratic_pair_generator_list
1442: |  203:    procedure insert_item_in_discrete
1443: |  221:    procedure insert_item_in_linear
1444: |  240:    procedure insert_item_in_single_quadratic
1445: |  264:    procedure insert_item_in_pair_quadratic
1446: |  293:    procedure insert_item_in_linear_and_quadratic
1447: |  320:    procedure print_vertex_
1448: |  327:    procedure print_adj_list_
1449: |  351:    procedure print_edge_list_
1450: |  372:    procedure find_augmenting_path
1451: |  444:    procedure update_matching
1452: |  478:    procedure find_matching
1453: |  510:    procedure dispose_adj_list_
1454: |  526:    procedure adj_set_to_adj_list_
1455: |  532:    procedure insert_edge_in_adj_list_fast
1456: |  548:    procedure make_matching_adj_list
1457: |  600:    procedure set_list_to_array
1458: |  655:    procedure insert_set_in_discrete_collected_list
1459: |  690:    procedure collect_identical_discrete_sets
1460: |  714:    procedure split_continuous
1461: |  731:    procedure sub_match_linear_and_quadratic
1462: |  811:    procedure tmp_match_linear_and_quadratic
1463: |  837:    procedure split_generator_lists
1464: |  846:    function g_c_size
1465: | 1048:    function prepare_mixed_item_for_mips
1466:    +++  ++
1467:    +++  ++

*/

Static boolean prepare_discrete_generator_list(q)
t_discrete_generator **q;
{
  boolean ok = true;
  t_discrete_generator *p;

  p = *q;
  while (ok && p != NULL) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1437L, 1L)) {
      write_pch(stdout, " Discrete generator (prepare):", 30L);
      print_vertex_set(p->d);
      write_char(stdout, ':');
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (em)
      write_warning_em(stdout, 1437L, " PrepareDiscreteGen.");
    p->n_d_offset = return_offset(p->d, &ok);
    p = p->pointer;
  }
  return ok;
}  /* prepare_discrete_generator_list */


Static boolean prepare_linear_generator_list(q, adj_set, ifail)
t_linear_generator **q;
t_vertex_set *adj_set;
t_integer *ifail;
{
  t_integer m1, m2, min_count;
  boolean ok = true;
  t_vertex v;
  t_vertex_set a;
  t_linear_generator *p;

  p = *q;
  while (ok && p != NULL) {
    p->line_search = boolean_option[77];
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, p->c) & P_inset(v, gamma_)) {
	P_setcpy(a, adj_set[v - MIN_VERTEX]);
	P_setdiff(a, a, p->d);
	P_setint(a, a, delta);
	p->line_search = (p->line_search || !P_setequal(a, empty_set));
      }
    }
    p->line_search = (p->line_search && !boolean_option[76]);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1438L, 1L)) {
      write_pch(stdout, " Linear generator (prepare):  ", 30L);
      print_vertex_set(p->d);
      print_vertex_set(p->c);
      write_char(stdout, '/');
      print_vertex_set(a);
      write_boolean(stdout, p->line_search);
      write_char(stdout, ':');
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (em)
      write_warning_em(stdout, 1438L, " PrepareLinearGeneL.");
    p->n_d_offset = return_offset(p->d, &ok);
    find_min_count(p->d, &p->n_d_offset, &min_count);
    if (min_count < 1)
      *ifail = 36;
    P_setunion(a, p->d, p->c);
    if (ok)
      ok = find_ssd(a, &m1, &m2, &p->n_d_offset, &p->O_s_d_offset, &p->O_s_d);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1438L, 8L))
      write_headed_ssd_s(" O_s_d:@@@@@@@@@@@@@                    ", 7L, a,
			 p->n_d_offset, p->O_s_d_offset, &p->O_s_d, m1, m2,
			 NULL, false, 2L, false);
    /*$endif TRACE*/
    p = p->pointer;
  }
  return ok;
}  /* prepare_linear_generator_list */


Static boolean prepare_linear_and_quadratic_generator_list(q, adj_set, ifail)
t_linear_and_quadratic_generator **q;
t_vertex_set *adj_set;
t_integer *ifail;
{
  t_integer m1, m2, min_count;
  boolean ok = true;
  t_vertex_set a;
  t_linear_and_quadratic_generator *p;

  p = *q;
  while (ok && p != NULL) {
    p->line_search = boolean_option[77];
    P_setcpy(a, adj_set[p->lambda - MIN_VERTEX]);
    P_setdiff(a, a, p->d);
    P_setint(a, a, delta);
    p->line_search = (p->line_search || !P_setequal(a, empty_set));
    p->line_search = (p->line_search && !boolean_option[76]);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1439L, 1L)) {
      write_pch(stdout, " Match generator (prepare):   ", 30L);
      print_vertex_set(p->d);
      print_vertex_set(p->b);
      write_char(stdout, ',');
      write_char(stdout, ' ');
      print_vertex(p->lambda);
      write_char(stdout, '/');
      print_vertex_set(a);
      write_boolean(stdout, p->line_search);
      write_char(stdout, ':');
      write_line(stdout);
    }
    /*$endif TRACE*/
    P_setcpy(a, empty_set);
    P_addset(a, p->lambda);
    P_setcpy(p->c, a);
    if (em)
      write_warning_em(stdout, 1439L, " PrepareLinQuadGLis.");
    p->n_b_offset = return_offset(p->b, &ok);
    if (ok)
      p->n_d_offset = return_offset(p->d, &ok);
    find_min_count(p->d, &p->n_d_offset, &min_count);
    if (min_count < 1)
      *ifail = 37;
    find_min_count(p->b, &p->n_b_offset, &min_count);
    if (min_count < 1)
      *ifail = 37;
    P_setunion(a, p->d, p->c);
    if (ok)
      ok = find_ssd(a, &m1, &m2, &p->n_d_offset, &p->O_s_d_offset, &p->O_s_d);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1439L, 8L))
      write_headed_ssd_s(" O_s_d:@@@@@@@@@@@@@                    ", 7L, a,
			 p->n_d_offset, p->O_s_d_offset, &p->O_s_d, m1, m2,
			 NULL, false, 2L, false);
    /*$endif TRACE*/
    P_setunion(a, p->b, p->c);
    if (ok)
      ok = find_ssd(a, &m1, &m2, &p->n_b_offset, &p->O_ssd_b_offset,
		    &p->O_ssd_b);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1439L, 8L))
      write_headed_ssd_s(" O_ssd_b:@@@@@@@@@@@                    ", 9L, a,
			 p->n_b_offset, p->O_ssd_b_offset, &p->O_ssd_b, m1,
			 m2, NULL, false, 2L, false);
    /*$endif TRACE*/
    p = p->pointer;
  }
  return ok;
}  /* prepare_linear_and_quadratic_generator_list */


Static boolean prepare_single_quadratic_generator_list(q, adj_set, ifail)
t_single_quadratic_generator **q;
t_vertex_set *adj_set;
t_integer *ifail;
{
  t_integer m1, m2, min_count;
  boolean ok = true;
  t_vertex_set a;
  t_single_quadratic_generator *p;

  p = *q;
  while (ok && p != NULL) {
    p->line_search = boolean_option[77];
    P_setcpy(a, adj_set[p->lambda - MIN_VERTEX]);
    P_setdiff(a, a, p->d);
    P_setint(a, a, delta);
    p->line_search = (p->line_search || !P_setequal(a, empty_set));
    p->line_search = (p->line_search && !boolean_option[76]);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1440L, 1L)) {
      write_pch(stdout, " Single generator (prepare):  ", 30L);
      print_vertex_set(p->d);
      write_char(stdout, ',');
      write_char(stdout, ' ');
      print_vertex(p->lambda);
      write_char(stdout, '/');
      print_vertex_set(a);
      write_boolean(stdout, p->line_search);
      write_char(stdout, ':');
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (em)
      write_warning_em(stdout, 1440L, " PrepareSinQuadGLis.");
    p->n_d_offset = return_offset(p->d, &ok);
    find_min_count(p->d, &p->n_d_offset, &min_count);
    if (min_count < 1)
      *ifail = 38;
    P_setcpy(a, empty_set);
    P_addset(a, p->lambda);
    P_setunion(a, a, p->d);
    /* if ok then
         ok := find_ssd(a, m1, m2, p^.n_d_offset, p^.O_s_d_offset, p^.O_s_d); */
    if (ok)
      ok = find_ssd(a, &m1, &m2, &p->n_d_offset, &p->O_ssd_d_offset,
		    &p->O_ssd_d);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1440L, 8L))
      write_headed_ssd_s(" O_ssd_d:@@@@@@@@@@@                    ", 9L, a,
			 p->n_d_offset, p->O_ssd_d_offset, &p->O_ssd_d, m1,
			 m2, NULL, false, 2L, false);
    /*$endif TRACE*/
    p = p->pointer;
  }
  return ok;
}  /* prepare_single_quadratic_generator_list */


Static boolean prepare_quadratic_pair_generator_list(q, adj_set, ifail)
t_quadratic_pair_generator **q;
t_vertex_set *adj_set;
t_integer *ifail;
{
  t_integer m1, m2, min_count;
  t_vertex_set a;
  boolean ok = true;
  t_quadratic_pair_generator *p;

  p = *q;
  while (ok && p != NULL) {
    /*$ifdef TRACE*/
    p->line_search = boolean_option[77];
    P_setcpy(a, adj_set[p->lambda - MIN_VERTEX]);
    P_setdiff(a, a, p->d);
    P_setint(a, a, delta);
    p->line_search = (p->line_search || !P_setequal(a, empty_set));
    P_setcpy(a, adj_set[p->my - MIN_VERTEX]);
    P_setdiff(a, a, p->d);
    P_setint(a, a, delta);
    p->line_search = (p->line_search || !P_setequal(a, empty_set));
    p->line_search = (p->line_search && !boolean_option[76]);
    P_setcpy(a, adj_set[p->lambda - MIN_VERTEX]);
    P_setunion(a, a, adj_set[p->my - MIN_VERTEX]);
    P_setdiff(a, a, p->d);
    P_setint(a, a, delta);
    if (trace_flag_set(20L, 1441L, 1L)) {
      write_pch(stdout, " Pair generator (prepare):    ", 30L);
      print_vertex_set(p->d);
      write_char(stdout, ',');
      write_char(stdout, ' ');
      print_vertex(p->lambda);
      write_char(stdout, ',');
      write_char(stdout, ' ');
      print_vertex(p->my);
      write_char(stdout, '/');
      print_vertex_set(a);
      write_boolean(stdout, p->line_search);
      write_char(stdout, ':');
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (em)
      write_warning_em(stdout, 1441L, " PreparePairQuadGLi.");
    p->n_d_offset = return_offset(p->d, &ok);
    find_min_count(p->d, &p->n_d_offset, &min_count);
    if (min_count < 1)
      *ifail = 39;
    P_setcpy(a, empty_set);
    P_addset(a, p->lambda);
    P_addset(a, p->my);
    P_setunion(a, a, p->d);
    /* if ok then
         ok := find_ssd(a, m1, m2, p^.n_d_offset, p^.O_s_d_offset, p^.O_s_d); */
    if (ok)
      ok = find_ssd(a, &m1, &m2, &p->n_d_offset, &p->O_ssd_d_offset,
		    &p->O_ssd_d);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1441L, 8L))
      write_headed_ssd_s(" O_ssd_d:@@@@@@@@@@@                    ", 9L, a,
			 p->n_d_offset, p->O_ssd_d_offset, &p->O_ssd_d, m1,
			 m2, NULL, false, 2L, false);
    /*$endif TRACE*/
    p = p->pointer;
  }
  return ok;
}  /* prepare_quadratic_pair_generator_list */


Static Void insert_item_in_discrete(d, item_list)
long *d;
t_discrete_generator **item_list;
{
  t_discrete_generator *p;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1442L, 1L)) {
    write_pch(stdout, " Discrete generator (insert): ", 30L);
    print_vertex_set(d);
    write_line(stdout);
  }
  /*$endif TRACE*/
  p = (t_discrete_generator *)Malloc(sizeof(t_discrete_generator));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->d, d);
  p->pointer = *item_list;
  *item_list = p;
}  /* insert_item_in_discrete */


Static Void insert_item_in_linear(a, item_list)
long *a;
t_linear_generator **item_list;
{
  t_linear_generator *p;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1443L, 1L)) {
    write_pch(stdout, " Linear generator (insert):   ", 30L);
    print_vertex_set(a);
    write_line(stdout);
  }
  /*$endif TRACE*/
  p = (t_linear_generator *)Malloc(sizeof(t_linear_generator));
  if (p == NULL)
    _OutMem();
  P_setint(p->d, a, delta);
  P_setint(p->c, a, gamma_);
  p->pointer = *item_list;
  *item_list = p;
}  /* insert_item_in_linear */


Static Void insert_item_in_single_quadratic(d, item_list)
long *d;
t_single_quadratic_generator **item_list;
{
  t_single_quadratic_generator *p;
  t_vertex v;
  t_vertex_set g;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1444L, 1L)) {
    write_pch(stdout, " Single generator (insert):   ", 30L);
    print_vertex_set(d);
    write_line(stdout);
  }
  /*$endif TRACE*/
  v = advance_to_continuous_vertex(d, first_vertex);
  P_setint(g, d, gamma_);
  while (P_inset(v, g)) {
    p = (t_single_quadratic_generator *)
	Malloc(sizeof(t_single_quadratic_generator));
    if (p == NULL)
      _OutMem();
    P_setint(p->d, d, delta);
    p->lambda = v;
    p->pointer = *item_list;
    *item_list = p;
    v = advance_to_continuous_vertex(d, v + 1);
    /*$ifdef TRACE*/
    if (!trace_flag_set(20L, 1444L, 1L))
      continue;
    /*$endif TRACE*/
    write_pch(stdout, " Single generator (..):       ", 30L);
    print_vertex_set(d);
    print_vertex(p->lambda);
    print_vertex(v);
    write_line(stdout);
  }
}  /* insert_item_in_single_quadratic */


Static Void insert_item_in_pair_quadratic(d, item_list)
long *d;
t_quadratic_pair_generator **item_list;
{
  t_quadratic_pair_generator *p;
  t_vertex v, w;
  t_vertex_set g;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1445L, 1L)) {
    write_pch(stdout, " Pair generator (insert):     ", 30L);
    print_vertex_set(d);
    write_line(stdout);
  }
  /*$endif TRACE*/
  v = advance_to_continuous_vertex(d, first_vertex);
  P_setint(g, d, gamma_);
  while (P_inset(v, g)) {
    w = advance_to_continuous_vertex(d, v + 1);
    while (P_inset(w, g)) {
      p = (t_quadratic_pair_generator *)Malloc(sizeof(t_quadratic_pair_generator));
      if (p == NULL)
	_OutMem();
      P_setint(p->d, d, delta);
      p->lambda = v;
      p->my = w;
      p->pointer = *item_list;
      *item_list = p;
      w = advance_to_continuous_vertex(d, w + 1);
      /*$ifdef TRACE*/
      if (!trace_flag_set(20L, 1445L, 1L))
	continue;
      /*$endif TRACE*/
      write_pch(stdout, " Pair generator (..):         ", 30L);
      print_vertex_set(d);
      print_vertex(p->lambda);
      print_vertex(p->my);
      print_vertex(w);
      print_vertex(v);
      write_line(stdout);
    }
    v = advance_to_continuous_vertex(d, v + 1);
  }
}  /* insert_item_in_pair_quadratic */


Static Void insert_item_in_linear_and_quadratic(b, d, item_list)
long *b, *d;
t_linear_and_quadratic_generator **item_list;
{
  t_linear_and_quadratic_generator *p;
  t_vertex v;
  t_vertex_set g;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1446L, 1L)) {
    write_pch(stdout, " Match generator (insert):    ", 30L);
    print_vertex_set(d);
    print_vertex_set(b);
    write_line(stdout);
  }
  /*$endif TRACE*/

  v = advance_to_continuous_vertex(d, first_vertex);
  P_setint(g, d, gamma_);
  while (P_inset(v, g)) {
    p = (t_linear_and_quadratic_generator *)
	Malloc(sizeof(t_linear_and_quadratic_generator));
    if (p == NULL)
      _OutMem();
    P_setint(p->b, b, delta);
    P_setint(p->d, d, delta);
    p->lambda = v;
    p->pointer = *item_list;
    *item_list = p;
    v = advance_to_continuous_vertex(d, v + 1);
    /*$ifdef TRACE*/
    if (!trace_flag_set(20L, 1446L, 1L))
      continue;
    /*$endif TRACE*/
    write_pch(stdout, " Match generator (..):        ", 30L);
    print_vertex_set(p->d);
    print_vertex_set(p->b);
    print_vertex(p->lambda);
    print_vertex(v);
    write_line(stdout);
  }
}  /* insert_item_in_linear_and_quadratic */


Static Void print_vertex_(v)
t_vertex v;
{
  write_char(stdout, '<');
  write_integer(stdout, (long)v, 1L);
  write_char(stdout, '>');
}  /* print_vertex_ */


Static Void print_adj_list_(S_ARRAY, L_ARRAY, first_S_vertex, last_S_vertex,
			    adj_list)
t_vertex_set *S_ARRAY, *L_ARRAY;
t_vertex *first_S_vertex, *last_S_vertex;
t_vertex_list **adj_list;
{
  t_vertex_list *p;
  t_vertex v, FORLIM;

  FORLIM = *last_S_vertex;
  for (v = *first_S_vertex; v <= FORLIM; v++) {
    write_char(stdout, ' ');
    print_vertex_(v);
    print_vertex_set(S_ARRAY[v - MIN_VERTEX]);
    write_char(stdout, ':');
    write_char(stdout, ' ');
    p = adj_list[v - MIN_VERTEX];
    while (p != NULL) {
      print_vertex_(p->vertex);
      print_vertex_set(L_ARRAY[p->vertex - MIN_VERTEX]);
      p = p->pointer;
    }
    write_char(stdout, ';');
    write_line(stdout);
  }
}  /* print_adj_list_ */


Static Void print_edge_list_(p, start, line_length)
t_edge_list *p;
t_integer start, line_length;
{
  t_integer stop = start;

  while (p != NULL) {
    if (stop + 4 > line_length && stop != start) {
      write_line(stdout);
      write_space(stdout, start);
      stop = start;
    }
    write_char(stdout, '[');
    print_vertex_(p->v);
    print_vertex_(p->w);
    write_char(stdout, ']');
    stop += 4;
    p = p->pointer;
  }
}  /* print_edge_list_ */


Static Void find_augmenting_path(adj_list, match, link_edge_list,
				 local_last_vertex)
t_vertex_list **adj_list;
t_vertex *match;
t_edge_list **link_edge_list;
t_vertex *local_last_vertex;
{
  t_v_arr_of_boolean explored;
  t_vertex_list *queue, *q, *p;
  t_vertex u, v, w;
  boolean continue_ = true;
  t_vertex FORLIM;
  long TEMP;

  FORLIM = *local_last_vertex;
  for (v = first_vertex; v <= FORLIM; v++)
    P_clrbits_B(explored, v - MIN_VERTEX, 0, 3);
  u = first_vertex;
  do {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1450L, 1L)) {
      write_char(stdout, ' ');
      write_char(stdout, '$');
      print_vertex_(u);
      write_char(stdout, ';');
    }
    /*$endif TRACE*/
    P_putbits_UB(explored, u - MIN_VERTEX, 1, 0, 3);
    if (match[u - MIN_VERTEX] == NULL_VERTEX) {
      queue = NULL;
      insert_vertex_in_vertex_list(u, &queue);
      while (continue_ && queue != NULL) {
	v = queue->vertex;
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1450L, 1L)) {
	  write_char(stdout, ' ');
	  print_vertex_(v);
	  write_char(stdout, ':');
	}
	/*$endif TRACE*/
	q = queue;
	queue = queue->pointer;
	_Free(q);
	p = adj_list[v - MIN_VERTEX];
	while (continue_ && p != NULL) {
	  w = p->vertex;
	  /*$ifdef TRACE*/
	  if (trace_flag_set(20L, 1450L, 1L))
	    print_vertex_(w);
	  /*$endif TRACE*/
	  if (!P_getbits_UB(explored, w - MIN_VERTEX, 0, 3)) {
	    insert_edge_in_edge_list(v, w, link_edge_list);
	    if (match[w - MIN_VERTEX] == NULL_VERTEX)
	      continue_ = false;
	    else {
	      insert_edge_in_edge_list(w, match[w - MIN_VERTEX],
				       link_edge_list);
	      insert_vertex_in_vertex_list(match[w - MIN_VERTEX], &queue);
	      P_putbits_UB(explored, w - MIN_VERTEX, 1, 0, 3);
	      TEMP = match[w - MIN_VERTEX] - MIN_VERTEX;
	      P_putbits_UB(explored, TEMP, 1, 0, 3);
	    }
	  }
	  p = p->pointer;
	}
      }
      if (queue != NULL)   /* ?!?!? */
	dispose_vertex_list(&queue);
    }
    while (P_getbits_UB(explored, u - MIN_VERTEX, 0, 3) &&
	   u < *local_last_vertex)
      u++;
  } while (!P_getbits_UB(explored, u - MIN_VERTEX, 0, 3));
  if (continue_)
    dispose_edge_list(link_edge_list);
}  /* find_augmenting_path */


Static Void update_matching(match, link_edge_list, continue_)
t_vertex *match;
t_edge_list **link_edge_list;
boolean *continue_;
{
  /* var adj_list : t_v_arr_of_v_lists; */
  t_edge_list *p;
  t_vertex v, w, u;

  *continue_ = (*link_edge_list != NULL);
  p = *link_edge_list;
  while (p != NULL) {
    v = p->v;
    w = p->w;
    match[v - MIN_VERTEX] = w;
    match[w - MIN_VERTEX] = v;
    u = NULL_VERTEX;
    while (u != v && p != NULL) {
      u = p->w;
      if (u != v)
	p = p->pointer;
    }
    if (p == NULL)
      break;
    v = p->v;
    u = NULL_VERTEX;
    while (u != v && p != NULL) {
      u = p->w;
      if (u != v)
	p = p->pointer;
    }
  }
  dispose_edge_list(link_edge_list);
}


Static Void find_matching(adj_list, match, local_last_vertex)
t_vertex_list **adj_list;
t_vertex *match;
t_vertex *local_last_vertex;
{
  t_edge_list *edge_list = NULL;
  t_vertex v;
  boolean continue_;
  t_vertex FORLIM;

  FORLIM = *local_last_vertex;
  for (v = first_vertex; v <= FORLIM; v++)
    match[v - MIN_VERTEX] = NULL_VERTEX;
  do {
    find_augmenting_path(adj_list, match, &edge_list, local_last_vertex);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1452L, 1L)) {   /* adj_list, */
      print_edge_list_(edge_list, 0L, 128L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    update_matching(match, &edge_list, &continue_);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1452L, 8L)) {
      write_char(stdout, ' ');
      write_char(stdout, '~');
      FORLIM = *local_last_vertex;
      for (v = first_vertex; v <= FORLIM; v++)
	print_vertex_(match[v - MIN_VERTEX]);
      write_line(stdout);
    }
    /*$endif TRACE*/
  } while (continue_);
}


Static Void dispose_adj_list_(adj_list)
t_vertex_list **adj_list;
{
  t_vertex_list *p, *q;
  t_vertex v;

  for (v = first_vertex; v <= MAX_VERTEX; v++) {   /* last_vertex */
    p = adj_list[v - MIN_VERTEX];
    while (p != NULL) {
      q = p->pointer;
      _Free(p);
      p = q;
    }
    adj_list[v - MIN_VERTEX] = NULL;
  }
}  /* dispose_adj_list_ */


Local Void insert_edge_in_adj_list_fast_(adj_list, v1, v2)
t_vertex_list **adj_list;
t_vertex v1, v2;
{
  insert_vertex_in_vertex_list(v1, &adj_list[v2 - MIN_VERTEX]);
  insert_vertex_in_vertex_list(v2, &adj_list[v1 - MIN_VERTEX]);
}  /* insert_edge_in_adj_list_fast */


Static Void adj_set_to_adj_list_(adj_set, adj_list, local_last_vertex)
t_vertex_set *adj_set;
t_vertex_list **adj_list;
t_vertex *local_last_vertex;
{
  t_vertex v1, v2, FORLIM, FORLIM1;

  for (v1 = first_vertex; v1 <= MAX_VERTEX; v1++)   /* local_last_vertex */
    adj_list[v1 - MIN_VERTEX] = NULL;
  FORLIM = *local_last_vertex;
  for (v1 = first_vertex; v1 <= FORLIM - 1; v1++) {
    FORLIM1 = *local_last_vertex;
    for (v2 = v1 + 1; v2 <= FORLIM1; v2++) {
      if (P_inset(v2, adj_set[v1 - MIN_VERTEX]))
	insert_edge_in_adj_list_fast_(adj_list, v1, v2);
    }
  }
}  /* adj_set_to_adj_list_ */


Static Void make_matching_adj_list(S_ARRAY, L_ARRAY, first_S_vertex,
  last_S_vertex, first_L_vertex, last_L_vertex, adj_list)
t_vertex_set *S_ARRAY, *L_ARRAY;
t_vertex *first_S_vertex, *last_S_vertex, *first_L_vertex, *last_L_vertex;
t_vertex_list **adj_list;
{
  t_vertex v, w;
  t_v_arr_of_v_sets adj_set;
  t_vertex FORLIM, FORLIM1;

  FORLIM = *last_L_vertex;
  for (v = *first_S_vertex; v <= FORLIM; v++)
    P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  FORLIM = *last_S_vertex;
  for (v = *first_S_vertex; v <= FORLIM; v++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1456L, 1L)) {
      write_char(stdout, ' ');
      print_vertex_(v);
      print_vertex_set(S_ARRAY[v - MIN_VERTEX]);
      write_char(stdout, ':');
      write_char(stdout, ' ');
    }
    FORLIM1 = *last_L_vertex;
    /*$endif TRACE*/
    for (w = *first_L_vertex; w <= FORLIM1; w++) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1456L, 1L)) {
	print_vertex_(w);
	print_vertex_set(L_ARRAY[w - MIN_VERTEX]);
      }
      /*$endif TRACE*/
      if (P_subset(S_ARRAY[v - MIN_VERTEX], L_ARRAY[w - MIN_VERTEX])) {
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1456L, 1L))
	  write_char(stdout, '*');
	/*$endif TRACE*/
	P_addset(adj_set[v - MIN_VERTEX], w);
	P_addset(adj_set[w - MIN_VERTEX], v);
      }
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1456L, 1L))
      write_line(stdout);
    /*$endif TRACE*/
  }
  /*$ifdef TRACE*/
  adj_set_to_adj_list_(adj_set, adj_list, last_L_vertex);
  if (trace_flag_set(20L, 1456L, 1L)) {
    print_adj_list_(S_ARRAY, L_ARRAY, first_S_vertex, last_S_vertex, adj_list);
    print_adj_list_(L_ARRAY, S_ARRAY, first_L_vertex, last_L_vertex, adj_list);
  }
  /*$endif TRACE*/
}  /* make_matching_adj_list */


Static Void set_list_to_array(p, set_array, first_S_vertex, last_S_vertex,
			      max_S_vertex, max_count, new_p, ok)
t_set_list **p;
t_vertex_set *set_array;
t_vertex *first_S_vertex, *last_S_vertex, max_S_vertex;
t_long_integer max_count;
t_set_list **new_p;
boolean *ok;
{
  t_vertex v, X;
  t_vertex_set a, b;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1457L, 1L)) {
    write_pch(stdout, " Set array: ", 12L);
    write_integer(stdout, max_count, 1L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  X = *first_S_vertex;
  *last_S_vertex = NULL_VERTEX;
  *ok = true;
  while (*ok && *p != NULL) {
    if ((max_count == -1) | (count_continuous((*p)->vertex_set) <= max_count)) {
      v = first_vertex;
      while (v <= last_vertex && *ok) {
	if (P_inset(v, gamma_)) {
	  if (P_inset(v, (*p)->vertex_set)) {
	    P_setint(a, (*p)->vertex_set, delta);
	    P_addset(P_expset(b, 0L), v);   /* empty_set + */
	    P_setunion(set_array[X - MIN_VERTEX], a, b);
	    /*$ifdef TRACE*/
	    if (trace_flag_set(20L, 1457L, 1L)) {
	      write_pch(stdout, " Set array: ", 12L);
	      print_vertex_(X);
	      print_vertex_set(set_array[X - MIN_VERTEX]);
	      write_line(stdout);
	    }
	    /*$endif TRACE*/
	    if (X < max_S_vertex)
	      X++;
	    else
	      *ok = false;
	  }
	}
	v++;
      }
    } else
      insert_clique((*p)->vertex_set, new_p);
    if (!*ok)
      break;
    *last_S_vertex = X - 1;
    *p = (*p)->pointer;
  }
}


Static Void insert_set_in_discrete_collected_list(a, set_list)
long *a;
t_set_list **set_list;
{
  t_set_list *p;
  t_vertex_set x, y;
  boolean continue_ = true;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1458L, 1L)) {
    write_pch(stdout, " Insert Discrete:             ", 30L);
    print_vertex_set(a);
    write_line(stdout);
  }
  /*$endif TRACE*/
  P_setint(x, a, delta);
  p = *set_list;
  while (continue_ && p != NULL) {
    P_setint(y, p->vertex_set, delta);
    if (P_setequal(x, y))
      continue_ = false;
    else
      p = p->pointer;
  }
  if (!continue_) {
    P_setunion(p->vertex_set, p->vertex_set, a);
    return;
  }
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, a);
  p->pointer = *set_list;
  *set_list = p;
}  /* insert_set_in_discrete_collected_list */


Static Void collect_identical_discrete_sets(set_list)
t_set_list **set_list;
{
  t_set_list *p, *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " CollectIdentical.. ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 1459L, 1L, -1L, -1L, set_list);
  /*$endif TRACE*/
  p = *set_list;
  q = p;
  *set_list = NULL;
  while (p != NULL) {
    insert_set_in_discrete_collected_list(p->vertex_set, set_list);
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 1459L, 8L, -1L, 999L, set_list);
  /*$endif TRACE*/
  dispose_set_list(&q);
}  /* collect_identical_discrete_sets */


Static Void split_continuous(a, set_list)
long *a;
t_set_list **set_list;
{
  t_vertex v;
  t_vertex_set b, c, d;

  P_setint(c, a, gamma_);
  P_setint(d, a, delta);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, c)) {
      P_setcpy(b, d);
      P_addset(b, v);
      insert_clique(b, set_list);
    }
  }
}


Static Void sub_match_linear_and_quadratic(l, s, lq, max_count, again)
t_set_list **l, **s;
t_linear_and_quadratic_generator **lq;
t_long_integer max_count;
boolean *again;
{
  t_vertex first_S_vertex, last_S_vertex, first_L_vertex, last_L_vertex, v;
  t_set_list *p_s, *p_l;
  t_set_list *new_s = NULL, *new_l = NULL;
  t_v_arr_of_v_sets S_ARRAY, L_ARRAY;
  t_v_arr_of_v_lists adj_list;
  t_v_arr_of_vertex match;
  boolean ok = true;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1461L, 1L))
    write_line(stdout);
  /*$endif TRACE*/
  p_s = *s;
  first_S_vertex = first_vertex;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1461L, 1L)) {
    write_pch(stdout, " Single generators: ", 20L);
    print_g_c(p_s, 0L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  set_list_to_array(&p_s, S_ARRAY, &first_S_vertex, &last_S_vertex,
		    MAX_HALF_VERTEX, -1L, &new_s, &ok);
  *again = !ok;
  p_l = *l;
  if (last_S_vertex == NULL_VERTEX)
    first_L_vertex = first_vertex;
  else
    first_L_vertex = last_S_vertex + 1;
  ok = true;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1461L, 1L)) {
    write_pch(stdout, " Linear generators: ", 20L);
    print_g_c(p_l, 0L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  set_list_to_array(&p_l, L_ARRAY, &first_L_vertex, &last_L_vertex,
		    MAX_VERTEX, max_count, &new_l, &ok);
  *again = (*again || !ok);
  if (last_S_vertex != NULL_VERTEX && last_L_vertex != NULL_VERTEX) {
    make_matching_adj_list(S_ARRAY, L_ARRAY, &first_S_vertex, &last_S_vertex,
			   &first_L_vertex, &last_L_vertex, adj_list);
    find_matching(adj_list, match, &last_L_vertex);
    dispose_adj_list_(adj_list);
  }
  if (last_S_vertex != NULL_VERTEX) {
    for (v = first_S_vertex; v <= last_S_vertex; v++) {
      if (match[v - MIN_VERTEX] == NULL_VERTEX)
	insert_set_in_discrete_collected_list(S_ARRAY[v - MIN_VERTEX], &new_s);
      else
	insert_item_in_linear_and_quadratic(S_ARRAY[v - MIN_VERTEX],
	  L_ARRAY[match[v - MIN_VERTEX] - MIN_VERTEX], lq);
    }
  }
  while (p_s != NULL) {
    insert_set_in_discrete_collected_list(p_s->vertex_set, &new_s);
    p_s = p_s->pointer;
  }
  dispose_set_list(s);
  *s = new_s;
  if (last_L_vertex != NULL_VERTEX) {
    for (v = first_L_vertex; v <= last_L_vertex; v++) {
      if (match[v - MIN_VERTEX] == NULL_VERTEX)
	insert_set_in_discrete_collected_list(L_ARRAY[v - MIN_VERTEX], &new_l);
    }
  }
  while (p_l != NULL) {
    insert_set_in_discrete_collected_list(p_l->vertex_set, &new_l);
    p_l = p_l->pointer;
  }
  dispose_set_list(l);
  *l = new_l;
}  /* sub_match_linear_and_quadratic */


Static Void tmp_match_linear_and_quadratic(l, s, max_count, length)
t_set_list **l, **s;
t_long_integer max_count;
t_integer *length;
{
  boolean again = true;
  t_set_list *p, *tmp_l, *tmp_s;
  t_linear_and_quadratic_generator *lq = NULL;

  copy_set_list(*l, &tmp_l);
  copy_set_list(*s, &tmp_s);
  sub_match_linear_and_quadratic(&tmp_l, &tmp_s, &lq, max_count, &again);
  while (again)
    sub_match_linear_and_quadratic(&tmp_l, &tmp_s, &lq, max_count, &again);
  *length = 0;
  p = tmp_s;
  while (p != NULL) {
    (*length)++;
    p = p->pointer;
  }
  dispose_set_list(&tmp_l);
  dispose_set_list(&tmp_s);
  dispose_linear_and_quadratic_generator_list(&lq);
}


Local t_long_integer g_c_size_(q)
t_set_list *q;
{
  t_integer tmp_size = 0;

  while (q != NULL) {
    tmp_size++;
    q = q->pointer;
  }
  return tmp_size;
}  /* g_c_size */


Static Void split_generator_lists(mixed_item, ok_d_collapsible,
				  ok_mean_linear, full_specified)
t_mips_element *mixed_item;
boolean *ok_d_collapsible, *ok_mean_linear, *full_specified;
{
  boolean again;
  t_set_list *p;
  t_set_list *d = NULL, *l = NULL, *sq = NULL, *pq = NULL;
  t_set_list *mg;
  t_linear_and_quadratic_generator *lq;
  t_vertex_set a;
  t_long_integer count, length, tmp_length;

  p = mixed_item->quadratic;
  while (p != NULL) {
    count = count_continuous(p->vertex_set);
    if (count > 1)
      insert_clique(p->vertex_set, &pq);
    if (!*full_specified || count == 1)
      split_continuous(p->vertex_set, &sq);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1463L, 1L)) {
      write_pch(stdout, " Split quadratic (prepare):   ", 30L);
      print_vertex_set(p->vertex_set);
      write_char(stdout, ':');
      write_line(stdout);
      write_pch(stdout, " Single generators (.): ", 24L);
      print_g_c(sq, 0L, line_length);
      write_line(stdout);
      write_pch(stdout, " Pair generators (.):   ", 24L);
      print_g_c(pq, 0L, line_length);
      write_line(stdout);
    }
    /*$endif TRACE*/
    p = p->pointer;
  }
  collect_identical_discrete_sets(&sq);
  p = mixed_item->linear;
  while (p != NULL) {
    /* if not subset_of_an_edge(p^.vertex_set, mixed_item.quadratic) then */
    insert_clique(p->vertex_set, &l);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1463L, 1L)) {
      write_pch(stdout, " Split linear (prepare):      ", 30L);
      print_vertex_set(p->vertex_set);
      write_char(stdout, ':');
      write_line(stdout);
      write_pch(stdout, " Linear generators (.): ", 24L);
      print_g_c(l, 0L, line_length);
      write_line(stdout);
    }
    /*$endif TRACE*/
    p = p->pointer;
  }
  collect_identical_discrete_sets(&l);
  p = mixed_item->discrete_;
  while (p != NULL) {
    if (((!subset_of_an_edge(p->vertex_set, &mixed_item->quadratic)) &
	 (!subset_of_an_edge(p->vertex_set, &mixed_item->linear))) ||
	*ok_d_collapsible)
      insert_clique(p->vertex_set, &d);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1463L, 1L)) {
      write_pch(stdout, " Split discrete (prepare):    ", 30L);
      print_vertex_set(p->vertex_set);
      write_char(stdout, ':');
      write_line(stdout);
      write_pch(stdout, " Discrete generator (.):", 24L);
      print_g_c(d, 0L, line_length);
      write_line(stdout);
    }
    /*$endif TRACE*/
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1463L, 1L)) {
    write_pch(stdout, " Discrete generator (2):", 24L);
    print_g_c(d, 0L, line_length);
    write_line(stdout);
    write_pch(stdout, " Linear generators (2): ", 24L);
    print_g_c(l, 0L, line_length);
    write_line(stdout);
    write_pch(stdout, " Single generators (2): ", 24L);
    print_g_c(sq, 0L, line_length);
    write_line(stdout);
    write_pch(stdout, " Pair generators (2):   ", 24L);
    print_g_c(pq, 0L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  mixed_item->generators->linear_and_quadratic_generators = NULL;

  /* if not boolean_option[91] and (not ok_d_collapsible or not ok_mean_linear) */
  /* if not boolean_option[91] and not (ok_d_collapsible and ok_mean_linear) */
  if (!boolean_option[78] ||
      !boolean_option[79] && (!*ok_d_collapsible || !*ok_mean_linear)) {
    tmp_match_linear_and_quadratic(&l, &sq, -1L, &length);
    count = 0;
    do {
      count++;
      tmp_match_linear_and_quadratic(&l, &sq, count, &tmp_length);
    } while (length != tmp_length);
    again = true;
    sub_match_linear_and_quadratic(&l, &sq,
      &mixed_item->generators->linear_and_quadratic_generators, count,
      &again);
    while (again)
      sub_match_linear_and_quadratic(&l, &sq,
	&mixed_item->generators->linear_and_quadratic_generators, count,
	&again);
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1463L, 8L)) {   /* true or */
    write_pch(stdout, " Discrete generator (3):", 24L);
    print_g_c(d, 0L, line_length);
    write_line(stdout);
    write_pch(stdout, " Linear generators (3): ", 24L);
    print_g_c(l, 0L, line_length);
    write_line(stdout);
    write_pch(stdout, " Single generators (3): ", 24L);
    print_g_c(sq, 0L, line_length);
    write_line(stdout);
    write_pch(stdout, " Pair generators (3):   ", 24L);
    print_g_c(pq, 0L, line_length);
    write_line(stdout);
    lq = mixed_item->generators->linear_and_quadratic_generators;
    mg = NULL;
    write_pch(stdout, " Match generators (3):  ", 24L);
    while (lq != NULL) {
      /* a := lq^.b + lq^.c; */
      P_setcpy(a, lq->d);
      P_addset(a, lq->lambda);
      insert_clique(a, &mg);
      lq = lq->pointer;
    }
    print_g_c(mg, 0L, line_length);
    dispose_set_list(&mg);
    write_line(stdout);
  }
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1463L, 0L)) {
    write_pch_30_text(report_file, " :: MIPS -  #  Model: @@@@@@@ ", 23L);
    print_set_list_on_report(report_file, mixed_item->discrete_);
    write_pch_10_text(report_file, " / ", 3L);
    print_set_list_on_report(report_file, mixed_item->linear);
    write_pch_10_text(report_file, " / ", 3L);
    print_set_list_on_report(report_file, mixed_item->quadratic);
    write_line_text(report_file);
    write_pch_40_text(report_file, " :: MIPS -  #  Discrete generator:  ",
		      36L);
    write_integer_text(report_file, g_c_size_(d), 3L);
    write_pch_10_text(report_file, ", ", 2L);
    print_set_list_on_report(report_file, d);
    write_line_text(report_file);
    write_pch_40_text(report_file, " :: MIPS -  #  Linear generators:   ",
		      36L);
    write_integer_text(report_file, g_c_size_(l), 3L);
    write_pch_10_text(report_file, ", ", 2L);
    print_set_list_on_report(report_file, l);
    write_line_text(report_file);
    write_pch_40_text(report_file, " :: MIPS -  #  Single generators:   ",
		      36L);
    write_integer_text(report_file, g_c_size_(sq), 3L);
    write_pch_10_text(report_file, ", ", 2L);
    print_set_list_on_report(report_file, sq);
    write_line_text(report_file);
    write_pch_40_text(report_file, " :: MIPS -  #  Pair generators:     ",
		      36L);
    write_integer_text(report_file, g_c_size_(pq), 3L);
    write_pch_10_text(report_file, ", ", 2L);
    print_set_list_on_report(report_file, pq);
    write_line_text(report_file);
    lq = mixed_item->generators->linear_and_quadratic_generators;
    mg = NULL;
    while (lq != NULL) {
      /* a := lq^.b + lq^.c; */
      P_setcpy(a, lq->d);
      P_addset(a, lq->lambda);
      insert_clique(a, &mg);
      lq = lq->pointer;
    }
    write_pch_40_text(report_file, " :: MIPS -  #  Match generators:   @@@@ ",
		      36L);
    write_integer_text(report_file, g_c_size_(mg), 3L);
    write_pch_10_text(report_file, ", ", 2L);
    lq = mixed_item->generators->linear_and_quadratic_generators;
    while (lq != NULL) {
      print_vertex_on_report(report_file, lq->lambda, 0L);
      write_char_text(report_file, '|');
      print_vertex_set_x_on_report(report_file, lq->b);
      write_char_text(report_file, '|');
      print_vertex_set_x_on_report(report_file, lq->c);
      write_char_text(report_file, '|');
      print_vertex_set_x_on_report(report_file, lq->d);
      lq = lq->pointer;
      if (lq == NULL)
	write_char_text(report_file, '.');
      else
	write_char_text(report_file, '/');
    }
    /* print_set_list_on_report(report_file, mg); */
    dispose_set_list(&mg);
    write_line_text(report_file);
  }
  /*$endif TRACE*/
  mixed_item->generators->discrete_generators = NULL;
  p = d;
  while (p != NULL) {
    insert_item_in_discrete(p->vertex_set,
			    &mixed_item->generators->discrete_generators);
    p = p->pointer;
  }
  dispose_set_list(&d);
  mixed_item->generators->linear_generators = NULL;
  p = l;
  while (p != NULL) {
    insert_item_in_linear(p->vertex_set,
			  &mixed_item->generators->linear_generators);
    p = p->pointer;
  }
  dispose_set_list(&l);
  mixed_item->generators->single_quadratic_generators = NULL;
  p = sq;
  while (p != NULL) {
    insert_item_in_single_quadratic(p->vertex_set,
      &mixed_item->generators->single_quadratic_generators);
    p = p->pointer;
  }
  dispose_set_list(&sq);
  mixed_item->generators->quadratic_pair_generators = NULL;
  p = pq;
  while (p != NULL) {
    insert_item_in_pair_quadratic(p->vertex_set,
      &mixed_item->generators->quadratic_pair_generators);
    p = p->pointer;
  }
  dispose_set_list(&pq);
}  /* split_generator_lists */


Static boolean prepare_mixed_item_for_mips(mixed_item, ok_d_collapsible,
  ok_mean_linear, full_specified, mips_g_c, model_set, m, m1, m2)
t_mips_element *mixed_item;
boolean *ok_d_collapsible, *ok_mean_linear, *full_specified;
t_set_list **mips_g_c;
long *model_set;
t_integer *m, *m1, *m2;
{
  t_v_arr_of_v_sets adj_set;
  boolean ok;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PrepareMixedItem   ", sizeof(pch20));
  ntr_mixed_item(tzt, 20L, 1465L, 1L, -1L, -1L, mixed_item, mips_g_c);
  /*$endif TRACE*/

  if (mixed_item->complete) {
    P_setint(a, model_set, delta);
    insert_clique(a, &mixed_item->discrete_);
    insert_clique(model_set, &mixed_item->linear);
    insert_clique(model_set, &mixed_item->quadratic);
  }
  *mips_g_c = NULL;
  add_cliques(mixed_item->discrete_, mips_g_c);
  add_cliques(mixed_item->linear, mips_g_c);
  add_cliques(mixed_item->quadratic, mips_g_c);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1465L, 1L)) {
    write_pch(stdout, " Generators:        ", 20L);
    print_g_c(*mips_g_c, 0L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  split_generator_lists(mixed_item, ok_d_collapsible, ok_mean_linear,
			full_specified);
  hypergraph_sets_to_graph_sets(*mips_g_c, model_set, adj_set);
  P_setint(a, model_set, delta);
  *m = marginal_dimension(a);
  if (em)
    write_warning_em(stdout, 1465L, " PrepareMixedItem   ");
  mixed_item->n_offset = return_offset(a, &ok);

  ok = find_ss(model_set, m1, m2, &mixed_item->n_offset,
	       &mixed_item->ss_offset, &mixed_item->ss);
  if (!ok && mixed_item->ifail == 0)
    mixed_item->ifail = 24;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1465L, 2L))
    write_headed_ssd_ss(" SS:@@@@@@@@@@@@@@@@                    ", 4L,
			model_set, mixed_item->n_offset,
			mixed_item->ss_offset, &mixed_item->ss, *m1, *m2,
			NULL, false, 1L, false);
  /*$endif TRACE*/

  if (ok)
    ok = return_t_space(*m * *m2, &mixed_item->r, &mixed_item->r_offset);
  if (!ok && mixed_item->ifail == 0)
    mixed_item->ifail = 25;

  if (ok)
    ok = prepare_discrete_generator_list(&mixed_item->generators->
					  discrete_generators);
  if (!ok && mixed_item->ifail == 0)
    mixed_item->ifail = 31;

  if (ok)
    ok = prepare_linear_generator_list(&mixed_item->generators->linear_generators,
				       adj_set, &mixed_item->ifail);
  if (!ok && mixed_item->ifail == 0)
    mixed_item->ifail = 32;

  if (ok)
    ok = prepare_linear_and_quadratic_generator_list(
	&mixed_item->generators->linear_and_quadratic_generators, adj_set,
	&mixed_item->ifail);
  if (!ok && mixed_item->ifail == 0)
    mixed_item->ifail = 33;

  if (ok)
    ok = prepare_single_quadratic_generator_list(
	&mixed_item->generators->single_quadratic_generators, adj_set,
	&mixed_item->ifail);
  if (!ok && mixed_item->ifail == 0)
    mixed_item->ifail = 34;

  if (ok)
    ok = prepare_quadratic_pair_generator_list(
	&mixed_item->generators->quadratic_pair_generators, adj_set,
	&mixed_item->ifail);
  if (!ok && mixed_item->ifail == 0)
    mixed_item->ifail = 35;
  return ok;
}  /* prepare_mixed_item_for_mips */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/*@+"mips.p"*/


/*

1468:    +++  ++
1469:    +++  ++
1470:    ---  -- p/mips.p          5      19     260 p/mips.p
1471: |    4:    procedure mips_iterate
1472: |  115:    procedure mips_first
1473: |  211:    procedure init_mips
1474: |  244:    procedure set_min_max_log_l_of_mixed_item
1475: |  249:    procedure mips
1476:    +++  ++
1477:    +++  ++

*/

Static Void mips_iterate(mixed_item, mips_g_c, model_set, copy_2,
			 copy_2_offset, workspace, workspace_offset, a, m, m1,
			 m2, n_total, mips_epsilon, max_cycle_number,
			 max_suff, update_discrete, update_linear, ok)
t_mips_element **mixed_item;
t_set_list **mips_g_c;
long *model_set;
t_t_r **copy_2;
t_t_offset *copy_2_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
long *a;
t_integer *m, *m1, *m2;
t_cell_count *n_total;
t_long_real *mips_epsilon;
t_integer *max_cycle_number;
t_long_real *max_suff;
boolean *update_discrete, *update_linear, *ok;
{
  /* var copy_1: t_t;
   var copy_1_offset: t_t_offset; */
  /* var
     line_search : boolean; */
  /* line_search := not boolean_option[76]; */
  *max_suff = 0.0;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1471L, 1L)) {
    write_pch(stdout, " Iterate Discrete generators: ", 30L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if ((*mixed_item)->generators->discrete_generators != NULL &&
      *update_discrete) {
    /* update_discrete, update_linear, */
    iterate_discrete_generators(mixed_item, mips_g_c, model_set, copy_2,
      copy_2_offset, workspace, workspace_offset, a, m, m1, m2, n_total,
      mips_epsilon, max_cycle_number, max_suff, ok, &boolean_option[95]);
  }

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1471L, 1L)) {
    write_pch(stdout, " Iterate Linear generators:   ", 30L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if ((*mixed_item)->generators->linear_generators != NULL && *update_linear)
	/* line_search, */
	  iterate_linear_generators(mixed_item, mips_g_c, model_set, copy_2,
	    copy_2_offset, workspace, workspace_offset, a, m, m1, m2, n_total,
	    mips_epsilon, max_cycle_number, max_suff, update_discrete,
	    update_linear, ok, &boolean_option[96]);

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1471L, 1L)) {
    write_pch(stdout, " Iterate Match generators:    ", 30L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if ((*mixed_item)->generators->linear_and_quadratic_generators != NULL &&
      *update_linear)
	/* line_search, */
	  iterate_linear_and_quadratic_generators(mixed_item, mips_g_c,
	    model_set, copy_2, copy_2_offset, workspace, workspace_offset, a,
	    m, m1, m2, n_total, mips_epsilon, max_cycle_number, max_suff,
	    update_discrete, update_linear, ok, &boolean_option[97]);

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1471L, 4L)) {
    write_pch(stdout, " Iterate Match generators:    ", 30L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (boolean_option[105]) {
    if ((*mixed_item)->generators->linear_and_quadratic_generators != NULL &&
	*update_linear)
	  /* line_search, */
	    iterate_linear_and_quadratic_generators(mixed_item, mips_g_c,
	      model_set, copy_2, copy_2_offset, workspace, workspace_offset,
	      a, m, m1, m2, n_total, mips_epsilon, max_cycle_number, max_suff,
	      update_discrete, update_linear, ok, &boolean_option[97]);
  }

  /* If Q-equivalent then update covariance matrices ?!?! */

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1471L, 1L)) {
    write_pch(stdout, " Iterate Single generators:   ", 30L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if ((*mixed_item)->generators->single_quadratic_generators != NULL) {
    /* line_search, */
    iterate_single_quadratic_generators(mixed_item, mips_g_c, model_set,
      copy_2, copy_2_offset, workspace, workspace_offset, a, m, m1, m2,
      n_total, mips_epsilon, max_cycle_number, max_suff, update_discrete,
      update_linear, ok);
  }

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1471L, 1L)) {
    write_pch(stdout, " Iterate Pair generators:     ", 30L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if ((*mixed_item)->generators->quadratic_pair_generators != NULL)
    iterate_quadratic_pair_generators(mixed_item, mips_g_c, model_set, copy_2,
      copy_2_offset, workspace, workspace_offset, a, m, m1, m2, n_total,
      mips_epsilon, max_cycle_number, max_suff, update_discrete,
      update_linear, ok);
  /* line_search, */

}  /* mips_iterate */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

Static Void mips_first(mixed_item, mips_g_c, model_set, copy_2, copy_2_offset,
		       workspace, workspace_offset, a, m, m1, m2, n_total,
		       mips_epsilon, max_cycle_number, max_suff,
		       ok_d_collapsible, ok_mean_linear, update_discrete,
		       update_linear, ok)
t_mips_element **mixed_item;
t_set_list **mips_g_c;
long *model_set;
t_t_r **copy_2;
t_t_offset *copy_2_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
long *a;
t_integer *m, *m1, *m2;
t_cell_count *n_total;
t_long_real *mips_epsilon;
t_integer *max_cycle_number;
t_long_real *max_suff;
boolean *ok_d_collapsible, *ok_mean_linear, *update_discrete, *update_linear,
	*ok;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " MipsFirst          ", sizeof(pch20));
  ntr_mixed_item(tzt, 20L, 1472L, 1L, -1L, -1L, *mixed_item, mips_g_c);
  /*$endif TRACE*/

  *max_suff = 0.0;

  if ((*mixed_item)->generators->discrete_generators != NULL &&
      *ok_d_collapsible) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1472L, 1L)) {
      write_pch(stdout, " First - Discrete generators: ", 30L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    /* The efficient IPS algorithm ?!?!? */
    /* update_discrete, update_linear, */
    iterate_discrete_generators(mixed_item, mips_g_c, model_set, copy_2,
      copy_2_offset, workspace, workspace_offset, a, m, m1, m2, n_total,
      mips_epsilon, max_cycle_number, max_suff, ok, ok_d_collapsible);
  }

  if ((*mixed_item)->generators->linear_generators != NULL &&
      *ok_d_collapsible && *ok_mean_linear) {
    /* The sweep algorithm ?!?!? */
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1472L, 1L)) {   /* line_search, */
      write_pch(stdout, " First - Linear generators:   ", 30L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    iterate_linear_generators(mixed_item, mips_g_c, model_set, copy_2,
      copy_2_offset, workspace, workspace_offset, a, m, m1, m2, n_total,
      mips_epsilon, max_cycle_number, max_suff, update_discrete,
      update_linear, ok, ok_mean_linear);
  }

  if (!((*mixed_item)->generators->linear_and_quadratic_generators != NULL &&
	*ok_d_collapsible && *ok_mean_linear))
    return;
  /* Iterate only the linear:
  ``Matching'' FALSE if mean-linear (or q-equivalent)? */
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1472L, 1L)) {   /* line_search, */
    write_pch(stdout, " First - Match generators:    ", 30L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  iterate_linear_and_quadratic_generators(mixed_item, mips_g_c, model_set,
    copy_2, copy_2_offset, workspace, workspace_offset, a, m, m1, m2, n_total,
    mips_epsilon, max_cycle_number, max_suff, update_discrete, update_linear,
    ok, ok_mean_linear);
}  /* mips_first */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

Static Void init_mips(mixed_item, model_set, s_, s__offset, workspace,
		      workspace_offset, m, m1, m2, ok)
t_mips_element **mixed_item;
long *model_set;
t_s_r **s_;
t_s_offset *s__offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m, *m1, *m2;
boolean *ok;
{
  t_e_r_cell_index i;
  /*$ifdef TRACE-ARRAY*/
  pch20 tzt;
  t_e_r_cell_index FORLIM;

  /*$endif TRACE-ARRAY*/
  /*$ifdef TRACE-ARRAY*/
  memcpy(tzt, " InitMips           ", sizeof(pch20));
  /*$endif TRACE-ARRAY*/
  if (!boolean_option[115])   /* , model_set */
    init_mips_estimates(&(*mixed_item)->r, &(*mixed_item)->r_offset, s_,
			s__offset, m, m1, m2);
  else
    *ok = find_ghk_(model_set, true, true, true, m1, m2,
		    &(*mixed_item)->n_offset, &(*mixed_item)->r_offset,
		    &(*mixed_item)->r);
  if (boolean_option[116]) {
    FORLIM = (*mixed_item)->r_offset + *m * *m2;
    for (i = (*mixed_item)->r_offset; i <= FORLIM - 1; i++) {   /* ntr */
      ntr_t_upd(&(*mixed_item)->r, &(*mixed_item)->r_offset, i,
		1 + mips_random_noise * uniform(&seed), 3L, tzt, 20L, 1473L,
		1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      (*mixed_item)->r->z[i] *= 1 + mips_random_noise * uniform(&seed);
    }
    /*$ifdef TRACE-ARRAY*/
  }
  /* model_set, */
  /* n_total, */

  normalise_ps(&(*mixed_item)->r, &(*mixed_item)->r_offset,
	       &(*mixed_item)->n_offset, workspace, *workspace_offset, m, m1,
	       m2, ok);
}  /* init_mips */


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/*Has-forward-1*/

Static Void set_min_max_log_l_of_mixed_item PP((t_mips_element *mixed_item));


/*Has-forward-1*/

Static Void mips(mixed_item, full_specified, homogeneous, model_set, n_total,
		 mips_epsilon, max_cycle_number, ok)
t_mips_element **mixed_item;
boolean *full_specified, *homogeneous;
long *model_set;
t_cell_count *n_total;
t_long_real mips_epsilon;
t_integer *max_cycle_number;
boolean *ok;
{
  /* init       : boolean; */
  t_set_list *mips_g_c = NULL;
  boolean ok_d_collapsible, ok_mean_linear, dummy_ok, update_discrete,
	  update_linear;
  t_vertex_set continuous_;
  t_t_r *workspace = NULL, *copy_1 = NULL, *copy_2 = NULL;
      /* T_T, return_tmp_t_space/alloc_workspace */
  t_t_offset copy_1_offset, copy_2_offset, workspace_offset, tmp_offset;
  t_s_r *s_ = NULL;   /* T_S, find_ssd */
  t_s_offset s__offset;
  t_offset dummy_offset;
  t_integer size, m, m1, m2;
  t_iterate_pack *iterate_pack;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " Mips               ", sizeof(pch20));
  ntr_mixed_item(tzt, 20L, 1475L, 1L, -1L, -1L, *mixed_item, &mips_g_c);
  /*$endif TRACE*/

  (*mixed_item)->generators = (t_mips_generators *)Malloc(sizeof(t_mips_generators));
  if ((*mixed_item)->generators == NULL)
    _OutMem();
  (*mixed_item)->generators->discrete_generators = NULL;
  (*mixed_item)->generators->linear_generators = NULL;
  (*mixed_item)->generators->linear_and_quadratic_generators = NULL;
  (*mixed_item)->generators->single_quadratic_generators = NULL;
  (*mixed_item)->generators->quadratic_pair_generators = NULL;

  iterate_pack = init_iterate_pack(&mips_epsilon, max_cycle_number, true,
				   true, boolean_option[64]);

  /* Loop is cut since sub- and suber-model is decomposable: */

  if (!boolean_option[69]) {
    if (is_invalid_real((*mixed_item)->min_l) &
	is_invalid_real((*mixed_item)->max_l))
      set_min_max_log_l_of_mixed_item(*mixed_item);
  }

  if ((*mixed_item)->mixed_characteristics->d_collapsible &&
      boolean_option[87]) {
    (*mixed_item)->mixed_characteristics->d_collapsible = *homogeneous;
    /* mixed_item^.graphical and */
  }

  ok_d_collapsible = ((*mixed_item)->mixed_characteristics->d_collapsible &&
		      boolean_option[66]);

  ok_mean_linear = ((*mixed_item)->mixed_characteristics->mean_linear &&
		    boolean_option[67]);

  update_discrete = (!ok_d_collapsible || boolean_option[65]);

  /* update_discrete not ok for [[ab]]/[[ay][ax][bx]]/[[ay^][axy][ax^]] !!!! */

  update_linear = (update_discrete || !ok_mean_linear);

  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1475L, 2L, 2L, 1L,
	      (*mixed_item)->mixed_characteristics->d_collapsible);
      /* ntr */
  ntr_boolean(tzt, 20L, 1475L, 2L, 2L, 3L, ok_d_collapsible);
  ntr_boolean(tzt, 20L, 1475L, 2L, 2L, 5L, update_discrete);
  ntr_boolean(tzt, 20L, 1475L, 2L, 2L, 2L,
	      (*mixed_item)->mixed_characteristics->mean_linear);
      /* ntr */
  ntr_boolean(tzt, 20L, 1475L, 2L, 2L, 4L, ok_mean_linear);
  ntr_boolean(tzt, 20L, 1475L, 2L, 2L, 6L, update_linear);
  /*$endif TRACE*/

  if (!(*mixed_item)->mixed_characteristics->degenerated || boolean_option[86]) {
    *ok = prepare_mixed_item_for_mips(*mixed_item, &ok_d_collapsible,
	&ok_mean_linear, full_specified, &mips_g_c, model_set, &m, &m1, &m2);
    if (!*ok && (*mixed_item)->ifail == 0)
      (*mixed_item)->ifail = 21;
  } else {
    *ok = false;
    (*mixed_item)->ifail = 20;
  }
  size = m * (m2 * 4 + 6) + m2 * 3;
  P_setint(continuous_, model_set, gamma_);
  if (*ok)
    *ok = return_tmp_t_space(size, &workspace, &workspace_offset);
  if (!*ok && (*mixed_item)->ifail == 0)
    (*mixed_item)->ifail = 22;
  /* if ok then
       ok := return_tmp_s_space(m2, s_, s__offset); */
  if (*ok)
    *ok = find_ssd(continuous_, &m1, &m2, &dummy_offset, &s__offset, &s_);
  if (!*ok && (*mixed_item)->ifail == 0)
    (*mixed_item)->ifail = 23;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1474L, 1L))   /**/
    write_headed_ssd_s(" SSD(Gamma):@@@@@@@@                    ", 12L,
		       continuous_, dummy_offset, s__offset, &s_, m1, m2,
		       NULL, false, 2L, false);
  /*$endif TRACE*/
  if (*ok && *max_cycle_number > 0) {
    init_mips(mixed_item, model_set, &s_, &s__offset, &workspace,
	      &workspace_offset, &m, &m1, &m2, ok);
    tmp_offset = workspace_offset;
    malloc_workspace(&workspace, &tmp_offset, &copy_1, &copy_1_offset, m * m2);
    malloc_workspace(&workspace, &tmp_offset, &copy_2, &copy_2_offset, m * m2);
    /* ok := true; */
    if (!*ok && (*mixed_item)->ifail == 0)
      (*mixed_item)->ifail = 46;
    if (*ok) {
      /* copy_1, copy_1_offset, */
      mips_first(mixed_item, &mips_g_c, model_set, &copy_2, &copy_2_offset,
		 &workspace, &tmp_offset, model_set, &m, &m1, &m2, n_total,
		 &mips_epsilon, max_cycle_number, &iterate_pack->max_suff,
		 &ok_d_collapsible, &ok_mean_linear, &update_discrete,
		 &update_linear, ok);
    }
    while (do_mips_iteration(mixed_item, &mips_g_c, model_set, " Outer:   ",
			     &copy_1, &copy_1_offset, &workspace, &tmp_offset,
			     &m, &m1, &m2, &iterate_pack) && *ok) {
      /* copy_1, copy_1_offset, */
      mips_iterate(mixed_item, &mips_g_c, model_set, &copy_2, &copy_2_offset,
		   &workspace, &tmp_offset, model_set, &m, &m1, &m2, n_total,
		   &mips_epsilon, max_cycle_number, &iterate_pack->max_suff,
		   &update_discrete, &update_linear, ok);
    }
  } else {
    if ((*mixed_item)->ifail != 20)
      warning_mips(mips_g_c);
    if ((*mixed_item)->ifail == 0)
      (*mixed_item)->ifail = 23;
  }

  /*$ifdef TRACE*/
  if ((*mixed_item)->ifail != 0) {
    memcpy(tzt, " Fail / Mips        ", sizeof(pch20));   /* ntr */
    ntr_mixed_item_short(tzt, 20L, 1472L, 8L, -1L, (*mixed_item)->ifail,
			 *mixed_item, &mips_g_c);
  }
  /*$endif TRACE*/

  dummy_ok = free_tmp_t_space();   /* size, workspace, workspace_offset */
  if (boolean_option[64])
    _Free(iterate_pack->differences);
  dispose_set_list(&mips_g_c);
  dispose_m_ips_generators(&(*mixed_item)->generators);
  /* dummy_ok := free_tmp_s_space(m2, s_, s__offset) */
  _Free(iterate_pack);
}  /* mips */


/*@+"cips.p"*/


/*

1478:    +++  ++
1479:    +++  ++
1480:    ---  -- p/cips.p         18      92    1117 p/cips.p
1481: |    3:    procedure extract_sub_matrix
1482: |   56:    procedure triple_product
1483: |  180:    procedure replace_by_extended_sum
1484: |  236:    procedure update_continuous_generator
1485: |  368:    procedure adjust_hs
1486: |  390:    procedure cips_iterate
1487: |  423:    function sub_find_cips_deviance
1488: |  527:    function find_cips_deviance
1489: |  605:    function find_cips_change
1490: |  637:    procedure clear_sub_matrix
1491: |  682:    function prepare_for_inverted_cips
1492: |  859:    procedure init_cips_estimates
1493: |  901:    procedure init_inverted_cips
1494: |  948:    procedure cips_change_after_update
1495: |  998:    procedure copy_cips_estimates
1496: | 1010:    procedure cips_save_before_update
1497: | 1023:    function do_cips_iteration
1498: | 1145:    procedure inverted_cips
1499:    +++  ++
1500:    +++  ++

*/

Static Void extract_sub_matrix(x, x_offset, g, m1_g, y, y_offset, b, m1_b)
t_t_r **x;
t_t_offset x_offset;
long *g;
t_integer *m1_g;
t_t_r **y;
t_t_offset *y_offset;
long *b;
t_integer *m1_b;
{
  t_integer i_full = 0;
  t_integer j_full;
  t_integer i_sub = 0;
  t_integer j_sub;
  t_continuous_vertex v1, v2;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ExtractSubMatrix   ", sizeof(pch20));
  ntr_continuous_set(tzt, 20L, 1481L, 1L, x_offset, *m1_g, g);
  ntr_continuous_set(tzt, 20L, 1481L, 1L, *y_offset, *m1_b, b);
  /*$endif TRACE*/
  for (v1 = first_continuous_vertex; v1 <= last_continuous_vertex; v1++) {
    if (P_inset(v1, g)) {
      if (P_inset(v1, b)) {
	/* j_full := i_full; */
	/* sm_index !!! */
	/* j_sub := i_sub; */
	/* sm_index !!! */
	j_full = 0;
	j_sub = 0;
	for (v2 = first_continuous_vertex; v2 <= v1; v2++) {
	  /* to last_continuous_vertex */
	  /* sm_index !!! */
	  if (P_inset(v2, g)) {
	    if (P_inset(v2, b)) {
	      /*$ifdef TRACE*/
	      ntr(tzt, 20L, 1481L, 2L, (long)v1, (long)v2);   /*ntr*/
	      /*ntr*/
	      /*ntr*/
	      /*ntr*/
	      ntr_6_real(tzt, 20L, 1481L, 2L, i_full, i_sub, j_full, j_sub,
		sm_index(i_sub, j_sub, *m1_b),
		sm_index(i_full, j_full, *m1_g),
		&(*x)->z[x_offset + sm_index(i_full, j_full, *m1_g)]);
		  /*ntr*/
	      /*$endif TRACE*/
	      (*y)->z[*y_offset + sm_index(i_sub, j_sub, *m1_b)] =
		(*x)->z[x_offset + sm_index(i_full, j_full, *m1_g)];
	      j_sub++;
	    }
	    j_full++;
	  }
	}
	i_sub++;
      }
      i_full++;
    }
  }
}  /* extract_sub_matrix */


Static Void triple_product(x, x_offset, y, y_offset, z, z_offset, g, a, b,
			   m1_g, m1_a, m1_b, workspace, workspace_offset)
t_t_r **x;
t_t_offset x_offset;
t_t_r **y;
t_t_offset *y_offset;
t_t_r **z;
t_t_offset *z_offset;
long *g, *a, *b;
t_integer *m1_g, *m1_a, *m1_b;
t_t_r **workspace;
t_t_offset *workspace_offset;
{
  t_integer i_full = 0, i_sub = 0;
  t_integer j_full, k_sub, l_sub, m_full, n_full, n_sub;
  t_continuous_vertex v_a_i, v_b_jk, v_b_lm, v_a_n;
  t_long_real d;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_continuous_vertex FORLIM1, FORLIM2;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " TripleProduct      ", sizeof(pch20));
  ntr_continuous_set(tzt, 20L, 1482L, 1L, x_offset, *m1_g, g);
  ntr_continuous_set(tzt, 20L, 1482L, 1L, *y_offset, *m1_a, a);
  ntr_continuous_set(tzt, 20L, 1482L, 1L, *z_offset, *m1_b, b);
  if (trace_flag_set(20L, 1482L, 5L)) {
    write_line(stdout);
    /*$endif TRACE*/
  }
  for (v_a_i = first_continuous_vertex; v_a_i <= last_continuous_vertex; v_a_i++) {
    if (P_inset(v_a_i, g)) {
      if (P_inset(v_a_i, a)) {
	/* m_full := 0; */
	l_sub = 0;
	FORLIM1 = last_continuous_vertex;
	for (v_b_lm = first_continuous_vertex; v_b_lm <= FORLIM1; v_b_lm++) {
	  if (P_inset(v_b_lm, g)) {
	    if (P_inset(v_b_lm, b)) {
	      d = 0.0;
	      j_full = 0;
	      k_sub = 0;
	      FORLIM2 = last_continuous_vertex;
	      for (v_b_jk = first_continuous_vertex; v_b_jk <= FORLIM2; v_b_jk++) {
		if (P_inset(v_b_jk, g)) {
		  if (P_inset(v_b_jk, b)) {
		    d += (*x)->z[x_offset + sm_index(i_full, j_full, *m1_g)] *
			 (*y)->z[*y_offset + sm_index(k_sub, l_sub, *m1_b)];
			/* i_sub, */
		    /*$ifdef TRACE*/
		    /*ntr*/
		    /* k_sub, */
		    /*ntr*/
		    /*ntr*/
		    /*ntr*/
		    ntr_6_real(tzt, 20L, 1482L, 2L, -1L, (long)v_a_i, i_full,
		      (long)v_b_jk, j_full, sm_index(i_full, j_full, *m1_g),
		      &(*x)->z[x_offset + sm_index(i_full, j_full, *m1_g)]);
			/*ntr*/
		    /*m_full,*/
		    /*ntr*/
		    /* j_full, */
		    /*ntr*/
		    /*ntr*/
		    /*ntr*/
		    ntr_6_real(tzt, 20L, 1482L, 2L, -2L, (long)v_b_lm, l_sub,
		      (long)v_b_jk, k_sub, sm_index(k_sub, l_sub, *m1_b),
		      &(*y)->z[*y_offset + sm_index(k_sub, l_sub, *m1_b)]);
			/*ntr*/
		    /*ntr*/
		    ntr_real(tzt, 20L, 1482L, 4L,
			     sm_index(i_full, j_full, *m1_g),
			     sm_index(k_sub, l_sub, *m1_b), &d);
			/*ntr*/
		    if (trace_flag_set(20L, 1482L, 5L))
		      write_line(stdout);
		    /*$endif TRACE*/
		    k_sub++;
		  }
		  j_full++;
		}
	      }
	      (*workspace)->z[*workspace_offset + l_sub] = d;
	      l_sub++;
	    }
	    /* m_full := m_full + 1 */
	  }
	}
	n_full = i_full;   /* 0 */
	n_sub = i_sub;   /* 0 */
	for (v_a_n = v_a_i; v_a_n <= last_continuous_vertex; v_a_n++) {
	  /* first_continuous_vertex */
	  if (P_inset(v_a_n, g)) {
	    if (P_inset(v_a_n, a)) {
	      d = 0.0;
	      m_full = 0;
	      l_sub = 0;
	      FORLIM2 = last_continuous_vertex;
	      for (v_b_lm = first_continuous_vertex; v_b_lm <= FORLIM2; v_b_lm++) {
		if (P_inset(v_b_lm, g)) {
		  if (P_inset(v_b_lm, b)) {
		    d += (*workspace)->z[*workspace_offset + l_sub] *
			 (*x)->z[x_offset + sm_index(n_full, m_full, *m1_g)];
			/* i_full, */
		    /*$ifdef TRACE*/
		    /*ntr*/
		    /* n_sub, */
		    /*ntr*/
		    /*ntr*/
		    /*ntr*/
		    ntr_6_real(tzt, 20L, 1482L, 3L, -3L, (long)v_a_i, i_sub,
		      (long)v_a_n, n_full, sm_index(i_sub, n_sub, *m1_a),
		      &(*x)->z[x_offset + sm_index(m_full, n_full, *m1_g)]);
			/*ntr*/
		    /* -1, */
		    /*ntr*/
		    /* m_full, */
		    ntr_6_real(tzt, 20L, 1482L, 3L, -4L, n_sub,
			       sm_index(i_sub, n_sub, *m1_a), (long)v_b_lm,
			       l_sub, l_sub, &d);
			/*ntr*/
		    if (trace_flag_set(20L, 1482L, 5L))
		      write_line(stdout);
		    /*$endif TRACE*/
		    l_sub++;
		  }
		  m_full++;
		}
	      }
	      /* z^[z_offset + sm_index(i_full, n_full, m1_g)] := d; */
	      (*z)->z[*z_offset + sm_index(i_sub, n_sub, *m1_a)] = d;

	      /*$ifdef TRACE*/
	      if (trace_flag_set(20L, 1482L, 6L))
		write_headed_matrix_t(" K(a, b) * K(b, b)^(-1) * K(b, a):",
				      34L, z, *z_offset, m1_a);

	      /*$endif TRACE*/
	      n_sub++;
	    }
	    n_full++;
	  }
	}
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1482L, 5L))
	  write_line(stdout);
	/*$endif TRACE*/
	i_sub++;
      }
      i_full++;
    }
  }
}  /* triple_product */


Static Void replace_by_extended_sum(x, x_offset, y, y_offset, z, z_offset, g,
				    a, m1_g, m1_a)
t_t_r **x;
t_t_offset x_offset;
t_t_r **y;
t_t_offset *y_offset;
t_t_r **z;
t_t_offset z_offset;
long *g, *a;
t_integer *m1_g, *m1_a;
{
  t_integer i_full = 0, i_sub = 0;
  t_integer j_full, j_sub, sub_index;
  t_continuous_vertex v_a_i, v_a_j;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReplaceByExtendedS ", sizeof(pch20));
  ntr_continuous_set(tzt, 20L, 1483L, 1L, x_offset, *m1_a, a);
  ntr_continuous_set(tzt, 20L, 1483L, 1L, *y_offset, *m1_a, a);
  ntr_continuous_set(tzt, 20L, 1483L, 1L, z_offset, *m1_g, g);
  /*$endif TRACE*/
  for (v_a_i = first_continuous_vertex; v_a_i <= last_continuous_vertex; v_a_i++) {
    if (P_inset(v_a_i, g)) {
      if (P_inset(v_a_i, a)) {
	/* j_full := 0; */
	/* j_sub := 0;  */
	j_full = i_full;
	j_sub = i_sub;
	for (v_a_j = v_a_i; v_a_j <= last_continuous_vertex; v_a_j++) {
	  /* first_continuous_vertex */
	  if (P_inset(v_a_j, g)) {
	    if (P_inset(v_a_j, a)) {
	      sub_index = sm_index(i_sub, j_sub, *m1_a);
	      (*z)->z[z_offset + sm_index(i_full, j_full, *m1_g)] =
		(*x)->z[x_offset + sub_index] + (*y)->z[*y_offset + sub_index];
	      /*$ifdef TRACE*/
	      ntr_4(tzt, 20L, 1483L, 2L, -11L, (long)v_a_i, i_full, i_sub);
	      ntr_4(tzt, 20L, 1483L, 2L, -12L, (long)v_a_j, j_full, j_sub);
		  /*ntr*/
	      /*ntr*/
	      ntr_double_real(tzt, 20L, 1483L, 4L, sub_index,
			      sm_index(i_full, j_full, *m1_g),
			      (*x)->z[x_offset + sub_index],
			      (*y)->z[*y_offset + sub_index]);
		  /*ntr*/
	      /*$endif TRACE*/
	      j_sub++;
	    }
	    j_full++;
	  }
	}
	i_sub++;
      }
      i_full++;
    }
  }
}  /* replace_by_extended_sum */


Static Void update_continuous_generator(generator, link_element, model_set,
  model_set_continuous, workspace, workspace_offset, m1, m2, n_total, ok)
t_cips_set_list **generator;
t_cips_element **link_element;
long *model_set;
long *model_set_continuous;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m1, *m2;
t_cell_count *n_total;
boolean *ok;
{
  t_offset n_offset = 0;
  t_integer i, bb_size, ma1, ma2, mb1, mb2, ma1_off;
  t_t_r *k = NULL, *l = NULL, *m = NULL, *k_invers = NULL;
      /* T_T, argument */
  t_t_offset k_offset, l_offset, m_offset, k_invers_offset;
  t_vertex_set a, b;
  t_continuous_vertex_set a_continuous, b_continuous;
  /*$ifdef TRACE*/
  pch20 tzt;
  long FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " UpdateContinuousG. ", sizeof(pch20));
  ntr_set(tzt, 20L, 1484L, 1L, 0L, (*generator)->r_offset,
	  (*generator)->vertex_set);
  /*$endif TRACE*/


  P_setcpy(a, (*generator)->vertex_set);
  P_setcpy(b, model_set);
  P_setdiff(b, b, a);

  P_setcpy(a_continuous, (*generator)->vertex_set_continuous);
  P_setcpy(b_continuous, model_set_continuous);
  P_setdiff(b_continuous, b_continuous, a_continuous);

  return_ghk_size(a, &ma1, &ma2);
  return_ghk_size(b, &mb1, &mb2);
  /* bb_size := (ma1+mb1) * ((ma1+mb1) + 1) div 2; */
  bb_size = mb1 * (mb1 + 1) / 2;

  k_invers = *workspace;
  k = *workspace;
  l = *workspace;
  m = *workspace;

  k_invers_offset = *workspace_offset;
  k_offset = *workspace_offset + bb_size;
  l_offset = *workspace_offset + bb_size * 2;
  m_offset = *workspace_offset + bb_size * 3;

  if (boolean_option[5]) {
    FORLIM = *m2 - *m1;
    for (i = 0; i <= FORLIM; i++)
      (*link_element)->r->z[(*link_element)->r_offset + *m1 + i] = i + 1.0;
  }

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1484L, 4L))
    write_headed_ssd_t(" K(before):@@@@@@@@@                    ", 11L,
		       model_set, n_offset, (*link_element)->r_offset,
		       &(*link_element)->r, *m1, *m2, NULL, false, 1L, false);
  /*$endif TRACE*/

  if (boolean_option[5] || *ok)   /* Extract k = K(b, b): */
    extract_sub_matrix(&(*link_element)->r, (*link_element)->r_offset + *m1,
		       model_set_continuous, m1, &k, &k_offset, b_continuous,
		       &mb1);

  /*$ifdef TRACE*/
  n_offset = 0;
  if (trace_flag_set(20L, 1484L, 4L))
    write_headed_matrix_t(" K(extracted):", 14L, &k,
			  k_offset, &mb1);
  /*$endif TRACE*/

  if (boolean_option[5] || *ok)   /* Compute k-inverse = K(b, b)^(-1): */
    find_one_k_inverse(&k, &k_invers, &l, &m, &k_offset, &k_invers_offset,
		       &l_offset, &m_offset, &mb1, !boolean_option[63], ok);

  /*$ifdef TRACE*/
  n_offset = 0;
  if (trace_flag_set(20L, 1484L, 4L))
    write_headed_matrix_t(" K(extracted)^-1:", 17L,
			  &k_invers, k_invers_offset, &mb1);
  /*$endif TRACE*/

  if (boolean_option[5]) {
    FORLIM = *m2 - *m1;
    for (i = 0; i <= FORLIM; i++)
      k_invers->z[k_invers_offset + i] = i + 1.0;

    /*$ifdef TRACE*/
    n_offset = 0;
    if (trace_flag_set(20L, 1484L, 4L))
      write_headed_matrix_t(" K(extracted)^-1:", 17L,
			    &k_invers, k_invers_offset, &mb1);
    /*$endif TRACE*/
  }

  if (boolean_option[5] || *ok) {
    /* Compute K(a, b) * K(b, b)^(-1) * K(b, a): */
    triple_product(&(*link_element)->r, (*link_element)->r_offset + *m1,
		   &k_invers, &k_invers_offset, &l, &l_offset,
		   model_set_continuous, a_continuous, b_continuous, m1, &ma1,
		   &mb1, &k, &k_offset);
  }

  /* if boolean_option[91] then
       ma1_off := ma1
    else */

  ma1_off = ma1;

  /*$ifdef TRACE*/
  n_offset = 0;
  if (trace_flag_set(20L, 1484L, 4L))
    write_headed_matrix_t(" K(a, b) * K(b, b)^(-1) * K(b, a):", 34L, &l,
			  l_offset, &ma1);
  if (trace_flag_set(20L, 1484L, 4L))
    write_headed_matrix_t(" n * (SSD(a, a))^(-1):", 22L,
			  &(*generator)->r, (*generator)->r_offset + ma1_off,
			  &ma1);
  /*$endif TRACE*/

  if (boolean_option[5] || *ok) {
    /*$ifdef TRACE*/
    replace_by_extended_sum(&(*generator)->r,
      (*generator)->r_offset + ma1_off, &l, &l_offset, &(*link_element)->r,
      (*link_element)->r_offset + *m1, model_set_continuous, a_continuous, m1,
      &ma1);
  }
  /* Add
               and K(a, b) * K(b, b)^(-1) * K(b, a): */

  n_offset = 0;
  if (trace_flag_set(20L, 1484L, 4L))
    write_headed_ssd_t(" K(after): @@@@@@@@@                    ", 11L,
		       model_set, n_offset, (*link_element)->r_offset,
		       &(*link_element)->r, *m1, *m2, NULL, false, 1L, false);
  /*$endif TRACE*/

}  /* update_continuous_generator */


Static Void adjust_hs(ss, r, ss_offset, r_offset, m1, divide_by_n)
t_ss_r **ss;
t_t_r **r;
t_ss_offset *ss_offset;
t_t_offset *r_offset;
t_integer *m1;
boolean divide_by_n;
{
  t_integer j;

  mult_symmetric_matrix_and_vector_ss_t_t(ss, r, r, ss_offset,
					  *r_offset + *m1, r_offset, m1);
  /* This is missing in `MIPS' ?!?!?! */
  if (!(divide_by_n && n[0] > 0))
    return;
  for (j = FIRST_INDEX; j < FIRST_INDEX + *m1; j++)
    (*r)->z[*r_offset + j] /= n[0];
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1485L, 1L)) {
    /*$endif TRACE*/
    write_headed_vector_t(" H:@@@@@@@                              ", 3L, r,
			  r_offset, m1);
  }
}  /* adjust_hs */


Static Void cips_iterate(link_element, model_set, model_set_continuous, copy,
			 copy_offset, workspace, workspace_offset, m1, m2,
			 n_total, ok)
t_cips_element **link_element;
long *model_set;
long *model_set_continuous;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m1, *m2;
t_cell_count *n_total;
boolean *ok;
{
  t_cips_set_list *p;

  *ok = true;
  p = (*link_element)->generators;
  while (p != NULL && (*ok || boolean_option[5])) {
    update_continuous_generator(&p, link_element, model_set,
				model_set_continuous, workspace,
				workspace_offset, m1, m2, n_total, ok);
    p = p->pointer;
  }
  if (*ok) {   /* and cips_in_use = 2 */
    /* This is missing in `MIPS': ?!?!?! */
    adjust_hs(&(*link_element)->ss, &(*link_element)->r,
	      &(*link_element)->ss_offset, &(*link_element)->r_offset, m1,
	      !boolean_option[118]);
  }
  if (!*ok && (*link_element)->ifail == 0)
    (*link_element)->ifail = 1;

}  /* cips_iterate */


Static t_long_real sub_find_cips_deviance(g, r, r_offset, s, s_offset,
					  workspace, workspace_offset, m1, m2)
long *g;
t_t_r **r;
t_t_offset *r_offset;
t_ss_r **s;
t_ss_offset *s_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m1, *m2;
{
  t_long_real a, b, c, l1;
  t_offset n_offset = 0;
  t_t_offset r_index, tmp_offset, determinants_offset, products_offset;
  t_ss_offset s_index;
  boolean ok;
  t_integer m = 1;
  t_t_r *determinants = NULL, *products = NULL;   /* T_T, malloc */


  /*SLL 5.14, page 132: */

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1487L, 1L))
    trace_1(" Cips-Log-L: ", 13L, *r_offset, *s_offset, 0L, 1L, *m1,
	    *m2, (double)n[0], log(10.0), -1.0);
  /*$endif TRACE*/


  r_index = *r_offset;
  s_index = *s_offset;


  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1487L, 1L))
    write_headed_ssd_t(" ghK (L):@@@@@@@@@@@                    ", 9L, g,
		       n_offset, *r_offset, r, *m1, *m2, NULL, false, 1L,
		       false);
  /*$endif TRACE*/

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1487L, 1L))
    write_headed_ssd_ss(" SS (L):@@@@@@@@@@@@                    ", 8L, g,
			n_offset, *s_offset, s, *m1, *m2, NULL, false, 1L,
			false);
  /*$endif TRACE*/

  /* ok := find_determinants(g, m1, m2, n_offset, r_offset, r); */
  c = (*r)->z[r_index + *m2 - 1];
  tmp_offset = *workspace_offset;
  malloc_workspace(workspace, &tmp_offset, &determinants,
		   &determinants_offset, m);
  malloc_workspace(workspace, &tmp_offset, &products, &products_offset, m);
  find_determinants_and_products(&m, m1, m2, &n_offset, r, r_offset,
    workspace, *workspace_offset, &determinants, &determinants_offset,
    &products, &products_offset, false, &ok);
  if (ok) {
    c = determinants->z[determinants_offset];

    a = find_scalar_product_ss_t(s, r, &s_index, &r_index, m1);
    b = trace_of_multiplum_of_symmetric(s, r, s_index + *m1, r_index + *m1, m1);

    /* l1 := - n[0] * ln(n[0]) + (n[0] - 1) * m1 * LN_2_PI_HALF; */
    l1 = -*m1 * LN_2_PI_HALF;
    l1 += n[0] * (*m1 / 2.0 - 1) * log((double)n[0]);
    l1 += log(c) * n[0] / 2;
    l1 -= n[0] * *m1 * log((double)n[0]) / 2;
    l1 += a / 2;   /* / n[0] */
    l1 -= b / 2;   /* / n[0] */
  }

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1487L, 1L)) {
    write_pch(stdout, " Cips-Log-L: ", 13L);
    write_integer(stdout, r_index, 5L);
    write_integer(stdout, s_index, 5L);
    write_integer(stdout, n[0], 5L);
    write_integer(stdout, *m1, 3L);
    write_integer(stdout, *m2, 3L);
    write_real(stdout, a, print_width, print_dec);
    write_real(stdout, b, print_width, print_dec);
    write_real(stdout, c, print_width, print_dec);
    write_line(stdout);
    write_real(stdout, -n[0] * *m1 * LN_2_PI_HALF, print_width, print_dec);
    write_real(stdout, -*m1 * LN_2_PI_HALF, print_width, print_dec);
    write_real(stdout, log(c) * n[0] / 2, print_width, print_dec);
	/* / n[0] */
    write_real(stdout, a / 2, print_width, print_dec);
    write_line(stdout);
    write_real(stdout, _INVALID_REAL, print_width, print_dec);
    write_real(stdout, n[0] * (*m1 / 2.0 - 1) * log((double)n[0]),
	       print_width, print_dec);
    write_real(stdout, n[0] * *m1 * log((double)n[0]) / -2, print_width,
	       print_dec);
	/* / n[0] */
    write_real(stdout, b / -2, print_width, print_dec);
    write_line(stdout);
    write_real(stdout, _INVALID_REAL, print_width, print_dec);
    write_real(stdout,
      n[0] * (*m1 / 2.0 - 1) * log((double)n[0]) - *m1 * LN_2_PI_HALF,
      print_width, print_dec);
    write_real(stdout, log(c) * n[0] / 2 - n[0] * *m1 * log((double)n[0]) / 2,
	       print_width, print_dec);
	/* / n[0] */
    /* / n[0] */
    write_real(stdout, a / 2 - b / 2, print_width, print_dec);
    write_real(stdout, l1, print_width, print_dec);
    write_line(stdout);
  }
  /*$endif TRACE*/

  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1487L, 8L))
    return l1;
  /*$endif TRACE*/

  write_pch(stdout, " Cips-Log-L: ", 13L);
  write_real(stdout, l1, print_width + 4, print_dec + 2);
  write_line(stdout);
  return l1;
}  /* sub_find_cips_deviance */


Static t_long_real find_cips_deviance(link_element, model_set, r, r_offset,
  r_old, r_old_offset, workspace, workspace_offset, n_total, m1, m2)
t_cips_element **link_element;
long *model_set;
t_t_r **r;
t_t_offset *r_offset;
t_t_r **r_old;
t_t_offset *r_old_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_cell_count *n_total;
t_integer *m1, *m2;
{
  double Result;
  t_offset n_offset = 0;
  t_integer m = 1;
  t_e_r_cell_index index;
  boolean ok = true;
  boolean report;
  t_long_real x;
  t_e_r_cell_index FORLIM;

  /*$ifdef TRACE*/
  if (boolean_option[60]) {
    report = false;
    FORLIM = FIRST_INDEX + *m2;
    for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
      x = (*r)->z[*r_offset + index] - (*r_old)->z[*r_old_offset + index];
      (*workspace)->z[*workspace_offset + index] = x;
      if (fabs(x) > 0)
	report = true;
    }
    if (report)
      write_headed_ssd_t(" Change, FMD:      @                    ", 19L,
			 model_set, n_offset, *workspace_offset, workspace,
			 *m1, *m2, NULL, false, 2L, false);
  }
  if (trace_flag_set(20L, 1488L, 2L))
    write_headed_ssd_t(" FindCipsDeviance: @                    ", 19L,
		       model_set, n_offset, *r_offset, r, *m1, *m2, NULL,
		       false, 2L, false);
  if (trace_flag_set(20L, 1488L, 3L)) {
    write_headed_ssd_ss(" SS:@@@@@@@@@@@@@@@@                    ", 4L,
			model_set, n_offset, (*link_element)->ss_offset,
			&(*link_element)->ss, *m1, *m2, NULL, false, 1L,
			false);
    /*$endif TRACE*/
  }
  if (boolean_option[114]) {   /* and false !!!! */
    normalise_ps(r, r_offset, &n_offset, workspace, *workspace_offset, &m, m1,
		 m2, &ok);
    if (ok)   /* link_element, */
      normalise_ps(r, r_offset, &n_offset, workspace, *workspace_offset, &m,
		   m1, m2, &ok);
    /* model_set, */
    /* n_total, */
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1488L, 4L))
      write_headed_ssd_t(" Normalised: @@@@@@@                    ", 13L,
			 model_set, n_offset, *r_offset, r, *m1, *m2, NULL,
			 false, 2L, false);
    /*$endif TRACE*/
  }
  /* link_element, */
  /* model_set, */
  /* n_total, */
  m = 1;
  if (ok) {
    if (boolean_option[91])
      return (sub_find_mips_deviance(r, r_offset, &(*link_element)->ss,
				     &(*link_element)->ss_offset, &n_offset,
				     &m, m1, m2));
    else
      return (sub_find_cips_deviance(model_set, r, r_offset,
		&(*link_element)->ss, &(*link_element)->ss_offset, workspace,
		workspace_offset, m1, m2));
  } else {
    Result = _INVALID_REAL;
    (*link_element)->ifail = 7;
    return Result;
  }
  return Result;
}  /* find_cips_deviance */


Static t_long_real find_cips_change(r, r_offset, copy, copy_offset, m2)
t_t_r **r;
t_t_offset *r_offset;
t_t_r **copy;
t_t_offset *copy_offset;
t_integer *m2;
{
  /* m1, */
  t_e_r_cell_index index;
  t_long_real d = 0.0;
  t_long_real cell_d;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_e_r_cell_index FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindCipsChange     ", sizeof(pch20));
  FORLIM = FIRST_INDEX + *m2;
  /*$endif TRACE*/
  for (index = FIRST_INDEX; index <= FORLIM - 1; index++) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1489L, 1L))   /*ntr*/
      ntr_double_real(tzt, 20L, 1489L, 1L, *r_offset + index,
		      *copy_offset + index, (*r)->z[*r_offset + index],
		      (*copy)->z[*copy_offset + index]);
    /*ntr*/
    /*$endif TRACE*/
    cell_d = fabs((*r)->z[*r_offset + index] - (*copy)->z[*copy_offset + index]);
    if (cell_d > d)
      d = cell_d;
  }
  return d;
}  /* find_cips_change */


Static Void clear_sub_matrix(ss, ss_offset, g, m1, g_c)
t_ss_r **ss;
t_ss_offset *ss_offset;
long *g;
t_integer *m1;
t_set_list **g_c;
{
  /**/
  /**/
  t_integer i_full = 0;
  t_integer j_full;
  t_continuous_vertex v1, v2;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ClearSubMatrix     ", sizeof(pch20));
  memcpy(tzt, " XxtractSubMatrix   ", sizeof(pch20));
  ntr_set(tzt, 20L, 1490L, 1L, 0L, *m1, g);
  /*$endif TRACE*/
  for (v1 = first_vertex; v1 <= last_vertex; v1++) {
    if (P_inset(v1, g)) {
      /* j_full := i_full; */
      /* sm_index !!! */
      j_full = 0;
      for (v2 = first_vertex; v2 <= v1; v2++) {
	/* to last_vertex */
	/* sm_index !!! */
	if (P_inset(v2, g)) {
	  P_addset(P_expset(a, 0L), v1);
	  P_addset(a, v2);
	  /*$ifdef TRACE*/
	  ntr_set(tzt, 20L, 1490L, 2L, (long)v1, (long)v2, a);
	  ntr(tzt, 20L, 1490L, 2L, (long)v1, (long)v2);   /*ntr*/
	  ntr_real(tzt, 20L, 1490L, 2L, i_full, j_full,
	    &(*ss)->z[*ss_offset + *m1 + sm_index(i_full, j_full, *m1)]);
	      /*ntr*/
	  /*$endif TRACE*/
	  if (!subset_of_an_edge(a, g_c))
	    (*ss)->z[*ss_offset + *m1 + sm_index(i_full, j_full, *m1)] = 0.0;
	  j_full++;
	}
      }
      i_full++;
    }
  }
}  /* clear_sub_matrix */


Static boolean prepare_for_inverted_cips(link_element, covariance_g_c,
  model_set, model_set_continuous, n_total, m1, m2, workspace,
  workspace_offset)
t_cips_element **link_element;
t_set_list **covariance_g_c;
long *model_set;
long *model_set_continuous;
t_cell_count *n_total;
t_integer *m1, *m2;
t_t_r **workspace;
t_t_offset *workspace_offset;
{
  t_e_r_cell_index i;
  t_cips_set_list *link_cips_set_list;
  t_offset n_offset = 0;
  boolean ok;
  t_t_r *r = NULL;   /* T_T, find_ghk_ */
  t_t_offset r_offset;
  t_ss_r *ss_ = NULL;   /* T_SS, find_ss */
  t_ss_offset ss__offset;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_e_r_cell_index FORLIM;

  /*$endif TRACE*/
  to_continuous_set(model_set, model_set_continuous);
  /*$ifdef TRACE*/
  memcpy(tzt, " PrepareForInverted ", sizeof(pch20));
  ntr_set(tzt, 20L, 1491L, 1L, 0L, 0L, model_set);
  ntr_continuous_set(tzt, 20L, 1491L, 1L, 0L, -1L, model_set_continuous);
  /*$endif TRACE*/
  (*link_element)->min_l = -_INFINITY_REAL;   /* ?!?!?!? */
  (*link_element)->max_l = _INFINITY_REAL;   /* ?!?!?!? */
  /*
     if ok then
        ok := return_t_space(m2, link_element^.r, link_element^.r_offset);
     if not ok and (link_element^.ifail = 0) then
        link_element^.ifail := 25;
  */
  if (boolean_option[93])
    ok = find_ghk_(model_set, true, true, true, m1, m2, &n_offset,
		   &(*link_element)->r_offset, &(*link_element)->r);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1491L, 1L))
    write_headed_ssd_t(" ghK (M):@@@@@@@@@@@                    ", 9L,
		       model_set, n_offset, (*link_element)->r_offset,
		       &(*link_element)->r, *m1, *m2, NULL, false, 1L, false);
  /*$endif TRACE*/

  /* For MIPS deviance !!!! */
  n_offset = 0;
  if (!boolean_option[92])
    ok = find_ss(model_set, m1, m2, &n_offset, &(*link_element)->ss_offset,
		 &(*link_element)->ss);
  else {
    ok = find_ss(model_set, m1, m2, &n_offset, &ss__offset, &ss_);
    (*link_element)->ss = (t_ss_r *)Malloc(sizeof(t_ss_r));
    if ((*link_element)->ss == NULL)
      _OutMem();
    /* Cast; Dispose is missing !?!?!? */
    /*$ifdef CAST*/
    (*link_element)->ss->z = (*workspace)->z;
	/* Cast of T_T to T_SS !!!         */
    /*$endif CAST*/
    (*link_element)->ss_offset = *workspace_offset;
    *workspace_offset += *m2;
    FORLIM = *m2;
    for (i = 0; i <= FORLIM; i++)
      (*link_element)->ss->z[(*link_element)->ss_offset + i] =
	ss_->z[ss__offset + i];
    clear_sub_matrix(&(*link_element)->ss, &(*link_element)->ss_offset,
		     model_set, m1, covariance_g_c);
  }
  if (!ok && (*link_element)->ifail == 0)
    (*link_element)->ifail = 24;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1491L, 1L))
    write_headed_ssd_ss(" SS (M):@@@@@@@@@@@@                    ", 8L,
			model_set, n_offset, (*link_element)->ss_offset,
			&(*link_element)->ss, *m1, *m2, NULL, false, 1L,
			false);
  /*$endif TRACE*/
  return_ghk_size(model_set, m1, m2);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1491L, 1L, 1L, 10L);
  /*$endif TRACE*/
  if (ok && boolean_option[91])
    ok = return_t_space(*m2, &(*link_element)->r, &(*link_element)->r_offset);
  if (!ok && (*link_element)->ifail == 0)
    (*link_element)->ifail = 25;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1491L, 1L, 1L, 20L);
  /*$endif TRACE*/
  link_cips_set_list = (*link_element)->generators;
  ok = true;
  while (link_cips_set_list != NULL) {   /* and ok */
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1491L, 1L, 1L, 1L, link_cips_set_list->vertex_set);
    /*$endif TRACE*/
    to_continuous_set(link_cips_set_list->vertex_set,
		      link_cips_set_list->vertex_set_continuous);
    if (boolean_option[91]) {
      ok = find_ghk_(link_cips_set_list->vertex_set, true, true, true, m1, m2,
		     &n_offset, &link_cips_set_list->r_offset,
		     &link_cips_set_list->r);
      /*$ifdef TRACE*/
      ntr_continuous_set(tzt, 20L, 1491L, 1L, 2L,
			 -link_cips_set_list->r_offset,
			 link_cips_set_list->vertex_set_continuous);
	  /*ntr*/
      if (trace_flag_set(20L, 1491L, 1L))
	write_headed_ssd_t(" ghK (1):@@@@@@@@@@@                    ", 9L,
	  link_cips_set_list->vertex_set, n_offset,
	  link_cips_set_list->r_offset, &link_cips_set_list->r, *m1, *m2,
	  NULL, false, 1L, false);
      FORLIM = link_cips_set_list->r_offset + *m2 - 2;
      /*$endif TRACE*/
      for (i = link_cips_set_list->r_offset + *m1; i <= FORLIM; i++)
	link_cips_set_list->r->z[i] *= n[0];
    } else {   /*ntr*/
      ok = find_ghk_(link_cips_set_list->vertex_set, true, true, true, m1, m2,
		     &n_offset, &r_offset, &r);
      /*$ifdef TRACE*/
      ntr_continuous_set(tzt, 20L, 1491L, 1L, 2L, -r_offset,
			 link_cips_set_list->vertex_set_continuous);
      if (trace_flag_set(20L, 1491L, 1L))
	write_headed_ssd_t(" ghK (2):@@@@@@@@@@@                    ", 9L,
			   link_cips_set_list->vertex_set, n_offset, r_offset,
			   &r, *m1, *m2, NULL, false, 1L, false);
      /*$endif TRACE*/
      if (ok) {
	link_cips_set_list->r = *workspace;
	link_cips_set_list->r_offset = *workspace_offset;
	*workspace_offset += *m2;
	FORLIM = *m1;
	for (i = 0; i <= FORLIM - 1; i++)
	  link_cips_set_list->r->z[link_cips_set_list->r_offset + i] =
	    r->z[r_offset + i];
	FORLIM = *m2 - 2;
	for (i = *m1; i <= FORLIM; i++)
	  link_cips_set_list->r->z[link_cips_set_list->r_offset + i] =
	    r->z[r_offset + i];
	      /* * n[0] */
      }
    }
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1491L, 1L, *m1, *m2, link_cips_set_list->vertex_set);
    if (trace_flag_set(20L, 1491L, 1L))
      write_headed_ssd_t(" ghK:@@@@@@@@@@@@@@@                    ", 5L,
			 link_cips_set_list->vertex_set, n_offset,
			 link_cips_set_list->r_offset, &link_cips_set_list->r,
			 *m1, *m2, NULL, false, 1L, false);
    ntr_set(tzt, 20L, 1491L, 1L, 9L, link_cips_set_list->r_offset,
	    link_cips_set_list->vertex_set);
	/*ntr*/
    /*$endif TRACE*/
    link_cips_set_list = link_cips_set_list->pointer;
  }
  if (!ok && (*link_element)->ifail == 0)
    (*link_element)->ifail = 26;
  return_ghk_size(model_set, m1, m2);
  return ok;
}  /* prepare_for_inverted_cips */


Static Void init_cips_estimates(r, r_offset, s, s_offset, m1, m2)
t_t_r **r;
t_t_offset *r_offset;
t_s_r **s;
t_s_offset *s_offset;
t_integer *m1, *m2;
{
  /* ;
  var a   : t_vertex_set */
  t_e_r_cell_index i, j, offset, FORLIM;
  t_long_real sum = 0.0;
  t_long_real g, h;

  g = log(1.0 / 1) - *m1 * LN_2_PI_HALF;

  offset = *r_offset;
  FORLIM = *m1;
  for (i = 0; i <= FORLIM - 1; i++) {
    h = (*s)->z[*s_offset + i];   /* `Inverted' ?!?!?! */
    sum += h * h;
    (*r)->z[offset + i] = h;
  }
  (*r)->z[offset + *m2 - 1] = g - sum / 2;
  offset += *m1;
  FORLIM = *m1;
  for (i = 0; i <= FORLIM - 1; i++) {
    for (j = 0; j <= i - 1; j++) {
      if (boolean_option[106])
	(*r)->z[offset + sm_index(i, j, *m1)] = mips_init_epsilon;
      else
	(*r)->z[offset + sm_index(i, j, *m1)] = 0.0;
    }
    (*r)->z[offset + sm_index(i, i, *m1)] = 1.0;
  }

  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1492L, 1L))
    return;
  /*$endif TRACE*/

  write_pch(stdout, " InitCipsEstimates.", 19L);
  FORLIM = *m2;
  for (i = 0; i <= FORLIM - 1; i++)
    write_real(stdout, (*r)->z[offset - *m1 + i], print_width, print_dec);
  write_line(stdout);
}  /* init_cips_estimates */


Static Void init_inverted_cips(link_element, model_set, s_, s__offset,
			       workspace, workspace_offset, m1, m2, ok)
t_cips_element **link_element;
long *model_set;
t_s_r **s_;
t_s_offset *s__offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m1, *m2;
boolean *ok;
{
  t_offset n_offset = 0;
  t_e_r_cell_index i, FORLIM;
  t_integer m = 1;

  if (!boolean_option[115])   /* , model_set */
    init_cips_estimates(&(*link_element)->r, &(*link_element)->r_offset, s_,
			s__offset, m1, m2);
  else
    *ok = find_ghk_(model_set, true, true, true, m1, m2, &n_offset,
		    &(*link_element)->r_offset, &(*link_element)->r);

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1493L, 1L))
    write_headed_ssd_t(" Init:@@@@@@@@@@@@@@                    ", 6L,
		       model_set, n_offset, (*link_element)->r_offset,
		       &(*link_element)->r, *m1, *m2, NULL, false, 1L, false);
  /*$endif TRACE*/

  if (boolean_option[116]) {
    FORLIM = (*link_element)->r_offset + *m2;
    for (i = (*link_element)->r_offset; i <= FORLIM - 1; i++)
      (*link_element)->r->z[i] *= 1 + mips_random_noise * uniform(&seed);
  }
  /* model_set, */
  /* n_total, */

  /*$ifdef TRACE*/
  normalise_ps(&(*link_element)->r, &(*link_element)->r_offset, &n_offset,
	       workspace, *workspace_offset, &m, m1, m2, ok);
  if (trace_flag_set(20L, 1493L, 1L))
    write_headed_ssd_t(" Init:@@@@@@@@@@@@@@                    ", 6L,
		       model_set, n_offset, (*link_element)->r_offset,
		       &(*link_element)->r, *m1, *m2, NULL, false, 1L, false);
  /*$endif TRACE*/

}  /* init_inverted_cips */


Static Void cips_change_after_update(link_element, model_set, r, r_offset,
  copy, copy_offset, workspace, workspace_offset, m1, m2, d, l1, l2)
t_cips_element **link_element;
long *model_set;
t_t_r **r;
t_t_offset *r_offset;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m1, *m2;
t_long_real *d, *l1, *l2;
{
  t_offset n_offset = 0;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1494L, 1L))
    write_headed_ssd_t(" Copy:@@@@@@@@@@@@@@                    ", 5L,
		       model_set, n_offset, *copy_offset, copy, *m1, *m2,
		       NULL, false, 1L, false);
  if (trace_flag_set(20L, 1494L, 1L))
    write_headed_ssd_t(" CipsChangeAfter..:@                    ", 19L,
		       model_set, n_offset, *r_offset, r, *m1, *m2, NULL,
		       false, 2L, false);
  /*$endif TRACE*/

  if (cips_in_use == 1)
    *d = find_cips_change(r, r_offset, copy, copy_offset, m2);   /* m1, */
  else {
    *l1 = find_cips_deviance(link_element, model_set, r, r_offset, copy,
			     copy_offset, workspace, workspace_offset, n, m1,
			     m2);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1494L, 2L)) {
      write_headed_ssd_t(" Estimates: @@@@@@@@                    ", 12L,
			 model_set, n_offset, *r_offset, r, *m1, *m2, NULL,
			 false, 2L, false);
      write_pch(stdout, " Likelihood: ", 13L);
      write_real(stdout, *l1, 20L, 10L);
    }
    /*$endif TRACE*/
    *d = *l2 - *l1;
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1494L, 8L))
    return;
  /*$endif TRACE*/
  write_pch(stdout, " Delta: ", 8L);
  write_real(stdout, *d, 20L, 10L);
  write_line(stdout);
}  /* cips_change_after_update */


Static Void copy_cips_estimates(r, r_offset, copy, copy_offset, m2)
t_t_r **r;
t_t_offset *r_offset;
t_t_r **copy;
t_t_offset *copy_offset;
t_integer *m2;
{
  /* m1, */
  t_e_r_cell_index index, FORLIM;

  FORLIM = FIRST_INDEX + *m2;
  for (index = FIRST_INDEX; index <= FORLIM - 1; index++)
    (*copy)->z[*copy_offset + index] = (*r)->z[*r_offset + index];
}  /* copy_cips_estimates */


Static Void cips_save_before_update(r, r_offset, copy, copy_offset, m2, l1, l2)
t_t_r **r;
t_t_offset *r_offset;
t_t_r **copy;
t_t_offset *copy_offset;
t_integer *m2;
t_long_real *l1, *l2;
{
  /* m1, */
  if ((cips_in_use == 1) | trace_flag_set(20L, 1488L, 0L))   /* m1, */
    copy_cips_estimates(r, r_offset, copy, copy_offset, m2);
  else
    *l2 = *l1;
}


Static boolean do_cips_iteration(link_element, covariance_g_c, model_set, c,
  copy, copy_offset, workspace, workspace_offset, m1, m2, iterate_pack)
t_cips_element **link_element;
t_set_list **covariance_g_c;
long *model_set;
Char *c;
t_t_r **copy;
t_t_offset *copy_offset;
t_t_r **workspace;
t_t_offset *workspace_offset;
t_integer *m1, *m2;
t_iterate_pack **iterate_pack;
{
  boolean continue_;
  t_long_real l = _INVALID_REAL, d = _INVALID_REAL;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_iterate_pack *WITH;
  FILE *TEMP;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DoCipsIteration    ", sizeof(pch20));
  ntr(tzt, 20L, 1497L, 1L, 0L, 0L);
  /*$endif TRACE*/
  WITH = *iterate_pack;
  if (WITH->cycle_number > 0) {
    /* ... -> l, old_l - l -> d */
    cips_change_after_update(link_element, model_set, &(*link_element)->r,
			     &(*link_element)->r_offset, copy, copy_offset,
			     workspace, workspace_offset, m1, m2, &d, &l,
			     &WITH->old_l);
  } else {
    WITH->old_l = _INVALID_REAL;
    if (WITH->iterate && cips_in_use != 1)
      l = find_cips_deviance(link_element, model_set, &(*link_element)->r,
	  &(*link_element)->r_offset, &(*link_element)->r,
	  &(*link_element)->r_offset, workspace, workspace_offset, n, m1, m2);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1497L, 1L, 0L, 1L);
  /*$endif TRACE*/
  (*link_element)->log_likelihood = l;
  /*$ifdef TRACE*/
  if (WITH->differences != NULL && boolean_option[64])   /* , bad_count */
    find_differences(&WITH->old_l, &l, &cips_epsilon, &WITH->cycle_number,
		     WITH->differences);
  if (trace_iteration(&d, iterate_pack)) {
    if (WITH->differences != NULL && boolean_option[64])
      report_differences((*link_element)->min_l, (*link_element)->max_l,
			 &WITH->old_l, &l, &cips_epsilon, &WITH->cycle_number,
			 WITH->differences, WITH->bad_count);
    else {
      write_pch(stdout, " Cips-cycle; ", 13L);
      write_pch(stdout, c, 10L);
      write_integer(stdout, WITH->cycle_number, print_width - print_dec);
      write_real(stdout, l, print_width + 4, print_dec + 2);
      write_real(stdout, WITH->old_l, print_width + 4, print_dec + 2);
      write_real(stdout, d, print_width + 8, print_dec + 6);
      write_line(stdout);
    }
  }
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1497L, 1L, 0L, 2L);
  /*$endif TRACE*/
  continue_ = (((fabs(d) > cips_epsilon &&
		 WITH->cycle_number < WITH->max_cycle_number &&
		 (*link_element)->ifail == 0 &&
		 WITH->iterate) || WITH->cycle_number == 0) && !interrupt_1);
      /* (d > 0) or */
  if (WITH->old_l - cips_epsilon <= l)
    WITH->bad_count = 0;
  else
    WITH->bad_count++;
  if (continue_) {
    if (WITH->bad_count > 10) {  /* As option to set cips .... ; !!! */
      (*link_element)->ifail = 9;
      continue_ = false;
    }
  }
  if ((!is_invalid_real((*link_element)->min_l)) &
      (!is_invalid_real((*link_element)->max_l))) {
    if (WITH->cycle_number > 20 &&
	(l < (*link_element)->min_l || (*link_element)->max_l < l))
    {   /* As option to set cips .... ; !!! */
      (*link_element)->ifail = 10;
      continue_ = false;
    }
  }
  if (WITH->cycle_number >= WITH->max_cycle_number)
    (*link_element)->ifail = 11;
  WITH->cycle_number++;
  WITH->old_l = l;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1497L, 1L, 0L, 3L);
  /*$endif TRACE*/
  if (WITH->iterate) {
    if (continue_) {   /* m1, */
      /* l -> old_l */
      cips_save_before_update(&(*link_element)->r, &(*link_element)->r_offset,
			      copy, copy_offset, m2, &l, &WITH->old_l);
    } else {
      (*link_element)->cycles = WITH->cycle_number;
      (*link_element)->cips_delta = d;
      (*link_element)->convergence = (fabs(d) < cips_epsilon);
      if (fabs(d) > cips_epsilon || (*link_element)->ifail > 0)
	no_convergence(*covariance_g_c, "CIPS", 4L,
		       &(*link_element)->ifail, &WITH->cycle_number, &d);
      if (fabs(d) > 0 && WITH->cycle_number > 2)
	report_convergence(*covariance_g_c, "CIPS", 4L, model_set,
			   &WITH->cycle_number, &WITH->start_clock, &d,
			   &cips_epsilon);
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1497L, 1L, 0L, 4L);
  TEMP = stdout;
  /*$endif TRACE*/
  flush_file(&TEMP);
  TEMP = stdout;
  flush_file(&TEMP);
  flush_file(&diary_file);
  flush_file(&log_file);
  return continue_;
}  /* do_iterate_cips */


Static Void inverted_cips(link_element, covariance_g_c, model_set, n_total,
			  cips_epsilon, cips_max_cycles, ok)
t_cips_element **link_element;
t_set_list **covariance_g_c;
long *model_set;
t_cell_count *n_total;
t_long_real cips_epsilon;
t_integer *cips_max_cycles;
boolean *ok;
{
  /* init    : boolean; */
  boolean dummy_ok;
  t_t_r *copy = NULL, *workspace = NULL;   /* T_T, return_tmp_t_space */
  t_t_offset copy_offset, workspace_offset, tmp_offset;
  t_s_r *s_ = NULL;   /* T_S, find_ssd */
  t_s_offset s__offset;
  t_offset dummy_offset = 0;
  t_integer size, m1, m2;
  t_iterate_pack *iterate_pack;
  t_continuous_vertex_set model_set_continuous;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/

  /*$ifdef TRACE*/
  memcpy(tzt, " Cips               ", sizeof(pch20));
  ntr_cips_item(tzt, 20L, 1498L, 1L, 0L, 0L, link_element, covariance_g_c);
  /*$endif TRACE*/


  iterate_pack = init_iterate_pack(&cips_epsilon, cips_max_cycles, true, true,
				   boolean_option[64]);

  if (boolean_option[91]) {
    if (true) {
      *ok = prepare_for_inverted_cips(link_element, covariance_g_c, model_set,
				      model_set_continuous, n_total, &m1, &m2,
				      &workspace, &workspace_offset);
      if (!*ok && (*link_element)->ifail == 0)
	(*link_element)->ifail = 21;
    } else {
      *ok = false;
      (*link_element)->ifail = 20;
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1498L, 2L, m1, m2);
    /*$endif TRACE*/
    size = m2 * 3;
    if (*ok)
      *ok = return_tmp_t_space(size, &workspace, &workspace_offset);
    if (!*ok && (*link_element)->ifail == 0)
      (*link_element)->ifail = 22;
    tmp_offset = workspace_offset;

  }

  else {
    return_ghk_size(model_set, &m1, &m2);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1498L, 2L, m1, m2);
    /*$endif TRACE*/

    *ok = true;

    if (*ok)
      *ok = return_t_space(m2, &(*link_element)->r,
			   &(*link_element)->r_offset);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1498L, 2L, -7L, (*link_element)->r_offset);
    /*$endif TRACE*/

    if (!*ok && (*link_element)->ifail == 0)
      (*link_element)->ifail = 25;

    size = m1 * (m1 + 1) / 2;
    size = size * 4 + g_c_size(*covariance_g_c) * m2;
    if (*ok)
      *ok = return_tmp_t_space(size, &workspace, &workspace_offset);
    if (!*ok && (*link_element)->ifail == 0)
      (*link_element)->ifail = 22;
    tmp_offset = workspace_offset;

    /*$ifdef TRACE*/
    if (!*ok) {
      memcpy(tzt, " Not OK / Cips      ", sizeof(pch20));   /*ntr*/
      ntr_cips_item_short(tzt, 20L, 1498L, 8L, -1L, (*link_element)->ifail,
			  link_element, covariance_g_c);
    }
    /*$endif TRACE*/

    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1498L, 2L, size, tmp_offset);
    /*$endif TRACE*/
    if (*ok) {   /* true: workspace = nil */
      *ok = prepare_for_inverted_cips(link_element, covariance_g_c, model_set,
	  model_set_continuous, n_total, &m1, &m2, &workspace, &tmp_offset);
      if (!*ok && (*link_element)->ifail == 0)
	(*link_element)->ifail = 21;
    } else {
      *ok = false;
      (*link_element)->ifail = 20;

    }
  }


  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1498L, 2L, 0L, 3L);
  /*$endif TRACE*/
  if (*ok)
    *ok = find_ssd(model_set, &m1, &m2, &dummy_offset, &s__offset, &s_);
  if (!*ok && (*link_element)->ifail == 0)
    (*link_element)->ifail = 23;

  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1498L, 2L, 0L, 4L);
  dummy_offset = 0;
  if (trace_flag_set(20L, 1498L, 1L))   /**/
    write_headed_ssd_s(" SSD(Gamma):@@@@@@@@                    ", 12L,
		       model_set, dummy_offset, s__offset, &s_, m1, m2, NULL,
		       false, 2L, false);
  ntr(tzt, 20L, 1498L, 2L, 0L, 5L);
  /*$endif TRACE*/

  if (*ok && *cips_max_cycles > 0) {
    init_inverted_cips(link_element, model_set, &s_, &s__offset, &workspace,
		       &tmp_offset, &m1, &m2, ok);
    malloc_workspace(&workspace, &tmp_offset, &copy, &copy_offset, m2);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1498L, 2L, 0L, 6L);
    /*$endif TRACE*/
    /* ok := true; */
    if (!*ok && (*link_element)->ifail == 0)
      (*link_element)->ifail = 6;
    while (do_cips_iteration(link_element, covariance_g_c, model_set,
			     " Outer:   ", &copy, &copy_offset, &workspace,
			     &tmp_offset, &m1, &m2, &iterate_pack) && *ok)
      cips_iterate(link_element, model_set, model_set_continuous, &copy,
		   &copy_offset, &workspace, &tmp_offset, &m1, &m2, n_total,
		   ok);
  } else {
    if ((*link_element)->ifail != 20)
      warning_cips(*covariance_g_c);
    if ((*link_element)->ifail == 0)
      (*link_element)->ifail = 23;
  }

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1498L, 1L))
    write_headed_ssd_t(" ghK (F):@@@@@@@@@@@                    ", 9L,
		       model_set, dummy_offset, (*link_element)->r_offset,
		       &(*link_element)->r, m1, m2, NULL, false, 1L, false);
  /*$endif TRACE*/

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1498L, 1L))
    write_headed_ssd_ss(" SS (F):@@@@@@@@@@@@                    ", 8L,
			model_set, dummy_offset, (*link_element)->ss_offset,
			&(*link_element)->ss, m1, m2, NULL, false, 1L, false);
  /*$endif TRACE*/

  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1498L, 2L, 0L, 7L);
  /*$endif TRACE*/

  /*$ifdef TRACE*/
  if ((*link_element)->ifail != 0) {
    memcpy(tzt, " Fail / Cips        ", sizeof(pch20));   /*ntr*/
    ntr_cips_item_short(tzt, 20L, 1498L, 8L, -1L, (*link_element)->ifail,
			link_element, covariance_g_c);
  }
  /*$endif TRACE*/

  /*$ifdef TRACE*/
  if (!*ok) {
    memcpy(tzt, " Not OK / Cips      ", sizeof(pch20));   /*ntr*/
    ntr_cips_item_short(tzt, 20L, 1498L, 8L, -1L, (*link_element)->ifail,
			link_element, covariance_g_c);
  }
  /*$endif TRACE*/

  dummy_ok = free_tmp_t_space();   /* size, workspace, workspace_offset */

  if (boolean_option[64])
    _Free(iterate_pack->differences);

  /* dummy_ok := free_tmp_s_space(m2, s_, s__offset) */
  _Free(iterate_pack);
}  /* inverted_cips */


/*@+"marghug.p"*/


/*

1501:    +++  ++
1502:    +++  ++
1503:    ---  -- p/marghug.p         22     103    1314 p/marghug.p
1504: |    4:    function marginal_hash_integer
1505: |   35:    procedure invers_marginal_hash
1506: |   55:    procedure insert_cell_list
1507: |   88:    procedure write_cell_list
1508: |  118:    function integer_list_less_than
1509: |  127:    function integer_array_less_than
1510: |  140:    procedure swap_integer_array
1511: |  151:    procedure sort_integer_array
1512: |  153:    function findpivot
1513: |  171:    function partition
1514: |  190:    procedure quicksort
1515: |  206:    procedure merge
1516: |  216:    procedure getrecord
1517: |  269:    procedure sort_integer_file
1518: |  278:    procedure init
1519: |  395:    procedure encode_cell_in_list
1520: |  409:    procedure find_log_l_file
1521: |  517:    procedure encode_cell_in_array
1522: |  531:    procedure find_log_l_array
1523: |  630:    procedure find_log_l_large
1524: |  709:    procedure find_log_l_small
1525: |  761:    function find_log_l
1526:    +++  ++
1527:    +++  ++

*/


Static t_long_integer marginal_hash_integer(a, i)
long *a;
t_level *i;
{
  t_long_integer sum, product;
  t_vertex v, f, l;
  t_vertex_set b;

  if (P_setequal(a, empty_set)) {
    sum = FIRST_INDEX;
    return sum;
  }
  f = first_vertex;
  while (!P_inset(f, a))
    f++;
  sum = FIRST_INDEX + i[f - MIN_VERTEX] - FIRST_LEVEL;
  P_addset(P_expset(b, 0L), f);   /* empty_set + */
  if (P_setequal(a, b))
    return sum;
  l = last_vertex;
  while (!P_inset(l, a))
    l--;
  product = variable_description[f - MIN_VERTEX]->UU.U0.levels;
  for (v = f + 1; v <= l - 1; v++) {
    if (P_inset(v, a)) {
      sum += (i[v - MIN_VERTEX] - FIRST_LEVEL) * product;
      product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
    }
  }
  sum += (i[l - MIN_VERTEX] - FIRST_LEVEL) * product;
  return sum;
}  /* marginal_hash_integer */


Static Void invers_marginal_hash(index, a, i)
t_long_integer index;
long *a;
t_level *i;
{
  t_vertex v;
  t_long_integer product;

  index -= FIRST_INDEX;
  product = marginal_hash_integer(a, last_cell) - FIRST_INDEX + 1;
  for (v = last_vertex; v >= first_vertex; v--) {
    if (P_inset(v, a)) {
      product /= variable_description[v - MIN_VERTEX]->UU.U0.levels;
      if (product <= index) {
	i[v - MIN_VERTEX] = FIRST_LEVEL + index / product;
	index %= product;
      } else
	i[v - MIN_VERTEX] = FIRST_LEVEL;
    }
  }
}  /* invers_marginal_hash */


Static Void insert_cell_list(p_integer_list, p_set_list, a, n_cell, n_sets, i,
  marginal_percentages, b_offset, b, ifail, sub_code, arg_int, arg_double,
  index_int, stop_int, index_double, stop_double)
t_integer_list *p_integer_list;
t_set_list *p_set_list;
long *a;
t_long_integer *n_cell, *n_sets;
t_level *i;
boolean marginal_percentages;
t_offset b_offset;
long *b;
t_integer *ifail, *sub_code;
long **arg_int;
double **arg_double;
t_integer *index_int, *stop_int, *index_double, *stop_double;
{
  t_long_integer j, k;
  t_vertex v;
  t_long_real x;

  put_one_integer(arg_int, index_int, stop_int, n_cell);
  for (j = 1; j <= *n_sets; j++) {
    invers_marginal_hash(p_integer_list->x, p_set_list->vertex_set, i);
    p_integer_list = p_integer_list->pointer;
    p_set_list = p_set_list->pointer;
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      k = i[v - MIN_VERTEX] + 1;
      put_one_integer(arg_int, index_int, stop_int, &k);
    }
  }
  if (marginal_percentages) {
    x = *n_cell * 100.0 / n[b_offset + marginal_hash(b, i)];
    put_one_long_real(arg_double, index_double, stop_double, &x);
  }
}  /* write_cell_list */


Static Void write_cell_list(p_integer_list, p_set_list, a, n_cell, n_sets, i,
			    marginal_percentages, b_offset, b)
t_integer_list *p_integer_list;
t_set_list *p_set_list;
long *a;
t_long_integer *n_cell, *n_sets;
t_level *i;
boolean marginal_percentages;
t_offset b_offset;
long *b;
{
  t_long_integer j;
  t_vertex v;

  write_char(stdout, '*');
  write_integer(stdout, *n_cell, 10L);
  write_space(stdout, 1L);
  for (j = 1; j <= *n_sets; j++) {
    invers_marginal_hash(p_integer_list->x, p_set_list->vertex_set, i);
    p_integer_list = p_integer_list->pointer;
    p_set_list = p_set_list->pointer;
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      write_integer(stdout, i[v - MIN_VERTEX] + 1L,
	floor_x(2 + log_10((double)variable_description[v - MIN_VERTEX]->
				   UU.U0.levels)));
  }
  if (marginal_percentages)
    write_real(stdout, *n_cell * 100.0 / n[b_offset + marginal_hash(b, i)],
	       8L, 2L);
  write_line(stdout);
}  /* write_cell_list */


Static boolean integer_list_less_than(p, q)
t_integer_list *p, *q;
{
  while (p->x == q->x && p->pointer != NULL) {
    p = p->pointer;
    q = q->pointer;
  }
  return (p->x < q->x);
}  /* integer_list_less_than */


Static boolean integer_array_less_than(i, j, n_sets)
t_long_integer i, j, n_sets;
{
  t_long_integer k = 1;

  while (n[i] == n[j] && k < n_sets) {
    i++;
    j++;
    k++;
  }
  return (n[i] < n[j]);
}  /* integer_array_less_than */


Static Void swap_integer_array(i, j, n_sets)
t_long_integer *i, *j, *n_sets;
{
  t_long_integer k, x;

  for (k = 0; k < *n_sets; k++) {
    x = n[*i + k];
    n[*i + k] = n[*j + k];
    n[*j + k] = x;
  }
}  /* swap_integer_array */


Local t_long_integer findpivot(i, j, n_sets)
t_long_integer *i, *j, *n_sets;
{
  long Result = 0;
  t_long_integer k;

  k = *i + *n_sets;
  while (k <= *j) {
    if (integer_array_less_than(*i, k, *n_sets)) {
      Result = k;
      k = *j;
    } else if (integer_array_less_than(k, *i, *n_sets)) {
      Result = *i;
      k = *j;
    }
    k += *n_sets;
  }
  return Result;
}  /* findpivot */

Local t_long_integer partition(l, r, pivotindex, n_sets)
t_long_integer l, r, *pivotindex, *n_sets;
{
  t_long_integer i;

  for (i = 1; i <= *n_sets; i++)
    n[max_cell_number - *n_sets + i] = n[*pivotindex + i - 1];
  *pivotindex = max_cell_number - *n_sets + 1;
  do {
    swap_integer_array(&l, &r, n_sets);
    while (integer_array_less_than(l, *pivotindex, *n_sets))
      l += *n_sets;
    while (!integer_array_less_than(r, *pivotindex, *n_sets))
      r -= *n_sets;
  } while (l <= r);
  return l;
}  /* partition */

Local Void quicksort(i, j, n_sets)
t_long_integer i, j, n_sets;
{
  t_long_integer pivotindex, k;

  pivotindex = findpivot(&i, &j, &n_sets);
  if (pivotindex == 0)
    return;
  k = partition(i, j, &pivotindex, &n_sets);
  quicksort(i, k - n_sets, n_sets);
  quicksort(k, j, n_sets);
}  /* quicksort */


Static Void sort_integer_array(min, max, n_sets)
t_long_integer min, max, n_sets;
{
  quicksort(min, max, n_sets);
}  /* sort_integer_array */


/* Local variables for merge: */
struct LOC_merge {
  FILE *f1, *f2;
  t_long_integer used[2];
  boolean fine[2];
  t_integer_list *current[2];
} ;

Local Void getrecord(k, i, LINK)
t_long_integer *k, i;
struct LOC_merge *LINK;
{
  if (LINK->used[i-1] == *k)
    LINK->fine[i-1] = true;
  else if (i == 1) {
    if (eof_integer_file(LINK->f1))
      LINK->fine[0] = true;
    else
      read_integer_list(LINK->f1, LINK->current[0]);
  } else if (eof_integer_file(LINK->f2))
    LINK->fine[1] = true;
  else
    read_integer_list(LINK->f2, LINK->current[1]);
  LINK->used[i-1]++;
}  /* getrecord */


Static Void merge(k, f1_, f2_, g1, g2, p, q)
t_long_integer *k;
FILE *f1_, *f2_, *g1, *g2;
t_integer_list **p, **q;
{
  struct LOC_merge Local_Var;
  boolean outswitch = true;
  t_long_integer winner;

  Local_Var.f1 = f1_;
  Local_Var.f2 = f2_;
  Local_Var.current[0] = *p;
  Local_Var.current[1] = *q;
  rewrite_integer_file(g1);
  rewrite_integer_file(g2);
  reset_integer_file(Local_Var.f1);
  reset_integer_file(Local_Var.f2);
  while ((!eof_integer_file(Local_Var.f1)) | (!eof_integer_file(Local_Var.f2))) {
    Local_Var.used[0] = 0;
    Local_Var.used[1] = 0;
    Local_Var.fine[0] = false;
    Local_Var.fine[1] = false;
    getrecord(k, 1L, &Local_Var);
    getrecord(k, 2L, &Local_Var);
    while (!Local_Var.fine[0] || !Local_Var.fine[1]) {
      if (Local_Var.fine[0])
	winner = 2;
      else if (Local_Var.fine[1])
	winner = 1;
      else if (integer_list_less_than(Local_Var.current[0],
				      Local_Var.current[1]))
	winner = 1;
      else
	winner = 2;
      if (outswitch)
	write_integer_list(g1, Local_Var.current[winner-1]);
      else
	write_integer_list(g2, Local_Var.current[winner-1]);
      getrecord(k, winner, &Local_Var);
    }
    outswitch = !outswitch;
  }
}  /* merge */


Local Void init(k, count, n_sets, int_list_1, f, g1, g2)
t_long_integer *k, *count, *n_sets;
t_integer_list **int_list_1;
FILE *f, *g1, *g2;
{
  boolean outswitch = true;
  t_long_integer n_int, i, j, min_index;
  long FORLIM;

  rewrite_integer_file(g1);
  rewrite_integer_file(g2);
  reset_integer_file(f);
  if (*k == 1) {
    FORLIM = *count - *count / 2;
    for (i = 1; i <= FORLIM; i++) {
      read_integer_list(f, *int_list_1);
      write_integer_list(g1, *int_list_1);
    }
    FORLIM = *count / 2;
    for (i = 1; i <= FORLIM; i++) {
      read_integer_list(f, *int_list_1);
      write_integer_list(g2, *int_list_1);
    }
    return;
  }
  min_index = fna;
  while (!eof_integer_file(f)) {
    i = 0;
    while (!eof_integer_file(f) && i < *k) {
      for (j = 0; j < *n_sets; j++) {
	read_integer_file(f, &n_int);
	n[min_index + i * *n_sets + j] = n_int;
      }
      i++;
    }
    sort_integer_array(min_index, min_index + (i - 1) * *n_sets, *n_sets);
    if (outswitch) {
      FORLIM = min_index + i * *n_sets;
      for (j = min_index; j < FORLIM; j++) {
	n_int = n[j];
	write_integer_file(g1, n_int);
      }
    } else {
      FORLIM = min_index + i * *n_sets;
      for (j = min_index; j < FORLIM; j++) {
	n_int = n[j];
	write_integer_file(g2, n_int);
      }
    }
    outswitch = !outswitch;
  }
}  /* init */


Static Void sort_integer_file(x_file, int_list_1, int_list_2, count, n_sets)
FILE *x_file;
t_integer_list **int_list_1, **int_list_2;
t_long_integer count, n_sets;
{
  pch_long file_name_f1, file_name_f2, file_name_g1, file_name_g2;
  FILE *f1 = NULL, *f2 = NULL, *g1 = NULL, *g2 = NULL;
  t_long_integer k;
  boolean ok;
  boolean out_f = true;

  default_to_file_name(DEFAULT_TMP, file_name_f1);
  assign_integer_file_write(&f1, file_name_f1, &tmp_count);
  default_to_file_name(DEFAULT_TMP, file_name_f2);
  assign_integer_file_write(&f2, file_name_f2, &tmp_count);
  default_to_file_name(DEFAULT_TMP, file_name_g1);
  assign_integer_file_write(&g1, file_name_g1, &tmp_count);
  default_to_file_name(DEFAULT_TMP, file_name_g2);
  assign_integer_file_write(&g2, file_name_g2, &tmp_count);
  tmp_count -= 4;
  if ((n[0] + 1) * n_sets > max_cell_number - fna) {
    ok = false;
    k = (n[0] + 1) * n_sets;
    if (k > MAX_CELL_NUMBER_MAX - fna)
      k = MAX_CELL_NUMBER_MAX - fna;
    while (!ok && k > 2) {
      if (!TURBO_PC)
	ok = space_in_n_array(k, fna);
      k /= 2;
    }
  }
  if (8 < (double)(max_cell_number - fna) / n_sets)
    k = floor_x((double)(max_cell_number - fna) / n_sets - 1);
  else
    k = 1;
  init(&k, &count, &n_sets, int_list_1, x_file, f1, f2);
  while (k < count) {
    out_f = !out_f;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1517L, 1L)) {
      write_pch(stdout, " Merge:", 7L);
      write_integer(stdout, k, 10L);
      write_integer(stdout, count, 10L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (out_f) {
      reassign_integer_file_write(&f1, file_name_f1);
      reassign_integer_file_write(&f2, file_name_f2);
      merge(&k, g1, g2, f1, f2, int_list_1, int_list_2);
    } else {
      reassign_integer_file_write(&g1, file_name_g1);
      reassign_integer_file_write(&g2, file_name_g2);
      merge(&k, f1, f2, g1, g2, int_list_1, int_list_2);
    }
    k *= 2;
  }
  rewrite_integer_file(x_file);
  if (out_f) {
    reset_integer_file(f1);
    while (!eof_integer_file(f1)) {
      read_integer_list(f1, *int_list_1);
      write_integer_list(x_file, *int_list_1);
    }
  } else {
    reset_integer_file(g1);
    while (!eof_integer_file(g1)) {
      read_integer_list(g1, *int_list_1);
      write_integer_list(x_file, *int_list_1);
    }
  }
  unlink_integer_file(&f1, file_name_f1);
  unlink_integer_file(&f2, file_name_f2);
  unlink_integer_file(&g1, file_name_g1);
  unlink_integer_file(&g2, file_name_g2);
  if (f1 != NULL)
    fclose(f1);
  if (f2 != NULL)
    fclose(f2);
  if (g1 != NULL)
    fclose(g1);
  if (g2 != NULL)
    fclose(g2);
}  /* sort_integer_file */


Static Void encode_cell_in_list(i, n_sets, p_set_list, p_integer_list)
t_level *i;
t_long_integer *n_sets;
t_set_list *p_set_list;
t_integer_list *p_integer_list;
{
  t_long_integer j;

  for (j = 1; j <= *n_sets; j++) {
    p_integer_list->x = marginal_hash_integer(p_set_list->vertex_set, i);
    p_integer_list = p_integer_list->pointer;
    p_set_list = p_set_list->pointer;
  }
}  /* encode_cell_in_list */


Static Void find_log_l_file(a, print_table, set_list, x, y, n_sets, log_l,
			    marginal_percentages, b_offset, b, ifail,
			    sub_code, arg_int, arg_double, i_int, stop_int,
			    i_double, stop_double)
long *a;
boolean print_table;
t_set_list **set_list;
t_integer_list **x, **y;
t_long_integer *n_sets;
t_long_real *log_l;
boolean marginal_percentages;
t_offset b_offset;
long *b;
t_integer *ifail, *sub_code;
long **arg_int;
double **arg_double;
t_integer *i_int, *stop_int, *i_double, *stop_double;
{
  t_cell i;
  t_vertex v;
  t_long_integer index;
  t_long_integer n_cell = 1, num = 1;
  pch_long file_name;
  FILE *x_file = NULL;
  t_integer_list *p_integer_list;
  t_case_list *p_case_list;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1520L, 1L)) {
    write_pch(stdout, " On File  ", 10L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  default_to_file_name(DEFAULT_TMP, file_name);
  assign_integer_file_write(&x_file, file_name, &tmp_count);
  for (v = first_vertex; v <= MAX_VERTEX; v++)
    i[v - MIN_VERTEX] = MAX_LEVEL;
  if (case_list != NULL) {
    p_case_list = case_list;
    for (index = 1; index <= n[0]; index++) {
      encode_cell_in_list(p_case_list->cell, n_sets, *set_list, *x);
      write_integer_list(x_file, *x);
      p_case_list = p_case_list->pointer;
    }
  } else if (!exclude_missing) {
    reset_level_file(file_read);
    for (index = 1; index <= n[0]; index++) {
      for (v = first_vertex; v <= last_vertex; v++)
	read_level_file(file_read, &i[v - MIN_VERTEX]);
      encode_cell_in_list(i, n_sets, *set_list, *x);
      write_integer_list(x_file, *x);
    }
  } else {
    reset_level_file(file_excluded);
    for (index = 1; index <= n[0]; index++) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, delta_missing_excluded))
	  read_level_file(file_excluded, &i[v - MIN_VERTEX]);
      }
      encode_cell_in_list(i, n_sets, *set_list, *x);
      write_integer_list(x_file, *x);
    }
  }
  sort_integer_file(x_file, x, y, n[0], *n_sets);
  reset_integer_file(x_file);
  read_integer_list(x_file, *y);
  while (!eof_integer_file(x_file)) {
    num++;
    read_integer_list(x_file, *x);
    if (!integer_list_less_than(*y, *x)) {
      n_cell++;
      continue;
    }
    if (print_table) {
      if (*sub_code == 1)
	write_cell_list(*y, *set_list, a, &n_cell, n_sets, i,
			marginal_percentages, b_offset, b);
      else
	insert_cell_list(*y, *set_list, a, &n_cell, n_sets, i,
			 marginal_percentages, b_offset, b, ifail, sub_code,
			 arg_int, arg_double, i_int, stop_int, i_double,
			 stop_double);
    }
    *log_l += n_cell * log((double)n_cell);
    n_cell = 1;
    p_integer_list = *y;
    *y = *x;
    *x = p_integer_list;
  }
  if (print_table) {
    if (*sub_code == 1) {
      write_cell_list(*y, *set_list, a, &n_cell, n_sets, i,
		      marginal_percentages, b_offset, b);
      write_line(stdout);
    } else
      insert_cell_list(*y, *set_list, a, &n_cell, n_sets, i,
		       marginal_percentages, b_offset, b, ifail, sub_code,
		       arg_int, arg_double, i_int, stop_int, i_double,
		       stop_double);
  }
  *log_l += n_cell * log((double)n_cell);
  tmp_count--;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1520L, 8L)) {
    write_pch(stdout, " Number of", 10L);
    write_integer(stdout, num, 5L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  unlink_integer_file(&x_file, file_name);
  if (x_file != NULL)
    fclose(x_file);
}  /* find_log_l_file */


Static Void encode_cell_in_array(i, index, min_index, n_sets, p_set_list)
t_level *i;
t_long_integer index, *min_index, *n_sets;
t_set_list *p_set_list;
{
  t_long_integer j;

  for (j = 0; j < *n_sets; j++) {
    n[*min_index + (index - 1) * *n_sets + j] = marginal_hash_integer(
	p_set_list->vertex_set, i);
    p_set_list = p_set_list->pointer;
  }
}  /* encode_cell_in_array */


Static Void find_log_l_array(a, print_table, set_list, y, n_sets, log_l,
  marginal_percentages, b_offset, b, ifail, sub_code, arg_int, arg_double,
  i_int, stop_int, i_double, stop_double)
long *a;
boolean print_table;
t_set_list **set_list;
t_integer_list **y;
t_long_integer *n_sets;
t_long_real *log_l;
boolean marginal_percentages;
t_offset b_offset;
long *b;
t_integer *ifail, *sub_code;
long **arg_int;
double **arg_double;
t_integer *i_int, *stop_int, *i_double, *stop_double;
{
  /* x, */
  t_cell i;
  t_vertex v;
  t_long_integer min_index, index;
  t_long_integer n_cell = 1;
  t_long_integer j;
  t_integer_list *p_integer_list;
  t_case_list *p_case_list;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1522L, 1L)) {
    write_pch(stdout, " In Array ", 10L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  for (v = first_vertex; v <= MAX_VERTEX; v++)
    i[v - MIN_VERTEX] = MAX_LEVEL;
  min_index = fna;
  if (case_list != NULL) {
    p_case_list = case_list;
    for (index = 1; index <= n[0]; index++) {
      encode_cell_in_array(p_case_list->cell, index, &min_index, n_sets,
			   *set_list);
      p_case_list = p_case_list->pointer;
    }
  } else if (!exclude_missing) {
    reset_level_file(file_read);
    for (index = 1; index <= n[0]; index++) {
      for (v = first_vertex; v <= last_vertex; v++)
	read_level_file(file_read, &i[v - MIN_VERTEX]);
      encode_cell_in_array(i, index, &min_index, n_sets, *set_list);
    }
  } else {
    reset_level_file(file_excluded);
    for (index = 1; index <= n[0]; index++) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, delta_missing_excluded))
	  read_level_file(file_excluded, &i[v - MIN_VERTEX]);
      }
      encode_cell_in_array(i, index, &min_index, n_sets, *set_list);
    }
  }
  sort_integer_array(min_index, min_index + (n[0] - 1) * *n_sets, *n_sets);
  for (index = 2; index <= n[0]; index++) {
    if (integer_array_less_than(min_index + (index - 2) * *n_sets,
				min_index + (index - 1) * *n_sets, *n_sets)) {
      if (print_table) {
	p_integer_list = *y;
	for (j = 0; j < *n_sets; j++) {
	  p_integer_list->x = n[min_index + (index - 2) * *n_sets + j];
	  p_integer_list = p_integer_list->pointer;
	}
	if (*sub_code == 1)
	  write_cell_list(*y, *set_list, a, &n_cell, n_sets, i,
			  marginal_percentages, b_offset, b);
	else
	  insert_cell_list(*y, *set_list, a, &n_cell, n_sets, i,
			   marginal_percentages, b_offset, b, ifail, sub_code,
			   arg_int, arg_double, i_int, stop_int, i_double,
			   stop_double);
      }
      *log_l += n_cell * log((double)n_cell);
      n_cell = 1;
    } else
      n_cell++;
  }
  if (print_table) {
    p_integer_list = *y;
    for (j = 0; j < *n_sets; j++) {
      p_integer_list->x = n[min_index + (n[0] - 1) * *n_sets + j];
      p_integer_list = p_integer_list->pointer;
    }
    if (*sub_code == 1) {
      write_cell_list(*y, *set_list, a, &n_cell, n_sets, i,
		      marginal_percentages, b_offset, b);
      write_line(stdout);
    } else
      insert_cell_list(*y, *set_list, a, &n_cell, n_sets, i,
		       marginal_percentages, b_offset, b, ifail, sub_code,
		       arg_int, arg_double, i_int, stop_int, i_double,
		       stop_double);
  }
  *log_l += n_cell * log((double)n_cell);
}  /* find_log_l_array */


Static Void find_log_l_large(a, print_table, log_l, marginal_percentages,
  b_offset, b, ifail, sub_code, arg_int, arg_double, i_int, stop_int,
  i_double, stop_double)
long *a;
boolean print_table;
t_long_real *log_l;
boolean marginal_percentages;
t_offset b_offset;
long *b;
t_integer *ifail, *sub_code;
long **arg_int;
double **arg_double;
t_integer *i_int, *stop_int, *i_double, *stop_double;
{
  t_vertex v;
  t_long_integer n_sets = 1, product = 1;
  t_set_list *set_list = NULL;
  t_integer_list *x = NULL, *y = NULL;

  if (mixed_data)
    note_mixed(stdout, " FindLogLLarge", 14L);
  insert_set_in_set_list(empty_set, &set_list);
  insert_integer_in_integer_list(0L, &x);
  insert_integer_in_integer_list(0L, &y);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      if (product > (double)MAX_COUNT_NUMBER /
		    variable_description[v - MIN_VERTEX]->UU.U0.levels) {
	insert_set_in_set_list(empty_set, &set_list);
	insert_integer_in_integer_list(0L, &x);
	insert_integer_in_integer_list(0L, &y);
	product = 1;
	n_sets++;
      }
      product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
      P_addset(set_list->vertex_set, v);
    }
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1523L, 2L)) {
    write_line(stdout);
    write_pch(stdout, " In HUGE  ", 10L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (case_list == NULL && !exclude_missing && space_for_case_list) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1523L, 2L)) {
      write_pch(stdout, " Making CASE-LIST   ", 20L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    make_case_list();
  }
  if (max_cell_number - fna < (n[0] + 1) * n_sets)
    find_log_l_file(a, print_table, &set_list, &x, &y, &n_sets, log_l,
		    marginal_percentages, b_offset, b, ifail, sub_code,
		    arg_int, arg_double, i_int, stop_int, i_double,
		    stop_double);
  else
    find_log_l_array(a, print_table, &set_list, &y, &n_sets, log_l,
		     marginal_percentages, b_offset, b, ifail, sub_code,
		     arg_int, arg_double, i_int, stop_int, i_double,
		     stop_double);
  /* x, */
  dispose_set_list(&set_list);
  dispose_integer_list(&x);
  dispose_integer_list(&y);
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1523L, 8L))
    return;
  /*$endif TRACE*/
  write_pch(stdout, " N sets  ", 9L);
  write_integer(stdout, n_sets, 5L);
  write_line(stdout);
}  /* find_log_l_large */


Static Void find_log_l_small(a, print_table, offset, log_l,
  marginal_percentages, b_offset, b, ifail, sub_code, arg_int, arg_double,
  i_int, stop_int, i_double, stop_double)
long *a;
boolean print_table;
t_long_integer offset;
t_long_real *log_l;
boolean marginal_percentages;
t_offset b_offset;
long *b;
t_integer *ifail, *sub_code;
long **arg_int;
double **arg_double;
t_long_integer *i_int, *stop_int, *i_double, *stop_double;
{
  t_cell i;
  t_vertex v;
  t_long_integer j, n_cell, k;
  t_long_real x;
  long FORLIM;

  memcpy(i, first_cell, sizeof(t_cell));
  FORLIM = offset + last_index(a);
  for (j = offset; j <= FORLIM; j++) {
    n_cell = n[j];
    if (print_table && n_cell != 0) {
      if (*sub_code > 0) {
	write_integer(stdout, n_cell, 10L);
	write_space(stdout, 2L);
      } else
	put_one_integer(arg_int, i_int, stop_int, &n_cell);
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  if (*sub_code > 0)
	    write_integer(stdout, i[v - MIN_VERTEX] + 1L, floor_x(
			    2 + log_10((double)variable_description[v - MIN_VERTEX]->
					       UU.U0.levels)));
	  else {
	    k = i[v - MIN_VERTEX] + 1;
	    put_one_integer(arg_int, i_int, stop_int, &k);
	  }
	}
      }
      if (marginal_percentages) {
	x = n_cell * 100.0 / n[b_offset + marginal_hash(b, i)];
	if (*sub_code > 0)
	  write_real(stdout, x, 8L, 2L);
	else
	  put_one_long_real(arg_double, i_double, stop_double, &x);
      }
      if (*sub_code > 0)
	write_line(stdout);
    }
    next_marginal_cell(a, i);
    if (n_cell != 0)
      *log_l += n_cell * log((double)n_cell);
  }
  if (print_table && *sub_code > 0)
    write_line(stdout);
}  /* find_log_l_small */


Static t_long_real find_log_l(a, print_table, ok, marginal_percentages,
  b_offset, b, as_argument, ifail, sub_code, arg_pos_int, arg_pos_double,
  nargs, arg_int, arg_double)
long *a;
boolean print_table, *ok, marginal_percentages;
t_offset b_offset;
long *b;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  t_vertex v;
  t_long_real log_l = 0.0;
  t_long_integer offset;
  t_offset_list *tmp_marginals = NULL;
  t_cell_index tmp_fna;
  t_integer i_int = 0, stop_int = 0, i_double = 0, stop_double = 0;

  if (*sub_code < 0 && *nargs != NULL) {
    stop_int = (*nargs)[arg_pos_int];
    stop_double = (*nargs)[arg_pos_double];
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1525L, 1L)) {
    write_pch(stdout, " FindLogL", 9L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (print_table && *sub_code > 0) {
    write_line(stdout);
    write_pch(stdout, "     Count", 10L);
    write_space(stdout, 2L);
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, a)) {
	write_space(stdout,
	  floor_x(1 + log_10((double)variable_description[v - MIN_VERTEX]->
				     UU.U0.levels)));
	print_vertex_on_file(stdout, v, 0L);
      }
    }
    write_line(stdout);
  }
  *ok = false;
  tmp_fna = fna;
  if (ok_to_find_marginal_hash(a)) {
    if (large_table(a, n))
      *ok = false;
    else
      offset = sub_find_marginal(a, &tmp_marginals, true, ok);
  }
  if (*ok) {
    find_log_l_small(a, print_table, offset, &log_l, marginal_percentages,
		     b_offset, b, ifail, sub_code, arg_int, arg_double,
		     &i_int, &stop_int, &i_double, &stop_double);
    dispose_tmp_marginals(&tmp_marginals, &tmp_fna);
  } else if (datastructure == list_file) {
#ifdef CoCo_Cygwin
    *ok = false;
#endif /* CoCo_Cygwin */
#ifndef NO_INT_FILE
    *ok = true;
    find_log_l_large(a, print_table, &log_l, marginal_percentages, b_offset,
		     b, ifail, sub_code, arg_int, arg_double, &i_int,
		     &stop_int, &i_double, &stop_double);
#endif /* NO_INT_FILE */
  }
  if (print_table && *sub_code < 0) {
    set_long_end(&i_int, ifail, arg_pos_int, nargs, arg_int);
    set_real_end(&i_double, ifail, arg_pos_double, nargs, arg_double);
  }
  return log_l;
}  /* find_log_l */


/*@+"logldis.p"*/


/*

1528:    +++  ++
1529:    +++  ++
1530:    ---  -- p/logldis.p          8      38     534 p/logldis.p
1531: |    4:    function find_log_l_d_complete
1532: |   87:    - function find_expression_log_l
1533: |  105:    function compute_log_l_d_complete
1534: |  116:    function find_log_l_d_ips_sub
1535: |  153:    function find_log_l_d_ips
1536: |  192:    function compute_log_l_d_ips
1537: |  204:    function find_log_l_r_ips
1538: |  255:    function compute_log_l_r_ips
1539:    +++  ++
1540:    +++  ++

*/

Static t_long_real find_log_l_d_complete(vertex_set, offset, found_offsets,
					 found_ps, ok)
long *vertex_set;
t_offset *offset;
boolean found_offsets, found_ps, *ok;
{
  t_long_real log_l_term = 0.0;
  t_integer index, stop, term, ifail, sub_code;
  t_vertex_set a;
  t_cell_index tmp_fna;
  t_offset_list *tmp_marginals = NULL;
  long *nargs, *arg_int;
  double *arg_double;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindLogLDComplete  ", sizeof(pch20));
  /*$endif TRACE*/
  P_setcpy(a, vertex_set);
  tmp_fna = fna;
  if (large) {
    conditional_dispose_both_marginals(&tmp_marginals);
    if (large_table(a, n))
      *ok = false;
    else
      index = sub_find_marginal(a, &tmp_marginals, true, ok);
  } else {
    if (found_ps) {
      if (found_offsets)
	index = *offset;
      else
	index = sub_find_marginal(a, &tmp_marginals, true, ok);
    } else {
      if (large_table(a, n))
	*ok = false;
      else
	index = sub_find_marginal(a, &tmp_marginals, true, ok);
    }
  }
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1533L, 1L, index, *offset, a);
  /*$endif TRACE*/
  if (*ok) {
    index--;
    stop = index + marginal_dimension(a);
    while (index < stop) {
      index++;
      term = n[index];
      if (term != 0)
	log_l_term += term * log((double)term);
    }
  } else {
    *ok = true;
    ifail = 0;
    sub_code = 1;
    if (permit_log_l) {
      /*$ifndef TRACE
               log_l_term := find_log_l(a, false, ok, false, -1, empty_set,
                                           false, ifail, sub_code, 0,
                                           0, nargs, arg_int, arg_double)
       $endifn TRACE*/
      /*$ifdef TRACE*/
      log_l_term = find_log_l(a, boolean_option[3], ok, false, -1L, empty_set,
			      false, &ifail, &sub_code, 0L, 0L, &nargs,
			      &arg_int, &arg_double);
      /*$endif TRACE*/
    } else
      *ok = false;
  }
  dispose_tmp_marginals(&tmp_marginals, &tmp_fna);
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1533L, 8L, stop, fna, &log_l_term);
  /*$endif TRACE*/
  return log_l_term;
}  /* find_log_l_d_complete */


/* Not used:
function find_expression_log_l
(    link_expression     : t_link_expression;
     found_offsets, found_ps : boolean;
 var ok     : boolean): t_long_real;
var
   log_l, log_l_term: t_long_real;
begin
   log_l := 0;
   while (link_expression <> nil) and ok do begin
      log_l_term := find_log_l_d_complete(link_expression^.vertex_set,
                                          link_expression^.offset,
                                          found_offsets, found_ps, ok);
      log_l := log_l + log_l_term * link_expression^.factor;
      link_expression := link_expression^.pointer
   end;
   find_expression_log_l := log_l
end; */
/* find_expression_log_l */

Static t_long_real compute_log_l_d_complete(d_complete_leaf, found_offsets,
					    found_ps, ok)
t_power_set **d_complete_leaf;
boolean found_offsets, found_ps, *ok;
{
  return (find_log_l_d_complete((*d_complete_leaf)->a,
				&(*d_complete_leaf)->offset, found_offsets,
				found_ps, ok));
      /* vertex_set */
}  /* compute_log_l_d_complete */


Static t_long_real find_log_l_d_ips_sub(ips_element, ok)
t_ips_element *ips_element;
boolean *ok;
{
  t_long_real log_l_term = 0.0;
  t_long_real prob;
  t_integer index, p_index, stop, term;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindLogLDIpsSub    ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1534L, 1L, -1L, -1L, *ok);
  /*$endif TRACE*/
  P_setcpy(a, ips_element->a);
  index = ips_element->n_offset - 1;
  p_index = ips_element->p_offset - 1;
  stop = index + marginal_dimension(a);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1534L, 1L, index, p_index, a);
  ntr_boolean(tzt, 20L, 1534L, 1L, -1L, -2L, *ok);
  /*$endif TRACE*/
  while (index < stop && *ok) {
    index++;
    p_index++;
    term = n[index];
    prob = p[p_index];
    if (prob == 0)
      *ok = (term == 0);
    else
      log_l_term += term * log(prob);
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1534L, 1L, index, p_index, *ok);
  ntr_real(tzt, 20L, 1534L, 8L, stop, 0L, &log_l_term);
  /*$endif TRACE*/
  return log_l_term;
}  /* find_log_l_d_ips_sub */


Static t_long_real find_log_l_d_ips(ips_element, tmp_fna, tmp_marginals,
				    found_ps, ok)
t_ips_element *ips_element;
t_cell_index *tmp_fna;
t_offset_list **tmp_marginals;
boolean *found_ps, *ok;
{
  double Result;
  t_vertex_set a;
  t_ips_set_list *link_gc;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindLogLDIps       ", sizeof(pch20));
  /*$endif TRACE*/
  P_setcpy(a, ips_element->a);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1535L, 1L, 1L, 1L, a);
  ntr_boolean(tzt, 20L, 1534L, 1L, -1L, -2L, *found_ps);
  ntr_boolean(tzt, 20L, 1534L, 1L, -1L, -3L, *ok);
  /*$endif TRACE*/
  if (large || !*found_ps) {
    conditional_dispose_both_marginals(tmp_marginals);
    ips_element->p_offset = 0;
    ips_element->n_offset = sub_find_marginal(ips_element->a, tmp_marginals,
					      true, ok);
    fpa += marginal_dimension(ips_element->a);
    if (!TURBO_PC)
      *ok = space_in_p_array(marginal_dimension(ips_element->a) * 2, fpa);
    if (marginal_dimension(ips_element->a) * 2 <= max_p_cell_number - fpa) {
      link_gc = ips_element->gen_class;
      while (link_gc != NULL && *ok) {
	link_gc->n_offset = sub_find_marginal(link_gc->vertex_set,
					      tmp_marginals, true, ok);
	link_gc = link_gc->pointer;
      }
    }
    if (*ok)
      ips_em(ips_element, n, ips_epsilon, &ips_max_it, true);
    fpa -= marginal_dimension(a);
  }
  if (ips_in_use == 1)
    ips_element->n_offset = sub_find_marginal(ips_element->a, tmp_marginals,
					      true, ok);
  Result = find_log_l_d_ips_sub(ips_element, ok);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1534L, 1L, -1L, -9L, *ok);
  /*$endif TRACE*/
  return Result;
}  /* find_log_l_d_ips */


/* Local variables for compute_log_l_d_ips: */
struct LOC_compute_log_l_d_ips {
  boolean found_ps;
} ;


Static t_long_real compute_log_l_d_ips(ips_element, tmp_fna, tmp_marginals,
				       found_ps_, ok)
t_ips_element **ips_element;
t_cell_index *tmp_fna;
t_offset_list **tmp_marginals;
boolean found_ps_, *ok;
{
  struct LOC_compute_log_l_d_ips Local_Var;

  Local_Var.found_ps = found_ps_;
  return (find_log_l_d_ips(*ips_element, tmp_fna, tmp_marginals,
			   &Local_Var.found_ps, ok));
}  /* compute_log_l_d_ips */


Static t_long_real find_log_l_r_ips(radim_element, found_ps, ok)
t_radim_element **radim_element;
boolean *found_ps, *ok;
{
  double Result;
  boolean ok_n, ok_p;
  t_e_p_cell_index tmp_fpa;
  t_list_ips_elements *tmp_ips_list;
  t_long_real log_l_term = 0.0;
  t_offset_list *tmp_marginals;
  t_cell_index tmp_fna;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindLogLRIps       ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1537L, 1L, -1L, -1L, *ok);
  /*$endif TRACE*/
  tmp_fpa = fpa;
  /* tmp_fpa := fpa; */
  if (large || !*found_ps) {
    tmp_fna = fna;
    tmp_marginals = NULL;
    find_of_one_radim_marginals_and_insert_offsets(*radim_element, &ok_n,
						   &ok_p, &fpa);
    if (ok_n && ok_p) {
      if ((*radim_element)->radim_parts != NULL)
	decomposed_ips_em(*radim_element, n, &ips_epsilon, &ips_max_it, true);
    } else
      *ok = false;
    dispose_tmp_marginals(&tmp_marginals, &tmp_fna);
  }
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1537L, 1L, fna, fpa, (*radim_element)->a);
  ntr_boolean(tzt, 20L, 1537L, 1L, -1L, -2L, *ok);
  /*$endif TRACE*/
  tmp_ips_list = (*radim_element)->ips_list;
  while (tmp_ips_list != NULL && *ok) {
    tmp_ips_list->ips_element.n_offset = sub_find_marginal(
	tmp_ips_list->ips_element.a, &tmp_marginals, true, ok);
    log_l_term += find_log_l_d_ips_sub(&tmp_ips_list->ips_element, ok);
    dispose_tmp_marginals(&tmp_marginals, &tmp_fna);
    tmp_ips_list = tmp_ips_list->pointer;
  }
  dispose_ips_list(&(*radim_element)->ips_list);
  Result = log_l_term;
  fpa = tmp_fpa;
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1537L, 1L, -1L, -3L, *ok);
  /* ;ntr_real(tzt, 20, 1537, 8, fna, fpa, log_l_term) */
  /*$endif TRACE*/
  return Result;
}  /* find_log_l_r_ips */


/* Local variables for compute_log_l_r_ips: */
struct LOC_compute_log_l_r_ips {
  boolean found_ps;
} ;


Static t_long_real compute_log_l_r_ips(radim_element, found_ps_, ok)
t_radim_element **radim_element;
boolean found_ps_, *ok;
{
  struct LOC_compute_log_l_r_ips Local_Var;

  Local_Var.found_ps = found_ps_;
  return (find_log_l_r_ips(radim_element, &Local_Var.found_ps, ok));
}  /* compute_log_l_r_ips */


/*@+"loglcon.p"*/


/*

1541:    +++  ++
1542:    +++  ++
1543:    ---  -- p/loglcon.p          6      30     369 p/loglcon.p
1544: |    3:    function sub_find_continuous_log_l
1545: |   80:    function test_cips_log_l
1546: |  142:    function find_log_l_c_complete
1547: |  169:    procedure adjust_gs
1548: |  214:    function find_log_l_c_ips
1549: |  270:    function compute_log_l_c_ips
1550:    +++  ++
1551:    +++  ++

*/

Static t_long_real sub_find_continuous_log_l(vertex_set, m1, m2, s_offset, s)
long *vertex_set;
t_integer *m1, *m2;
t_t_offset *s_offset;
t_t_r *s;
{
  /* var */
  t_long_real a;
  t_long_real l1 = 0.0;
  t_long_real det;
  t_integer q;
  t_offset offset = 0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/

  q = cardinality(vertex_set);

  /*$ifdef TRACE*/
  memcpy(tzt, " SubFindContinuousL ", sizeof(pch20));
  ntr_set(tzt, 20L, 1544L, 1L, q, n[0], vertex_set);
  /*$endif TRACE*/


  if (q <= 0)
    return l1;


  if (boolean_option[126]) {
    a = l1;
    /* l1 := l1 + (n[0] - 1) * q * LN_2_PI_HALF; */
    l1 -= n[0] * q * LN_2_PI_HALF;
    /*$ifdef TRACE*/
    ntr_double_real(tzt, 20L, 1544L, 2L, -1L, -1L, l1 - a, l1);
    /*$endif TRACE*/

  }

  else {
    /* The above term replaced by the following two terms ?!?!?!? */

    a = l1;
    l1 = -q * LN_2_PI_HALF;
    /*$ifdef TRACE*/
    ntr_double_real(tzt, 20L, 1544L, 3L, -1L, -1L, l1 - a, l1);
    /*$endif TRACE*/

    a = l1;
    l1 += n[0] * (q / 2.0 - 1) * log((double)n[0]);
    /*$ifdef TRACE*/
    ntr_double_real(tzt, 20L, 1544L, 4L, -1L, -1L, l1 - a, l1);
    /*$endif TRACE*/

  }


  a = l1;
  l1 -= n[0] * q / 2.0;
  /*$ifdef TRACE*/
  ntr_double_real(tzt, 20L, 1544L, 5L, -1L, -1L, l1 - a, l1);
  /*$endif TRACE*/

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1544L, 7L))
    write_headed_ssd_t(" SS:@@@@@@@@@@@@@@@@                    ", 4L,
		       vertex_set, offset, *s_offset, &s, *m1, *m2, NULL,
		       false, 1L, false);
  /*$endif TRACE*/

  /*$ifdef TRACE-ARRAY*/
  ntr_t_ref(&s, s_offset, *s_offset + *m2 - 1, " SubFindContLogL    ", 20L,
	    1544L, 1L);
  /*$endif TRACE-ARRAY*/
  det = s->z[*s_offset + *m2 - 1];
  det = n[0] * log(det) / -2;
  l1 += det;
  /*$ifdef TRACE*/
  ntr_double_real(tzt, 20L, 1544L, 6L, -1L, -1L, det, l1);
  /*$endif TRACE*/

  return l1;
}  /* sub_find_continuous_log_l */


Static t_long_real test_cips_log_l(a, ok)
long *a;
boolean *ok;
{
  t_t_offset r_offset, workspace_offset;
  t_t_r *r = NULL;   /* T_T, find_ghk_ */
  t_ss_offset ss_offset;
  t_ss_r *ss = NULL;   /* T_SS, find_ss */
  t_t_r *workspace = NULL;   /* T_T, return_tmp_t_space */
  t_long_real l1;
  t_offset n_offset = 0;
  t_integer m = 1;
  t_integer m1, m2;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " TestCipsLogL       ", sizeof(pch20));
  ntr_set(tzt, 20L, 1545L, 1L, -1L, -1L, a);
  /*$endif TRACE*/

  *ok = find_ghk_(a, true, true, true, &m1, &m2, &n_offset, &r_offset, &r);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1545L, 1L))
    write_headed_ssd_t(" ghK:@@@@@@@@@@@@@@@                    ", 5L, a,
		       n_offset, r_offset, &r, m1, m2, NULL, false, 1L,
		       false);
  /*$endif TRACE*/

  *ok = find_ss(a, &m1, &m2, &n_offset, &ss_offset, &ss);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1545L, 1L))
    write_headed_ssd_ss(" SS:@@@@@@@@@@@@@@@@                    ", 4L, a,
			n_offset, ss_offset, &ss, m1, m2, NULL, false, 1L,
			false);
  /*$endif TRACE*/

  if (*ok)
    *ok = return_tmp_t_space(m2, &workspace, &workspace_offset);
  if (boolean_option[91])
    l1 = sub_find_mips_deviance(&r, &r_offset, &ss, &ss_offset, &n_offset, &m,
				&m1, &m2);
  else
    l1 = sub_find_cips_deviance(a, &r, &r_offset, &ss, &ss_offset, &workspace,
				&workspace_offset, &m1, &m2);

  free_tmp_t_space();   /* size, workspace, workspace_offset */

/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1545L, 1L, -1L, 888L, &l1);
  /*$endif TRACE*/

  l1 = sub_find_continuous_log_l(a, &m1, &m2, &r_offset, r);

  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1545L, 8L, -1L, 999L, &l1);
  /*$endif TRACE*/

  return l1;
}  /* test_cips_log_l */


/* Not used:
function find_log_l_c_complete(var vertex_set : t_vertex_set;
                               var ok      : boolean): t_long_real;
var
   n_offset : t_offset;
   l1    : t_long_real;
   m1, m2   : t_integer;
   s_offset : t_s_offset;
   s    : t_s;
   t_offset : t_t_offset;
   t    : t_t;
begin
   r := nil;
   t := nil;
   l1 := test_cips_log_l(vertex_set, ok);

   l1 := 0;
   n_offset := 0;
   ok := find_determinants(vertex_set, m1, m2, n_offset, s_offset, s);
   if ok then begin
      t_offset := s_offset;
      new(t);
      t^.z := s^.z;
      l1 := sub_find_continuous_log_l(vertex_set, m1, m2, t_offset, t);
      dispose(t);
   end;
   find_log_l_c_complete := l1

end; */
/* find_log_l_c_complete */

Static Void adjust_gs(r, r_offset, n_offset, workspace, workspace_offset, m,
		      m1, m2, ok)
t_t_r **r;
t_t_offset *r_offset;
t_offset *n_offset;
t_t_r **workspace;
t_t_offset workspace_offset;
t_integer *m, *m1, *m2;
boolean *ok;
{
  t_integer i;
  t_long_real p = 1.0;
  t_long_real gamma_constant;
  t_t_r *ps = NULL, *determinants = NULL, *products = NULL;
      /* T_T, malloc_workspace */
  t_t_offset tmp_offset, ps_offset, determinants_offset, products_offset;
  /*$ifdef TRACE*/
  pch20 tzt;
  long FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " AdjustGs           ", sizeof(pch20));
  /*$endif TRACE*/
  gamma_constant = *m1 * LN_2_PI_HALF;
  tmp_offset = workspace_offset;
  malloc_workspace(workspace, &tmp_offset, &ps, &ps_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &determinants,
		   &determinants_offset, *m);
  malloc_workspace(workspace, &tmp_offset, &products, &products_offset, *m);
  /* -> m * (3) */
  find_determinants_and_products(m, m1, m2, n_offset, r, r_offset, workspace,
    tmp_offset, &determinants, &determinants_offset, &products,
    &products_offset, false, ok);
  if (!*ok)
    return;
  FORLIM = FIRST_INDEX + *m;
  for (i = FIRST_INDEX; i < FORLIM; i++) {
    ps->z[ps_offset + i] = (double)n[*n_offset + i] / n[0];
    /*$ifdef TRACE*/
    /*$endif TRACE*/
    ntr_real(tzt, 20L, 1547L, 1L, i, n[*n_offset + i], &ps->z[ps_offset + i]);
  }
  /* m1, */
  p_to_gs(p, &gamma_constant, m, m2, n_offset, r, r_offset, &ps, &ps_offset,
	  &determinants, &determinants_offset, &products, &products_offset);
  /* Catch ? */
}  /* adjust_gs */


Static t_long_real find_log_l_c_ips(link_element, model_set, ok)
t_cips_element **link_element;
long *model_set;
boolean *ok;
{
  boolean dummy_ok;
  t_t_r *workspace = NULL;   /* T_T, return_tmp_t_space */
  t_t_offset workspace_offset;
  t_long_real l1 = _INVALID_REAL;
  t_offset n_offset;
  t_integer m, m1, m2;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindLogLforCips    ", sizeof(pch20));
  /*$endif TRACE*/
  if (false) {   /* link_element^.complete */
    l1 = test_cips_log_l(model_set, ok);
    return_ghk_size(model_set, &m1, &m2);
    l1 = sub_find_continuous_log_l(model_set, &m1, &m2,
	&(*link_element)->r_offset, (*link_element)->r);
  } else {
    n_offset = 0;
    *ok = find_ss(model_set, &m1, &m2, &n_offset, &(*link_element)->ss_offset,
		  &(*link_element)->ss);
    m = 1;
    if (*ok) {
      *ok = return_tmp_t_space(m2, &workspace, &workspace_offset);
      /* Delete adjust_gs and sub_find_mips_deviance !!! */
      if (*ok) {
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1548L, 1L))
	  write_headed_ssd_t(" ghK (1):@@@@@@@@@@@                    ", 9L,
			     model_set, n_offset, (*link_element)->r_offset,
			     &(*link_element)->r, m1, m2, NULL, false, 1L,
			     false);
	/*$endif TRACE*/

	adjust_gs(&(*link_element)->r, &(*link_element)->r_offset, &n_offset,
		  &workspace, workspace_offset, &m, &m1, &m2, ok);

	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1548L, 1L))
	  write_headed_ssd_t(" ghK (2):@@@@@@@@@@@                    ", 9L,
			     model_set, n_offset, (*link_element)->r_offset,
			     &(*link_element)->r, m1, m2, NULL, false, 1L,
			     false);
	/*$endif TRACE*/

	l1 = sub_find_mips_deviance(&(*link_element)->r,
	    &(*link_element)->r_offset, &(*link_element)->ss,
	    &(*link_element)->ss_offset, &n_offset, &m, &m1, &m2);

	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1548L, 1L))
	  write_headed_ssd_t(" ghK (3):@@@@@@@@@@@                    ", 9L,
			     model_set, n_offset, (*link_element)->r_offset,
			     &(*link_element)->r, m1, m2, NULL, false, 1L,
			     false);
	/*$endif TRACE*/

	if (!boolean_option[91])
	  l1 = sub_find_cips_deviance(model_set, &(*link_element)->r,
	      &(*link_element)->r_offset, &(*link_element)->ss,
	      &(*link_element)->ss_offset, &workspace, &workspace_offset, &m1,
	      &m2);
	dummy_ok = free_tmp_t_space();
	    /* size, workspace, workspace_offset */
      }

    }
  }
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1548L, 9L, -1L, 999L, &l1);
  /*$endif TRACE*/
  return l1;
}  /* find_log_l_c_ips */


Static t_long_real compute_log_l_c_ips(link_element, model_set, ok)
t_cips_element **link_element;
long *model_set;
boolean *ok;
{
  return (find_log_l_c_ips(link_element, model_set, ok));
}  /* compute_log_l_c_ips */


/*@+"loglmix.p"*/

/*

1552:    +++  ++
1553:    +++  ++
1554:    ---  -- p/loglmix.p          9      46     587 p/loglmix.p
1555: |    4:    function sub_find_n_product
1556: |   40:    function sub_find_det_product
1557: |   82:    function find_det_product
1558: |  155:    function sub_find_mixed_products
1559: |  249:    function sub_find_m_ips_products
1560: |  288:    function find_m_ips_products
1561: |  297:    function compute_log_l_m_complete
1562: |  355:    function compute_log_l_c_complete
1563: |  360:    function compute_log_l_m_ips
1564:    +++  ++
1565:    +++  ++

*/

Static boolean sub_find_n_product(a, y, n_offset)
long *a;
t_long_real *y;
t_offset *n_offset;
{
  t_integer i, stop;
  boolean ok;

/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  *y = 0.0;
  i = *n_offset;
  stop = i + marginal_dimension(a) - 1;
  while (i <= stop) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1555L, 1L)) {
      write_pch(stdout, " N: ", 4L);
      write_integer(stdout, i, 4L);
      write_integer(stdout, n[i], 5L);
      write_real(stdout, *y, 10L, 4L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (n[i] > 0)
      *y += n[i] * log((double)n[i]);
    i++;
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1555L, 1L))
    return true;
  write_pch(stdout, " Y: ", 4L);
  write_space(stdout, 9L);
  write_real(stdout, *y, 10L, 4L);
  write_line(stdout);
  /*$endif TRACE*/
  return true;
}  /* sub_find_n_product */


Static boolean sub_find_det_product(a, x, y, m2, n_offset, s_offset, s)
long *a;
t_long_real *x, *y;
t_integer *m2;
t_offset *n_offset;
t_s_offset *s_offset;
t_s_r **s;
{
  /* m1, */
  t_integer i, stop;
  t_s_offset x_offset;
  t_vertex_set b;

  /* ok    : boolean; */
  /* ok := true; */
  *x = 0.0;
  *y = 0.0;
  x_offset = *s_offset + *m2 - 1;
  i = *n_offset;
  P_setint(b, a, delta);
  stop = i + marginal_dimension(b) - 1;
  while (i <= stop) {   /* and ok */
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1556L, 1L)) {
      write_pch(stdout, " Det: ", 6L);
      write_integer(stdout, i, 4L);
      write_integer(stdout, n[i], 5L);
      write_integer(stdout, x_offset, 4L);
      write_real(stdout, (*s)->z[x_offset], 10L, 4L);
      write_real(stdout, n[i] * log((*s)->z[x_offset]), 10L, 4L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (n[i] > 0) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ref(s, s_offset, x_offset, " SubFindDetProdukt  ", 20L, 1556L, 1L);
      /*$endif TRACE-ARRAY*/
      if ((*s)->z[x_offset] > 0)
	*x += n[i] * log((*s)->z[x_offset]);
      *y += n[i] * log((double)n[i]);
    }
    x_offset += *m2;
    i++;
  }
  return true;   /* ok */
}  /* sub_find_det_product */


Static boolean find_det_product(a, homogeneous, x, y)
long *a;
boolean *homogeneous;
t_long_real *x, *y;
{
  t_vertex_set b;
  boolean ok;
  t_integer count, m1, m2;
  t_offset n_offset;
  t_s_offset s_offset;
  t_s_r *s = NULL;   /* T_S, find_ssd */
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindDetProduct     ", sizeof(pch20));
  ntr_set_and_boolean(tzt, 20L, 1557L, 1L, -1L, -1L, a, *homogeneous);
  /*$endif TRACE*/
  P_setint(b, a, gamma_);
  if (P_setequal(b, empty_set)) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1557L, 1L, -2L, -1L);
    /*$endif TRACE*/
    n_offset = find_marginal(a, &ok);
    if (ok) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1557L, 1L, -3L, -1L);
      /*$endif TRACE*/
      ok = sub_find_n_product(a, y, &n_offset);
      if (ok) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1557L, 1L, -3L, -2L);
	/*$endif TRACE*/
	*x = 0.0;
	/*
	if not homogeneous then begin
	   count := count_continuous(a);
	   y := y * (1 + count / 2)
	end
	 */
      } else {
	if (note_warnings)
	  write_pch(stdout, " Note-2 (FindDetProduct): SubFindNprdct.", 40L);
      }
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1557L, 1L, -4L, -1L);
      /*$endif TRACE*/
      if (note_warnings) {
	write_pch(stdout, " Note-1 (FindDetProduct): FindMarginal.", 39L);
	write_line(stdout);
      }
    }
  } else {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1557L, 1L, -5L, -1L);
    /*$endif TRACE*/
    ok = find_ssd(a, &m1, &m2, &n_offset, &s_offset, &s);
    if (ok) {
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1557L, 1L, -5L, -2L, ok);
      /*$endif TRACE*/
      if (*homogeneous)   /* and false */
      {  /* ?!?!?, for ExaminTerms */
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1557L, 1L, -3L, -2L);
	/*$endif TRACE*/
	ok = find_determinant_of_sum(a, &m1, &m2, &n_offset, &s_offset, &s, x,
				     y);
	/*$ifdef TRACE*/
	ntr_boolean(tzt, 20L, 1557L, 1L, -6L, -1L, ok);
	/*$endif TRACE*/
	if (ok)
	  *x = *x * n[0] / 2;
	else {
	  if (note_warnings) {
	    write_pch(stdout, " Note-4 (FindDetProduct): FindDetOfSum.",
			39L);
	    write_line(stdout);
	  }
	}
      } else {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1557L, 1L, -7L, -1L);
	/*$endif TRACE*/
	ok = find_determinants(a, &m1, &m2, &n_offset, &s_offset, &s);
	/*$ifdef TRACE*/
	ntr_boolean(tzt, 20L, 1557L, 1L, -7L, -1L, ok);
	/*$endif TRACE*/
	if (ok)
	  ok = sub_find_det_product(a, x, y, &m2, &n_offset, &s_offset, &s);
	      /* m1, */
	/*$ifdef TRACE*/
	ntr_boolean(tzt, 20L, 1557L, 1L, -7L, -2L, ok);
	/*$endif TRACE*/
	if (ok) {
	  *x /= 2;
	  count = count_continuous(a);
	  *y *= 1 + count / 2.0;
	} else {
	  if (note_warnings) {
	    write_pch(stdout, " Note-5 (FindDetProduct): Non-homognous.",
			40L);
	    write_line(stdout);
	  }
	}
      }
    } else {
      if (note_warnings) {
	write_pch(stdout, " Note-3 (FindDetProduct): FindSsd.", 34L);
	write_line(stdout);
      }
    }
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1557L, 1L))
    return ok;
  if (P_setequal(b, empty_set))
    write_pch(stdout, " X, Y: ", 7L);
  else
    write_pch(stdout, " x, y: ", 7L);
  write_real(stdout, *x, print_width + 2, print_dec);
  write_real(stdout, *y, print_width + 2, print_dec);
  write_space(stdout, 3L);
  print_vertex_set(a);
  if (*homogeneous)
    write_pch(stdout, " homogen. ", 10L);
  write_space(stdout, 3L);
  if (!ok)
    write_pch(stdout, " Not OK ", 8L);
  /*$endif TRACE*/
  return ok;
}  /* find_det_product */


Static boolean sub_find_mixed_products(p, model_set, separator,
  full_specified, homogeneous, a, b, ifail)
t_mips_element *p;
long *model_set, *separator;
boolean *full_specified, *homogeneous;
t_long_real *a, *b;
t_integer *ifail;
{
  t_integer stop;
  t_long_real x, y;
  boolean ok = true;
  /*$ifdef TRACE*/
  t_set_list *mips_g_c;
  pch20 tzt;

  /*$endif TRACE*/
  *a = 0.0;
  *b = 0.0;
  if (p != NULL) {
    if (!P_setequal(separator, empty_set))
      note_error_sets(stdout, 1558L, 1L, " SubFindMixedProd.: ", model_set,
		      separator, false);
  }

  if ((!p->complete || boolean_option[117]) && !p->fund_ghk) {
    /*$ifdef TRACE*/
    mips_g_c = NULL;
    memcpy(tzt, " SubFindMixedProd.. ", sizeof(pch20));
    ntr_mixed_item(tzt, 20L, 1558L, 1L, 0L, 0L, p, &mips_g_c);   /* true, */
    /*$endif TRACE*/
    mips(&p, full_specified, homogeneous, model_set, n, mips_epsilon,
	 &mips_max_it, &p->fund_ghk);
    note_error_sets(stdout, 1558L, 2L, " SubFindMixedProd.: ", model_set,
		    separator, false);
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1558L, 1L)) {
    write_pch(stdout, " F ( I ", 7L);
    print_vertex_set(model_set);
    write_pch(stdout, " / ", 3L);
    print_vertex_set(separator);
    if (p->complete)
      write_pch(stdout, " % ", 3L);
    else
      write_pch(stdout, " : ", 3L);
    print_g_c_stop(p->discrete_, 21L, line_length, &stop);
    write_pch(stdout, " / ", 3L);
    print_g_c_stop(p->linear, 21L, line_length, &stop);
    write_pch(stdout, " / ", 3L);
    print_g_c_stop(p->quadratic, 21L, line_length, &stop);
    write_pch(stdout, " ) : ", 5L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (p->ifail == 0)
    ok = find_det_product(model_set, homogeneous, &x, &y);
  else {
    ok = false;
    *ifail = p->ifail;
  }
  if (!ok)
    return ok;
  *a += x;
  *b += y;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1558L, 1L)) {
    write_pch(stdout, " + a, b: ", 9L);
    write_real(stdout, *a, print_width + 2, print_dec);
    write_real(stdout, *b, print_width + 2, print_dec);
    write_space(stdout, 3L);
    print_vertex_set(model_set);
    write_line(stdout);
  }
  /*$endif TRACE*/
  ok = find_det_product(separator, homogeneous, &x, &y);
  if (!ok)
    return ok;
  *a -= x;
  *b -= y;
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1558L, 1L))
    return ok;
  /*$endif TRACE*/
  write_pch(stdout, " - A, B: ", 9L);
  write_real(stdout, *a, print_width + 2, print_dec);
  write_real(stdout, *b, print_width + 2, print_dec);
  write_space(stdout, 3L);
  print_vertex_set(separator);
  write_line(stdout);
  return ok;
}  /* sub_find_mixed_products */


Static boolean sub_find_m_ips_products(model, c, homogeneous, a, b, ifail)
t_model **model;
long *c;
boolean *homogeneous;
t_long_real *a, *b;
t_integer *ifail;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula, *separator;
  t_vertex_set c_left, c_right;
  boolean full_specified = false, ok = true;

  formula = (*model)->formula_node;
  if (formula == NULL)
    return ok;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    separator = decomposition_element->separator;
    if (P_subset(c, decomposition_element->right_model->id->vertices)) {
      P_setcpy(c_left, separator->UU.m_complete_leaf->a);
      P_setcpy(c_right, c);
    } else {
      P_setcpy(c_left, c);
      P_setcpy(c_right, separator->UU.m_complete_leaf->a);
    }
    ok = sub_find_m_ips_products(&decomposition_element->left_model, c_left,
				 homogeneous, a, b, ifail);
    if (ok)
      ok = sub_find_m_ips_products(&decomposition_element->right_model,
				   c_right, homogeneous, a, b, ifail);
    return ok;
  }
  if ((*model)->id->model_type == mixed)
    full_specified = (*model)->id->UU.U1.full_specified;
  if (formula->node_type == m_ips_node)
    ok = sub_find_mixed_products(formula->UU.m_ips_leaf,
	(*model)->id->vertices, c, &full_specified, homogeneous, a, b, ifail);
  return ok;
}  /* sub_find_m_ips_products */


/* Local variables for compute_log_l_m_complete: */
struct LOC_compute_log_l_m_complete {
  boolean homogeneous;
} ;


/* Not used:
function find_m_ips_products(var model     : t_link_model;
                             var homogeneous : boolean;
                             var a, b     : t_long_real;
                             var ifail     : t_integer): boolean;
begin
   find_m_ips_products := sub_find_m_ips_products(model, empty_set,
                                                  homogeneous, a, b, ifail);
end; */
/* find_m_ips_products */

Static t_long_real compute_log_l_m_complete(upper, homogeneous_)
long *upper;
boolean homogeneous_;
{
  struct LOC_compute_log_l_m_complete Local_Var;
  t_long_real a, b, log_l;
  /* min_count, */
  t_long_integer count;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.homogeneous = homogeneous_;
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  count = count_continuous(upper);

  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeMixedLogLSet", sizeof(pch20));
  ntr_set(tzt, 20L, 1561L, 1L, 0L, -1L, upper);
  ntr(tzt, 20L, 1561L, 1L, 0L, n[0]);
  ntr_boolean(tzt, 20L, 1561L, 1L, 0L, count, Local_Var.homogeneous);
  /*$endif TRACE*/

  log_l = -count * LN_2_PI_HALF;
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1561L, 4L, 1L, 0L, &log_l);
  /*$endif TRACE*/

  a = log_l;
  if (Local_Var.homogeneous)
    log_l += n[0] * log((double)n[0]) * (count / 2.0 - 2);
  else
    log_l -= n[0] * log((double)n[0]) * 2;
  /*$ifdef TRACE*/
  ntr_double_real(tzt, 20L, 1561L, 5L, 1L, 1L, log_l - a, log_l);
  /*$endif TRACE*/

  a = log_l;
  log_l -= n[0] * count / 2.0;   /* 4 */
  /*$ifdef TRACE*/
  ntr_double_real(tzt, 20L, 1561L, 6L, 1L, 3L, log_l - a, log_l);
  /*$endif TRACE*/

  /*
  n_offset := return_offset(upper, ok);
  min_count(upper, n_offset, min_count);
  if min_count < 1 then
     ifail := 40;
  */

  ok = find_det_product(upper, &Local_Var.homogeneous, &a, &b);
  if (ok)   /* 3 */
    log_l += b - a;
  /*$ifdef TRACE*/
  ntr_double_real(tzt, 20L, 1561L, 7L, 0L, 0L, a, b);
  ntr_double_real(tzt, 20L, 1561L, 8L, 1L, 4L, b - a, log_l);
  /*$endif TRACE*/

  if (ok)
    return log_l;
  else
    return _INVALID_REAL;
}  /* compute_log_l_m_complete */


Static t_long_real compute_log_l_c_complete(upper)
long *upper;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeLogLCComp.  ", sizeof(pch20));
  ntr_set(tzt, 20L, 1562L, 1L, -1L, -1L, upper);
  /*$endif TRACE*/
  return (compute_log_l_m_complete(upper, true));
}  /* compute_log_l_c_complete */


Static t_long_real compute_log_l_m_ips(link_element, model_set, ok)
t_mips_element **link_element;
long *model_set;
boolean *ok;
{
  t_integer m, m1, m2;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  m = marginal_dimension(model_set);
  return_ghk_size(model_set, &m1, &m2);
  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeLogLMIps    ", sizeof(pch20));
  ntr_4(tzt, 20L, 1563L, 1L, m, m1, m2, -1L);
  /*$endif TRACE*/
  if ((*link_element)->r != NULL)
    return (sub_find_mips_deviance(&(*link_element)->r,
	      &(*link_element)->r_offset, &(*link_element)->ss,
	      &(*link_element)->ss_offset, &(*link_element)->n_offset, &m,
	      &m1, &m2));
  else
    return _INVALID_REAL;
}  /* compute_log_l_m_ips */


/*@+"xsquare.p"*/


/*

1566:    +++  ++
1567:    +++  ++
1568:    ---  -- p/xsquare.p          3      13     218 p/xsquare.p
1569: |    4:    procedure note_p_value
1570: |   35:    procedure compute_x_deviance_and_x_pearson_g_offset
1571: |  144:    procedure compute_x_deviance_and_x_pearson
1572:    +++  ++
1573:    +++  ++

*/

Static Void note_p_value(p1, p2, g, i, index)
t_long_real *p1, *p2;
long *g;
t_level *i;
t_long_integer *index;
{
  t_vertex v;

  write_pch_20_text(report_file, " :: Log(Q): ", 12L);
  write_pch_20_text(report_file, "  P<1>(i): ", 11L);
  if (*p1 == LONG_MAX)
    write_pch_20_text(report_file, " Undef.      ", 13L);
  else
    write_real_text(report_file, *p1, 13L, 10L);
  write_pch_20_text(report_file, "  P<2>(i): ", 11L);
  if (*p2 == LONG_MAX)
    write_pch_20_text(report_file, " Undef.      ", 13L);
  else
    write_real_text(report_file, *p2, 13L, 10L);
  write_pch_10_text(report_file, "  n(i): ", 8L);
  write_cell_count_text(report_file, &n[*index], 8L);
  write_line_text(report_file);
  write_pch_20_text(report_file, " :: Log(Q): ", 12L);
  write_pch_10_text(report_file, "  DELTA: ", 9L);
  print_vertex_set_on_report(report_file, g);
  write_pch_20_text(report_file, "  SUCC(i): ", 11L);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, g))
      write_integer_text(report_file, i[v - MIN_VERTEX] - FIRST_LEVEL + 1L,
			 3L);
  }
  write_line_text(report_file);
}  /* note_p_value */


Static Void compute_x_deviance_and_x_pearson_g_offset(current_model,
  base_model, g, g_offset, x_deviance, x_pearson, x_power)
t_model **current_model, **base_model;
long *g;
t_long_integer g_offset;
t_long_real *x_deviance, *x_pearson, *x_power;
{
  t_long_real ln_p2_p1, p1, p2, x;
  t_cell i;
  t_long_integer index, stop;
  boolean ok_1 = true, ok_2 = true;
  t_product_list *link_prod_list;
  t_v_arr_of_integer levels;
  t_vertex l_a_vertex;
  t_vertex_set vertex_set;
  t_expression *link_c_expression, *link_b_expression;
  t_list_ips_elements *link_c_ips_list, *link_b_ips_list;
  /*$ifdef TRACE*/
  pch20 tzt;
  double TEMP;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeXdevianceA. ", sizeof(pch20));
  /*$endif TRACE*/
  *x_deviance = _INVALID_REAL;
  *x_power = _INVALID_REAL;
  *x_pearson = _INVALID_REAL;
  if ((*current_model)->found_log_l && (*base_model)->found_log_l &&
      (em || !((*current_model)->found_ps && (*base_model)->found_ps))) {
    if (!(is_invalid_real((*current_model)->log_l) |
	  is_invalid_real((*base_model)->log_l)))
      *x_deviance = ddiff(&(*base_model)->log_l, &(*current_model)->log_l);
    return;
  }
  *x_deviance = 0.0;
  *x_pearson = 0.0;
  *x_power = 0.0;
  memcpy(i, first_cell, sizeof(t_cell));
  index = g_offset - 1;
  stop = index + marginal_dimension(g);
  return_expression_and_ips_list(current_model, &link_c_expression,
				 &link_c_ips_list, !em);
  return_expression_and_ips_list(base_model, &link_b_expression,
				 &link_b_ips_list, !em);
  /* *** ToDo: Check for identical ips-elements!!! *** */
  find_product_list_2(g, &link_c_expression, &link_c_ips_list,
		      &link_b_expression, &link_b_ips_list, &link_prod_list,
		      levels, &l_a_vertex);
  add_to_offsets(link_c_expression, link_c_ips_list, (long)FIRST_INDEX);
  add_to_offsets(link_b_expression, link_b_ips_list, (long)FIRST_INDEX);
  while (index < stop && (ok_1 || ok_2)) {
    index++;
    p1 = compute_p_fast(&(*current_model)->constant, link_c_expression,
			link_c_ips_list);
    p2 = compute_p_fast(&(*base_model)->constant, link_b_expression,
			link_b_ips_list);
    /*$ifdef TRACE*/
    ntr_double_real(tzt, 20L, 1570L, 4L, stop, index, p1, p2);
    /*$endif TRACE*/
    if (0 < p1 && p1 <= 1 && p2 <= 1) {
      x = 1 / p1;
      TEMP = p1 - p2;
      *x_pearson += TEMP * TEMP * x;
    } else if (n[index] != 0)
      ok_2 = false;
    if (0 < p1 && p1 <= 1 && 0 < p2 && p2 <= 1) {
      ln_p2_p1 = log(p2 * x);
      *x_power += p2 * (exp(ln_p2_p1 * lambda) - 1);
      *x_deviance += n[index] * ln_p2_p1;
    } else if (n[index] != 0)
      ok_1 = false;
    /*$ifdef TRACE*/
    ntr_real(tzt, 20L, 1570L, 8L, stop, index, x_deviance);
    /*$endif TRACE*/
    next_offset_in_exp_list_2(&link_c_expression, &link_c_ips_list,
			      &link_b_expression, &link_b_ips_list,
			      &link_prod_list, levels, &l_a_vertex, i);
  }
  add_to_offsets(link_c_expression, link_c_ips_list, (long)(-FIRST_INDEX));
  add_to_offsets(link_b_expression, link_b_ips_list, (long)(-FIRST_INDEX));
  dismiss_expression_and_ips_list(&link_c_expression, &link_c_ips_list);
  dismiss_expression_and_ips_list(&link_b_expression, &link_b_ips_list);
  dispose_product_list(&link_prod_list);
  P_setdiff(vertex_set, delta, g);
  x = marginal_dimension_real(vertex_set);
  if (!(ok_1 && ok_2))
    note_p_value(&p1, &p2, g, i, &index);
  if (ok_1)
    *x_deviance = 2 * *x_deviance;
  else
    *x_deviance = _INVALID_REAL;
  if (ok_1) {
    *x_power = n[0] * 2 * x * *x_power;
    *x_power /= lambda * (lambda + 1);
  } else
    *x_power = _INVALID_REAL;
  if (ok_2)
    *x_pearson = n[0] * *x_pearson * x;
  else
    *x_pearson = _INVALID_REAL;
}  /* compute_x_deviance_and_x_pearson_g_offset */


Static Void compute_x_deviance_and_x_pearson(current_model, base_model, g,
					     x_deviance, x_pearson, x_power)
t_model **current_model, **base_model;
long *g;
t_long_real *x_deviance, *x_pearson, *x_power;
{
  boolean ok = true;
  t_long_integer g_offset = -1;

  if (em)
    write_warning_em(stdout, 1571L, " ComputeXdevianceA. ");
  if (!em && (*current_model)->found_ps && (*base_model)->found_ps ||
      !((*current_model)->found_log_l && (*base_model)->found_log_l))
    g_offset = return_offset(g, &ok);
  if (ok) {
    compute_x_deviance_and_x_pearson_g_offset(current_model, base_model, g,
      g_offset, x_deviance, x_pearson, x_power);
    return;
  }
  *x_deviance = _INVALID_REAL;
  *x_power = _INVALID_REAL;
  *x_pearson = _INVALID_REAL;
}  /* compute_x_deviance_and_x_pearson */


/*@+"xsquaref.p"*/


/*

1574:    +++  ++
1575:    +++  ++
1576:    ---  -- p/xsquaref.p         1       4      76 p/xsquaref.p
1577: |    4:    procedure compute_full_x_deviance_and_x_pearson
1578:    +++  ++
1579:    +++  ++

*/

Static Void compute_full_x_deviance_and_x_pearson(model, g, x_deviance,
						  x_pearson, x_power)
t_model **model;
long *g;
t_long_real *x_deviance, *x_pearson, *x_power;
{
  t_long_real ln_p2_p1, p1, p2, marg_dim_g_comp;
  t_cell i;
  t_long_integer index, stop;
  boolean ok_1 = true, ok_2 = true;
  t_product_list *link_prod_list;
  t_v_arr_of_integer levels;
  t_vertex l_a_vertex;
  t_vertex_set vertex_set;
  t_expression *link_expression;
  t_list_ips_elements *link_ips_list;
  double TEMP;

  if (em) {
    *x_deviance = _INVALID_REAL;
    *x_power = _INVALID_REAL;
    *x_pearson = _INVALID_REAL;
    return;
  }
  *x_deviance = 0.0;
  *x_pearson = 0.0;
  *x_power = 0.0;
  memcpy(i, first_cell, sizeof(t_cell));
  index = return_offset(g, &ok_1) - 1;
  stop = index + marginal_dimension(g);
  P_setdiff(vertex_set, delta, g);
  marg_dim_g_comp = marginal_dimension_real(vertex_set);
  return_expression_and_ips_list(model, &link_expression, &link_ips_list, !em);
  find_product_list(g, &link_expression, &link_ips_list, &link_prod_list,
		    levels, &l_a_vertex);
  add_to_offsets(link_expression, link_ips_list, (long)FIRST_INDEX);
  while (index < stop && (ok_1 || ok_2)) {
    index++;
    p1 = compute_p_fast(&(*model)->constant, link_expression, link_ips_list);
    p2 = (double)n[index] / n[0] / marg_dim_g_comp;
    if (0 < p1 && p1 <= 1 && 0 < p2 && p2 <= 1) {
      ln_p2_p1 = log(p2 / p1);
      *x_power += p2 * (exp(ln_p2_p1 * lambda) - 1);
      *x_deviance += n[index] * ln_p2_p1;
    } else if (n[index] != 0)
      ok_1 = false;
    if (0 < p1 && p1 <= 1 && p2 <= 1) {
      TEMP = p1 - p2;
      *x_pearson += TEMP * TEMP / p1;
    } else if (n[index] != 0)
      ok_2 = false;
    next_offset_in_exp_list(&link_expression, &link_ips_list, &link_prod_list,
			    levels, &l_a_vertex, i);
  }
  add_to_offsets(link_expression, link_ips_list, (long)(-FIRST_INDEX));
  dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
  dispose_product_list(&link_prod_list);
  if (!(ok_1 && ok_2))
    note_p_value(&p1, &p2, g, i, &index);
  if (ok_1)
    *x_deviance = 2 * *x_deviance;
  else
    *x_deviance = _INVALID_REAL;
  if (ok_1)
    *x_power = 2 * *x_power / lambda / (lambda + 1) * n[0] * marg_dim_g_comp;
  else
    *x_power = _INVALID_REAL;
  if (ok_2)
    *x_pearson = n[0] * *x_pearson * marg_dim_g_comp;
  else
    *x_pearson = _INVALID_REAL;
}  /* compute_full_x_deviance_and_x_pearson */


/* 65536 */

#define max_par         _INFINITY_SHORT


/*@+"rmodel.p"*/


/*

1580:    +++  ++
1581:    +++  ++
1582:    ---  -- p/rmodel.p          9      47     586 p/rmodel.p
1583: |    2:    function return_model_parity
1584: |   24:    procedure insert_link_model_in_2_3_tree
1585: |   41:    procedure insert_link_model_in_internal_list
1586: |   56:    procedure copy_model
1587: |   95:    procedure insert_link_model
1588: |  129:    procedure find_model_in_2_3_tree
1589: |  158:    function sub_return_model
1590: |  171:    function found_model
1591: |  273:    function return_model
1592:    +++  ++
1593:    +++  ++

*/

Static t_long_integer return_id_parity(id)
t_model_specification **id;
{
  t_long_integer sum;

  if ((*id)->model_type == pure_discrete)
    sum = add_parity_terms((*id)->UU.g_c_log_linear, (long)max_par);
  else if ((*id)->model_type == pure_continuous)
    sum = add_parity_terms((*id)->UU.g_c_covariance, (long)max_par);
  else if ((*id)->model_type == mixed)
    sum = return_triple_gc_parity(&(*id)->UU.U1.g_c_discrete,
	&(*id)->UU.U1.g_c_linear, &(*id)->UU.U1.g_c_quadratic);
  sum += add_parity_terms((*id)->causal_structure, (long)max_par);
  return (sum % max_par);
}  /* return_id_parity */

#undef max_par


/* 65536 */

#define max_par         _INFINITY_SHORT


Static t_long_integer return_double_parity(id_a, id_b)
t_model_specification **id_a, **id_b;
{
  t_long_integer sum;

  sum = return_id_parity(id_a) + return_id_parity(id_b);
  return (sum % max_par);
}  /* return_double_parity */

#undef max_par


Static t_long_integer return_model_parity(model)
t_model **model;
{
  t_long_integer sum;

  sum = return_id_parity(&(*model)->id);
  /*$ifdef TRACE*/
  ntr_model_g_c(" ReturnModelParitet ", 20L, 1583L, 8L, -1L, sum, model);
  /*$endif TRACE*/
  return sum;
}  /* return_model_parity */


/*Has-forward-2*/

Static Void proc_return_model_parity(model, parity)
t_model **model;
t_long_integer *parity;
{

  /*Has-forward-2*/

  /* No-forward

procedure proc_return_model_parity(var model  : t_link_model;
                                     var parity : t_long_integer);

    No-forward */
  *parity = return_model_parity(model);
}  /* return_model_parity */


Static Void insert_link_model_in_2_3_tree(x, key)
t_model_list **x;
t_long_integer *key;
{
  t_2_3_element element;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertLinkMdlIn-2-3", sizeof(pch20));
  ntr(tzt, 20L, 1584L, 1L, 0L, 0L);
  if (trace_flag[TRACE_FLAG_FACTOR * 1584])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  ntr(tzt, 20L, 1584L, 1L, 0L, 1L);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (boolean_option[2]) {
    write_pch_40_text(report_file, " ## insert_link_model_in_2_3_tree:@@@@@ ",
		      35L);
    write_integer_text(report_file, *key, 8L);
  }
  /*$endif TRACE*/
  element.tree_type = model_tree;
  element.UU.model_element = *x;
  element.key = *key;
  /*$ifdef TRACE*/
  insert_in_2_3_tree(&element, &model_2_3_tree);
  ntr(tzt, 20L, 1584L, 1L, 0L, 888L);
  if (trace_flag[TRACE_FLAG_FACTOR * 1584])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  ntr(tzt, 20L, 1584L, 1L, 0L, 999L);
  /*$endif TRACE*/
}  /* insert_link_model_in_2_3_tree */


Static Void insert_link_model_in_internal_list(p)
t_model_list **p;
{
  t_list_of_model_lists *q;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertLinkMdlInInte", sizeof(pch20));
  ntr(tzt, 20L, 1585L, 1L, 0L, 0L);
  /*$endif TRACE*/
  q = (t_list_of_model_lists *)Malloc(sizeof(t_list_of_model_lists));
  if (q == NULL)
    _OutMem();
  q->model_number = (*p)->model->model_number;
  q->model_list = *p;
  q->pointer = internal_model_list;
  if (internal_model_list == NULL)
    q->model_number = 1;
  else
    q->model_number = internal_model_list->model_number + 1;
  internal_model_list = q;
}  /* insert_link_model_in_internal_list */


Static Void copy_model(model, new_model)
t_model **model, **new_model;
{
  erase_model(new_model, (*model)->id->model_type, true);

  (*new_model)->copy = true;
  (*new_model)->model_number = (*model)->model_number;

  (*new_model)->found_log_l = (*model)->found_log_l;

  (*new_model)->graphical = (*model)->graphical;
  (*new_model)->decomposable = (*model)->decomposable;
  (*new_model)->log_l = (*model)->log_l;

  (*new_model)->dim = (*model)->dim;
  (*new_model)->dimdec = (*model)->dimdec;
  (*new_model)->model_ifail = (*model)->model_ifail;

  (*new_model)->constant = (*model)->constant;

  (*new_model)->id->paritet = (*model)->id->paritet;
  P_setcpy((*new_model)->id->vertices, (*model)->id->vertices);

  (*new_model)->formula_node = NULL;
  (*new_model)->found_expression = false;   /* model^.false_expression  ; */
  (*new_model)->found_ps = false;   /* model^.found_ps          ; */

  if ((*model)->id->model_type == pure_discrete)
    copy_set_list((*model)->id->UU.g_c_log_linear,
		  &(*new_model)->id->UU.g_c_log_linear);
  else if ((*model)->id->model_type == pure_continuous)
    copy_set_list((*model)->id->UU.g_c_covariance,
		  &(*new_model)->id->UU.g_c_covariance);
  else {
    (*new_model)->id->UU.U1.full_specified = (*model)->id->UU.U1.full_specified;
    (*new_model)->id->UU.U1.homogeneous = (*model)->id->UU.U1.homogeneous;
    (*new_model)->id->UU.U1.decompose = (*model)->id->UU.U1.decompose;
    copy_set_list((*model)->id->UU.U1.g_c_discrete,
		  &(*new_model)->id->UU.U1.g_c_discrete);
    copy_set_list((*model)->id->UU.U1.g_c_linear,
		  &(*new_model)->id->UU.U1.g_c_linear);
    copy_set_list((*model)->id->UU.U1.g_c_quadratic,
		  &(*new_model)->id->UU.U1.g_c_quadratic);
  }

  copy_set_list((*model)->id->causal_structure,
		&(*new_model)->id->causal_structure);
}  /* copy_model */


Static Void insert_link_model(p, model)
t_model_list **p;
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  (*model)->id->paritet = return_model_parity(model);
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertModel        ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1587L, 1L, -1L, 0L, model);
  ntr_model_numbers(tzt, 20L, 1587L, 1L, -1L, 1L, model);
  /*$endif TRACE*/
  *p = (t_model_list *)Malloc(sizeof(t_model_list));
  if (*p == NULL)
    _OutMem();
  new_model(&(*p)->model);
  copy_model(model, &(*p)->model);
  if (internal_model_list == NULL)
    (*p)->model->model_number = 1;
  else
    (*p)->model->model_number = internal_model_list->model_list->model->
				model_number + 1;
  (*p)->pointer = NULL;
  if (!boolean_option[113])
    insert_link_model_in_2_3_tree(p, &(*model)->id->paritet);
  /*$ifdef TRACE*/
  insert_link_model_in_internal_list(p);
  ntr_model_g_c(tzt, 20L, 1587L, 8L, -1L, 997L, &(*p)->model);
  ntr_model_numbers(tzt, 20L, 1587L, 8L, -1L, 998L, &(*p)->model);
  ntr_set(tzt, 20L, 1587L, 8L, -1L, 999L, (*model)->id->vertices);
  /*$endif TRACE*/
}  /* insert_link_model */


Static Void find_model_in_2_3_tree(key, p)
t_2_3_key *key;
t_model_list **p;
{
  t_2_3_leaf *result;

  /*$ifdef TRACE*/
  if (boolean_option[2]) {
    write_pch_30_text(report_file, " ## find_model_in_2_3_tree:@@ ", 28L);
    write_integer_text(report_file, *key, 8L);
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  }
  /*$endif TRACE*/
  *p = NULL;
  if (model_2_3_tree != NULL) {
    find_in_2_3_tree(&model_2_3_tree, *key, &result);
    if (result != NULL)
      *p = result->UU.model_list;
  }
  /*$ifdef TRACE*/
  if (!boolean_option[2])
    return;
  /*$endif TRACE*/
  if (*p == NULL)
    write_pch_20_text(stdout, " <> not found <> ", 17L);
  else
    write_pch_10_text(stdout, "<> found", 8L);
  write_line_stdout();
}  /* find_model_in_2_3_tree */


Static boolean identical_ids(id_a, id_b)
t_model_specification **id_a, **id_b;
{
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  ok = ((*id_a)->model_type == (*id_b)->model_type);
  /*$ifdef TRACE*/
  memcpy(tzt, " IdenticalIds       ", sizeof(pch20));
  ntr_id(tzt, 20L, 1590L, 1L, -1L, 0L, id_a);
  ntr_id(tzt, 20L, 1590L, 1L, -1L, 1L, id_b);
  /*$endif TRACE*/
  if (ok)
    ok = P_setequal((*id_a)->vertices, (*id_b)->vertices);
  if (ok) {
    if ((*id_b)->model_type == pure_discrete)
      ok = identical_g_c((*id_a)->UU.g_c_log_linear,
			 (*id_b)->UU.g_c_log_linear);
    else if ((*id_b)->model_type == pure_continuous)
      ok = identical_g_c((*id_a)->UU.g_c_covariance,
			 (*id_b)->UU.g_c_covariance);
    else {
      ok = ((*id_a)->UU.U1.homogeneous == (*id_b)->UU.U1.homogeneous);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1590L, 2L, -1L, -1L, ok);
      /*$endif TRACE*/
      if (ok)
	ok = ((*id_a)->UU.U1.full_specified == (*id_b)->UU.U1.full_specified);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1590L, 2L, -1L, 0L, ok);
      /*$endif TRACE*/
      if (ok)
	ok = identical_g_c((*id_a)->UU.U1.g_c_discrete,
			   (*id_b)->UU.U1.g_c_discrete);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1590L, 2L, -1L, 1L, ok);
      /*$endif TRACE*/
      if (ok)
	ok = identical_g_c((*id_a)->UU.U1.g_c_linear,
			   (*id_b)->UU.U1.g_c_linear);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 1590L, 3L, -1L, 2L, ok);
      /*$endif TRACE*/
      if (ok) {
	ok = identical_g_c((*id_a)->UU.U1.g_c_quadratic,
			   (*id_b)->UU.U1.g_c_quadratic);
	/*$ifdef TRACE*/
      }
      ntr_boolean(tzt, 20L, 1590L, 4L, -1L, 3L, ok);
      /*$endif TRACE*/
    }
  }
  if (ok)
    return (identical_g_c((*id_a)->causal_structure,
			  (*id_b)->causal_structure));
  else
    return false;
}  /* identical_ids */


/*$endif TRACE*/

Local boolean found_model(search_model, model)
t_model **search_model, **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FoundModel         ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1590L, 1L, -1L, 0L, model);
  ntr_model_g_c(tzt, 20L, 1590L, 1L, -1L, 1L, search_model);
  /*$endif TRACE*/
  return (identical_ids(&(*search_model)->id, &(*model)->id));
}  /* found_model */


Static boolean sub_return_model(search_model, p, model)
t_model **search_model;
t_model_list **p;
t_model **model;
{
  boolean Result, found;
  t_long_integer i, paritet;
  t_2_3_key key;
  t_model_list *q;
  t_list_of_model_lists *qq;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$ifdef TRACE*/
  memcpy(tzt, " SubReturnModel     ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1589L, 1L, -1L, 0L, model);
  ntr_model_g_c(tzt, 20L, 1589L, 1L, -1L, 1L, search_model);
  /*$endif TRACE*/
  if (re_use_test) {
    found = false;
    paritet = return_model_parity(search_model);
    if (!boolean_option[113]) {
      key = paritet;
      find_model_in_2_3_tree(&key, &q);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1589L, 2L, key, paritet);
      i = 0;   /* ntr */
      /*$endif TRACE*/
      while (q != NULL && !found) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1589L, 3L, 9999L, i);   /* ntr */
	i++;   /* ntr */
	/*$endif TRACE*/
	if (q->model != NULL) {
	  if (q->model->id != NULL) {
	    if (paritet == q->model->id->paritet)
	      found = found_model(search_model, &q->model);
	    /*$ifdef TRACE*/
	    ntr_boolean(tzt, 20L, 1589L, 3L, paritet, q->model->id->paritet,
			found);
		/* ntr */
	    /*$endif TRACE*/
	  }
	  /*$ifdef TRACE*/
	  else
	    ntr(tzt, 20L, 1589L, 3L, 8888L, i);
	} else {
	  /* ntr */
	  /*$endif TRACE*/
	  ntr(tzt, 20L, 1589L, 3L, 7777L, i);
	}
	/* ntr */
	if (found)
	  *p = q;
	else
	  q = q->pointer;
      }
    } else {
      qq = internal_model_list;
      while (qq != NULL && !found) {
	*p = qq->model_list;
	if ((*p)->model != NULL) {
	  if ((*p)->model->id != NULL) {
	    if (paritet == (*p)->model->id->paritet)
	      found = found_model(search_model, &(*p)->model);
	  }
	}
	if (!found)
	  qq = qq->pointer;
      }
    }
    found = ((*model)->found_log_l && found);
    if (found) {
      _Free((*model)->id);
      dispose_model_link(model);
      *model = (*p)->model;
      /* p^.pointer := nil */
    }
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 1589L, 4L, 2L, 1L, (*model)->found_log_l);
    ntr_boolean(tzt, 20L, 1589L, 4L, 2L, 2L, found);
    ntr_model_numbers(tzt, 20L, 1589L, 4L, 2L, 3L, model);
    if (found)
      ntr_model_numbers(tzt, 20L, 1589L, 4L, 2L, 4L, &(*p)->model);
    /*$endif TRACE*/
    Result = ((*model)->found_log_l && found);
  } else {
    Result = false;
    /*$ifdef TRACE*/
  }
  ntr_model_g_c(tzt, 20L, 1589L, 8L, -1L, 998L, model);
  /*$endif TRACE*/
  ntr_model_g_c(tzt, 20L, 1589L, 8L, -1L, 999L, search_model);
  return Result;
}  /* sub_return_model */


Static boolean return_model(search_model, p)
t_model **search_model;
t_model_list **p;
{
  t_model *returned_model;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnModel        ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1591L, 1L, -1L, 0L, search_model);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1591L, 2L)) {
    write_model_type(search_model);
    write_line(stdout);
  }
  /*$endif TRACE*/
  new_model(&returned_model);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1591L, 2L)) {
    write_model_type(search_model);
    write_line(stdout);
  }
  /*$endif TRACE*/
  erase_model(&returned_model, (*search_model)->id->model_type, true);
  ok = sub_return_model(search_model, p, &returned_model);
  /*$ifdef TRACE*/
  ntr_model_numbers(tzt, 20L, 1591L, 8L, -1L, 996L, &returned_model);
  /*$endif TRACE*/
  if (!ok) {
    _Free(returned_model->id);
    dispose_model_link(&returned_model);
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1591L, 8L, -1L, 997L, ok);
  if (ok)
    ntr_model_numbers(tzt, 20L, 1591L, 8L, -1L, 998L, &(*p)->model);
  /*$endif TRACE*/
  return ok;
}  /* return_model */


/*@+"offsets.p"*/


/*

1639:    +++  ++
1640:    +++  ++
1641:    ---  -- p/offsets.p         19      87    1294 p/offsets.p
1642: |    4:    function ok_to_find_radim_part
1643: |   25:    function sub_ok_to_find_marginals
1644: |   62:    function ok_to_find_model_marginals
1645: |   67:    procedure sub_find_ips_marginals_and_insert_offsets
1646: |  108:    procedure sub_find_marginals_and_insert_offsets
1647: |  164:    procedure find_marginals_and_insert_offsets
1648: |  197:    procedure find_complete_marginals_and_insert_offsets
1649: |  214:    procedure sub_insert_marginals_in_list
1650: |  259:    procedure insert_marginals_in_list
1651: |  266:    procedure test_expression_marginals
1652: |  305:    procedure test_expression_marginals_one
1653: |  338:    procedure test_of_one_radim_marginals_and_insert_offsets
1654: |  428:    function sub_test_ips_space
1655: |  458:    function sub_test_model_space
1656: |  508:    function test_model_space
1657: |  513:    procedure find_offsets_and_marginals
1658: |  538:    procedure find_decomposable_offsets_and_marginals
1659: |  546:    procedure sub_clear_offsets
1660: |  581:    procedure clear_offsets
1661:    +++  ++
1662:    +++  ++

*/

Static boolean ok_to_find_radim_part(upper, lower)
t_offset_list *upper, *lower;
{
  boolean ok = true;
  t_vertex_set vertex_set;

  if (lower == NULL) {
    if (upper != NULL)
      ok = ok_to_find_marginal_hash(upper->vertex_set);
    return ok;
  }
  P_setunion(vertex_set, upper->vertex_set, lower->vertex_set);
  ok = ok_to_find_marginal_hash(vertex_set);
  upper = upper->pointer;
  while (upper != NULL && ok) {
    P_setunion(vertex_set, upper->vertex_set, lower->vertex_set);
    ok = ok_to_find_marginal_hash(vertex_set);
    upper = upper->pointer;
    lower = lower->pointer;
  }
  return ok;
}  /* ok_to_find_radim_part */


Static boolean sub_ok_to_find_marginals(model)
t_model **model;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;
  boolean ok = false;

  formula = (*model)->formula_node;
  if (formula == NULL)
    return ok;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    ok = sub_ok_to_find_marginals(&decomposition_element->left_model);
    if (ok)
      ok = sub_ok_to_find_marginals(&decomposition_element->right_model);
    return ok;
  }
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    ok = ok_to_find_marginal_hash(formula->UU.d_complete_leaf->a);
    /* vertex_set */
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    ok = ok_to_find_marginal_hash(formula->UU.d_ips_leaf->a);
    break;

  case r_ips_node:
    if (formula->UU.r_ips_leaf->radim_parts != NULL)
      ok = ok_to_find_radim_part(formula->UU.r_ips_leaf->radim_parts->upper,
				 formula->UU.r_ips_leaf->radim_parts->lower);
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    /* blank case */
    break;
  }
  return ok;
}  /* sub_ok_to_find_marginals */


Static boolean ok_to_find_model_marginals(model)
t_model **model;
{
  return (sub_ok_to_find_marginals(model));
}  /* ok_to_find_marginals */


Static Void sub_find_ips_marginals_and_insert_offsets(ips_element, ok_n, ok_p,
						      tmp_fpa, max, s)
t_ips_element *ips_element;
boolean *ok_n, *ok_p;
t_e_p_cell_index *tmp_fpa;
t_long_integer *max, *s;
{
  t_ips_set_list *pp;
  t_long_integer m;
  t_long_integer m1 = 0;
  t_long_integer m2;

  if (em)
    write_warning_em(stdout, 1645L, " SubFindIpsMargAnd. ");
  ips_element->p_offset = *tmp_fpa;
  if (ips_in_use != 1)
    ips_element->n_offset = return_offset(ips_element->a, ok_n);
  m = marginal_dimension(ips_element->a);
  if (m < MAX_P_CELL_NUMBER_MAX - *tmp_fpa)
    *tmp_fpa += m;
  else
    *ok_p = false;
  pp = ips_element->gen_class;
  while (pp != NULL && *ok_n) {
    pp->n_offset = return_offset(pp->vertex_set, ok_n);
    m2 = marginal_dimension(pp->vertex_set);
    if (m2 > m1)
      m1 = m2;
    pp = pp->pointer;
  }
  *s += m;
  if (ips_in_use == 1)
    m1 += m;
  if (mean_ips_in_use != normal_ips)
    m1 += m;
  if (m1 < MAX_P_CELL_NUMBER_MAX - *s) {
    if (*s + m1 > *max)
      *max = *s + m1;
  } else
    *ok_p = false;
}  /* sub_find_ips_marginals_and_insert_offsets */


Static Void sub_find_marginals_and_insert_offsets(model, complete, ips, ok_n,
						  ok_p, tmp_fpa, max, s)
t_model **model;
boolean *complete, *ips, *ok_n, *ok_p;
t_e_p_cell_index *tmp_fpa;
t_long_integer *max, *s;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula, *separator;

  if (em)
    write_warning_em(stdout, 1646L, " SubFindMarginals.. ");
  formula = (*model)->formula_node;
  if (formula == NULL)
    return;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    sub_find_marginals_and_insert_offsets(&decomposition_element->left_model,
      complete, ips, ok_n, ok_p, tmp_fpa, max, s);
    sub_find_marginals_and_insert_offsets(&decomposition_element->right_model,
      complete, ips, ok_n, ok_p, tmp_fpa, max, s);
    separator = decomposition_element->separator;
    switch (separator->node_type) {

    case d_complete_node:
      separator->UU.d_complete_leaf->offset = return_offset(
	  separator->UU.d_complete_leaf->a, ok_n);
	  /* vertex_set */
      break;

    case c_complete_node:
      /* blank case */
      break;

    /*
    separator^.c_complete_leaf^.offset :=
    return_offset(separator^.c_complete_leaf^.a, ok_n) */
    case m_complete_node:
      break;
      /*
      separator^.m_complete_leaf^.offset :=
      return_offset(separator^.m_complete_leaf^.a, ok_n) */
    }
    return;
  }
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    if (*complete)
      formula->UU.d_complete_leaf->offset = return_offset(
	  formula->UU.d_complete_leaf->a, ok_n);
	  /* vertex_set */
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    if (*ips)
      sub_find_ips_marginals_and_insert_offsets(formula->UU.d_ips_leaf, ok_n,
						ok_p, tmp_fpa, max, s);
    break;

  case r_ips_node:
    if (*ips)
      find_of_one_radim_marginals_and_insert_offsets(formula->UU.r_ips_leaf,
						     ok_n, ok_p, tmp_fpa);
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    /* blank case */
    break;
  }
}  /* sub_find_marginals_and_insert_offsets */


/* Local variables for find_marginals_and_insert_offsets: */
struct LOC_find_marginals_and_insert_offsets {
  boolean complete, ips;
} ;


Static Void find_marginals_and_insert_offsets(model, complete_, ips_, ok_n, ok_p)
t_model **model;
boolean complete_, ips_, *ok_n, *ok_p;
{
  struct LOC_find_marginals_and_insert_offsets Local_Var;
  t_e_p_cell_index tmp_fpa;
  t_long_integer max = 0, s = 0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.complete = complete_;
  Local_Var.ips = ips_;
  /*$ifdef TRACE*/
  memcpy(tzt, " FindMarginalsAndIn.", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1646L, 1L, 1L, fpa, Local_Var.complete);
  ntr_boolean(tzt, 20L, 1646L, 1L, 2L, fpa, Local_Var.ips);
  /*$endif TRACE*/
  *ok_n = true;
  *ok_p = true;
  tmp_fpa = fpa;
  sub_find_marginals_and_insert_offsets(model, &Local_Var.complete,
    &Local_Var.ips, ok_n, ok_p, &tmp_fpa, &max, &s);
  if (*ok_p && !TURBO_PC)
    *ok_p = space_in_p_array(max, tmp_fpa);
  if (*ok_p)
    *ok_p = (max <= max_p_cell_number - tmp_fpa);
  if (*ok_n && *ok_p) {
    fpa = tmp_fpa;
    /*$ifdef TRACE*/
  }
  ntr_boolean(tzt, 20L, 1646L, 8L, max, s, *ok_n);
  ntr_boolean(tzt, 20L, 1646L, 8L, tmp_fpa, fpa, *ok_n);
  /*$endif TRACE*/
}  /* find_marginals_and_insert_offsets */


Static Void find_complete_marginals_and_insert_offsets(model, ok_n)
t_model **model;
boolean *ok_n;
{
  boolean complete = true, ips = false, ok_p = true;
  t_e_p_cell_index tmp_fpa;
  t_long_integer max = 0, s = 0;

  *ok_n = true;
  tmp_fpa = fpa;
  sub_find_marginals_and_insert_offsets(model, &complete, &ips, ok_n, &ok_p,
					&tmp_fpa, &max, &s);
}  /* find_complete_marginals_and_insert_offsets */


Static Void sub_insert_marginals_in_list(model, complete, ips, link_set_list)
t_model **model;
boolean *complete, *ips;
t_set_list **link_set_list;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;
  t_ips_set_list *p;

  formula = (*model)->formula_node;
  if (formula == NULL)
    return;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    sub_insert_marginals_in_list(&decomposition_element->left_model, complete,
				 ips, link_set_list);
    sub_insert_marginals_in_list(&decomposition_element->right_model,
				 complete, ips, link_set_list);
    return;
  }
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    if (*complete)   /* vertex_set */
      insert_set_in_list_of_marginals_to_find(formula->UU.d_complete_leaf->a,
					      link_set_list);
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    if (*ips) {
      if (ips_in_use != 1)
	insert_set_in_list_of_marginals_to_find(formula->UU.d_ips_leaf->a,
						link_set_list);
      p = formula->UU.d_ips_leaf->gen_class;
      while (p != NULL) {
	insert_set_in_list_of_marginals_to_find(p->vertex_set, link_set_list);
	p = p->pointer;
      }
    }
    break;

  case r_ips_node:   /* ?!?!? */
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    /* blank case */
    break;
  }
}  /* sub_insert_marginals_in_list */


/* Local variables for insert_marginals_in_list: */
struct LOC_insert_marginals_in_list {
  boolean complete, ips;
} ;


Static Void insert_marginals_in_list(model, complete_, ips_, link_set_list)
t_model **model;
boolean complete_, ips_;
t_set_list **link_set_list;
{
  struct LOC_insert_marginals_in_list Local_Var;

  Local_Var.complete = complete_;
  Local_Var.ips = ips_;
  sub_insert_marginals_in_list(model, &Local_Var.complete, &Local_Var.ips,
			       link_set_list);
}  /* insert_marginals_in_list */


Static Void test_expression_marginals(current_model, base_model, g, ok)
t_model **current_model, **base_model;
long *g;
boolean *ok;
{
  t_long_integer dimension_g;
  t_set_list *marginal_list;

  if (mixed_data && ((*current_model)->id->model_type != pure_discrete ||
		     (*base_model)->id->model_type != pure_discrete)) {
    /* note_mixed(output, ' TestExpressionMar..', 20); */
    *ok = false;
  } else {
    if (datastructure != all) {
      marginal_list = NULL;
      if (ok_to_find_marginal_hash(g)) {
	dimension_g = marginal_dimension(g);
	if (!TURBO_PC)
	  *ok = space_in_n_array(dimension_g, fna);
	if (dimension_g <= max_cell_number - fna)
	  insert_set_in_list_of_marginals_to_find(g, &marginal_list);
	else
	  *ok = false;
      } else
	*ok = false;
      if (*ok) {
	insert_marginals_in_list(current_model, true, false, &marginal_list);
	insert_marginals_in_list(base_model, true, false, &marginal_list);
	find_list_of_marginals(&marginal_list, ok);
      }
      dispose_set_list(&marginal_list);
    }
  }
  if (*ok) {
    find_complete_marginals_and_insert_offsets(current_model, ok);
    find_complete_marginals_and_insert_offsets(base_model, ok);
  }
}  /* test_expression_marginals */


Static Void test_expression_marginals_one(model, g, ok)
t_model **model;
long *g;
boolean *ok;
{
  t_long_integer dimension_g;
  t_set_list *marginal_list;

  if (mixed_data && (*model)->id->model_type != pure_discrete) {
    /* note_mixed(output, ' TestExpressionM.One', 20); */
    *ok = false;
  } else {
    if (datastructure != all) {
      marginal_list = NULL;
      if (ok_to_find_marginal_hash(g)) {
	dimension_g = marginal_dimension(g);
	if (!TURBO_PC)
	  *ok = space_in_n_array(dimension_g, fna);
	if (dimension_g <= max_cell_number - fna)
	  insert_set_in_list_of_marginals_to_find(g, &marginal_list);
	else
	  *ok = false;
      } else
	*ok = false;
      if (*ok) {
	insert_marginals_in_list(model, true, false, &marginal_list);
	find_list_of_marginals(&marginal_list, ok);
      }
      dispose_set_list(&marginal_list);
    }
  }
  if (*ok)
    find_complete_marginals_and_insert_offsets(model, ok);
}  /* test_expression_marginals_one */


Static Void test_of_one_radim_marginals_and_insert_offsets(radim_element, ok)
t_radim_element *radim_element;
boolean *ok;
{
  t_long_integer m, tmp_fpa, max_m;
  t_vertex_set a;
  t_radim_part *radim_part;
  t_offset_list *generators, *upper, *lower;
  boolean ok_n = true;

  if (em)
    write_warning_em(stdout, 1653L, " TestOfOneRadimMarg.");
  *ok = true;
  tmp_fpa = fpa;
  radim_part = radim_element->radim_parts;
  if (radim_part != NULL) {
    generators = radim_part->generators;
    while (generators != NULL && ok_n) {
      generators->offset = return_offset(generators->vertex_set, &ok_n);
      generators = generators->pointer;
    }
    upper = radim_part->upper;
    lower = radim_part->lower;
    P_setunion(a, upper->vertex_set, lower->vertex_set);
    upper->offset = tmp_fpa;
    lower->offset = return_offset(a, &ok_n);
    m = marginal_dimension(a);
    if (m < MAX_P_CELL_NUMBER_MAX - tmp_fpa)
      tmp_fpa += m;
    else
      *ok = false;
    upper = upper->pointer;
    lower = lower->pointer;
    max_m = m;
    while (upper != NULL && *ok) {
      P_setunion(a, upper->vertex_set, lower->vertex_set);
      upper->offset = tmp_fpa;
      lower->offset = return_offset(a, &ok_n);
      m = marginal_dimension(a);
      if (m < MAX_P_CELL_NUMBER_MAX - tmp_fpa)
	tmp_fpa += m;
      else
	*ok = false;
      if (m > max_m)
	max_m = m;
      upper = upper->pointer;
      lower = lower->pointer;
    }
    radim_part = radim_part->pointer;
  }
  m = max_m;
  if (ips_in_use == 1)
    m += tmp_fpa - fpa;
  if (m < MAX_P_CELL_NUMBER_MAX - fpa)
    tmp_fpa += m;
  else
    *ok = false;
  if (*ok && !TURBO_PC)
    *ok = space_in_p_array(tmp_fpa, 0L);
  if (*ok) {
    while (radim_part != NULL && ok_n) {
      generators = radim_part->generators;
      while (generators != NULL && ok_n) {
	generators->offset = return_offset(generators->vertex_set, &ok_n);
	generators = generators->pointer;
      }
      upper = radim_part->upper;
      lower = radim_part->lower;
      P_setunion(a, upper->vertex_set, lower->vertex_set);
      lower->offset = return_offset(a, &ok_n);
      upper = upper->pointer;
      lower = lower->pointer;
      while (upper != NULL) {
	P_setunion(a, upper->vertex_set, lower->vertex_set);
	lower->offset = return_offset(a, &ok_n);
	upper = upper->pointer;
	lower = lower->pointer;
      }
      radim_part = radim_part->pointer;
    }
  }
  *ok = (*ok && ok_n);
  /*$ifdef TRACE*/
  if (!*ok && (boolean_option[3] || boolean_option[4] || boolean_option[5] ||
	       boolean_option[21])) {
    /*$endif TRACE*/
    write_warning(stdout, " Out of space in TestRadimSpace.", 32L);
  }
}  /* test_of_one_radim_marginals_and_insert_offsets */


Static boolean sub_test_ips_space(ips_element)
t_ips_element *ips_element;
{
  t_long_integer m, mp1, mp2;
  boolean ok = true;
  t_ips_set_list *link_gc;

  m = marginal_dimension(ips_element->a);
  mp1 = m;
  if (ips_in_use == 1)
    mp1 += m;
  if (mean_ips_in_use != normal_ips)
    mp1 += m;
  link_gc = ips_element->gen_class;
  while (link_gc != NULL && ok) {
    mp2 = marginal_dimension(link_gc->vertex_set);
    m += mp2;
    if (!TURBO_PC) {
      space_in_p_array(mp1 + mp2, 0L);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    }
    ok = (mp1 + mp2 <= max_p_cell_number);
    if (ok && !TURBO_PC)
      ok = space_in_n_array(m, fna);
    ok = (m <= max_cell_number - fna && ok);
    link_gc = link_gc->pointer;
  }
  return ok;
}  /* sub_test_ips_space */


Static boolean sub_test_model_space(model)
t_model **model;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;
  boolean ok = true;

  formula = (*model)->formula_node;
  if (formula == NULL)
    return ok;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    ok = sub_test_model_space(&decomposition_element->left_model);
    if (ok)
      ok = sub_test_model_space(&decomposition_element->right_model);
    return ok;
  }
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    ok = ok_to_find_marginal_hash(formula->UU.d_complete_leaf->a);
	/* vertex_set */
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    ok = sub_test_ips_space(formula->UU.d_ips_leaf);
    /*$ifdef TRACE*/
    if (!ok && (boolean_option[3] || boolean_option[4] || boolean_option[5] ||
		boolean_option[21]))
      write_warning(stdout, " Out of space in TestIpsSpace.", 30L);
    /*$endif TRACE*/
    break;

  case r_ips_node:
    test_of_one_radim_marginals_and_insert_offsets(formula->UU.r_ips_leaf, &ok);
    /*$ifdef TRACE*/
    if (!ok && (boolean_option[3] || boolean_option[4] || boolean_option[5] ||
		boolean_option[21]))
      write_warning(stdout, " Out of space in TestRadSpace.", 30L);
    /*$endif TRACE*/
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    /* blank case */
    break;
  }
  return ok;
}  /* sub_test_model_space */


Static boolean test_model_space(model)
t_model **model;
{
  return (sub_test_model_space(model));
}  /* test_model_space */


Static Void find_offsets_and_marginals(model, expression_marginals, ok_n, ok_p)
t_model **model;
boolean expression_marginals, *ok_n, *ok_p;
{
  t_set_list *marginal_list;

  if (mixed_data && (*model)->id->model_type != pure_discrete) {
    *ok_n = false;
    *ok_p = false;
    return;
  }
  *ok_p = true;
  if (datastructure != all) {
    marginal_list = NULL;
    insert_marginals_in_list(model, expression_marginals, true,
			     &marginal_list);
    find_list_of_marginals(&marginal_list, ok_n);
    dispose_set_list(&marginal_list);
  } else
    *ok_n = true;
  if (*ok_n)
    find_marginals_and_insert_offsets(model, expression_marginals, true, ok_n,
				      ok_p);
}  /* find_offsets_and_marginals */


Static Void find_decomposable_offsets_and_marginals(model, ok)
t_model **model;
boolean *ok;
{
  boolean dummy_ok;

  find_offsets_and_marginals(model, true, ok, &dummy_ok);
}


Static Void sub_clear_offsets(model, node_type)
t_model **model;
t_formula_node_type *node_type;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;

  formula = (*model)->formula_node;
  if (formula == NULL)
    return;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    sub_clear_offsets(&decomposition_element->left_model, node_type);
    sub_clear_offsets(&decomposition_element->right_model, node_type);
    return;
  }
  if (formula->node_type != *node_type && null_node != *node_type)
    return;
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    formula->UU.d_complete_leaf->offset = -1;
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    /* formula^.d_ips_leaf^.p_offset := max_offset */
    formula->UU.d_ips_leaf = NULL;
    break;

  case r_ips_node:
    formula->UU.r_ips_leaf = NULL;
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    /* blank case */
    break;
  }
}  /* sub_clear_offsets */


Static Void clear_offsets(model, node_type)
t_model **model;
t_formula_node_type node_type;
{
  sub_clear_offsets(model, &node_type);
}  /* clear_offsets */


/*@+"estimate.p"*/


/*

1594:    +++  ++
1595:    +++  ++
1596:    ---  -- p/estimate.p         9      40     506 p/estimate.p
1597: |    4:    procedure sub_sub_estimate_model
1598: |   81:    procedure sub_estimate_model
1599: |  110:    procedure estimate_model
1600: |  116:    function find_empty_det_product
1601: |  128:    function sub_sub_compute_log_l
1602: |  185:    function sub_compute_log_l
1603: |  286:    function compute_log_l_
1604: |  337:    function compute_log_l
1605: |  343:    function compute_decomposable_log_l
1606:    +++  ++
1607:    +++  ++

*/

Static Void sub_sub_estimate_model(model, formula)
t_model **model;
t_formula_node **formula;
{
  t_integer m1, m2;
  t_offset n_offset;   /* ?!?!?!? */
  /*$ifdef TRACE*/
  t_set_list *mips_g_c;
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubSubEstimateMo.. ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1597L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  switch ((*formula)->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    /* blank case */
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1597L, 1L, -2L, -1L);
    /*$endif TRACE*/
    if (!(*formula)->UU.d_ips_leaf->radim_part)
      ips_em((*formula)->UU.d_ips_leaf, n, ips_epsilon, &ips_max_it, true);
    break;

  case r_ips_node:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1597L, 1L, -3L, -1L);
    /*$endif TRACE*/
    if ((*formula)->UU.r_ips_leaf->radim_parts != NULL)
      decomposed_ips_em((*formula)->UU.r_ips_leaf, n, &ips_epsilon,
			&ips_max_it, true);
    break;

  case c_ips_node:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1597L, 1L, -4L, -1L);
    /*$endif TRACE*/
    if (!(*formula)->UU.c_ips_leaf->fund_ghk) {
      if (true) {   /* formula^.c_ips_leaf^.complete */
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1597L, 1L, -4L, -2L);   /* true, */
	/*$endif TRACE*/
	/*$ifdef TRACE*/
	inverted_cips(&(*formula)->UU.c_ips_leaf,
		      &(*model)->id->UU.g_c_covariance,
		      (*model)->id->vertices, n, cips_epsilon, &cips_max_it,
		      &(*formula)->UU.c_ips_leaf->fund_ghk);
	ntr(tzt, 20L, 1597L, 1L, -8L, (*formula)->UU.c_ips_leaf->r_offset);
	/*$endif TRACE*/
      } else {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1597L, 1L, -4L, -3L);
	/*$endif TRACE*/
	(*formula)->UU.c_ips_leaf->fund_ghk = find_ghk_(
	    (*model)->id->vertices, true, true, true, &m1, &m2, &n_offset,
	    &(*formula)->UU.c_ips_leaf->r_offset,
	    &(*formula)->UU.c_ips_leaf->r);
	/* formula^.c_ips_leaf^.upper */
      }
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1597L, 1L, -4L, -9L);
    /*$endif TRACE*/
    break;

  case m_ips_node:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1597L, 1L, -5L, -1L);
    /*$endif TRACE*/
    if (!(*formula)->UU.m_ips_leaf->fund_ghk) {
      if (!(*formula)->UU.m_ips_leaf->complete || boolean_option[117]) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1597L, 1L, -5L, -2L);
	/*$endif TRACE*/
	/* set_min_max_log_l_of_mixed_item(p^); */
	/*$ifdef TRACE*/
	mips_g_c = NULL;
	ntr_mixed_item(tzt, 20L, 1597L, 1L, 0L, 0L, (*formula)->UU.m_ips_leaf,
		       &mips_g_c);
	    /*ntr*/
	/*$endif TRACE*/
	/* true, */
	mips(&(*formula)->UU.m_ips_leaf, &(*model)->id->UU.U1.full_specified,
	     &(*model)->id->UU.U1.homogeneous, (*model)->id->vertices, n,
	     mips_epsilon, &mips_max_it,
	     &(*formula)->UU.m_ips_leaf->fund_ghk);
      } else {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1597L, 1L, -5L, -3L);
	/*$endif TRACE*/
	(*formula)->UU.m_ips_leaf->fund_ghk = find_ghk_((*model)->id->vertices,
	    true, true, true, &m1, &m2, &(*formula)->UU.m_ips_leaf->n_offset,
	    &(*formula)->UU.m_ips_leaf->r_offset,
	    &(*formula)->UU.m_ips_leaf->r);
	/* formula^.m_ips_leaf^.upper */
      }
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1597L, 1L, -5L, -9L);
    /*$endif TRACE*/
    break;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1597L, 1L, -9L, -9L);
  /*$endif TRACE*/
  (*model)->found_ps = true;
}  /* sub_sub_estimate_model */


Static Void sub_estimate_model(model)
t_model **model;
{
  t_decomposition_element *decomposition_element;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubEstimateModel   ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1598L, 1L, -1L, -1L, model);
  if (trace_flag[TRACE_FLAG_FACTOR * 1598])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  if ((*model)->formula_node != NULL) {
    if ((*model)->formula_node->node_type == decomposition_node) {
      decomposition_element = (*model)->formula_node->UU.decomposition_node_;
      sub_estimate_model(&decomposition_element->left_model);
      sub_estimate_model(&decomposition_element->right_model);
      (*model)->found_ps = true;   /* 2004-06-25: ? */
      /*$ifdef TRACE*/
      switch (decomposition_element->separator->node_type) {

      case d_complete_node:
	ntr(tzt, 20L, 1598L, 3L, -2L, -1L);
	break;

      case c_complete_node:
	ntr(tzt, 20L, 1598L, 3L, -2L, -2L);
	break;

      case m_complete_node:
	ntr(tzt, 20L, 1598L, 3L, -2L, -3L);
	break;
      }
      /*$endif TRACE*/
    } else
      sub_sub_estimate_model(model, &(*model)->formula_node);
  }
  /*$ifdef TRACE*/
  ntr_model_numbers(tzt, 20L, 1598L, 8L, -1L, -1L, model);
  if (trace_flag[TRACE_FLAG_FACTOR * 1598])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
}  /* sub_estimate_model */


Static Void estimate_model(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " EstimateModel      ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1599L, 1L, -1L, -1L, model);
  if (trace_flag[TRACE_FLAG_FACTOR * 1599])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  sub_estimate_model(model);
  ntr_model_numbers(tzt, 20L, 1599L, 8L, -1L, -1L, model);
  if (trace_flag[TRACE_FLAG_FACTOR * 1599])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
}  /* estimate_model */


/* Local variables for find_empty_det_product: */
struct LOC_find_empty_det_product {
  boolean homogeneous;
} ;


Static t_long_real find_empty_det_product(homogeneous_)
boolean homogeneous_;
{
  struct LOC_find_empty_det_product Local_Var;
  t_long_real x, y, z;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.homogeneous = homogeneous_;
  /*$ifdef TRACE*/
  memcpy(tzt, " FindEmptyDetProd.  ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1600L, 1L, -1L, -1L, Local_Var.homogeneous);
  /*$endif TRACE*/
  ok = find_det_product(empty_set, &Local_Var.homogeneous, &x, &y);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1600L, 1L, -1L, -1L, ok);
  z = x - y;
  ntr_real(tzt, 20L, 1600L, 1L, -9L, -9L, &z);
  /*$endif TRACE*/
  if (ok)
    return (x - y);
  else
    return _INVALID_REAL;
}  /* find_empty_det_product */


Static t_long_real sub_sub_compute_log_l(model, ifail, formula,
					 found_offsets_and_ps)
t_model **model;
t_integer *ifail;
t_formula_node **formula;
boolean *found_offsets_and_ps;
{
  t_cell_index tmp_fna;
  t_offset_list *tmp_marginals;
  boolean ok = true;
  t_long_real l = 0.0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /* _invalid_real */
  /*$ifdef TRACE*/
  memcpy(tzt, " SubSubComputeLogL  ", sizeof(pch20));
  ntr(tzt, 20L, 1601L, 1L, (*model)->model_ifail, *ifail);
  ntr_model_g_c(tzt, 20L, 1601L, 1L, -1L, -1L, model);
  ntr_model_numbers(tzt, 20L, 1601L, 1L, -1L, -1L, model);
  ntr_model_formula(tzt, 20L, 1601L, 2L, -1L, -1L, *model);
  /*$endif TRACE*/
  if (!(*model)->found_ps && !*found_offsets_and_ps) {
    /* This was removed october 13-18 2003 when working with pure
       discrete models. Put back oktober 24 2003 to handle non-
       decomposable mixed models in count mixed. */
    sub_sub_estimate_model(model, formula);
  }
  *ifail = 0;
  switch ((*formula)->node_type) {

  case decomposition_node:
    /* blank case */
    break;

  case null_node:
    /* blank case */
    break;

  case d_complete_node:
    l = compute_log_l_d_complete(&(*formula)->UU.d_complete_leaf,
	*found_offsets_and_ps, (*model)->found_ps || *found_offsets_and_ps,
	&ok);
    l += find_empty_det_product(true);   /* model^.id^.homogeneous */
    l -= n[0] * log((double)n[0]);
    /*$ifdef TRACE*/
    ntr_real(tzt, 20L, 1601L, 3L, -1L, -1L, &l);
    /*$endif TRACE*/
    break;

  case c_complete_node:
    l = compute_log_l_c_complete((*formula)->UU.c_complete_leaf->a);
    /*$ifdef TRACE*/
    ntr_real(tzt, 20L, 1601L, 3L, -1L, -2L, &l);
    /*$endif TRACE*/
    break;

  case m_complete_node:
    l = compute_log_l_m_complete((*formula)->UU.m_complete_leaf->a,
				 (*model)->id->UU.U1.homogeneous);
    /*$ifdef TRACE*/
    ntr_real(tzt, 20L, 1601L, 3L, -1L, -3L, &l);
    /*$endif TRACE*/
    break;

  case d_ips_node:
    tmp_fna = fna;
    tmp_marginals = NULL;
    l = compute_log_l_d_ips(&(*formula)->UU.d_ips_leaf, &tmp_fna,
			    &tmp_marginals,
			    (*model)->found_ps && *found_offsets_and_ps, &ok);
    l += find_empty_det_product(true);   /* model^.id^.homogeneous */
    /*$ifdef TRACE*/
    ntr_real(tzt, 20L, 1601L, 3L, -2L, -1L, &l);
    /*$endif TRACE*/
    break;

  case r_ips_node:
    l = compute_log_l_r_ips(&(*formula)->UU.r_ips_leaf,
			    (*model)->found_ps && *found_offsets_and_ps, &ok);
    l += find_empty_det_product(true);   /* model^.id^.homogeneous */
    /*$ifdef TRACE*/
    ntr_real(tzt, 20L, 1601L, 3L, -2L, -4L, &l);
    /*$endif TRACE*/
    break;

  case c_ips_node:
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1601L, 1L, (*model)->model_ifail,
	(*formula)->UU.c_ips_leaf->ifail);
    ntr(tzt, 20L, 1601L, 1L, (*formula)->UU.c_ips_leaf->r_offset,
	(*formula)->UU.c_ips_leaf->ss_offset);
    /*$endif TRACE*/
    if ((*formula)->UU.c_ips_leaf->ifail == 0)
      l = compute_log_l_c_ips(&(*formula)->UU.c_ips_leaf,
			      (*model)->id->vertices, &ok);
    *ifail = (*formula)->UU.c_ips_leaf->ifail;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1601L, 1L, (*formula)->UU.c_ips_leaf->r_offset,
	(*formula)->UU.c_ips_leaf->ss_offset);
    ntr_real(tzt, 20L, 1601L, 3L, -2L, -2L, &l);
    /*$endif TRACE*/
    break;

  case m_ips_node:
    /*$ifdef TRACE*/
    ntr_real(tzt, 20L, 1601L, 3L, -2L, -31L, &l);
    /*$endif TRACE*/
    if ((*formula)->UU.m_ips_leaf->complete)
      l = compute_log_l_m_complete((*model)->id->vertices,
				   (*model)->id->UU.U1.homogeneous);
    else
      l = compute_log_l_m_ips(&(*formula)->UU.m_ips_leaf,
			      (*model)->id->vertices, &ok);
    *ifail = (*formula)->UU.m_ips_leaf->ifail;
    /*$ifdef TRACE*/
    ntr_real(tzt, 20L, 1601L, 3L, -2L, -32L, &l);
    /*$endif TRACE*/
    break;
  }
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1601L, 1L, -8L, -88L, &l);
  /*$endif TRACE*/
  if (true) {   /**/
    if ((*model)->id->model_type == mixed)
      l -= find_empty_det_product((*model)->id->UU.U1.homogeneous);
    else
      l -= find_empty_det_product(true);   /* model^.id^.homogeneous */
  }
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1601L, 1L, -8L, -88L, &l);
  /*$endif TRACE*/
  return l;
}


/* Local variables for sub_compute_log_l: */
struct LOC_sub_compute_log_l {
  boolean found_offsets_and_ps;
} ;


Static t_long_real sub_compute_log_l(model, ifail, fail_compare,
				     found_offsets_and_ps_)
t_model **model;
t_integer *ifail;
boolean *fail_compare, found_offsets_and_ps_;
{
  struct LOC_sub_compute_log_l Local_Var;
  t_model_list *p;
  boolean found_model;
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;
  t_integer tmp_ifail;
  t_long_real l = 0.0, l_a = 0.0, l_b = 0.0, l_c = 0.0, l_a_0 = 0.0,
	      l_b_0 = 0.0, l_c_0 = 0.0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.found_offsets_and_ps = found_offsets_and_ps_;
  /*$ifdef TRACE*/
  memcpy(tzt, " SubComputeLogL     ", sizeof(pch20));
  ntr(tzt, 20L, 1602L, 1L, (*model)->model_ifail, *ifail);
  ntr_model_g_c(tzt, 20L, 1602L, 1L, -1L, -1L, model);
  ntr_model_numbers(tzt, 20L, 1602L, 1L, -1L, -1L, model);
  ntr_model_formula(tzt, 20L, 1602L, 1L, -1L, -1L, *model);
  /*$endif TRACE*/
  check_model_constant(model, " ConstantSubComLogL ");
  l = 0.0;   /* _invalid_real */
  if ((*model)->found_log_l) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1602L, 1L, 2L, -100L);
    /*$endif TRACE*/
    l = (*model)->log_l;
    *ifail = (*model)->model_ifail;
  } else {
    found_model = return_model(model, &p);
    formula = (*model)->formula_node;
    if (!found_model || !boolean_option[72]) {
      if (formula == NULL) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1602L, 1L, 2L, -10L);
	/*$endif TRACE*/
	l = 0.0;
	if (found_model)
	  l = p->model->log_l;
	*ifail = 0;
      } else {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1602L, 1L, 2L, -1L);
	/*$endif TRACE*/
	if (formula->node_type == decomposition_node) {
	  /*$ifdef TRACE*/
	  ntr(tzt, 20L, 1602L, 1L, 2L, -2L);
	  /*$endif TRACE*/
	  decomposition_element = formula->UU.decomposition_node_;
	  l_a = sub_compute_log_l(&decomposition_element->left_model, ifail,
				  fail_compare,
				  Local_Var.found_offsets_and_ps);
	  l_a_0 = n[0] * log(decomposition_element->left_model->constant);
	  l_a -= l_a_0;
	  /*$ifdef TRACE*/
	  ntr_real(tzt, 20L, 1602L, 1L, 3L, -1L, &l_a);
	  /*$endif TRACE*/
	  tmp_ifail = 0;
	  l_b = sub_compute_log_l(&decomposition_element->right_model,
				  &tmp_ifail, fail_compare,
				  Local_Var.found_offsets_and_ps);
	  l_b_0 = n[0] * log(decomposition_element->right_model->constant);
	  l_b -= l_b_0;
	  /*$ifdef TRACE*/
	  ntr_real(tzt, 20L, 1602L, 1L, 3L, -2L, &l_b);
	  /*$endif TRACE*/
	  if (tmp_ifail > 0) {
	    if (*ifail > 0)
	      *ifail += tmp_ifail * 1000;
	    else
	      *ifail = tmp_ifail;
	  }
	  l_c = sub_sub_compute_log_l(model, &tmp_ifail,
				      &decomposition_element->separator,
				      &Local_Var.found_offsets_and_ps);
	  /*$ifdef TRACE*/
	  ntr_real(tzt, 20L, 1602L, 1L, 3L, -3L, &l_c);
	  ntr_triple_reals(tzt, 20L, 1602L, 1L, 4L, -3L, &l_a, &l_b, &l_c);
	  /*$endif TRACE*/
	  l = l_a + l_b - l_c;
	  /*$ifdef TRACE*/
	  ntr_real(tzt, 20L, 1602L, 1L, 3L, -4L, &l);
	  /*$endif TRACE*/
	} else {
	  /*$ifdef TRACE*/
	  ntr(tzt, 20L, 1602L, 1L, 2L, -3L);
	  /*$endif TRACE*/
	  l = sub_sub_compute_log_l(model, ifail, &formula,
				    &Local_Var.found_offsets_and_ps);
	  /* ifail := model^.model_ifail */
	}
      }
      /*$ifdef TRACE*/
      ntr_real(tzt, 20L, 1602L, 1L, 5L, -1L, &l);
      /*$endif TRACE*/
      l += n[0] * log((*model)->constant);
      /*$ifdef TRACE*/
      ntr_real(tzt, 20L, 1602L, 1L, 6L, -1L, &l);
      /*$endif TRACE*/
      /*$ifdef TRACE*/
      ntr_real(tzt, 20L, 1602L, 1L, 7L, -1L, &l);
      /*$endif TRACE*/
    }
    if (found_model) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1602L, 1L, 2L, -4L);
      /*$endif TRACE*/
      if ((!boolean_option[72]) & different_reals(&l, &p->model->log_l)) {
	*fail_compare = true;
	note_error_reals(stdout, 1602L, 1L, " SubComputeLogL-1:  ", l,
			 p->model->log_l, *model, p->model);
	begin_error(stdout, 1602L, " SubComputeLogL-2:  ", 20L, false);
	ntr_triple_reals(tzt, 20L, 1602L, 2L, 1L, -1L, &l_a, &l_b, &l_c);

	ntr_triple_reals(tzt, 20L, 1602L, 2L, *ifail, -2L, &l_a_0, &l_b_0,
			 &l_c_0);
	check_decompositions(model);
	end_error(stdout, 1602L, false);
      }
      *ifail = p->model->model_ifail;
      l = p->model->log_l;
      (*model)->log_l = l;
      (*model)->found_log_l = true;
      (*model)->model_ifail = p->model->model_ifail;
      (*model)->dim = p->model->dim;
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1602L, 1L, 2L, -5L);
      /*$endif TRACE*/
      (*model)->log_l = l;
      (*model)->found_log_l = true;
      (*model)->model_ifail = *ifail;
      if (re_use_test)
	insert_link_model(&p, model);
    }
  }
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1602L, 1L, 99L, *ifail, &l);
  /*$endif TRACE*/
  return l;
}  /* sub_compute_log_l */


Static t_long_real compute_log_l_(model, dummy_g, found_offsets_and_ps)
t_model **model;
long *dummy_g;
boolean found_offsets_and_ps;
{
  t_integer ifail = 0;
  t_long_real log_l;
  boolean fail_compare = false;
  boolean unused_ok, ok_n, ok_p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeLogL        ", sizeof(pch20));
  ntr_set(tzt, 20L, 1603L, 1L, -1L, -1L, (*model)->id->vertices);
  ntr_model_formula(tzt, 20L, 1603L, 2L, -1L, -1L, *model);
  /*$endif TRACE*/
  if ((*model)->found_log_l)
    log_l = (*model)->log_l;
  else {
    /* begin
       found_model := return_model(model, p);
       if found_model then begin
          if not boolean_option[72] then begin
             log_l := sub_compute_log_l(model, ifail, fail_compare,
                                        found_offsets_and_ps);
             if different_reals(log_l, p^.model^.log_l) then begin
                note_error_reals(output, 1602, 1, ' ComputeLogL-1:    ',
                                 log_l, p^.model^.log_l, model, p^.model);
                begin_error(output, 1602, false);
                check_decompositions(model);
                end_error(output, 1602, false)
             end
          end;
          log_l := p^.model^.log_l;
          model^.log_l := log_l;
          model^.found_log_l := true;
          model^.model_ifail := p^.model^.model_ifail;
          model^.dim := p^.model^.dim
       end else begin
          log_l := sub_compute_log_l(model, ifail, fail_compare,
                                         found_offsets_and_ps);
          model^.log_l := log_l;
          model^.found_log_l := true;
          model^.model_ifail := ifail;
          if re_use_test then
             insert_link_model(p, model)
       end
    end; */
    if (!(*model)->found_ps && !found_offsets_and_ps) {
      ok_n = true;
      ok_p = true;
      /* if model^.id^.model_type = pure_discrete then */
      find_offsets_and_marginals(model, true, &ok_n, &ok_p);
      if (ok_n && ok_p) {
	/* Doing it twich!!! */
	estimate_model(model);
	unused_ok = true;
      } else
	unused_ok = ((*model)->id->model_type == pure_discrete) &
		    test_model_space(model);
    }
    log_l = sub_compute_log_l(model, &ifail, &fail_compare,
			      found_offsets_and_ps);
  }
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1603L, 8L, -1L, ifail, &log_l);
  ntr_real(tzt, 20L, 1603L, 8L, -1L, -1L, &(*model)->constant);
  ntr_set(tzt, 20L, 1603L, 8L, -1L, -1L, (*model)->id->vertices);
  if (fail_compare)
    check_decompositions(model);
  /*$endif TRACE*/
  return log_l;
}  /* compute_log_l_ */


Static t_long_real compute_log_l(model, dummy_g)
t_model **model;
long *dummy_g;
{
  return (compute_log_l_(model, dummy_g, false));
}  /* compute_log_l */


Static t_long_real compute_decomposable_log_l(model, ok)
t_model **model;
boolean *ok;
{
  return (compute_log_l_(model, (*model)->id->vertices, true));
}  /* compute_decomposable_log_l */


/*@+"pslice.p"*/
/*@-"slicehead.c"*/


Static Void write_measure_head(f, c, w, l)
FILE *f;
Char *c;
t_long_integer w, l;
{
  write_line(f);
  write_space(f, l - w);
  write_pch(f, c, w);
  write_space(f, labs(x_width) - 7);
  write_pch(f, "Statistic", 9L);
  write_space(f, 3L);
  write_pch(f, "DF", 2L);
  write_space(f, labs(prob_width) - 4);
  write_pch(f, "P-value", 7L);
  write_space(f, 3L);
  write_pch(f, "DF", 2L);
  write_space(f, labs(prob_width) - 4);
  write_pch(f, "P-value", 7L);
  write_line(f);
}  /* write_measure_head */


Static Void write_measure(f, c, w, l, k, df_a, df_b, x, p_a, p_b)
FILE *f;
Char *c;
t_long_integer w, l, k, *df_a, *df_b;
t_long_real *x, *p_a, *p_b;
{
  write_pch_r(f, c, w, l);
  write_real(f, *x, x_width, x_dec);
  if (k > 1 && *df_b != _INVALID) {
    write_space(f, 1L);
    write_integer(f, *df_b, 4L);
    write_space(f, 3L);
    write_real(f, *p_b, prob_width, prob_dec);
  }
  if (k > 1) {
    write_space(f, 1L);
    write_integer(f, *df_a, 4L);
    write_space(f, 3L);
    write_real(f, *p_a, prob_width, prob_dec);
  }
  write_line(f);
  *df_a = _INVALID;
  *df_b = _INVALID;
  *x = _INVALID_REAL;
  *p_a = _INVALID_REAL;
  *p_b = _INVALID_REAL;
}  /* write_measure */


Static Void write_measure_normal_head(f, c, w, l)
FILE *f;
Char *c;
t_long_integer w, l;
{
  write_line(f);
  write_space(f, l - w);
  write_pch(f, c, w);
  write_space(f, labs(x_width) - 7);
  write_pch(f, "Statistic", 9L);
  if (c_factorizes < 2) {
    write_space(f, labs(x_width) - 2);
    write_pch(f, "Var", 3L);
  }
  write_space(f, labs(x_width) - 5);
  write_pch(f, "ASE/1", 5L);
  if (c_factorizes == 1 || c_factorizes == 3) {
    write_space(f, labs(x_width) - 1);
    write_pch(f, "T", 1L);
  }
  if (c_factorizes == 1 || c_factorizes == 2) {
    write_space(f, labs(prob_width) - 6);
    write_pch(f, "P-value", 7L);
  }
  if (c_factorizes < 2) {
    write_line(f);
    write_space(f, l + labs(x_width) + 2);
  }
  if (c_factorizes < 2) {
    write_space(f, labs(x_width) - 2);
    write_pch(f, "Var", 3L);
  }
  write_space(f, labs(x_width) - 5);
  write_pch(f, "ASE/0", 5L);
  if (c_factorizes == 1 || c_factorizes == 3) {
    write_space(f, labs(x_width) - 1);
    write_pch(f, "T", 1L);
  }
  if (c_factorizes == 1 || c_factorizes == 2) {
    write_space(f, labs(prob_width) - 6);
    write_pch(f, "P-value", 7L);
  }
  write_line(f);
}  /* write_measure_normal_head */


Static Void write_measure_normal(f, c, w, l, x, x_s0, x_s1)
FILE *f;
Char *c;
t_long_integer w, l;
t_long_real *x, *x_s0, *x_s1;
{
  write_pch_r(f, c, w, l);
  write_real(f, *x, x_width, x_dec);
  if (((!is_invalid_real(*x)) & (!is_invalid_real(*x_s1))) && *x_s1 != 0) {
    if (c_factorizes < 2) {
      write_char(f, ' ');
      write_real(f, *x_s1, x_width, prob_dec);
    }
    write_real(f, *x_s1 / sqrt(fabs(*x_s1)), x_width, x_dec);
    if (c_factorizes == 1 || c_factorizes == 3) {
      if (*x_s1 > 0)
	write_real(f, *x / sqrt(*x_s1), x_width, x_dec);
      else
	write_space(f, labs(x_width));
    }
    if (c_factorizes == 1 || c_factorizes == 2) {
      write_char(f, ' ');
      if (*x_s1 > 0)
	write_real(f, 2 * pnormal(fabs(*x) / sqrt(*x_s1)), prob_width,
		   prob_dec);
      else
	write_space(f, labs(prob_width));
    }
  } else {
    if (c_factorizes < 2)
      write_space(f, labs(x_width) + 1);
    write_space(f, labs(x_width));
    if (c_factorizes == 1 || c_factorizes == 3)
      write_space(f, labs(x_width));
    if (c_factorizes == 1 || c_factorizes == 2)
      write_space(f, labs(prob_width));
  }
  if (((!is_invalid_real(*x)) & (!is_invalid_real(*x_s0))) && *x_s0 != 0) {
    if (c_factorizes < 2) {
      write_line(f);
      write_space(f, l + labs(x_width) + 2);
    }
    if (c_factorizes < 2) {
      write_char(f, ' ');
      write_real(f, *x_s0, x_width, prob_dec);
    }
    write_real(f, *x_s0 / sqrt(fabs(*x_s0)), x_width, x_dec);
    if (c_factorizes == 1 || c_factorizes == 3) {
      if (*x_s0 > 0)
	write_real(f, *x / sqrt(*x_s0), x_width, x_dec);
      else
	write_space(f, labs(x_width));
    }
    if (c_factorizes == 1 || c_factorizes == 2) {
      write_char(f, ' ');
      if (*x_s0 > 0)
	write_real(f, 2 * pnormal(fabs(*x) / sqrt(*x_s0)), prob_width,
		   prob_dec);
      else
	write_space(f, labs(prob_width));
    }
  }
  write_line(f);
  *x = _INVALID_REAL;
  *x_s0 = _INVALID_REAL;
  *x_s1 = _INVALID_REAL;
}  /* write_measure_normal */


/*@-"gammatau.c"*/


Static Void sub_find_concedances(nrow, ncol, nmatpos, cij, dij, p, q)
t_integer *nrow, *ncol;
t_integer (*nmatpos)[MAX_LEVEL], (*cij)[MAX_LEVEL], (*dij)[MAX_LEVEL];
t_long_integer *p, *q;
{
  t_long_integer i, j, k, l, nij;

  for (i = 1; i <= *nrow; i++) {
    for (j = 1; j <= *ncol; j++) {
      cij[i-1][j-1] = 0;
      dij[i-1][j-1] = 0;
      for (k = 0; k <= i - 2; k++) {
	for (l = 0; l <= j - 2; l++)
	  cij[i-1][j-1] += n[nmatpos[k][l]];
      }
      for (k = i; k < *nrow; k++) {
	for (l = 0; l <= j - 2; l++)
	  dij[i-1][j-1] += n[nmatpos[k][l]];
      }
      for (k = 0; k <= i - 2; k++) {
	for (l = j; l < *ncol; l++)
	  dij[i-1][j-1] += n[nmatpos[k][l]];
      }
      for (k = i; k < *nrow; k++) {
	for (l = j; l < *ncol; l++)
	  cij[i-1][j-1] += n[nmatpos[k][l]];
      }
      nij = n[nmatpos[i-1][j-1]];
      *p += nij * cij[i-1][j-1];
      *q += nij * dij[i-1][j-1];
    }
  }
}  /* sub_find_concedances */


Static Void gamma_and_tau(n_total, nrow, ncol, n_total_2, n_total_3,
			  n_total_4, ss_r, ss_c, ss_1_r, ss_1_c, m, x, x_s0,
			  x_s1, nrowpos, ncolpos, nmatpos)
t_long_integer *n_total;
t_integer *nrow, *ncol;
t_long_real *n_total_2, *n_total_3, *n_total_4, *ss_r, *ss_c, *ss_1_r,
	    *ss_1_c, *m, *x, *x_s0, *x_s1;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
{
  t_long_real gamma;
  t_long_real gamma_s0 = 0.0;
  t_long_real gamma_s1, tau_b, tau_b_s0, tau_b_s1, tau_c_s0, d_as_1_s0,
	      d_as_1_s1, d_as_2_s0, d_as_2_s1, ppq, pmq, o, y, w, r_i, c_j;
  t_long_integer p = 0, q = 0;
  t_long_integer i, j;
  t_integer (*cij)[MAX_LEVEL], (*dij)[MAX_LEVEL];
  double TEMP;

  cij = (t_integer(*)[MAX_LEVEL])Malloc(sizeof(t_level_2_arr_of_integer));
  if (cij == NULL)
    _OutMem();
  dij = (t_integer(*)[MAX_LEVEL])Malloc(sizeof(t_level_2_arr_of_integer));
  if (dij == NULL)
    _OutMem();
  sub_find_concedances(nrow, ncol, nmatpos, cij, dij, &p, &q);
  ppq = p + q;
  pmq = p - q;
  y = sqrt((*n_total_2 - *ss_r) * (*n_total_2 - *ss_c));
  if (y != 0)
    tau_b = pmq / y;
  if (ppq > 0) {
    gamma_s0 = 0.0;
    gamma_s1 = 0.0;
    tau_b_s1 = 0.0;
    d_as_1_s1 = 0.0;
    d_as_2_s1 = 0.0;
    for (i = 0; i < *nrow; i++) {
      r_i = n[nrowpos[i]];
      for (j = 0; j < *ncol; j++) {
	c_j = n[ncolpos[j]];
	o = n[nmatpos[i][j]];
	w = cij[i][j] - dij[i][j];
	gamma_s0 += o * w * w;
	TEMP = 2 * y * w +
	    tau_b * (c_j * (*n_total_2 - *ss_r) + r_i * (*n_total_2 - *ss_c));
	tau_b_s1 += o * (TEMP * TEMP);
	TEMP = (*n_total_2 - *ss_r) * w + (n[nrowpos[i]] - *n_total) * pmq;
	d_as_1_s1 += o * (TEMP * TEMP);
	TEMP = (*n_total_2 - *ss_c) * w + (n[ncolpos[j]] - *n_total) * pmq;
	d_as_2_s1 += o * (TEMP * TEMP);
	w = q * cij[i][j] - p * dij[i][j];
	gamma_s1 += o * w * w;
      }
    }
    w = *n_total * (*n_total - 1) - *ss_1_r;
    w *= *n_total * (*n_total - 1) - *ss_1_c;
    if (w != 0)
      tau_b_s0 = (gamma_s0 - pmq * pmq / *n_total) * 4 / w;
    tau_c_s0 = gamma_s0 - pmq * pmq / *n_total;
    tau_c_s0 /= *n_total_4;
    TEMP = *m / (*m - 1);
    tau_c_s0 *= 4 * (TEMP * TEMP);
    w = *n_total * (*n_total - 1) - *ss_1_r;
    w *= w;
    d_as_1_s0 = gamma_s0 * 4 / w;
    w = *n_total_2 - *ss_r;
    w *= w;
    d_as_1_s1 = d_as_1_s1 * 4 / (w * w);
    w = *n_total * (*n_total - 1) - *ss_1_c;
    w *= w;
    d_as_2_s0 = gamma_s0 * 4 / w;
    w = *n_total_2 - *ss_c;
    w *= w;
    d_as_2_s1 = d_as_2_s1 * 4 / (w * w);
    TEMP = 2 * *n_total_2 - *ss_r - *ss_c;
    tau_b_s1 -= *n_total_3 * tau_b * tau_b * (TEMP * TEMP);
    TEMP = y * y;
    tau_b_s1 /= TEMP * TEMP;
    gamma_s0 -= pmq * pmq / *n_total;
    gamma_s0 *= 4;
    w = ppq * ppq;
    gamma_s0 /= w;
    gamma_s1 = gamma_s1 * 16 / (w * w);
    gamma = pmq / ppq;
  } else {
    gamma = _INVALID_REAL;
    gamma_s0 = _INVALID_REAL;
    gamma_s1 = _INVALID_REAL;
    tau_b_s0 = _INVALID_REAL;
    tau_b_s1 = _INVALID_REAL;
    tau_c_s0 = _INVALID_REAL;
    d_as_1_s0 = _INVALID_REAL;
    d_as_1_s1 = _INVALID_REAL;
    d_as_2_s0 = _INVALID_REAL;
    d_as_2_s1 = _INVALID_REAL;
  }
  _Free(cij);
  _Free(dij);
  *x = gamma;
  *x_s0 = gamma_s0;
  *x_s1 = gamma_s1;
  write_measure_normal(stdout, "Gamma, G", 8L, 31L, x,
		       x_s0, x_s1);
  *x = pmq / sqrt((*n_total_2 - *ss_r) * (*n_total_2 - *ss_c));
  *x_s0 = tau_b_s0;
  *x_s1 = tau_b_s1;
  write_measure_normal(stdout, "Kendall's Tau b", 15L, 31L, x,
		       x_s0, x_s1);
  if (*m > 1)
    *x = pmq / *n_total_2 * *m / (*m - 1);
  *x_s0 = tau_c_s0;
  *x_s1 = tau_c_s0;
  write_measure_normal(stdout, "Stuart's Tau c", 14L, 31L, x,
		       x_s0, x_s1);
  *x = pmq / (*n_total_2 - *ss_r);
  *x_s0 = d_as_1_s0;
  *x_s1 = d_as_1_s1;
  write_measure_normal(stdout, "Somers' D, R|C", 14L, 31L, x,
		       x_s0, x_s1);
  *x = pmq / (*n_total_2 - *ss_c);
  *x_s0 = d_as_2_s0;
  *x_s1 = d_as_2_s1;
  write_measure_normal(stdout, "Somers' D, C|R", 14L, 31L, x,
		       x_s0, x_s1);
}  /* gamma_and_tau */


Local t_long_real p_(a, b, c, d)
t_long_integer a, b, c, d;
{
  return exp(log_fact(a + b) + log_fact(c + d) + log_fact(a + c) +
	     log_fact(b + d) - log_fact(a) - log_fact(b) - log_fact(c) -
	     log_fact(d) - log_fact(a + b + c + d));
}  /* p */

Local Void f(a, b, c, d, p_1_side, p_2_side)
t_long_integer *a, *b, *c, *d;
t_long_real *p_1_side, *p_2_side;
{
  t_long_integer i;
  t_long_real x, y;

  if (*a >= 100 && c_factorizes != 1) {
    *p_1_side = _INVALID_REAL;
    *p_2_side = *p_1_side;
    return;
  }
  *p_1_side = 0.0;
  for (i = 0; i <= *a; i++)
    *p_1_side += p_(*a - i, *b + i, *c + i, *d - i);
  if (*b < *c)
    i = *b;
  else
    i = *c;
  if (i >= 100 && c_factorizes != 1) {
    *p_2_side = _INVALID_REAL;
    return;
  }
  *p_2_side = *p_1_side;
  x = p_(*a, *b, *c, *d);
  y = p_(*a + i, *b - i, *c - i, *d + i);
  while (y <= x && 0 < i) {
    *p_2_side += y;
    i--;
    y = p_(*a + i, *b - i, *c - i, *d + i);
  }
}  /* f */


Static Void fisher(a, b, c, d, p_1_side, p_2_side)
t_long_integer a, b, c, d;
t_long_real *p_1_side, *p_2_side;
{
  if (a * d < b * c) {
    if (a < d)
      f(&a, &b, &c, &d, p_1_side, p_2_side);
    else
      f(&d, &b, &c, &a, p_1_side, p_2_side);
    return;
  }
  if (b < c)
    f(&b, &a, &d, &c, p_1_side, p_2_side);
  else
    f(&c, &a, &d, &b, p_1_side, p_2_side);
}  /* fisher */


/*@-"optimal.c"*/


Static Void optimal_prediction(n_total, nrow, ncol, x, x_s0, x_s1, nrowpos,
			       ncolpos, nmatpos)
t_long_integer *n_total;
t_integer *nrow, *ncol;
t_long_real *x, *x_s0, *x_s1;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
{
  t_long_real max_row = 0.0, max_col = 0.0, max_row_ = 0.0, max_col_ = 0.0,
	      sum_max_in_row = 0.0, sum_max_in_col = 0.0,
	      sum_max_in_row_ = 0.0, sum_max_in_col_ = 0.0;
  t_long_real l_ij, l_ji, l_sym;
  t_long_real lambda_asym_ji_s1 = 0.0, lambda_asym_ij_s1 = 0.0,
	      lambda_sym_s1 = 0.0, lambda_asyms_ji_s1 = 0.0,
	      lambda_asyms_ij_s1 = 0.0;
  t_long_real r_i, c_j, w, o;
  t_level_arr_of_integer max_in_row, max_in_col, n_, m_;
  t_long_integer d_k_i, d_l_j, d_mj_ij, d_in_ij, l_, k_, l__, k__, i, j;
  double TEMP;
  long TEMP1;

  for (j = 1; j <= *ncol; j++) {
    c_j = n[ncolpos[j-1]];
    if (c_j > max_col) {
      max_col = c_j;
      l_ = j;
    }
    max_in_col[j-1] = -1;
    w = 0.0;
    for (i = 0; i < *nrow; i++) {
      r_i = n[nrowpos[i]];
      if (r_i != 0)
	w += n[nmatpos[i][j-1]] / r_i;
    }
    if (w > max_col_) {
      max_col_ = w;
      l__ = j;
    }
  }
  for (i = 1; i <= *nrow; i++) {
    r_i = n[nrowpos[i-1]];
    if (r_i > max_row) {
      max_row = r_i;
      k_ = i;
    }
    max_in_row[i-1] = -1;
    w = 0.0;
    for (j = 0; j < *ncol; j++) {
      c_j = n[ncolpos[j]];
      if (c_j != 0)
	w += n[nmatpos[i-1][j]] / c_j;
    }
    if (w > max_row_) {
      max_row_ = w;
      k__ = i;
    }
  }
  for (j = 0; j < *ncol; j++) {
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    for (i = 0; i < *nrow; i++) {
      o = n[nmatpos[i][j]];
      if (o > max_in_col[j]) {
	max_in_col[j] = n[nmatpos[i][j]];
	m_[j] = i + 1;
      }
      if (o > max_in_row[i]) {
	max_in_row[i] = n[nmatpos[i][j]];
	n_[i] = j + 1;
      }
    }
  }
  for (j = 0; j < *ncol; j++) {
    *x = n[ncolpos[j]];
    sum_max_in_col += max_in_col[j];
    if (*x != 0)
      sum_max_in_col_ += max_in_col[j] / *x;
  }
  for (i = 0; i < *nrow; i++) {
    *x = n[nrowpos[i]];
    sum_max_in_row += max_in_row[i];
    if (*x != 0)
      sum_max_in_row_ += max_in_row[i] / *x;
  }
  l_ij = (sum_max_in_row - max_col) / (*n_total - max_col);
  l_ji = (sum_max_in_col - max_row) / (*n_total - max_row);
  l_sym = (sum_max_in_col + sum_max_in_row - max_col - max_row) /
	  (*n_total * 2 - max_col - max_row);
  for (j = 1; j <= *ncol; j++) {
    if (j == l_)
      d_l_j = 1;
    else
      d_l_j = 0;
    for (i = 1; i <= *nrow; i++) {
      if (i == k_)
	d_k_i = 1;
      else
	d_k_i = 0;
      if (j == n_[i-1])
	d_in_ij = 1;
      else
	d_in_ij = 0;
      if (i == m_[j-1])
	d_mj_ij = 1;
      else
	d_mj_ij = 0;
      o = n[nmatpos[i-1][j-1]];
      TEMP = d_in_ij - d_l_j + l_sym * d_l_j;
      lambda_asym_ji_s1 += o * (TEMP * TEMP);
      TEMP = d_mj_ij - d_k_i + l_sym * d_k_i;
      lambda_asym_ij_s1 += o * (TEMP * TEMP);
      TEMP = d_in_ij + d_mj_ij - d_l_j - d_k_i + l_sym * (d_l_j + d_k_i);
      lambda_sym_s1 += o * (TEMP * TEMP);
    }
  }
  lambda_asym_ji_s1 -= *n_total * l_ij * l_ij;
  TEMP1 = *n_total - n[ncolpos[l_-1]];
  lambda_asym_ji_s1 /= TEMP1 * TEMP1;
  lambda_asym_ij_s1 -= *n_total * l_ji * l_ji;
  TEMP1 = *n_total - n[nrowpos[k_-1]];
  lambda_asym_ij_s1 /= TEMP1 * TEMP1;
  lambda_sym_s1 -= *n_total * 4 * l_sym * l_sym;
  TEMP1 = *n_total * 2 - n[nrowpos[k_-1]] - n[ncolpos[l_-1]];
  lambda_sym_s1 /= TEMP1 * TEMP1;
  l_ji = (sum_max_in_row_ - max_col_) / (*nrow - max_col_);
  l_ij = (sum_max_in_col_ - max_row_) / (*ncol - max_row_);
  for (i = 0; i < *nrow; i++) {
    r_i = n[nrowpos[i]];
    o = n[nmatpos[i][l__-1]];
    if (r_i > 0) {
      TEMP = n[nmatpos[i][n_[i] - 1]] - o + l_ji * o;
      lambda_asyms_ji_s1 -= TEMP * TEMP / r_i / r_i / r_i;
    }
  }
  for (j = 0; j < *ncol; j++) {
    c_j = n[ncolpos[j]];
    o = n[nmatpos[k__-1][j]];
    if (c_j > 0) {
      TEMP = n[nmatpos[m_[j] - 1][j]] - o + l_ij * o;
      lambda_asyms_ij_s1 -= TEMP * TEMP / c_j / c_j / c_j;
    }
  }
  for (j = 1; j <= *ncol; j++) {
    c_j = n[ncolpos[j-1]];
    if (j == l__)
      d_l_j = 1;
    else
      d_l_j = 0;
    for (i = 1; i <= *nrow; i++) {
      if (i == k__)
	d_k_i = 1;
      else
	d_k_i = 0;
      if (j == n_[i-1])
	d_in_ij = 1;
      else
	d_in_ij = 0;
      if (i == m_[j-1])
	d_mj_ij = 1;
      else
	d_mj_ij = 0;
      r_i = n[nrowpos[i-1]];
      o = n[nmatpos[i-1][j-1]];
      if (r_i > 0) {
	TEMP = d_in_ij - d_l_j + l_ji * d_l_j;
	lambda_asyms_ji_s1 += o * (TEMP * TEMP) / (r_i * r_i);
      }
      if (c_j > 0) {
	TEMP = d_mj_ij - d_k_i + l_ij * d_k_i;
	lambda_asyms_ij_s1 += o * (TEMP * TEMP) / (c_j * c_j);
      }
    }
  }
  if (*nrow - max_col_ != 0) {
    TEMP = *nrow - max_col_;
    lambda_asyms_ji_s1 /= TEMP * TEMP;
  }
  if (*ncol - max_row_ != 0) {
    TEMP = *ncol - max_row_;
    lambda_asyms_ij_s1 /= TEMP * TEMP;
  }
  *x = (sum_max_in_row - max_col) / (*n_total - max_col);
  *x_s1 = lambda_asym_ji_s1;
  write_measure_normal(stdout, "Optimal prediction lambda, R|C", 30L, 31L, x,
		       x_s0, x_s1);
  *x = (sum_max_in_col - max_row) / (*n_total - max_row);
  *x_s1 = lambda_asym_ij_s1;
  write_measure_normal(stdout, "Optimal prediction lambda, C|R", 30L, 31L, x,
		       x_s0, x_s1);
  *x = (sum_max_in_col + sum_max_in_row - max_col - max_row) /
       (*n_total * 2 - max_col - max_row);
  *x_s1 = lambda_sym_s1;
  write_measure_normal(stdout, "Optimal prediction lambda, sym", 30L, 31L, x,
		       x_s0, x_s1);
  *x = (sum_max_in_row_ - max_col_) / (*nrow - max_col_);
  *x_s1 = lambda_asyms_ji_s1;
  write_measure_normal(stdout, "Optimal prediction lambda* R|C", 30L, 31L, x,
		       x_s0, x_s1);
  *x = (sum_max_in_col_ - max_row_) / (*ncol - max_row_);
  *x_s1 = lambda_asyms_ij_s1;
  write_measure_normal(stdout, "Optimal prediction lambda* C|R", 30L, 31L, x,
		       x_s0, x_s1);
}  /* optimal_prediction */


/*@-"goodman.c"*/


Static Void goodman_and_kruskal(n_total, nrow, ncol, n_total_2, ss_r, ss_c,
				sc_r, sc_c, x, x_s0, x_s1, nrowpos, ncolpos,
				nmatpos)
t_long_integer *n_total;
t_integer *nrow, *ncol;
t_long_real *n_total_2, *ss_r, *ss_c, *sc_r, *sc_c, *x, *x_s0, *x_s1;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
{
  t_long_real sum_a_2;
  t_long_real sum_a_2_r = 0.0, sum_a_2_c = 0.0, sum_a_3_o_r_2 = 0.0,
	      sum_a_3_o_c_2 = 0.0, sum_a_2_c_o_r = 0.0, sum_a_2_r_o_c = 0.0,
	      sum_a_2_o_r = 0.0, sum_a_2_o_c = 0.0;
  t_long_real sum_a_c, sum_a_r;
  t_long_real sum_o_r_1 = 0.0, sum_o_r_2 = 0.0, sum_o_r_3 = 0.0,
	      sum_o_c_1 = 0.0, sum_o_c_2 = 0.0, sum_o_c_3 = 0.0;
  t_long_real r_i, c_j, o, o_2, o_3, y, v, w;
  t_long_integer i, j;
  double TEMP;

  for (j = 0; j < *ncol; j++) {
    c_j = n[ncolpos[j]];
    sum_a_r = 0.0;
    sum_a_2 = 0.0;
    for (i = 0; i < *nrow; i++) {
      r_i = n[nrowpos[i]];
      o = n[nmatpos[i][j]];
      sum_a_r += o * r_i;
      sum_a_2 += o * o;
    }
    if (c_j != 0) {
      sum_o_c_1 += sum_a_r * sum_a_r / c_j;
      sum_o_c_2 += sum_a_2 * sum_a_r / c_j / c_j;
      sum_o_c_3 += sum_a_2 * sum_a_2 / c_j / c_j / c_j;
    }
  }
  for (i = 0; i < *nrow; i++) {
    r_i = n[nrowpos[i]];
    sum_a_c = 0.0;
    sum_a_2 = 0.0;
    for (j = 0; j < *ncol; j++) {
      c_j = n[ncolpos[j]];
      o = n[nmatpos[i][j]];
      sum_a_c += o * c_j;
      sum_a_2 += o * o;
    }
    if (r_i != 0) {
      sum_o_r_1 += sum_a_c * sum_a_c / r_i;
      sum_o_r_2 += sum_a_c * sum_a_2 / r_i / r_i;
      sum_o_r_3 += sum_a_2 * sum_a_2 / r_i / r_i / r_i;
    }
  }
  for (j = 0; j < *ncol; j++) {
    c_j = n[ncolpos[j]];
    for (i = 0; i < *nrow; i++) {
      r_i = n[nrowpos[i]];
      o = n[nmatpos[i][j]];
      o_2 = o * o;
      o_3 = o_2 * o;
      sum_a_2_r += o_2 * r_i;
      sum_a_2_c += o_2 * c_j;
      if (c_j > 0) {
	sum_a_2_o_c += o_2 / c_j;
	sum_a_2_r_o_c += o_2 * r_i / c_j;
	sum_a_3_o_c_2 += o_3 / (c_j * c_j);
      }
      if (r_i > 0) {
	sum_a_2_o_r += o_2 / r_i;
	sum_a_2_c_o_r += o_2 * c_j / r_i;
	sum_a_3_o_r_2 += o_3 / (r_i * r_i);
      }
    }
  }
  v = *n_total * sum_a_2_o_r - *ss_c;
  w = *n_total_2 - *ss_c;
  *x = v / w;
  y = v - w;
  *x_s1 = w * w * *n_total_2 * sum_a_3_o_r_2;
  *x_s1 += y * y * *sc_c;
  *x_s1 += 2 * w * y * *n_total * sum_a_2_c_o_r;
  *x_s1 -= w * w * *n_total_2 * sum_o_r_3;
  *x_s1 -= y * y * sum_o_r_1;
  *x_s1 -= 2 * w * y * *n_total * sum_o_r_2;
  TEMP = w * w;
  *x_s1 = *x_s1 * 4 / (TEMP * TEMP);
  write_measure_normal(stdout, "Goodman and Kruskal's Tau, R|C", 30L, 31L, x,
		       x_s0, x_s1);
  v = *n_total * sum_a_2_o_c - *ss_r;
  w = *n_total_2 - *ss_r;
  *x = v / w;
  y = v - w;
  *x_s1 = w * w * *n_total_2 * sum_a_3_o_c_2;
  *x_s1 += y * y * *sc_r;
  *x_s1 += 2 * w * y * *n_total * sum_a_2_r_o_c;
  *x_s1 -= w * w * *n_total_2 * sum_o_c_3;
  *x_s1 -= y * y * sum_o_c_1;
  *x_s1 -= 2 * w * y * *n_total * sum_o_c_2;
  TEMP = w * w;
  *x_s1 = *x_s1 * 4 / (TEMP * TEMP);
  write_measure_normal(stdout, "Goodman and Kruskal's Tau, C|R", 30L, 31L, x,
		       x_s0, x_s1);
}  /* goodman_and_kruskal */


/*@-"spearman.c"*/


Static Void spearman(n_total, nrow, ncol, nr, nc, df_a, df_b, n_total_2,
		     n_total_3, sc_r, sc_c, x, x_s0, x_s1, p_a, p_b, nrowpos,
		     ncolpos, nmatpos)
t_long_integer *n_total;
t_integer *nrow, *ncol;
t_long_integer *nr, *nc, *df_a, *df_b;
t_long_real *n_total_2, *n_total_3, *sc_r, *sc_c, *x, *x_s0, *x_s1, *p_a,
	    *p_b;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
{
  t_long_real a, b, c, d;
  t_long_real a_i_i_j_j = 0.0, a_i_j = 0.0, r_i_i = 0.0, c_j_j = 0.0,
	      pmc_s1 = 0.0, r_s_u = 0.0, sum_v_ij = 0.0, sum_w_ij = 0.0;
  t_long_real v_ij, w_ij, ri, cj, r_i, c_j, o;
  t_long_real src_s0 = 0.0, src_s1 = 0.0, i_ = 0.0, j_ = 0.0;
  t_long_real y, v, w;
  t_long_integer h = 0;
  t_long_integer i, j, k, l;
  t_level_arr_of_integer cum_row_sum, cum_col_sum;
  double TEMP;

  for (j = 1; j <= *ncol; j++) {
    c_j = n[ncolpos[j-1]];
    cum_col_sum[j-1] = h;
    h += n[ncolpos[j-1]];
    j_ += j * c_j;
  }
  j_ /= *n_total;
  h = 0;
  for (i = 1; i <= *nrow; i++) {
    r_i = n[nrowpos[i-1]];
    cum_row_sum[i-1] = h;
    h += n[nrowpos[i-1]];
    i_ += i * r_i;
  }
  i_ /= *n_total;
  for (j = 1; j <= *ncol; j++) {
    *x = n[ncolpos[j-1]];
    c_j_j += *x * (j - j_) * (j - j_);
  }
  for (i = 1; i <= *nrow; i++) {
    *x = n[nrowpos[i-1]];
    r_i_i += *x * (i - i_) * (i - i_);
  }
  for (j = 1; j <= *ncol; j++) {
    c_j = n[ncolpos[j-1]];
    for (i = 1; i <= *nrow; i++) {
      o = n[nmatpos[i-1][j-1]];
      r_i = n[nrowpos[i-1]];
      r_s_u += o * (cum_row_sum[i-1] + r_i / 2 - *n_total / 2.0) *
	       (cum_col_sum[j-1] + c_j / 2 - *n_total / 2.0);
      a = i - i_;
      b = j - j_;
      c = a * b;
      d = c * c;
      a_i_j += o * c;
      a_i_i_j_j += o * d;
    }
  }
  y = sqrt(c_j_j * r_i_i);
  for (j = 1; j <= *ncol; j++) {
    for (i = 1; i <= *nrow; i++) {
      o = n[nmatpos[i-1][j-1]];
      a = i - i_;
      b = j - j_;
      TEMP = y * a * b - a_i_j * (a * a * c_j_j + b * b * r_i_i) / 2 / y;
      pmc_s1 += o * (TEMP * TEMP);
    }
  }
  y *= y;
  pmc_s1 /= y * y;
  v = r_s_u;
  w = sqrt(*n_total_3 - *sc_r) * sqrt(*n_total_3 - *sc_c) / 12;
  for (j = 1; j <= *ncol; j++) {
    c_j = n[ncolpos[j-1]];
    cj = cum_col_sum[j-1] * 2 + c_j - *n_total;
    for (i = 1; i <= *nrow; i++) {
      r_i = n[nrowpos[i-1]];
      ri = cum_row_sum[i-1] * 2 + r_i - *n_total;
      v_ij = ri * cj;
      for (k = 0; k < *ncol; k++)
	v_ij += n[nmatpos[i-1][k]] *
		(cum_col_sum[k] * 2 + n[ncolpos[k]] - *n_total);
      for (k = 0; k < *nrow; k++)
	v_ij += n[nmatpos[k][j-1]] *
		(cum_row_sum[k] * 2 + n[nrowpos[k]] - *n_total);
      for (l = 0; l < *ncol; l++) {
	for (k = i; k < *nrow; k++)
	  v_ij += n[nmatpos[k][l]] *
		  (cum_col_sum[l] * 2 + n[ncolpos[l]] - *n_total) * 2;
      }
      for (k = 0; k < *nrow; k++) {
	for (l = j; l < *ncol; l++)
	  v_ij += n[nmatpos[k][l]] *
		  (cum_row_sum[k] * 2 + n[nrowpos[k]] - *n_total) * 2;
      }
      v_ij = v_ij * *n_total / 4;
      w_ij = (*sc_r - *n_total_3) * c_j * c_j - (*n_total_3 - *sc_c) * r_i * r_i;
      w_ij = w_ij * *n_total / 96 / w;
      o = n[nmatpos[i-1][j-1]];
      sum_v_ij += o * v_ij;
      sum_w_ij += o * w_ij;
    }
  }
  for (j = 1; j <= *ncol; j++) {
    c_j = n[ncolpos[j-1]];
    cj = cum_col_sum[j-1] * 2 + c_j - *n_total;
    for (i = 1; i <= *nrow; i++) {
      r_i = n[nrowpos[i-1]];
      ri = cum_row_sum[i-1] * 2 + r_i - *n_total;
      v_ij = ri * cj;
      for (l = 0; l < *ncol; l++)
	v_ij += n[nmatpos[i-1][l]] *
		(cum_col_sum[l] * 2 + n[ncolpos[l]] - *n_total);
      for (k = 0; k < *nrow; k++)
	v_ij += n[nmatpos[k][j-1]] *
		(cum_row_sum[k] * 2 + n[nrowpos[k]] - *n_total);
      for (l = 0; l < *ncol; l++) {
	for (k = i; k < *nrow; k++)
	  v_ij += n[nmatpos[k][l]] *
		  (cum_col_sum[l] * 2 + n[ncolpos[l]] - *n_total) * 2;
      }
      for (k = 0; k < *nrow; k++) {
	for (l = j; l < *ncol; l++)
	  v_ij += n[nmatpos[k][l]] *
		  (cum_row_sum[k] * 2 + n[nrowpos[k]] - *n_total) * 2;
      }
      v_ij = v_ij * *n_total / 4;
      w_ij = (*sc_r - *n_total_3) * c_j * c_j - (*n_total_3 - *sc_c) * r_i * r_i;
      w_ij = w_ij * *n_total / 96 / w;
      o = n[nmatpos[i-1][j-1]];
      TEMP = v_ij - sum_v_ij / *n_total;
      src_s0 += o * (TEMP * TEMP);
      TEMP = w * v_ij - v * w_ij - w * sum_v_ij / *n_total +
	     v * sum_w_ij / *n_total;
      src_s1 += o * (TEMP * TEMP);
    }
  }
  w *= w;
  src_s0 = src_s0 / *n_total_2 / w;
  src_s1 = src_s1 / *n_total_2 / (w * w);
  if (*nc == 2 && *nr == 2) {
    *x = (*n_total - 1) * a_i_j * a_i_j / (c_j_j * r_i_i);
    *df_a = 1;
    *p_a = khi(*df_a, *x);
    write_measure(stdout, "Mantel-Haenszel chi-square", 26L, 31L, 3L,
		  df_a, df_b, x, p_a, p_b);
  }
  write_measure_normal_head(stdout, "", 0L, 31L);
  y = sqrt(c_j_j * r_i_i);
  *x = a_i_j / y;
  *x_s0 = (a_i_i_j_j - a_i_j * a_i_j / *n_total) / (y * y);
  *x_s1 = pmc_s1;
  write_measure_normal(stdout, "Pearson (product-moment) corr.", 30L, 31L, x,
		       x_s0, x_s1);
  *x = 12 * r_s_u / sqrt(*n_total_3 - *sc_r) / sqrt(*n_total_3 - *sc_c);
  *x_s0 = src_s0;
  *x_s1 = src_s1;
  write_measure_normal(stdout, "Spearman rank corr. coef.", 25L, 31L, x,
		       x_s0, x_s1);
}  /* spearman */


/*@-"linear.c"*/


Static Void uncertainty(n_total, nrow, ncol, x, x_s0, x_s1, nrowpos, ncolpos,
			nmatpos)
t_long_integer *n_total;
t_integer *nrow, *ncol;
t_long_real *x, *x_s0, *x_s1;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
{
  t_long_real u_i = 0.0, u_j = 0.0, u_ij = 0.0, s_u_ij = 0.0, s_u_ji = 0.0,
	      s_u = 0.0;
  t_long_real r_i, c_j, o;
  t_long_integer i, j;
  double TEMP, TEMP1;

  for (j = 0; j < *ncol; j++) {
    c_j = n[ncolpos[j]];
    if (c_j != 0)
      u_j -= log(c_j / *n_total) * (c_j / *n_total);
  }
  for (i = 0; i < *nrow; i++) {
    r_i = n[nrowpos[i]];
    if (r_i != 0)
      u_i -= log(r_i / *n_total) * (r_i / *n_total);
  }
  for (j = 0; j < *ncol; j++) {
    for (i = 0; i < *nrow; i++) {
      o = n[nmatpos[i][j]];
      if (o != 0)
	u_ij -= log(o / *n_total) * (o / *n_total);
    }
  }
  for (j = 0; j < *ncol; j++) {
    c_j = (double)n[ncolpos[j]] / *n_total;
    for (i = 0; i < *nrow; i++) {
      o = n[nmatpos[i][j]];
      o /= *n_total;
      r_i = (double)n[nrowpos[i]] / *n_total;
      if (o > 0) {
	TEMP = (u_i - u_ij) * log(c_j) + u_j * (log(o) - log(r_i));
	s_u_ij += o * (TEMP * TEMP);
	TEMP = (u_j - u_ij) * log(r_i) + u_i * (log(o) - log(c_j));
	s_u_ji += o * (TEMP * TEMP);
	TEMP = u_ij * (log(r_i) + log(c_j)) - (u_j + u_i) * log(o);
	s_u += o * (TEMP * TEMP);
      }
    }
  }
  TEMP = u_j * u_j;
  s_u_ij = s_u_ij / (TEMP * TEMP) / *n_total;
  TEMP = u_i * u_i;
  s_u_ji = s_u_ji / (TEMP * TEMP) / *n_total;
  TEMP = u_j + u_i;
  TEMP1 = TEMP * TEMP;
  s_u = s_u * 4 / (TEMP1 * TEMP1) / *n_total;
  *x = (u_j + u_i - u_ij) / u_j;
  *x_s1 = s_u_ij;
  write_measure_normal(stdout, "Uncertainty coefficient U, R|C", 30L, 31L, x,
		       x_s0, x_s1);
  *x = (u_j + u_i - u_ij) / u_i;
  *x_s1 = s_u_ji;
  write_measure_normal(stdout, "Uncertainty coefficient U, C|R", 30L, 31L, x,
		       x_s0, x_s1);
  *x = (u_j + u_i - u_ij) / (u_i + u_j) * 2;
  *x_s1 = s_u;
  write_measure_normal(stdout, "Uncertainty coefficient U, sym", 30L, 31L, x,
		       x_s0, x_s1);
}  /* uncertainty */


Static Void kappa(n_total, nrow, ncol, n_total_2, n_total_3, x, x_s0, x_s1,
		  nrowpos, ncolpos, nmatpos)
t_long_integer *n_total;
t_integer *nrow, *ncol;
t_long_real *n_total_2, *n_total_3, *x, *x_s0, *x_s1;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
{
  t_long_real r_i, c_j, o, y, z;
  t_long_real p_o = 0.0, p_c = 0.0, p_c_1 = 0.0, p_c_2 = 0.0, p_c_3 = 0.0;
  t_long_integer i, j;
  double TEMP;

  if (*ncol == *nrow) {
    for (i = 0; i < *ncol; i++) {
      r_i = n[nrowpos[i]];
      c_j = n[ncolpos[i]];
      o = n[nmatpos[i][i]];
      p_o += o;
      p_c += r_i * c_j;
      *x = r_i + c_j;
      p_c_1 += o * *x;
      p_c_3 += r_i * c_j * *x;
      for (j = 0; j < *ncol; j++) {
	c_j = n[ncolpos[j]];
	o = n[nmatpos[i][j]];
	*x = r_i + c_j;
	p_c_2 += o * *x * *x;
      }
    }
  }
  p_o /= *n_total;
  p_c /= *n_total_2;
  p_c_1 /= *n_total_2;
  p_c_2 /= *n_total_3;
  p_c_3 /= *n_total_3;
  if (*ncol != *nrow)
    return;
  y = 1 - p_c;
  z = y * y;
  *x = (p_o - p_c) / y;
  *x_s0 = p_o * (1 - p_o) / z;
  *x_s1 = *x_s0 / *n_total;
  *x_s0 += 2 * (1 - p_o) * (2 * p_o * p_c - p_c_1) / z / y;
  TEMP = 1 - p_o;
  *x_s0 += TEMP * TEMP * (p_c_2 - 4 * p_c * p_c) / z / z;
  *x_s0 /= *n_total;
  write_measure_normal(stdout, "Kappa", 5L, 31L, x,
		       x_s0, x_s1);
  *x = (p_o - p_c) / y;
  *x_s0 = p_c + p_c * p_c - p_c_3;
  *x_s0 /= z * z;
  *x_s0 /= *n_total;
  write_measure_normal(stdout, "Kappa", 5L, 31L, x,
		       x_s0, x_s1);
}  /* kappa */


Static Void linear_trend(n_total, nrow, ncol, nr, nc, fr, lr, fc, lc, df_a,
			 df_b, x, p_a, p_b, nrowpos, ncolpos, nmatpos)
t_long_integer *n_total;
t_integer *nrow, *ncol;
t_long_integer *nr, *nc, *fr, *lr, *fc, *lc, *df_a, *df_b;
t_long_real *x, *p_a, *p_b;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
{
  t_long_real x_ = 0.0, b = 0.0, x_2_l = 0.0;
  t_long_real z_2;
  t_long_real y = 0.0;
  t_long_real z, p_1, p_2, o_1, mm;
  t_long_integer npoints, i;

  if (*nc != 2 && *nr != 2 || *nc <= 2 && *nr <= 2)
    return;
  if (*nc == 2) {
    p_1 = (double)n[ncolpos[*fc - 1]] / *n_total;
    p_2 = (double)n[ncolpos[*lc - 1]] / *n_total;
    npoints = *nrow;
  } else {
    p_1 = (double)n[nrowpos[*fr - 1]] / *n_total;
    p_2 = (double)n[nrowpos[*lr - 1]] / *n_total;
    npoints = *ncol;
  }
  for (i = 1; i <= npoints; i++) {
    if (*nc == 2)
      mm = n[nrowpos[i-1]];
    else
      mm = n[ncolpos[i-1]];
    x_ += mm * i;
  }
  x_ /= *n_total;
  for (i = 1; i <= npoints; i++) {
    if (*nc == 2) {
      mm = n[nrowpos[i-1]];
      o_1 = n[nmatpos[i-1][*fc - 1]];
    } else {
      mm = n[ncolpos[i-1]];
      o_1 = n[nmatpos[*fr - 1][i-1]];
    }
    if (mm > 0) {
      z = i - x_;
      b += mm * (o_1 / mm - p_1) * z;
      y += mm * z * z;
    }
  }
  b /= y;
  z_2 = b * b * y / p_1 / p_2;
  *x = z_2;
  *df_a = 1;
  *p_a = khi(*df_a, *x);
  write_measure(stdout, "Cochran-Armitage Trend Test", 27L, 31L, 3L, df_a,
		df_b, x, p_a, p_b);
  for (i = 1; i <= npoints; i++) {
    if (*nc == 2) {
      mm = n[nrowpos[i-1]];
      o_1 = n[nmatpos[i-1][*fc - 1]];
    } else {
      mm = n[ncolpos[i-1]];
      o_1 = n[nmatpos[*fr - 1][i-1]];
    }
    if (mm > 0) {
      z = p_1 + b * (i - x_);
      z = o_1 / mm - z;
      x_2_l += mm * z * z;
    }
  }
  x_2_l = x_2_l / p_1 / p_2;
  *x = x_2_l;
  *df_a = npoints - 2;
  *p_a = khi(*df_a, *x);
  if (*nc == 2)
    *df_b = *nr - 2;
  else
    *df_b = *nc - 2;
  if (*df_b < *df_a)
    *p_b = khi(*df_b, *x);
  else
    *df_b = _INVALID;
  write_measure(stdout, "Goodness of fit, linear trend", 29L, 31L, 3L, df_a,
		df_b, x, p_a, p_b);
}  /* linear_trend */


Static Void mcnemar(nrow, ncol, nr, df_a, df_b, x, p_a, p_b, nmatpos)
t_integer *nrow, *ncol;
t_long_integer *nr, *df_a, *df_b;
t_long_real *x, *p_a, *p_b;
t_integer (*nmatpos)[MAX_LEVEL];
{
  t_long_real mcnemar = 0.0;
  t_long_real a, b, c;
  t_long_integer i, j;

  if (*ncol == *nrow) {
    for (i = 0; i < *ncol; i++) {
      for (j = i + 1; j < *nrow; j++) {
	a = n[nmatpos[j][i]];
	b = n[nmatpos[i][j]];
	c = a - b;
	if (a + b > 0)
	  mcnemar += c * c / (a + b);
      }
    }
  }
  if (*ncol != *nrow)
    return;
  *x = mcnemar;
  *df_a = (long)floor(*nrow * (*nrow - 1.0) / 2 + 0.5);
  *p_a = khi(*df_a, *x);
  if (*nr < *nrow) {
    *df_b = (long)floor(*nr * (*nr - 1.0) / 2 + 0.5);
    *p_b = khi(*df_b, *x);
  }
  write_measure(stdout, "McNemar's test of symmetry", 26L, 31L, 3L, df_a,
		df_b, x, p_a, p_b);
}  /* mcnemar */


/*@-"slice.c"*/


Static Void print_slice(v__, w__, vertex_set, cell, n_total, nrow, ncol,
			nrowpos, ncolpos, nmatpos)
t_vertex *v__, *w__;
long *vertex_set;
t_level *cell;
t_long_integer *n_total;
t_integer *nrow, *ncol;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
{
  t_vertex u__, u___;
  t_long_real n_total_2, n_total_3, n_total_4, p_1_side, p_2_side, x_2, g_2,
	      q_c, o, e, m, x, x_s0, x_s1, p_a, p_b, ss_r, ss_c, ss_1_r,
	      ss_1_c, sc_r, sc_c, r_i, c_j, a, b, c, d, r1, r2, c1, c2;
  t_long_integer fr, lr, fc, lc, nr, nc, df_a, df_b, i, j;
  boolean ok;
  long FORLIM;
  double TEMP;

  n_total_2 = *n_total * *n_total;
  n_total_3 = *n_total * n_total_2;
  n_total_4 = n_total_2 * n_total_2;
  if (n_total_2 >= *n_total && n_total_3 >= n_total_2 &&
      n_total_4 >= n_total_3) {
    nc = 0;
    ss_c = 0.0;
    sc_c = 0.0;
    ss_1_c = 0.0;
    fc = 1;
    lc = 1;
    for (j = 1; j <= *ncol; j++) {
      c_j = n[ncolpos[j-1]];
      if (c_j != 0) {
	nc++;
	if (nc == 1)
	  fc = j;
	else
	  lc = j;
      }
      ss_c += c_j * c_j;
      sc_c += c_j * c_j * c_j;
      ss_1_c += c_j * (c_j - 1);
    }
    nr = 0;
    ss_r = 0.0;
    sc_r = 0.0;
    ss_1_r = 0.0;
    fr = 1;
    lr = 1;
    for (i = 1; i <= *nrow; i++) {
      r_i = n[nrowpos[i-1]];
      if (r_i != 0) {
	nr++;
	if (nr == 1)
	  fr = i;
	else
	  lr = i;
      }
      ss_r += r_i * r_i;
      sc_r += r_i * r_i * r_i;
      ss_1_r += r_i * (r_i - 1);
    }
    df_a = _INVALID;
    df_b = _INVALID;
    x = _INVALID_REAL;
    x_s0 = _INVALID_REAL;
    x_s1 = _INVALID_REAL;
    p_a = _INVALID_REAL;
    p_b = _INVALID_REAL;
    x_2 = 0.0;
    g_2 = 0.0;
    q_c = 0.0;
    for (j = 0; j < *ncol; j++) {
      c_j = n[ncolpos[j]];
      for (i = 0; i < *nrow; i++) {
	r_i = n[nrowpos[i]];
	e = c_j * r_i / *n_total;
	o = n[nmatpos[i][j]];
	if (e > 0) {
	  TEMP = o - e;
	  x_2 += TEMP * TEMP / e;
	}
	x = fabs(e - o) - 0.5;
	if (x > 0 && e > 0)
	  q_c += x * x / e;
	if (e > 0 && o > 0)
	  g_2 += 2 * o * log(o / e);
      }
    }
    if (*nrow < *ncol)
      m = *nrow;
    else
      m = *ncol;
    if (nr < nc)
      m = nr;
    else
      m = nc;
    a = n[nmatpos[fr-1][fc-1]];
    b = n[nmatpos[lr-1][fc-1]];
    c = n[nmatpos[fr-1][lc-1]];
    d = n[nmatpos[lr-1][lc-1]];
    c1 = n[ncolpos[fc-1]];
    c2 = n[ncolpos[lc-1]];
    r1 = n[nrowpos[fr-1]];
    r2 = n[nrowpos[lr-1]];
    page(stdout);
    write_line(stdout);
    if (!P_setequal(vertex_set, empty_set)) {
      ok = false;
      write_space(stdout, 2L);
      write_pch(stdout, "Cell:", 5L);
      u___ = first_vertex;
      for (u__ = first_vertex; u__ <= last_vertex; u__++) {
	if (P_inset(u__, vertex_set)) {
	  if (ok)
	    write_char(stdout, ',');
	  ok = true;
	  write_space(stdout, 2L);
	  print_vertex_on_file(stdout, u__, 0L);
	  write_space(stdout, 1L);
	  write_char(stdout, '=');
	  write_space(stdout, 1L);
	  write_integer(stdout, cell[u___ - MIN_VERTEX] - FIRST_LEVEL + 1L,
			1L);
	  u___++;
	}
      }
      write_char(stdout, '.');
      write_line(stdout);
      write_line(stdout);
    }
    write_space(stdout, 3L);
    write_char(stdout, '\\');
    write_char(stdout, ' ');
    write_char(stdout, variable_description[*w__ - MIN_VERTEX]->name);
    write_char(stdout, ' ');
    write_char(stdout, '|');
    for (i = 1; i <= *ncol; i++)
      write_integer(stdout, i, 5L);
    write_space(stdout, 1L);
    write_char(stdout, '|');
    write_space(stdout, 6L);
    if (long_names)
      print_vertex_on_file(stdout, *w__, 0L);
    write_line(stdout);
    write_space(stdout, 4L);
    write_char(stdout, '\\');
    write_space(stdout, 2L);
    write_char(stdout, '|');
    write_space(stdout, *ncol * 5 + 1);
    write_char(stdout, '|');
    write_space(stdout, 6L);
    write_line(stdout);
    write_space(stdout, 3L);
    write_char(stdout, variable_description[*v__ - MIN_VERTEX]->name);
    write_space(stdout, 1L);
    write_char(stdout, '\\');
    write_space(stdout, 1L);
    write_char(stdout, '|');
    write_space(stdout, *ncol * 5 + 1);
    write_char(stdout, '|');
    write_space(stdout, 6L);
    if (long_names)
      print_vertex_on_file(stdout, *v__, 0L);
    write_line(stdout);
    write_space(stdout, 2L);
    for (i = 2; i <= 5; i++)
      write_char(stdout, '_');
    write_char(stdout, '\\');
    write_char(stdout, '|');
    FORLIM = *ncol * 5 + 1;
    for (i = 1; i <= FORLIM; i++)
      write_char(stdout, '_');
    write_char(stdout, '|');
    for (i = 1; i <= 6; i++)
      write_char(stdout, '_');
    write_line(stdout);
    for (j = 1; j <= *nrow; j++) {
      write_space(stdout, 2L);
      write_integer(stdout, j, 2L);
      write_space(stdout, 2L);
      write_space(stdout, 1L);
      write_char(stdout, '|');
      for (i = 0; i < *ncol; i++)
	write_integer(stdout, n[nmatpos[j-1][i]], 5L);
      write_space(stdout, 1L);
      write_char(stdout, '|');
      write_space(stdout, 1L);
      write_integer(stdout, n[nrowpos[j-1]], 5L);
      write_line(stdout);
    }
    write_space(stdout, 2L);
    FORLIM = (*ncol + 1) * 5 + 9;
    for (i = 1; i <= FORLIM; i++)
      write_char(stdout, '=');
    write_line(stdout);
    write_space(stdout, 7L);
    write_char(stdout, '|');
    for (i = 0; i < *ncol; i++)
      write_integer(stdout, n[ncolpos[i]], 5L);
    write_space(stdout, 1L);
    write_char(stdout, '|');
    write_space(stdout, 1L);
    write_integer(stdout, *n_total, 5L);
    write_line(stdout);
    write_line(stdout);
    if (nc == 2 && nr == 2) {
      fisher((long)floor(a + 0.5), (long)floor(b + 0.5), (long)floor(c + 0.5),
	     (long)floor(d + 0.5), &p_1_side, &p_2_side);
      write_pch_r(stdout, "Fisher's exact test", 19L, 31L);
      write_space(stdout, 2L);
      write_pch(stdout, "(1-Tail): ", 10L);
      write_real(stdout, p_1_side, prob_width, prob_dec);
      write_space(stdout, 1L);
      write_pch(stdout, "(2-Tail): ", 10L);
      write_real(stdout, p_2_side, prob_width, prob_dec);
      write_line(stdout);
    }
    write_measure_head(stdout, "", 0L, 31L);
    x = x_2;
    df_a = (*ncol - 1) * (*nrow - 1);
    p_a = khi(df_a, x);
    if (nc < *ncol || nr < *nrow) {
      df_b = (nc - 1) * (nr - 1);
      p_b = khi(df_b, x);
    }
    write_measure(stdout, "Pearson X^2 test", 16L, 31L, 3L,
		  &df_a, &df_b, &x, &p_a, &p_b);
    x = g_2;
    df_a = (*ncol - 1) * (*nrow - 1);
    p_a = khi(df_a, x);
    if (nc < *ncol || nr < *nrow) {
      df_b = (nc - 1) * (nr - 1);
      p_b = khi(df_b, x);
    }
    write_measure(stdout, "G^2 likelihood ratio test", 25L, 31L, 3L,
		  &df_a, &df_b, &x, &p_a, &p_b);
    x = q_c;
    df_a = (*ncol - 1) * (*nrow - 1);
    p_a = khi(df_a, x);
    if (nc < *ncol || nr < *nrow) {
      df_b = (nc - 1) * (nr - 1);
      p_b = khi(df_b, x);
    }
    write_measure(stdout, "Continuity-adjusted chi-square", 30L, 31L, 3L,
		  &df_a, &df_b, &x, &p_a, &p_b);
    if (nc == 2 && nr == 2) {
      TEMP = fabs(a * d - b * c) - *n_total / 2.0;
      x = *n_total * (TEMP * TEMP) / r1 / r2 / c1 / c2;
      df_a = 1;
      p_a = khi(df_a, x);
      write_measure(stdout, "Yates corrected X^2", 19L, 31L, 3L,
		    &df_a, &df_b, &x, &p_a, &p_b);
    }
    mcnemar(nrow, ncol, &nr, &df_a, &df_b, &x, &p_a, &p_b, nmatpos);
    if (m > 1 && *n_total > 0) {
      x = sqrt(x_2 / *n_total / (m - 1));
      df_a = 1;
      p_a = khi(df_a, x);
    }
    write_measure(stdout, "Cramer's V", 10L, 31L, 3L,
		  &df_a, &df_b, &x, &p_a, &p_b);
    if (nc == 2 && nr == 2)
      x = (a * d - b * c) / sqrt(r1 * r2 * c1 * c2);
    else if (*n_total > 0)
      x = sqrt(x_2 / *n_total);
    write_measure(stdout, "Phi", 3L, 31L, 1L,
		  &df_a, &df_b, &x, &p_a, &p_b);
    if (nc == 2 && nr == 2) {
      if (r1 != 0 && r2 != 0 && c1 != 0 && c2 != 0) {
	if (a * d < b * c)
	  x = -sqrt(r1 * c1 / r2 / c2);
	else
	  x = sqrt(r1 * c2 / r2 / c1);
	if (fabs(x) > 1)
	  x = 1 / x;
      }
      write_measure(stdout, "Max Phi", 7L, 31L, 1L,
		    &df_a, &df_b, &x, &p_a, &p_b);
    }
    if (*n_total > 0)
      x = sqrt(x_2 / (*n_total + x_2));
    write_measure(stdout, "Contingency Coefficient C", 25L, 31L, 1L,
		  &df_a, &df_b, &x, &p_a, &p_b);
    if (nc == 2 && nr == 2) {
      if (r1 != 0 && r2 != 0 && c1 != 0 && c2 != 0) {
	if (a * d < b * c)
	  x = -sqrt(r1 * c1 / r2 / c2);
	else
	  x = sqrt(r1 * c2 / r2 / c1);
	if (fabs(x) > 1)
	  x = 1 / x;
	x = sqrt(x * x / (1 + x * x));
      }
      write_measure(stdout, "Max Contingency coefficient", 27L, 31L, 1L,
		    &df_a, &df_b, &x, &p_a, &p_b);
    }
    if (false)
      write_measure(stdout, "Tetrachoric correlation", 23L, 31L, 3L,
		    &df_a, &df_b, &x, &p_a, &p_b);
    if (nc >= 2 && nr >= 2)
      linear_trend(n_total, nrow, ncol, &nr, &nc, &fr, &lr, &fc, &lc, &df_a,
		   &df_b, &x, &p_a, &p_b, nrowpos, ncolpos, nmatpos);
    if (nc == 2 && nr == 2) {
      if (b * c != 0) {
	x = a * d / (b * c);
	df_a = 1;
	p_a = khi(df_a, x);
      }
      write_measure(stdout, "Cross-product ratio alpha", 25L, 31L, 3L,
		    &df_a, &df_b, &x, &p_a, &p_b);
    }
    if (nc >= 2 && nr >= 2)
      spearman(n_total, nrow, ncol, &nr, &nc, &df_a, &df_b, &n_total_2,
	       &n_total_3, &sc_r, &sc_c, &x, &x_s0, &x_s1, &p_a, &p_b,
	       nrowpos, ncolpos, nmatpos);
    if (nc == 2 && nr == 2) {
      if (a * b * c * d != 0) {
	x = log(a * d / (b * c));
	x_s1 = 1 / a + 1 / b + 1 / c + 1 / d;
	x_s0 = n_total_3 / ((a + b) * (a + c) * (b + d) * (c + d));
      }
      write_measure_normal(stdout, "Ln(Cross-product ratio)", 23L, 31L,
			   &x, &x_s0, &x_s1);
    }
    if (nc == 2 && nr == 2) {
      if (a * d + b * c != 0) {
	x = (a * d - b * c) / (a * d + b * c);
	if (a * b * c * d != 0) {
	  TEMP = 1 - x * x;
	  x_s1 = TEMP * TEMP * (1 / a + 1 / b + 1 / c + 1 / d) / 4;
	}
	x_s0 = n_total_3 / ((a + b) * (a + c) * (b + d) * (c + d)) / 4;
      }
      write_measure_normal(stdout, "Yule's Q", 8L, 31L,
			   &x, &x_s0, &x_s1);
    }
    if (nc == 2 && nr == 2) {
      if (sqrt(a * d) + sqrt(b * c) != 0) {
	x = (sqrt(a * d) - sqrt(b * c)) / (sqrt(a * d) + sqrt(b * c));
	if (a * b * c * d != 0) {
	  TEMP = 1 - x * x;
	  x_s1 = TEMP * TEMP * (1 / a + 1 / b + 1 / c + 1 / d) / 16;
	}
	x_s0 = n_total_3 / ((a + b) * (a + c) * (b + d) * (c + d)) / 16;
      }
      write_measure_normal(stdout, "Yule's Y", 8L, 31L,
			   &x, &x_s0, &x_s1);
    }
    if (nc >= 2 && nr >= 2) {
      gamma_and_tau(n_total, nrow, ncol, &n_total_2, &n_total_3, &n_total_4,
		    &ss_r, &ss_c, &ss_1_r, &ss_1_c, &m, &x, &x_s0, &x_s1,
		    nrowpos, ncolpos, nmatpos);
      goodman_and_kruskal(n_total, nrow, ncol, &n_total_2, &ss_r, &ss_c,
			  &sc_r, &sc_c, &x, &x_s0, &x_s1, nrowpos, ncolpos,
			  nmatpos);
      optimal_prediction(n_total, nrow, ncol, &x, &x_s0, &x_s1, nrowpos,
			 ncolpos, nmatpos);
      uncertainty(n_total, nrow, ncol, &x, &x_s0, &x_s1, nrowpos, ncolpos,
		  nmatpos);
      kappa(n_total, nrow, ncol, &n_total_2, &n_total_3, &x, &x_s0, &x_s1,
	    nrowpos, ncolpos, nmatpos);
    }
  } else
    write_pch(stdout, " Too many observations", 22L);
  write_line(stdout);
}  /* print_slice */


/*@-"gamma.c"*/
/*@+"gamma.p"*/


Static Void find_concedances_fast(nrow, ncol, nmatpos, s, s1, p, q, pvalues,
				  ok)
t_integer *nrow, *ncol;
t_integer (*nmatpos)[MAX_LEVEL];
t_long_real *s, *s1;
t_long_integer *p, *q;
boolean pvalues, *ok;
{
  t_long_integer c, d, i, j, k, l, nij;
  t_long_integer ncc = 0, ndd = 0, ncd = 0;
  t_long_real p2, q2, m;

  *s = 0.0;
  for (i = 1; i <= *nrow; i++) {
    for (j = 1; j <= *ncol; j++) {
      c = 0;
      d = 0;
      for (k = 0; k <= i - 2; k++) {
	for (l = 0; l <= j - 2; l++)
	  c += n[nmatpos[k][l]];
      }
      for (k = i; k < *nrow; k++) {
	for (l = 0; l <= j - 2; l++)
	  d += n[nmatpos[k][l]];
      }
      for (k = 0; k <= i - 2; k++) {
	for (l = j; l < *ncol; l++)
	  d += n[nmatpos[k][l]];
      }
      for (k = i; k < *nrow; k++) {
	for (l = j; l < *ncol; l++)
	  c += n[nmatpos[k][l]];
      }
      nij = n[nmatpos[i-1][j-1]];
      ncc += nij * c * c;
      ndd += nij * d * d;
      ncd += nij * c * d;
      *p += nij * c;
      *q += nij * d;
      m = c - d;
      *s += nij * m * m;
    }
  }
  if (pvalues && *p + *q > 0) {
    *ok = true;
    p2 = *p;
    q2 = *q;
    *s1 = q2 * q2 * ncc + p2 * p2 * ndd - 2 * p2 * q2 * ncd;
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1633L, 1L))
    return;
  /*$endif TRACE*/
  write_real(stdout, m, 10L, 0L);
  write_real(stdout, (double)ncc, 10L, 0L);
  write_real(stdout, (double)ndd, 10L, 0L);
  write_real(stdout, (double)ncd, 10L, 0L);
}  /* find_concedances_fast */


Static Void find_concedances_large_counts(nrow, ncol, nmatpos, s, s1, p, q,
					  pvalues, ok)
t_integer *nrow, *ncol;
t_integer (*nmatpos)[MAX_LEVEL];
t_long_real *s, *s1;
t_long_integer *p, *q;
boolean pvalues, *ok;
{
  t_long_integer i, j;
  t_long_real m;
  t_integer (*cij)[MAX_LEVEL], (*dij)[MAX_LEVEL];

  cij = (t_integer(*)[MAX_LEVEL])Malloc(sizeof(t_level_2_arr_of_integer));
  if (cij == NULL)
    _OutMem();
  dij = (t_integer(*)[MAX_LEVEL])Malloc(sizeof(t_level_2_arr_of_integer));
  if (dij == NULL)
    _OutMem();
  sub_find_concedances(nrow, ncol, nmatpos, cij, dij, p, q);
  if (pvalues && *p + *q > 0) {
    *ok = true;
    *s = 0.0;
    for (i = 0; i < *nrow; i++) {
      for (j = 0; j < *ncol; j++) {
	m = cij[i][j] - dij[i][j];
	*s += n[nmatpos[i][j]] * m * m;
	m = *q * cij[i][j] - *p * dij[i][j];
	*s1 += n[nmatpos[i][j]] * m * m;
      }
    }
  }
  _Free(cij);
  _Free(dij);
}  /* find_concedances_large_counts */


Static Void find_gamma(n_total, nrow, ncol, nmatpos, pvalues, ppq, pmq, gamma,
		       s, s1, ok)
t_long_integer *n_total;
t_integer *nrow, *ncol;
t_integer (*nmatpos)[MAX_LEVEL];
boolean pvalues;
t_long_real *ppq, *pmq, *gamma, *s, *s1;
boolean *ok;
{
  t_long_integer p = 0, q = 0;

  *s = 0.0;
  *s1 = 0.0;
  *ok = false;
  if (boolean_option[109] && *n_total < 100 || boolean_option[108])
    find_concedances_fast(nrow, ncol, nmatpos, s, s1, &p, &q, pvalues, ok);
  else
    find_concedances_large_counts(nrow, ncol, nmatpos, s, s1, &p, &q, pvalues,
				  ok);
  *ppq = p + q;
  *pmq = p - q;
  if (*ok) {
    *gamma = *pmq / *ppq;
    *s -= *pmq * *pmq / *n_total;
    *s *= 4;
    *s1 = *s1 * 16 / *ppq / *ppq;
  } else {
    *gamma = 0.0;
    *s = 0.0;
    *s1 = 0.0;
    *ok = false;
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1635L, 1L))
    return;
  /*$endif TRACE*/
  write_integer(stdout, *nrow, 4L);
  write_integer(stdout, *ncol, 4L);
  write_integer(stdout, *n_total, 4L);
  write_real(stdout, (double)p, 10L, 0L);
  write_real(stdout, (double)q, 10L, 0L);
  write_line(stdout);
  write_real(stdout, *ppq, 10L, 6L);
  write_real(stdout, *pmq, 10L, 6L);
  write_real(stdout, *gamma, 10L, 6L);
  if (*s > 0)
    write_real(stdout, pnormal(fabs(*gamma / sqrt(*s) * *ppq)), 10L, 6L);
  else
    write_real(stdout, 2.0, 10L, 6L);
  write_real(stdout, *s, 10L, 6L);
  write_real(stdout, *s1, 10L, 6L);
  write_real(stdout, (*s - *s1) / (*s + *s1), 10L, 6L);
  write_line(stdout);
}  /* find_gamma */


Static Void compute_slice_statistics(v, w, n_levels_v, n_levels_w, c,
  vc_offset, wc_offset, vwc_offset, slice_pack, gammatot, stot, s1tot,
  print_slices)
t_vertex *v, *w;
t_level *n_levels_v, *n_levels_w;
long *c;
t_offset vc_offset, wc_offset, vwc_offset;
t_slice_pack *slice_pack;
t_long_real *gammatot, *stot, *s1tot;
boolean print_slices;
{
  t_cell_index index_1, index_2, n_l_w_p_vwc_w, pos_1_vc, pos_2_wc, pos_3_vwc;
  boolean ok;
  t_long_real gamma, ppq, pmq, s, s1;
  t_long_real ppqtot = 0.0, pmqtot = 0.0;
  t_long_integer n_total;
  t_cell i;
  t_offset i_v, i_w, i_c;
  t_integer nrowx, ncolx, ncolx1;
  long *nrowpos, *ncolpos;
  t_integer (*nmatpos)[MAX_LEVEL];
  boolean zero_col[MAX_LEVEL];
  t_offset FORLIM;

  nmatpos = (t_integer(*)[MAX_LEVEL])Malloc(sizeof(t_level_2_arr_of_integer));
  if (nmatpos == NULL)
    _OutMem();
  nrowpos = (long *)Malloc(sizeof(t_level_arr_of_integer));
  if (nrowpos == NULL)
    _OutMem();
  ncolpos = (long *)Malloc(sizeof(t_level_arr_of_integer));
  if (ncolpos == NULL)
    _OutMem();
  memcpy(i, first_cell, sizeof(t_cell));
  n_l_w_p_vwc_w = *n_levels_w * slice_pack->p_vwc_w;
  pos_1_vc = vc_offset;
  pos_2_wc = wc_offset;
  pos_3_vwc = vwc_offset;
  *stot = 0.0;
  *s1tot = 0.0;
  FORLIM = slice_pack->marginal_dimension_c;
  for (i_c = 1; i_c <= FORLIM; i_c++) {
    index_2 = pos_2_wc;
    ncolx = 0;
    n_total = 0;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1636L, 4L))
      write_pch_10_text(stdout, " Ncol: ", 7L);
    /*$endif TRACE*/
    for (i_w = 0; i_w <= *n_levels_w - 1; i_w++) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1636L, 4L))
	write_cell_count_text(stdout, &n[index_2], 4L);
      /*$endif TRACE*/
      if (n[index_2] == 0 && !print_slices)
	zero_col[i_w] = true;
      else {
	n_total += n[index_2];
	zero_col[i_w] = false;
	ncolx++;
	ncolpos[ncolx-1] = index_2;
      }
      index_2 += slice_pack->p_wc_w;
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1636L, 4L)) {
      write_integer_text(stdout, n_total, 4L);
      write_integer_text(stdout, ncolx, 4L);
      write_line_text(stdout);
    }
    /*$endif TRACE*/
    index_1 = pos_1_vc;
    index_2 = pos_3_vwc;
    nrowx = 0;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1636L, 4L))
      write_pch_10_text(stdout, " Nrow: ", 7L);
    /*$endif TRACE*/
    n_total = 0;
    for (i_v = 1; i_v <= *n_levels_v; i_v++) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1636L, 4L))
	write_cell_count_text(stdout, &n[index_1], 4L);
      /*$endif TRACE*/
      if (n[index_1] == 0 && !print_slices) {
	for (i_w = 1; i_w <= *n_levels_w; i_w++)
	  index_2 += slice_pack->p_vwc_w;
      } else {
	n_total += n[index_1];
	nrowx++;
	nrowpos[nrowx-1] = index_1;
	ncolx1 = 0;
	for (i_w = 0; i_w <= *n_levels_w - 1; i_w++) {
	  if (!zero_col[i_w]) {
	    ncolx1++;
	    nmatpos[nrowx-1][ncolx1-1] = index_2;
	  }
	  index_2 += slice_pack->p_vwc_w;
	}
      }
      index_2 += slice_pack->p_vwc_v - n_l_w_p_vwc_w;
      index_1 += slice_pack->p_vc_v;
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1636L, 4L)) {
      write_integer_text(stdout, n_total, 4L);
      write_integer_text(stdout, nrowx, 4L);
      write_line_text(stdout);
    }
    /*$endif TRACE*/
    if (nrowx > 1 && ncolx > 1) {
      if (print_slices)
	print_slice(v, w, c, i, &n_total, &nrowx, &ncolx, nrowpos, ncolpos,
		    nmatpos);
      else {
	find_gamma(&n_total, &nrowx, &ncolx, nmatpos, true, &ppq, &pmq,
		   &gamma, &s, &s1, &ok);
	ppqtot += ppq;
	pmqtot += pmq;
	*stot += s;
	*s1tot += s1;
      }
    }
    next_offset_in_slice(slice_pack, &pos_1_vc, &pos_2_wc, &pos_3_vwc, i);
  }
  _Free(nmatpos);
  _Free(nrowpos);
  _Free(ncolpos);
  if (ppqtot > 0 && !print_slices) {
    *gammatot = pmqtot / ppqtot;
    *stot /= ppqtot;
    *stot /= ppqtot;
    *s1tot /= ppqtot;
    *s1tot /= ppqtot;
  } else {
    *gammatot = _INVALID_REAL;
    *stot = _INVALID_REAL;
    *s1tot = _INVALID_REAL;
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1636L, 1L))
    return;
  /*$endif TRACE*/
  write_real(stdout, ppqtot, 10L, 6L);
  write_real(stdout, pmqtot, 10L, 6L);
  write_real(stdout, *gammatot, 10L, 6L);
  write_real(stdout, pnormal(fabs(*gammatot / sqrt(*stot))), 10L, 6L);
  write_real(stdout, *stot, 10L, 6L);
  write_real(stdout, *s1tot, 10L, 6L);
  write_line(stdout);
}  /* compute_slice_statistics */


/*@-"offsets.c"*/
/*@+"dual.p"*/


Static Void find_g_c_intersection_maximal(in_1, in_2, out_g_c)
t_set_list *in_1, **in_2, **out_g_c;
{
  t_set_list *p;
  t_vertex_set vertex_set;

  *out_g_c = NULL;
  while (in_1 != NULL) {
    p = *in_2;
    while (p != NULL) {
      P_setint(vertex_set, in_1->vertex_set, p->vertex_set);
      insert_clique(vertex_set, out_g_c);
      p = p->pointer;
    }
    in_1 = in_1->pointer;
  }
}  /* find_g_c_intersection_maximal */


Static Void find_g_c_union_minimal(in_1, in_2, out_g_c)
t_set_list *in_1, **in_2, **out_g_c;
{
  t_set_list *p;
  t_vertex_set vertex_set;

  *out_g_c = NULL;
  while (in_1 != NULL) {
    p = *in_2;
    while (p != NULL) {
      P_setunion(vertex_set, in_1->vertex_set, p->vertex_set);
      insert_set_minimal(vertex_set, out_g_c);
      p = p->pointer;
    }
    in_1 = in_1->pointer;
  }
}  /* find_g_c_union_minimal */


Static Void normal_to_dual(g_c, g, g_c_dual)
t_set_list *g_c;
long *g;
t_set_list **g_c_dual;
{
  t_g_c_list *g_c_list = NULL;
  t_g_c_list *tmp_g_c;
  t_set_list *p;
  t_vertex v;
  t_vertex_set b, c;

  if (g_c == NULL) {
    write_pch(stdout, " --NormalDualError--", 20L);
    *g_c_dual = NULL;
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, g)) {
	P_addset(P_expset(b, 0L), v);   /* empty_set + */
	insert_set_in_set_list(b, g_c_dual);
      }
    }
    return;
  }
  if (g_c->pointer == NULL && P_setequal(g_c->vertex_set, g)) {
    *g_c_dual = (t_set_list *)Malloc(sizeof(t_set_list));
    if (*g_c_dual == NULL)
      _OutMem();
    P_setcpy((*g_c_dual)->vertex_set, empty_set);
    (*g_c_dual)->pointer = NULL;
    return;
  }
  while (g_c != NULL) {
    tmp_g_c = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (tmp_g_c == NULL)
      _OutMem();
    tmp_g_c->g_c = NULL;
    tmp_g_c->pointer = g_c_list;
    g_c_list = tmp_g_c;
    P_setdiff(c, g, g_c->vertex_set);
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, c)) {
	P_addset(P_expset(b, 0L), v);   /* empty_set + */
	insert_set_in_set_list(b, &g_c_list->g_c);
      }
    }
    g_c = g_c->pointer;
  }
  while (g_c_list->pointer != NULL) {
    find_g_c_union_minimal(g_c_list->g_c, &g_c_list->pointer->g_c, &p);
    dispose_set_list(&g_c_list->g_c);
    tmp_g_c = g_c_list;
    g_c_list = g_c_list->pointer;
    _Free(tmp_g_c);
    dispose_set_list(&g_c_list->g_c);
    g_c_list->g_c = p;
  }
  *g_c_dual = g_c_list->g_c;
  _Free(g_c_list);
}  /* normal_to_dual */


Static Void dual_to_normal(g_c_dual, g, g_c)
t_set_list *g_c_dual;
long *g;
t_set_list **g_c;
{
  t_g_c_list *g_c_list = NULL;
  t_g_c_list *tmp_g_c;
  t_set_list *p;
  t_vertex v;
  t_vertex_set vertex_set;

  if (g_c_dual == NULL) {
    write_pch(stdout, " --DualNormalError--", 20L);
    *g_c = (t_set_list *)Malloc(sizeof(t_set_list));
    if (*g_c == NULL)
      _OutMem();
    P_setcpy((*g_c)->vertex_set, g);
    (*g_c)->pointer = NULL;
    return;
  }
  if (g_c_dual->pointer == NULL && P_setequal(g_c_dual->vertex_set, empty_set)) {
    *g_c = (t_set_list *)Malloc(sizeof(t_set_list));
    if (*g_c == NULL)
      _OutMem();
    P_setcpy((*g_c)->vertex_set, g);
    (*g_c)->pointer = NULL;
    return;
  }
  while (g_c_dual != NULL) {
    tmp_g_c = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (tmp_g_c == NULL)
      _OutMem();
    tmp_g_c->g_c = NULL;
    tmp_g_c->pointer = g_c_list;
    g_c_list = tmp_g_c;
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, g_c_dual->vertex_set)) {
	P_setcpy(vertex_set, g);
	P_remset(vertex_set, v);
	insert_set_in_set_list(vertex_set, &g_c_list->g_c);
      }
    }
    g_c_dual = g_c_dual->pointer;
  }
  while (g_c_list->pointer != NULL) {
    find_g_c_intersection_maximal(g_c_list->g_c, &g_c_list->pointer->g_c, &p);
    dispose_set_list(&g_c_list->g_c);
    tmp_g_c = g_c_list;
    g_c_list = g_c_list->pointer;
    _Free(tmp_g_c);
    dispose_set_list(&g_c_list->g_c);
    g_c_list->g_c = p;
  }
  *g_c = g_c_list->g_c;
  _Free(g_c_list);
}  /* dual_to_normal */


/*@-"print.c"*/
/*@+"print.p"*/


/*

1672:    +++  ++
1673:    +++  ++
1674:    ---  -- p/print.p         16      71     897 p/print.p
1675: |    4:    function negative_flag_set
1676: |   17:    procedure identify_model_full
1677: |  109:    procedure print_adjacency_matrix
1678: |  147:    procedure sub_print_order
1679: |  174:    procedure print_order
1680: |  195:    procedure describe_edges
1681: |  237:    procedure write_discrete_model
1682: |  356:    procedure write_mixed_model
1683: |  416:    procedure write_continuous_model
1684: |  452:    procedure write_model
1685: |  463:    procedure describe_formula
1686: |  474:    procedure describe_model
1687: |  525:    procedure note_trace_model
1688: |  531:    procedure note_trace_model
1689: |  559:    procedure note_trace_expression
1690: |  565:    procedure note_trace_expression
1691:    +++  ++
1692:    +++  ++

*/


Static boolean negative_flag_set(sub_code, n)
t_long_integer *sub_code, n;
{
  boolean ok = false;

  if (*sub_code <= -n) {
    ok = true;
    *sub_code += n;
  }
  return ok;
}  /* negative_flag_set */


Static boolean neg_pos_flag_set(sub_code, n)
t_long_integer *sub_code, n;
{
  boolean ok = false;

  if (*sub_code <= -n) {
    ok = true;
    *sub_code += n;
  }
  if (*sub_code >= n) {
    ok = true;
    *sub_code -= n;
  }
  return ok;
}  /* neg_pos_flag_set */


Static Void identify_model_full_discrete(model, sets_d_g_c, sets_g_g_c,
  fill_in_adj_list, order, invers_order, c, complete)
t_model **model;
t_set_list **sets_d_g_c, **sets_g_g_c;
t_vertex_list **fill_in_adj_list;
short *order;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
{
  t_v_arr_of_v_sets fill_in_adj_set, adj_set;
  t_v_arr_of_v_lists adj_list;
  t_vertex v;
  t_adjacency_matrix gc_adjacency_matrix;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IdentifyModelFullDe", sizeof(pch20));
  ntr(tzt, 20L, 1676L, 1L, -1L, -1L);
  /*$endif TRACE*/
  dispose_model_but_identification(model);
  *sets_g_g_c = NULL;
  *sets_d_g_c = NULL;
  for (v = first_vertex; v <= last_vertex; v++) {
    order[v - MIN_VERTEX] = 1;
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
    P_setcpy(c[v - MIN_VERTEX], empty_set);
    P_clrbits_B(complete, v - MIN_VERTEX, 0, 3);
  }
  WITH = *model;
  if (incomplete_table)
    decompose_incomplete_model(model, &WITH->id->UU.g_c_log_linear,
			       WITH->id->vertices, &WITH->constant,
			       &WITH->dim);
  else {
    WITH->graphical = true;
    WITH->decomposable = true;
    hypergraph_sets_to_graph_sets(WITH->id->UU.g_c_log_linear,
				  WITH->id->vertices, adj_set);
    adj_set_to_adj_list(adj_set, adj_list);
    if (!test_graphical(adj_set, &WITH->id->UU.g_c_log_linear)) {
      WITH->graphical = false;
      find_cliques_and_order(adj_set, adj_list, fill_in_adj_list, order,
			     invers_order, c, complete, &WITH->decomposable,
			     WITH->id->vertices, sets_g_g_c);
      if (WITH->decomposable) {
	fill_in_computation(adj_list, order, invers_order, fill_in_adj_list);
	find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
      } else {
	adj_list_to_adj_set(fill_in_adj_list, fill_in_adj_set);
	find_cliques(fill_in_adj_set, WITH->id->vertices, sets_d_g_c);
      }
    } else {
      WITH->graphical = true;
      maximum_cardinality_search(adj_list, order, invers_order);
      if (test_for_zero_fill_in(adj_list, order, invers_order)) {
	WITH->decomposable = true;
	fill_in_computation(adj_list, order, invers_order, fill_in_adj_list);
	find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
      } else {
	WITH->decomposable = false;
	lex_m(adj_list, order, invers_order, fill_in_adj_list);
	find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
	adj_list_to_adj_set(fill_in_adj_list, fill_in_adj_set);
	find_cliques(fill_in_adj_set, WITH->id->vertices, sets_d_g_c);
      }
    }
    if (WITH->decomposable && WITH->graphical)
      decompose_decomposable(model, &WITH->id->UU.g_c_log_linear,
			     WITH->id->vertices, adj_list, true, order,
			     invers_order, &WITH->constant, &WITH->dim);
    else {
      create_adjacency_matrix(&gc_adjacency_matrix,
			      WITH->id->UU.g_c_log_linear);
      decompose_non_decomposable(model, &WITH->graphical,
	&gc_adjacency_matrix, WITH->id->vertices, adj_list, adj_set,
	invers_order, c, complete, &WITH->constant, &WITH->dim);
      delete_edges_with_vertices(&gc_adjacency_matrix, WITH->id->vertices);
    }
    dispose_adj_list(fill_in_adj_list);
    dispose_adj_list(adj_list);
  }
  WITH->found_expression = true;
}  /* identify_model_full_discrete */


Static Void compute_order(s, sets_h_g_c, max_card, default_order, order,
			  invers_order, c, complete)
long *s;
t_set_list **sets_h_g_c;
boolean *max_card, *default_order;
short *order;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
{
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_v_lists fill_in_adj_list, adj_list;
  t_vertex v;
  boolean decomposable;
  t_vertex_set g;

  for (v = first_vertex; v <= last_vertex; v++) {
    order[v - MIN_VERTEX] = 1;
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
    P_setcpy(c[v - MIN_VERTEX], empty_set);
    P_clrbits_B(complete, v - MIN_VERTEX, 0, 3);
  }
  hypergraph_sets_to_graph_sets(*sets_h_g_c, g, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  test_graphical(adj_set, sets_h_g_c);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  maximum_cardinality_search(adj_list, order, invers_order);
  decomposable = test_for_zero_fill_in(adj_list, order, invers_order);
  if (*default_order && P_setequal(s, empty_set))
    *max_card = decomposable;
  if (*max_card)
    fill_in_computation(adj_list, order, invers_order, fill_in_adj_list);
  else
    marked_lex_m(s, adj_list, order, invers_order, fill_in_adj_list);
  find_c(adj_set, order, invers_order, fill_in_adj_list, c, complete);
  dispose_adj_list(fill_in_adj_list);
  dispose_adj_list(adj_list);
}  /* compute_order */


Static Void identify_model_full(model, sets_d_g_c, sets_g_g_c,
  fill_in_adj_list, order, invers_order, c, complete)
t_model **model;
t_set_list **sets_d_g_c, **sets_g_g_c;
t_vertex_list **fill_in_adj_list;
short *order;
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
{
  t_set_list *g_c;
  boolean max_card, default_order;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IdentifyModelFull  ", sizeof(pch20));
  ntr(tzt, 20L, 1676L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if ((*model)->id->model_type == pure_discrete)
    identify_model_full_discrete(model, sets_d_g_c, sets_g_g_c,
				 fill_in_adj_list, order, invers_order, c,
				 complete);
  else {
    *sets_d_g_c = NULL;
    *sets_g_g_c = NULL;
    if ((*model)->id->model_type == pure_continuous)
      identify_continuous_model(model);
    else if ((*model)->id->model_type == mixed)
      identify_mixed_model(model);
    g_c = return_g_c_copy_for_mixed_model(model);
    max_card = false;
    default_order = true;
    compute_order(delta_gamma, &g_c, &max_card, &default_order, order,
		  invers_order, c, complete);
    dispose_g_c_copy_for_mixed_model(model, &g_c);
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_model_g_c(tzt, 20L, 1676L, 8L, -1L, 999L, model);
}  /* identify_model_full */


Static Void print_adjacency_matrix(model)
t_model **model;
{
  t_vertex v, w;
  t_v_arr_of_v_sets adj_set;
  t_set_list *g_c;

  g_c = return_g_c_copy_for_mixed_model(model);
  hypergraph_sets_to_graph_sets(g_c, (*model)->id->vertices, adj_set);
  write_line(stdout);
  write_space(stdout, 2L);
  write_pch(stdout, " Adjacency matrix", 17L);
  write_line(stdout);
  write_line(stdout);
  write_space(stdout, 4L);
  for (v = first_vertex; v <= last_vertex; v++) {
    write_char(stdout, variable_description[v - MIN_VERTEX]->name);
    write_space(stdout, 1L);
  }
  write_line(stdout);
  for (v = first_vertex; v <= last_vertex; v++) {
    write_space(stdout, 2L);
    write_char(stdout, variable_description[v - MIN_VERTEX]->name);
    write_space(stdout, 1L);
    for (w = first_vertex; w <= last_vertex; w++) {
      if (P_inset(w, adj_set[v - MIN_VERTEX]))
	write_char(stdout, '*');
      else
	write_char(stdout, ' ');
      write_char(stdout, ' ');
    }
    write_space(stdout, 2L);
    print_vertex_set_table(adj_set[v - MIN_VERTEX]);
    write_line(stdout);
  }
  write_line(stdout);
  dispose_g_c_copy_for_mixed_model(model, &g_c);
}  /* print_adjacency_matrix */


Static Void sub_print_order(order, c, complete)
short *order;
t_vertex_set *c;
uchar *complete;
{
  t_vertex v;

  write_space(stdout, 2L);
  write_char(stdout, 'V');
  write_pch(stdout, "  ", 2L);
  write_pch(stdout, " Order(V) ", 10L);
  write_space(stdout, 2L);
  write_pch(stdout, "C(V)", 4L);
  write_space(stdout, dimension - 2L);
  write_pch(stdout, "Complete(V)  ", 13L);
  write_line(stdout);
  for (v = first_vertex; v <= last_vertex; v++) {
    write_space(stdout, 2L);
    print_vertex_on_file(stdout, v, 0L);
    write_pch(stdout, ": ", 2L);
    write_integer(stdout, (long)order[v - MIN_VERTEX], 10L);
    write_space(stdout, 3L);
    print_vertex_set_table_full(c[v - MIN_VERTEX]);
    write_boolean(stdout, P_getbits_UB(complete, v - MIN_VERTEX, 0, 3));
    write_line(stdout);
  }
}  /* sub_print_order */


Static Void print_order(model, print_invers_order)
t_model **model;
boolean print_invers_order;
{
  t_set_list *sets_g_g_c, *sets_d_g_c;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_lists fill_in_adj_list;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;

  identify_model_full(model, &sets_d_g_c, &sets_g_g_c, fill_in_adj_list,
		      order, invers_order, c, complete);
  if (print_invers_order)
    sub_print_invers_order(invers_order, c, complete);
  else
    sub_print_order(order, c, complete);
  dispose_set_list(&sets_g_g_c);
  dispose_set_list(&sets_d_g_c);
  dispose_adj_list(fill_in_adj_list);
}  /* print_order */


Static Void describe_edges(link_cliques)
t_set_list *link_cliques;
{
  t_edge_list *edge_list[MAX_DIMENSION];
  t_set_list *p;
  t_long_integer count, i, j;
  t_vertex v, w;
  t_vertex_set vertex_set;

  for (i = 0; i < dimension; i++)
    edge_list[i] = NULL;
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    for (w = v + 1; w <= last_vertex; w++) {
      P_addset(P_expset(vertex_set, 0L), v);
      P_addset(vertex_set, w);
      p = link_cliques;
      count = 0;
      while (p != NULL) {
	if (P_subset(vertex_set, p->vertex_set))
	  count++;
	p = p->pointer;
      }
      if (count > 0) {
	if (count > dimension)
	  count = dimension;
	insert_edge_in_edge_list(v, w, &edge_list[count-1]);
      }
    }
  }
  j = dimension;
  while (edge_list[j-1] == NULL && j >= 2)
    j--;
  for (i = 1; i <= j; i++) {
    if (edge_list[i-1] != NULL) {
      write_integer(stdout, i, 10L);
      if (i == dimension)
	write_pch(stdout, ">  ", 3L);
      else
	write_pch(stdout, ":  ", 3L);
      print_edge_list(edge_list[i-1], 13L, line_length);
      dispose_edge_list(&edge_list[i-1]);
      write_line(stdout);
    }
  }
}  /* describe_edges */


Static Void write_discrete_model(model, as_is)
t_model **model;
boolean as_is;
{
  t_vertex v;
  t_set_list *sets_g_g_c = NULL, *sets_d_g_c = NULL;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_lists fill_in_adj_list;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;
  t_formula_node *link_formula_node;
  boolean found_exp;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_vertex FORLIM;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " Write_DiscreteModel", sizeof(pch20));
  ntr(tzt, 20L, 1681L, 1L, -1L, -1L);
  /*$endif TRACE*/
  FORLIM = last_vertex;
  for (v = first_vertex; v <= FORLIM; v++) {
    order[v - MIN_VERTEX] = 1;
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
    P_setcpy(c[v - MIN_VERTEX], empty_set);
    P_clrbits_B(complete, v - MIN_VERTEX, 0, 3);
  }
  write_line_diary();
  if (!((*model)->found_expression &&
	((*model)->graphical && (*model)->decomposable || incomplete_table)) &&
      !as_is) {
    found_exp = (*model)->found_expression;
    if (found_exp) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1681L, 2L, -1L, -1L);
      if (trace_flag_set(20L, 1681L, 1L))
	print_formula(model, true);
      /*$endif TRACE*/
      link_formula_node = (*model)->formula_node;
      (*model)->formula_node = NULL;
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1681L, 3L, -1L, -1L);
    /*$endif TRACE*/
    identify_model_full(model, &sets_d_g_c, &sets_g_g_c, fill_in_adj_list,
			order, invers_order, c, complete);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1681L, 4L, -1L, -1L);
    /*$endif TRACE*/
    if (found_exp) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1681L, 5L, -1L, -1L);
      if (trace_flag_set(20L, 1681L, 1L))
	print_formula(model, true);
      /*$endif TRACE*/
      dispose_formula_blind(model);
      (*model)->found_expression = true;
      (*model)->found_ps = false;   /* ?!?!? */
      (*model)->formula_node = link_formula_node;
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1681L, 6L, -1L, -1L);
    if (trace_flag_set(20L, 1681L, 1L))
      print_formula(model, true);
    /*$endif TRACE*/
    if ((*model)->decomposable)
      dispose_adj_list(fill_in_adj_list);
  }
  WITH = *model;
  write_integer(stdout, WITH->model_number, 4L);
  write_pch(stdout, ": ", 2L);
  print_model_g_c(model, 7L);
  write_line(stdout);
  write_model_type(model);
  write_line(stdout);
  if (incomplete_table) {
    write_pch(stdout, " Table is incomplete", 20L);
    write_line(stdout);
  } else {
    if (WITH->graphical) {
      write_pch(stdout, " Model is graphical", 19L);
      write_line(stdout);
    } else {
      write_pch(stdout, " Model is not graphical", 23L);
      write_line(stdout);
      write_pch(stdout, " Cliques:", 9L);
      dispose_set_list(&sets_g_g_c);
      write_line(stdout);
      write_pch(stdout, " 2-Section", 10L);
    }
    if (WITH->decomposable) {
      write_pch(stdout, " Graph is decomposable ", 23L);
      write_line(stdout);
    } else {
      write_pch(stdout, " Graph is not decomposable", 26L);
      dispose_adj_list(fill_in_adj_list);
      write_line(stdout);
      write_pch(stdout, " Generating class for Fill In:", 30L);
      write_char(stdout, ' ');
      print_g_c(sets_d_g_c, 19L, line_length);
      dispose_set_list(&sets_d_g_c);
      write_line(stdout);
    }
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1681L, 1L))
    return;
  if (((*model)->found_expression &&
       ((*model)->graphical && (*model)->decomposable || incomplete_table)) ||
      as_is)
    return;
  /*$endif TRACE*/
  write_line(stdout);
  sub_print_invers_order(invers_order, c, complete);
  write_line(stdout);
}  /* write_discrete_model */


Static Void write_mixed_model(model)
t_model **model;
{
  t_mixed_characteristics *mixed_characteristics;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " WriteMixedModel    ", sizeof(pch20));
  /*$endif TRACE*/
  if (!(*model)->found_expression)
    identify_model(model);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1682L, 1L, -1L, -1L,
	      (*model)->id->model_type == pure_discrete);
  /*$endif TRACE*/
  WITH = *model;
  write_integer(stdout, WITH->model_number, 4L);
  write_pch(stdout, ": ", 2L);
  print_model_g_c(model, 16L);
  write_line(stdout);
  write_model_type(model);
  write_line(stdout);
  mixed_characteristics = return_mixed_characteristics(model);
  if (mixed_characteristics->mim_model)
    write_pch(stdout, " Model is MIM-model", 19L);
  write_line(stdout);
  if (mixed_characteristics->degenerated)
    write_pch(stdout, " Model is DEGENERATED", 21L);
  write_line(stdout);
  if (mixed_characteristics->mean_linear)
    write_pch(stdout, " Model is MEAN-LINEAR", 21L);
  write_line(stdout);
  if (mixed_characteristics->d_collapsible)
    write_pch(stdout, " Model is D-collapsible", 23L);
  write_line(stdout);
  if (mixed_characteristics->q_equivalent)
    write_pch(stdout, " Model is Q-equivalent", 22L);
  write_line(stdout);
  _Free(mixed_characteristics);
  if (incomplete_table) {
    write_pch(stdout, " Table is incomplete", 20L);
    write_line(stdout);
    return;
  }
  if (WITH->graphical) {
    write_pch(stdout, " Model is graphical", 19L);
    write_line(stdout);
    if (WITH->id->UU.U1.homogeneous)
      write_pch(stdout, " Model is homogeneous", 21L);
    else
      write_pch(stdout, " Model is heterogenous", 22L);
    write_line(stdout);
  } else {
    write_pch(stdout, " Model is not graphical", 23L);
    write_line(stdout);
    write_pch(stdout, " 2-Section", 10L);
  }
  if (WITH->decomposable) {
    write_pch(stdout, " Graph is decomposable ", 23L);
    write_line(stdout);
  } else {
    write_pch(stdout, " Graph is not decomposable", 26L);
    write_line(stdout);
  }
}  /* write_mixed_model */


Static Void write_continuous_model(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " WriteContinuousMdl ", sizeof(pch20));
  /*$endif TRACE*/
  if (!(*model)->found_expression)
    identify_model(model);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1683L, 1L, -1L, -1L,
	      (*model)->id->model_type == pure_discrete);
  /*$endif TRACE*/
  WITH = *model;
  write_integer(stdout, WITH->model_number, 4L);
  write_pch(stdout, ": ", 2L);
  print_model_g_c(model, 16L);
  write_line(stdout);
  write_model_type(model);
  write_line(stdout);
  if (incomplete_table) {
    write_pch(stdout, " Table is incomplete", 20L);
    write_line(stdout);
    return;
  }
  if (WITH->graphical) {
    write_pch(stdout, " Model is graphical", 19L);
    write_line(stdout);
  } else {
    write_pch(stdout, " Model is not graphical", 23L);
    write_line(stdout);
    write_pch(stdout, " 2-Section", 10L);
  }
  if (WITH->decomposable) {
    write_pch(stdout, " Graph is decomposable ", 23L);
    write_line(stdout);
  } else {
    write_pch(stdout, " Graph is not decomposable", 26L);
    write_line(stdout);
  }
}  /* write_continuous_model */


Static Void write_model(model, as_is)
t_model **model;
boolean as_is;
{
  if ((*model)->id->model_type == pure_discrete) {
    write_discrete_model(model, as_is);
    return;
  }
  if ((*model)->id->model_type == pure_continuous)
    write_continuous_model(model);
  else
    write_mixed_model(model);
}  /* write_model */


Static Void describe_formula(model, full)
t_model **model;
boolean full;
{
  if (full)
    write_space(stdout, 15L);
  write_space(stdout, 2L);
  write_real(stdout, (*model)->constant, 12L, 9L);
  write_line(stdout);
  print_formula(model, full);
}  /* describe_formula */


Static Void describe_model(model, print_model, as_is)
t_model **model;
boolean print_model, as_is;
{
  t_set_list *g_c, *alt_rep;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DescribeModel      ", sizeof(pch20));
  /*$endif TRACE*/
  if (print_model) {
    write_pch(stdout, " Model no. ", 11L);
    write_integer(stdout, (*model)->model_number, 3L);
    write_char(stdout, ' ');
    print_model_g_c(model, 16L);
    write_line(stdout);
    return;
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1686L, -1L, -1L, 1L,
	      (*model)->id->model_type == pure_discrete);
  /*$endif TRACE*/
  write_model(model, as_is);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1686L, -1L, -1L, 2L,
	      (*model)->id->model_type == pure_discrete);
  /*$endif TRACE*/
  g_c = return_g_c_copy_for_mixed_model(model);
  normal_to_dual(g_c, (*model)->id->vertices, &alt_rep);
  write_pch(stdout, " Vertex set:   ", 15L);
  print_vertex_set((*model)->id->vertices);
  write_line(stdout);
  write_pch(stdout, " Dual rep:     ", 15L);
  print_g_c(alt_rep, 16L, line_length);
  write_line(stdout);
  dispose_set_list(&alt_rep);
  print_adjacency_matrix(model);
  write_pch(stdout, "  #Cliques", 10L);
  write_pch(stdout, "   Edges  ", 10L);
  write_line(stdout);
  describe_edges(g_c);
  dispose_g_c_copy_for_mixed_model(model, &g_c);
  write_line(stdout);
  write_pch(stdout, "      #Cells", 12L);
  write_pch(stdout, "      Expression    ", 20L);
  write_line(stdout);
  describe_formula(model, true);
  write_line(stdout);
  write_pch(stdout, " Log(L):          ", 18L);
  write_real(stdout, (*model)->log_l, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " Dimension:   ", 14L);
  write_integer(stdout, (*model)->dim, 14L);
  write_line(stdout);
  write_line(stdout);
}  /* describe_model */


/*@-"model.c"*/

/*Has-forward-2*/

Static Void ntr_model(t, w, o, p, n, m, model)
Char *t;
t_long_integer w, o, p, n, m;
t_model *model;
{

  /*Has-forward-2*/

  /* No-forward

procedure ntr_model(t  : pch20;
                      w, o, p, n, m : t_long_integer;
                      model  : t_link_model);

    No-forward */

  /*$ifdef TRACE*/
  FILE *TEMP;

  if (!trace_flag_set(w, o, p))
    return;
  write_pch(stdout, t, w);
  write_char(stdout, ':');
  write_integer(stdout, n, 3L);
  write_char(stdout, '/');
  write_integer(stdout, m, 3L);
  write_char(stdout, '/');
  write_line(stdout);
  describe_model(&model, false, true);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
}


/*$endif TRACE*/

/*Has-forward-2*/

Static Void ntr_expression(t, w, o, p, n, m, model)
Char *t;
t_long_integer w, o, p, n, m;
t_model *model;
{

  /*Has-forward-2*/

  /* No-forward

procedure ntr_expression(t       : pch20;
                           w, o, p, n, m : t_long_integer;
                           model       : t_link_model);

    No-forward */

  /*$ifdef TRACE*/
  FILE *TEMP;

  if (!trace_flag_set(w, o, p))
    return;
  write_pch(stdout, t, w);
  write_char(stdout, ':');
  write_integer(stdout, n, 3L);
  write_char(stdout, '/');
  write_integer(stdout, m, 3L);
  write_char(stdout, '/');
  write_line(stdout);
  describe_formula(&model, true);
  TEMP = stdout;
  flush_file(&TEMP);
}


/*$endif TRACE*/
/*@+"return.p"*/


/*

1693:    +++  ++
1694:    +++  ++
1695:    ---  -- p/return.p         25     127    1756 p/return.p
1696: |    4:    procedure return_ips_set_list_in_pch
1697: |   20:    procedure return_expression_factors_in_int
1698: |   38:    procedure return_in_pch_d_complete_node
1699: |   53:    procedure return_in_pch_c_complete_node
1700: |   63:    procedure return_in_pch_m_complete_node
1701: |   73:    procedure return_in_pch_d_ips_node
1702: |   90:    procedure return_in_pch_r_ips_node
1703: |  107:    procedure return_in_pch_r_ips_node_short
1704: |  116:    procedure return_in_pch_c_ips_node
1705: |  125:    procedure return_in_pch_m_ips_node
1706: |  134:    procedure sub_return_in_pch_formula
1707: |  191:    procedure return_in_pch_formula
1708: |  200:    procedure return_expression_sets_in_pch
1709: |  220:    procedure return_radim_list_in_pch
1710: |  242:    procedure return_ips_list_in_pch
1711: |  264:    procedure proc_get_expression
1712: |  371:    procedure return_invers_order_in_int
1713: |  406:    procedure return_order_in_int
1714: |  428:    procedure compute_order
1715: |  464:    procedure find_the_path
1716: |  475:    procedure find_path_set
1717: |  545:    procedure return_path_order
1718: |  576:    procedure return_order
1719: |  613:    procedure proc_return_order
1720: |  655:    procedure proc_return_path_order
1721:    +++  ++
1722:    +++  ++

*/

Static Void return_ips_set_list_in_pch(p, full, s, j, stop)
t_ips_set_list *p;
boolean *full;
Char *s;
t_integer *j, *stop;
{
  insert_chr_in_pch(',', s, j, stop);
  while (p != NULL) {
    if (*j > *stop && !long_names)
      *j += cardinality(p->vertex_set) + 2;
    else
      return_vertex_set_in_pch(p->vertex_set, full, s, j, stop);
    p = p->pointer;
  }
}  /* return_ips_set_list_in_pch */


Static Void return_expression_factors_in_int(p, upper_sets, lower_sets,
					     arg_int, j, stop)
t_expression *p;
boolean *upper_sets, *lower_sets;
long **arg_int;
t_integer *j, *stop;
{
  while (p != NULL) {
    if (*lower_sets && p->factor <= 0 || *upper_sets && p->factor > 0) {
      if (*j < *stop - 1)
	(*arg_int)[*j] = p->factor;
      (*j)++;
    }
    p = p->pointer;
  }
}  /* return_expression_factors_in_int */


Static Void return_in_pch_is_denominator(factor, dept, denominator, s, j, stop)
t_integer *factor, *dept;
boolean denominator;
Char *s;
t_integer *j, *stop;
{
  /* if factor > 0 then
       if denominator then
          insert_chr_in_pch('*', s, j, stop)
       else
          insert_chr_in_pch('+', s, j, stop)
    else
       if denominator then
          insert_chr_in_pch('-', s, j, stop)
       else
          insert_chr_in_pch('%', s, j, stop); */
}  /* return_in_pch_is_denominator */


Static Void return_in_pch_d_complete_node(d_complete_leaf, dept, denominator,
  upper_sets, lower_sets, full, s, j, stop)
t_power_set **d_complete_leaf;
t_integer *dept;
boolean denominator, *upper_sets, *lower_sets, *full;
Char *s;
t_integer *j, *stop;
{
  /*$ifdef TRACE*/
  ntr_set(" RInPchDCompleteNode", 20L, 1698L, 1L, *j, *stop,
	  (*d_complete_leaf)->a);
  /*$endif TRACE*/
  return_in_pch_is_denominator(&(*d_complete_leaf)->factor, dept, denominator,
			       s, j, stop);
  if (!(*lower_sets && denominator || *upper_sets && !denominator))
    return;
  if (*j > *stop && !long_names)
    *j += cardinality((*d_complete_leaf)->a) + 2;   /* vertex_set */
  else {
    return_vertex_set_in_pch((*d_complete_leaf)->a, full, s, j, stop);
    /* vertex_set */
  }
}  /* return_in_pch_d_complete_node */


Static Void return_in_pch_c_complete_node(c_complete_leaf, dept, denominator,
  upper_sets, lower_sets, full, s, j, stop)
t_power_set **c_complete_leaf;
t_integer *dept;
boolean denominator, *upper_sets, *lower_sets, *full;
Char *s;
t_integer *j, *stop;
{
  /*$ifdef TRACE*/
  ntr_set(" RInPchCompleteNode ", 20L, 1699L, 1L, *j, *stop,
	  (*c_complete_leaf)->a);
  /*$endif TRACE*/
  return_in_pch_is_denominator(&(*c_complete_leaf)->factor, dept, denominator,
			       s, j, stop);
  if (!(*lower_sets && denominator || *upper_sets && !denominator))
    return;
  if (*j > *stop && !long_names)
    *j += cardinality((*c_complete_leaf)->a) + 2;   /* vertex_set */
  else {
    return_vertex_set_in_pch((*c_complete_leaf)->a, full, s, j, stop);
    /* vertex_set */
  }
}  /* return_in_pch_c_complete_node */


Static Void return_in_pch_m_complete_node(m_complete_leaf, dept, denominator,
  upper_sets, lower_sets, full, s, j, stop)
t_power_set **m_complete_leaf;
t_integer *dept;
boolean denominator, *upper_sets, *lower_sets, *full;
Char *s;
t_integer *j, *stop;
{
  /*$ifdef TRACE*/
  ntr_set(" RInPchCompleteNode ", 20L, 1700L, 1L, *j, *stop,
	  (*m_complete_leaf)->a);
  /*$endif TRACE*/
  return_in_pch_is_denominator(&(*m_complete_leaf)->factor, dept, denominator,
			       s, j, stop);
  if (!(*lower_sets && denominator || *upper_sets && !denominator))
    return;
  if (*j > *stop && !long_names)
    *j += cardinality((*m_complete_leaf)->a) + 2;   /* vertex_set */
  else {
    return_vertex_set_in_pch((*m_complete_leaf)->a, full, s, j, stop);
    /* vertex_set */
  }
}  /* return_in_pch_m_complete_node */


Static Void return_in_pch_d_ips_node(id, d_ips_leaf, dept, upper_sets,
				     generators, flags, full, s, j, stop)
t_model_specification **id;
t_ips_element **d_ips_leaf;
t_integer *dept;
boolean *upper_sets, *generators, *flags, *full;
Char *s;
t_integer *j, *stop;
{
  /*$ifdef TRACE*/
  ntr_set(" ReturnInPchDIpsNode", 20L, 1701L, 1L, *j, *stop, (*d_ips_leaf)->a);
  /*$endif TRACE*/
  if (*upper_sets) {
    if (*j > *stop && !long_names)
      *j += cardinality((*d_ips_leaf)->a) + 2;
    else
      return_vertex_set_in_pch((*d_ips_leaf)->a, full, s, j, stop);
  }
  if (*flags) {
    insert_chr_in_pch('/', s, j, stop);
    insert_chr_in_pch('D', s, j, stop);
  }
  if (!*generators)
    return;
  if (*upper_sets || *flags)
    insert_chr_in_pch(',', s, j, stop);
  return_ips_set_list_in_pch((*d_ips_leaf)->gen_class, full, s, j, stop);
}  /* return_in_pch_d_ips_node */


Static Void return_in_pch_r_ips_node(id, r_ips_leaf, dept, upper_sets,
				     generators, flags, full, s, j, stop)
t_model_specification **id;
t_radim_element **r_ips_leaf;
t_integer *dept;
boolean *upper_sets, *generators, *flags, *full;
Char *s;
t_integer *j, *stop;
{
  /*$ifdef TRACE*/
  ntr_set(" ReturnInPchRIpsNode", 20L, 1702L, 1L, *j, *stop, (*r_ips_leaf)->a);
  /*$endif TRACE*/
  if (*upper_sets) {
    if (*j > *stop && !long_names)
      *j += cardinality((*r_ips_leaf)->a) + 2;
    else
      return_vertex_set_in_pch((*r_ips_leaf)->a, full, s, j, stop);
  }
  if (*flags) {
    insert_chr_in_pch('/', s, j, stop);
    insert_chr_in_pch('R', s, j, stop);
  }
  if (!*generators)
    return;
  if (*upper_sets || *flags)
    insert_chr_in_pch(',', s, j, stop);
  return_ips_set_list_in_pch((*r_ips_leaf)->gen_class, full, s, j, stop);
}  /* return_in_pch_r_ips_node */


Static Void return_in_pch_c_ips_node(id, c_ips_leaf, dept, upper_sets,
				     generators, flags, full, s, j, stop)
t_model_specification **id;
t_cips_element **c_ips_leaf;
t_integer *dept;
boolean *upper_sets, *generators, *flags, *full;
Char *s;
t_integer *j, *stop;
{
  t_cips_set_list *q;
  t_set_list *cliques = NULL;
  t_vertex_set a;

  /*$ifdef TRACE*/
  ntr(" ReturnInPchCIpsNode", 20L, 1704L, 1L, *j, *stop);
  /*$endif TRACE*/
  q = (*c_ips_leaf)->generators;
  P_setcpy(a, empty_set);
  while (q != NULL) {
    P_setunion(a, a, q->vertex_set);
    insert_set_in_set_list(q->vertex_set, &cliques);
    q = q->pointer;
  }
  if (*upper_sets) {
    if (*j > *stop && !long_names)
      *j += cardinality(a) + 2;
    else
      return_vertex_set_in_pch(a, full, s, j, stop);
  }
  if (*flags) {
    insert_chr_in_pch('/', s, j, stop);
    insert_chr_in_pch('C', s, j, stop);
  }
  if (*generators) {
    if (*upper_sets || *flags)
      insert_chr_in_pch(',', s, j, stop);
    return_g_c_in_pch(cliques, full, s, j, stop);
  }
  dispose_set_list(&cliques);
}  /* return_in_pch_c_ips_node */


Static Void return_in_pch_m_ips_node(id, m_ips_leaf, dept, upper_sets,
				     generators, flags, full, s, j, stop)
t_model_specification **id;
t_mips_element **m_ips_leaf;
t_integer *dept;
boolean *upper_sets, *generators, *flags, *full;
Char *s;
t_integer *j, *stop;
{
  t_set_list *q;
  t_set_list *cliques = NULL;
  t_vertex_set a;

  /*$ifdef TRACE*/
  ntr(" ReturnInPchMIpsNode", 20L, 1705L, 1L, *j, *stop);
  /*$endif TRACE*/
  P_setcpy(a, empty_set);
  q = (*m_ips_leaf)->discrete_;
  while (q != NULL) {
    P_setunion(a, a, q->vertex_set);
    insert_set_in_set_list(q->vertex_set, &cliques);
    q = q->pointer;
  }
  q = (*m_ips_leaf)->linear;
  while (q != NULL) {
    P_setunion(a, a, q->vertex_set);
    insert_set_in_set_list(q->vertex_set, &cliques);
    q = q->pointer;
  }
  q = (*m_ips_leaf)->quadratic;
  while (q != NULL) {
    P_setunion(a, a, q->vertex_set);
    insert_set_in_set_list(q->vertex_set, &cliques);
    q = q->pointer;
  }
  if (*upper_sets) {
    if (*j > *stop && !long_names)
      *j += cardinality(a) + 2;
    else
      return_vertex_set_in_pch(a, full, s, j, stop);
  }
  if (*flags) {
    insert_chr_in_pch('/', s, j, stop);
    insert_chr_in_pch('M', s, j, stop);
    if (*id != NULL) {
      if ((*id)->model_type != pure_discrete) {
	if ((*id)->model_type != pure_continuous) {
	  if ((*id)->UU.U1.full_specified)
	    insert_chr_in_pch('f', s, j, stop);
	  if ((*id)->UU.U1.homogeneous)
	    insert_chr_in_pch('h', s, j, stop);
	}
      }
    } else
      insert_chr_in_pch('?', s, j, stop);
    if ((*m_ips_leaf)->complete)
      insert_chr_in_pch('c', s, j, stop);
    else
      insert_chr_in_pch('i', s, j, stop);
    if ((*m_ips_leaf)->mixed_characteristics != NULL) {
      if ((*m_ips_leaf)->mixed_characteristics->degenerated)
	insert_chr_in_pch('0', s, j, stop);
      if ((*m_ips_leaf)->mixed_characteristics->mim_model)
	insert_chr_in_pch('m', s, j, stop);
      if ((*m_ips_leaf)->mixed_characteristics->d_collapsible)
	insert_chr_in_pch('d', s, j, stop);
      if ((*m_ips_leaf)->mixed_characteristics->mean_linear)
	insert_chr_in_pch('l', s, j, stop);
      if ((*m_ips_leaf)->mixed_characteristics->q_equivalent)
	insert_chr_in_pch('q', s, j, stop);
    }
  }
  if (*generators) {
    if (*upper_sets || *flags)
      insert_chr_in_pch(',', s, j, stop);
    /* insert_chr_in_pch('[', s, j, stop); */
    /* if id <> nil then begin
         if id^.model_type = pure_discrete then begin
         end else if id^.model_type = pure_continuous then begin
         end else begin */
    return_g_c_in_pch((*m_ips_leaf)->discrete_, full, s, j, stop);
    insert_chr_in_pch('/', s, j, stop);
    return_g_c_in_pch((*m_ips_leaf)->linear, full, s, j, stop);
    insert_chr_in_pch('/', s, j, stop);
    /* end
      end */
    /* insert_chr_in_pch(']', s, j, stop) */
    return_g_c_in_pch((*m_ips_leaf)->quadratic, full, s, j, stop);
  }
  dispose_set_list(&cliques);
}  /* return_in_pch_m_ips_node */


Static Void sub_return_in_pch_formula(model, dept, upper_sets, lower_sets,
				      generators, flags, full, s, j, stop)
t_model **model;
t_integer dept;
boolean *upper_sets, *lower_sets, *generators, *flags, *full;
Char *s;
t_integer *j, *stop;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;
  t_model_specification *id;

  /*$ifdef TRACE*/
  ntr(" SubRetuInPchFormula", 20L, 1706L, 1L, *j, *stop);
  /*$endif TRACE*/
  formula = (*model)->formula_node;
  id = (*model)->id;
  if (formula == NULL)
    return;
  insert_chr_in_pch('{', s, j, stop);
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    decomposition_element = formula->UU.decomposition_node_;
    sub_return_in_pch_formula(&decomposition_element->left_model, dept + 1,
			      upper_sets, lower_sets, generators, flags, full,
			      s, j, stop);
    formula = decomposition_element->separator;
    insert_chr_in_pch('<', s, j, stop);
    switch (formula->node_type) {

    case d_complete_node:
      return_in_pch_d_complete_node(&formula->UU.d_complete_leaf, &dept, true,
				    upper_sets, lower_sets, full, s, j, stop);
      break;

    case c_complete_node:
      return_in_pch_c_complete_node(&formula->UU.c_complete_leaf, &dept, true,
				    upper_sets, lower_sets, full, s, j, stop);
      break;

    case m_complete_node:
      return_in_pch_m_complete_node(&formula->UU.m_complete_leaf, &dept, true,
				    upper_sets, lower_sets, full, s, j, stop);
      break;
    }
    insert_chr_in_pch('>', s, j, stop);
    sub_return_in_pch_formula(&decomposition_element->right_model, dept + 1,
			      upper_sets, lower_sets, generators, flags, full,
			      s, j, stop);
    break;

  case d_complete_node:
    return_in_pch_d_complete_node(&formula->UU.d_complete_leaf, &dept, false,
				  upper_sets, lower_sets, full, s, j, stop);
    break;

  case c_complete_node:
    return_in_pch_c_complete_node(&formula->UU.c_complete_leaf, &dept, false,
				  upper_sets, lower_sets, full, s, j, stop);
    break;

  case m_complete_node:
    return_in_pch_m_complete_node(&formula->UU.m_complete_leaf, &dept, false,
				  upper_sets, lower_sets, full, s, j, stop);
    break;

  case d_ips_node:
    return_in_pch_d_ips_node(&id, &formula->UU.d_ips_leaf, &dept, upper_sets,
			     generators, flags, full, s, j, stop);
    break;

  case r_ips_node:
    return_in_pch_r_ips_node(&id, &formula->UU.r_ips_leaf, &dept, upper_sets,
			     generators, flags, full, s, j, stop);
    break;

  case c_ips_node:
    return_in_pch_c_ips_node(&id, &formula->UU.c_ips_leaf, &dept, upper_sets,
			     generators, flags, full, s, j, stop);
    break;

  case m_ips_node:
    return_in_pch_m_ips_node(&id, &formula->UU.m_ips_leaf, &dept, upper_sets,
			     generators, flags, full, s, j, stop);
    break;
  }
  insert_chr_in_pch('}', s, j, stop);
}  /* sub_return_in_pch_formula */


Static Void return_in_pch_formula(model, upper_sets, lower_sets, generators,
				  flags, full, s, j, stop)
t_model **model;
boolean *upper_sets, *lower_sets, *generators, *flags, *full;
Char *s;
t_integer *j, *stop;
{
  sub_return_in_pch_formula(model, 0L, upper_sets, lower_sets, generators,
			    flags, full, s, j, stop);
}  /* return_in_pch_formula */


Static Void return_expression_sets_in_pch(p, upper_sets, lower_sets, full, s,
					  j, stop)
t_expression *p;
boolean *upper_sets, *lower_sets, *full;
Char *s;
t_integer *j, *stop;
{
  while (p != NULL) {
    if (*lower_sets && p->factor <= 0 || *upper_sets && p->factor > 0) {
      if (*j > *stop && !long_names)
	*j += cardinality(p->vertex_set) + 2;
      else
	return_vertex_set_in_pch(p->vertex_set, full, s, j, stop);
    }
    p = p->pointer;
  }
  insert_chr_in_pch('/', s, j, stop);
}  /* return_expression_sets_in_pch */


Static Void return_radim_list_in_pch(p, generators, full, s, j, stop)
t_list_radim_elements *p;
boolean generators, *full;
Char *s;
t_integer *j, *stop;
{
  while (p != NULL) {
    insert_chr_in_pch('[', s, j, stop);
    if (*j > *stop && !long_names)
      *j += cardinality(p->radim_element.a) + 2;
    else
      return_vertex_set_in_pch(p->radim_element.a, full, s, j, stop);
    if (generators)
      return_ips_set_list_in_pch(p->radim_element.gen_class, full, s, j, stop);
    insert_chr_in_pch(']', s, j, stop);
    p = p->pointer;
  }
  insert_chr_in_pch('/', s, j, stop);
}  /* return_radim_list_in_pch */


Static Void return_ips_list_in_pch(p, generators, full, s, j, stop)
t_list_ips_elements *p;
boolean generators, *full;
Char *s;
t_integer *j, *stop;
{
  while (p != NULL) {
    insert_chr_in_pch('[', s, j, stop);
    if (*j > *stop && !long_names)
      *j += cardinality(p->ips_element.a) + 2;
    else
      return_vertex_set_in_pch(p->ips_element.a, full, s, j, stop);
    if (generators)
      return_ips_set_list_in_pch(p->ips_element.gen_class, full, s, j, stop);
    insert_chr_in_pch(']', s, j, stop);
    p = p->pointer;
  }
  insert_chr_in_pch('/', s, j, stop);
}  /* return_ips_list_in_pch */


Static Void proc_get_expression(ifail, sub_code, arg_pos_char, arg_pos_int,
  arg_pos_double, nargs, arg_char, arg_int, arg_double)
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int, arg_pos_double;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
{
  /* var command_file  : text;
                                    as_argument  : boolean; */
  /* stop  : t_integer; */
  t_model_list *q = NULL;
  t_integer i = 1;
  boolean flags, red_expres, components, upper_sets, lower_sets, generators;
  boolean full = false;
  t_vertex v;
  t_set_list *sets_g_g_c = NULL, *sets_d_g_c = NULL;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_lists fill_in_adj_list;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;
  boolean found_exp;
  t_formula_node *link_formula_node;
  t_expression *expression;
  t_list_ips_elements *ips_list;
  t_list_radim_elements *radim_list;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ProcGetExpression  ", sizeof(pch20));
  ntr(tzt, 20L, 1711L, 1L, *sub_code, *ifail);
  /*$endif TRACE*/
  flags = negative_flag_set(sub_code, 128L);
  red_expres = negative_flag_set(sub_code, 64L);
  upper_sets = !negative_flag_set(sub_code, 32L);
  lower_sets = !negative_flag_set(sub_code, 16L);
  generators = !negative_flag_set(sub_code, 8L);
  components = !negative_flag_set(sub_code, 4L);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1711L, 2L, *sub_code, *ifail);
  /*$endif TRACE*/
  sub_code_to_model(ifail, sub_code, &q);
  if (q == NULL) {
    set_ifail(ifail, 20L);
    return;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1711L, 2L, -1L, *ifail);
  /*$endif TRACE*/
  for (v = first_vertex; v <= last_vertex; v++) {
    order[v - MIN_VERTEX] = 1;
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
    P_setcpy(c[v - MIN_VERTEX], empty_set);
    P_clrbits_B(complete, v - MIN_VERTEX, 0, 3);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1711L, 3L, 1L, *ifail);
  /*$endif TRACE*/
  if (components) {
    found_exp = q->model->found_expression;
    if (found_exp) {
      link_formula_node = q->model->formula_node;
      q->model->formula_node = NULL;
    }
    identify_model_full(&q->model, &sets_d_g_c, &sets_g_g_c, fill_in_adj_list,
			order, invers_order, c, complete);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1711L, 3L, 2L, *ifail);
  /*$endif TRACE*/
  if (ok_double_arg(ifail, arg_pos_double, 1L, nargs, arg_double)) {
    if (is_invalid_real(q->model->constant))
      (*arg_double)[0] = my_var_na_double;
    else
      (*arg_double)[0] = q->model->constant;
  }
  set_real_end(&i, ifail, arg_pos_double, nargs, arg_double);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1711L, 3L, 3L, *ifail);
  /*$endif TRACE*/
  if (red_expres) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1711L, 4L, 1L, *ifail);
    /*$endif TRACE*/
    return_expression(&q->model, &expression, &ips_list, &radim_list, false);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1711L, 4L, 2L, *ifail);
    /*$endif TRACE*/
    i = 0;
    return_expression_factors_in_int(expression, &upper_sets, &lower_sets,
				     arg_int, &i, &(*nargs)[arg_pos_int]);
    set_long_end(&i, ifail, arg_pos_int, nargs, arg_int);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1711L, 4L, 3L, *ifail);
    /*$endif TRACE*/
    i = PCH_START;
    return_expression_sets_in_pch(expression, &upper_sets, &lower_sets, &full,
				  *arg_char, &i, &(*nargs)[arg_pos_char]);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1711L, 4L, 4L, *ifail);
    /*$endif TRACE*/
    if (upper_sets) {
      return_radim_list_in_pch(radim_list, generators, &full, *arg_char, &i,
			       &(*nargs)[arg_pos_char]);
      return_ips_list_in_pch(ips_list, generators, &full, *arg_char, &i,
			     &(*nargs)[arg_pos_char]);
    }
    set_string_end(&i, ifail, arg_pos_char, nargs, arg_char);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1711L, 4L, 5L, *ifail);
    /*$endif TRACE*/
    /*$ifdef TRACE*/
    dismiss_expression(&expression, &ips_list, &radim_list);
    ntr(tzt, 20L, 1711L, 4L, 6L, *ifail);
    /*$endif TRACE*/
  } else {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1711L, 5L, 1L, *ifail);
    /*$endif TRACE*/
    i = 0;
    set_long_end(&i, ifail, arg_pos_int, nargs, arg_int);
    i = PCH_START;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1711L, 5L, 2L, *ifail);
    /*$endif TRACE*/
    return_in_pch_formula(&q->model, &upper_sets, &lower_sets, &generators,
			  &flags, &full, *arg_char, &i,
			  &(*nargs)[arg_pos_char]);
    set_string_end(&i, ifail, arg_pos_char, nargs, arg_char);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1711L, 5L, 3L, *ifail);
    /*$endif TRACE*/
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1711L, 6L, -1L, *ifail);
  /*$endif TRACE*/
  if (components) {
    if (found_exp) {
      dispose_formula_blind(&q->model);
      q->model->formula_node = link_formula_node;
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1711L, 7L, -1L, *ifail);
  /*$endif TRACE*/
  if (!incomplete_table) {
    dispose_adj_list(fill_in_adj_list);
    if (!q->model->graphical)
      dispose_set_list(&sets_g_g_c);
    if (!q->model->decomposable)
      dispose_set_list(&sets_d_g_c);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1711L, 8L, -1L, *ifail);
  /*$endif TRACE*/
}  /* proc_get_expression */


Static Void return_invers_order_in_int(invers_order, c, complete, arg_int, j,
				       stop)
t_vertex *invers_order;
t_vertex_set *c;
uchar *complete;
long **arg_int;
t_integer *j, *stop;
{
  t_integer i;
  t_vertex v;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1712L, 1L)) {
    write_char(stdout, '2');
    sub_print_invers_order(invers_order, c, complete);
  }
  /*$endif TRACE*/
  for (i = 0; i < dimension; i++) {
    v = invers_order[i];
    if (*j < *stop - 2) {
      if (v == MAX_VERTEX) {
	(*arg_int)[*j] = -1;
	(*arg_int)[*j + 1] = -1;
      } else {
	(*arg_int)[*j] = v - first_vertex;
	if (P_getbits_UB(complete, v - MIN_VERTEX, 0, 3))
	  (*arg_int)[*j + 1] = 1;
	else
	  (*arg_int)[*j + 1] = 0;
      }
    }
    /* c[v] ? */
    *j += 2;
  }
}  /* return_invers_order_in_int */


Static Void return_order_in_int(order, c, complete, arg_int, j, stop)
short *order;
t_vertex_set *c;
uchar *complete;
long **arg_int;
t_integer *j, *stop;
{
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (*j < *stop - 2) {
      (*arg_int)[*j] = order[v - MIN_VERTEX];
      if (P_getbits_UB(complete, v - MIN_VERTEX, 0, 3))
	(*arg_int)[*j + 1] = 1;
      else {
	(*arg_int)[*j + 1] = 0;
	/* c[v] ? */
      }
    }
    *j += 2;
  }
}  /* return_order_in_int */


/* Local variables for find_the_path: */
struct LOC_find_the_path {
  long *s;
  t_vertex *b;
  t_vertex_list **adj_list;
  t_vertex *invers_order;
  boolean *sub_path, done;
  t_vertex_set r;
} ;

Local Void find_path_set(v, i, path, LINK)
t_vertex v;
t_integer i;
long *path;
struct LOC_find_the_path *LINK;
{
  t_vertex_set new_path, vertex_set;
  t_vertex_list *p;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1716L, 1L)) {
    write_integer(stdout, i, 2L);
    write_char(stdout, ':');
    write_space(stdout, i);
    write_char(stdout, '<');
    print_vertex(v);
    write_char(stdout, '|');
    print_vertex_set(LINK->r);
    write_char(stdout, ',');
    print_vertex_set(path);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  LINK->invers_order[i-1] = v;
  if (v == *LINK->b) {
    if (P_setequal(path, LINK->s) || *LINK->sub_path)
      LINK->done = true;
    return;
  }
  p = LINK->adj_list[v - MIN_VERTEX];
  P_addset(P_expset(vertex_set, 0L), v);
  P_setunion(new_path, path, vertex_set);
  while (p != NULL && !LINK->done) {
    if (P_inset(p->vertex, LINK->r) & (!P_inset(p->vertex, path)))
      find_path_set(p->vertex, i + 1, new_path, LINK);
    p = p->pointer;
  }
}  /* find_path_set */


Static Void find_the_path(s_, a, b_, adj_list_, invers_order_, sub_path_)
long *s_;
t_vertex *a, *b_;
t_vertex_list **adj_list_;
t_vertex *invers_order_;
boolean *sub_path_;
{
  struct LOC_find_the_path Local_Var;
  t_vertex_list *p;
  t_integer i;

  Local_Var.s = s_;
  Local_Var.b = b_;
  Local_Var.adj_list = adj_list_;
  Local_Var.invers_order = invers_order_;
  Local_Var.sub_path = sub_path_;
  P_addset(P_expset(Local_Var.r, 0L), *Local_Var.b);
  P_setunion(Local_Var.r, Local_Var.s, Local_Var.r);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1715L, 1L)) {
    write_char(stdout, '<');
    print_vertex(*a);
    write_char(stdout, ',');
    print_vertex(*Local_Var.b);
    write_char(stdout, '|');
    print_vertex_set(Local_Var.s);
    write_char(stdout, '/');
    print_vertex_set(Local_Var.r);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  Local_Var.done = false;
  for (i = 0; i < dimension; i++)
    Local_Var.invers_order[i] = MAX_VERTEX;   /* min_vertex */
  Local_Var.invers_order[0] = *a;
  p = Local_Var.adj_list[*a - MIN_VERTEX];
  while (p != NULL && !Local_Var.done) {
    if (P_inset(p->vertex, Local_Var.r))
      find_path_set(p->vertex, 2L, empty_set, &Local_Var);
    p = p->pointer;
  }
  if (!Local_Var.done) {
    for (i = 0; i < dimension; i++)
      Local_Var.invers_order[i] = MIN_VERTEX;   /* min_vertex */
  }
}  /* find_the_path */


Static Void return_path_order(s, v, w, g_c, invers_order, sub_path)
long *s;
t_vertex *v, *w;
t_set_list **g_c;
t_vertex *invers_order;
boolean *sub_path;
{
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_v_lists adj_list;
  t_vertex_set g;

  hypergraph_sets_to_graph_sets(*g_c, g, adj_set);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1717L, 1L)) {
    write_char(stdout, '<');
    print_vertex(*v);
    write_char(stdout, ',');
    print_vertex(*w);
    write_char(stdout, '|');
    print_vertex_set(s);
    write_char(stdout, '/');
    print_vertex_set(g);
    write_char(stdout, ':');
    print_g_c(*g_c, 0L, line_length);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  adj_set_to_adj_list(adj_set, adj_list);
  find_the_path(s, v, w, adj_list, invers_order, sub_path);
}  /* return_path_order */


/* Local variables for return_order: */
struct LOC_return_order {
  boolean max_card, default_order, sub_path;
} ;


Static Void return_order(s, v, w, g_c, max_card_, default_order_, path_order,
			 sub_path_, return_invers_order, arg_int, j, stop)
long *s;
t_vertex *v, *w;
t_set_list **g_c;
boolean max_card_, default_order_, path_order, sub_path_, return_invers_order;
long **arg_int;
t_integer *j, *stop;
{
  struct LOC_return_order Local_Var;
  t_vertex u;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;

  Local_Var.max_card = max_card_;
  Local_Var.default_order = default_order_;
  Local_Var.sub_path = sub_path_;
  for (u = first_vertex; u <= last_vertex; u++) {
    order[u - MIN_VERTEX] = 1;
    P_setcpy(c[u - MIN_VERTEX], empty_set);
    P_clrbits_B(complete, u - MIN_VERTEX, 0, 3);
  }
  if (path_order)
    return_path_order(s, v, w, g_c, invers_order, &Local_Var.sub_path);
  else
    compute_order(s, g_c, &Local_Var.max_card, &Local_Var.default_order,
		  order, invers_order, c, complete);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1718L, 1L)) {
    write_char(stdout, '1');
    sub_print_invers_order(invers_order, c, complete);
  }
  /*$endif TRACE*/
  if (return_invers_order || path_order)
    return_invers_order_in_int(invers_order, c, complete, arg_int, j, stop);
  else
    return_order_in_int(order, c, complete, arg_int, j, stop);
}  /* return_order */


Static Void proc_return_order(command_file, as_argument, ifail, sub_code,
			      arg_pos_char, arg_pos_int, arg_pos_double,
			      nargs, arg_char, arg_int, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int, arg_pos_double;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
{
  t_set_list *g_c_old;
  t_model_list *q = NULL;
  t_integer i = PCH_START;
  boolean path_order, max_card, default_order, invers_order;
  t_vertex_set s;

  path_order = negative_flag_set(sub_code, 32L);
  max_card = negative_flag_set(sub_code, 16L);
  default_order = negative_flag_set(sub_code, 8L);
  invers_order = negative_flag_set(sub_code, 4L);
  path_order = false;
  sub_code_to_model(ifail, sub_code, &q);
  if (*ifail != 0)
    return;
  if (!get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		      sub_code, arg_pos_char, nargs, arg_char, " SET->",
		      6L, s, s))
    return;
  i = 0;
  if (q == NULL)
    return;
  g_c_old = return_g_c_copy_for_mixed_model(&q->model);
  return_order(s, &first_vertex, &last_vertex, &g_c_old, max_card,
	       default_order, path_order, false, invers_order, arg_int, &i,
	       &(*nargs)[arg_pos_int]);
  dispose_g_c_copy_for_mixed_model(&q->model, &g_c_old);
  set_long_end(&i, ifail, arg_pos_int, nargs, arg_int);
}  /* proc_return_order */


Static Void proc_return_path_order(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_vertex_set b;
  t_vertex v, w;
  t_set_list *gc, *g_c_old;
  boolean sub_path, invers_order, dummy_ok;
  t_model_list *q = NULL;
  t_integer i = 0;

  dummy_ok = negative_flag_set(sub_code, 32L);
  sub_path = negative_flag_set(sub_code, 16L);
  dummy_ok = negative_flag_set(sub_code, 8L);
  invers_order = negative_flag_set(sub_code, 4L);
  sub_code_to_model(ifail, sub_code, &q);
  get_two_vertices_and_set_list(command_file, as_argument, false, ifail,
				sub_code, arg_pos_char, nargs, arg_char, &v,
				&w, &gc);
  if (*ifail != 0)
    return;
  P_setcpy(b, empty_set);
  if (gc != NULL) {
    add_union_of_gc(gc, b);
    dispose_set_list(&gc);
  }
  g_c_old = return_g_c_copy_for_mixed_model(&q->model);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1720L, 1L)) {
    write_char(stdout, '<');
    print_vertex(v);
    write_char(stdout, ',');
    print_vertex(w);
    write_char(stdout, '|');
    print_vertex_set(b);
    write_char(stdout, ':');
    print_g_c(gc, 0L, line_length);
    write_char(stdout, '/');
    print_g_c(g_c_old, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  return_order(b, &v, &w, &g_c_old, false, false, true, sub_path,
	       invers_order, arg_int, &i, &(*nargs)[arg_pos_int]);
  dispose_g_c_copy_for_mixed_model(&q->model, &g_c_old);
  set_long_end(&i, ifail, arg_pos_int, nargs, arg_int);
}  /* proc_return_path_order */


/*@-"model.c"*/
/*@+"em.p"*/


/*

1723:    +++  ++
1724:    +++  ++
1725:    ---  -- p/em.p           13      57     740 p/em.p
1726: |    4:    procedure next_cell_total
1727: |   21:    function return_from_offset_from_list
1728: |   63:    procedure find_em_offsets
1729: |   83:    function return_p_offset
1730: |   99:    procedure revers_list
1731: |  263:    procedure sub_find_expected_table
1732: |  280:    procedure insert_cases
1733: |  298:    procedure write_case
1734: |  330:    function random_x
1735: |  587:    procedure find_expected_table
1736: |  604:    procedure find_marginal_expected_table
1737: |  636:    procedure e_step
1738: |  709:    procedure em_estimate
1739:    +++  ++
1740:    +++  ++

*/

Static Void next_cell_total(i)
t_level *i;
{
  t_vertex v;

  v = first_vertex;
  while (i[v - MIN_VERTEX] ==
	 FIRST_LEVEL + variable_description[v - MIN_VERTEX]->
		       UU.U0.levels_total - 1 && v < last_vertex) {
    i[v - MIN_VERTEX] = FIRST_LEVEL;
    v++;
  }
  if (v == last_vertex &&
      i[v - MIN_VERTEX] ==
      FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels_total - 1)
    i[v - MIN_VERTEX] = FIRST_LEVEL;
  else
    i[v - MIN_VERTEX]++;
}  /* next_cell_total */


Static boolean return_from_offset_from_list(a, a_offset, g, g_offset, fna,
					    local_offset_list)
long *a;
t_offset *a_offset;
long *g;
t_offset *g_offset, *fna;
t_offset_list **local_offset_list;
{
  boolean Result;
  t_offset_list *p;
  t_cell_index size_g, size_g0;
  boolean b = true;
  t_vertex_set g0;

  p = *local_offset_list;
  P_setcpy(g, delta);
  *a_offset = -1;
  *g_offset = -1;
  size_g = max_cell_number;
  while (p != NULL) {
    P_setcpy(g0, p->vertex_set);
    if (P_setequal(a, g0)) {
      Result = true;
      b = false;
      *a_offset = p->offset;
    } else {
      size_g0 = marginal_dimension(g0);
      if (P_subset(a, g0) && !P_setequal(a, g0) && size_g0 < size_g) {
	P_setcpy(g, g0);
	*g_offset = p->offset;
	size_g = size_g0;
      }
    }
    p = p->pointer;
  }
  if (!b)
    return Result;
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  insert_offset(a, *fna, local_offset_list);
  *a_offset = *fna;
  *fna += marginal_dimension(a);
  return false;
}  /* return_from_offset_from_list */


Static boolean return_offset_from_ips_list(a, a_offset, local_offset_list)
long *a;
t_offset *a_offset;
t_list_ips_elements **local_offset_list;
{
  boolean Result = false;
  t_list_ips_elements *p;
  boolean b = true;

  p = *local_offset_list;
  *a_offset = -1;
  while (b && p != NULL) {
    if (P_setequal(a, p->ips_element.a)) {
      *a_offset = p->ips_element.p_offset;
      Result = true;
      b = false;
    }
    p = p->pointer;
  }
  return Result;
}  /* return_offset_from_ips_list */


Static Void sub_insert_offsets(link_model, n_offset_list, p_offset_list)
t_model **link_model;
t_offset_list **n_offset_list;
t_list_ips_elements **p_offset_list;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula, *separator;
  t_list_ips_elements *p;
  t_vertex_set g;
  t_offset g_offset, fna;
  boolean dummy_ok;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_power_set *WITH;
  t_ips_element *WITH1;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubReturnExpressio ", sizeof(pch20));
  ntr(tzt, 20L, 1726L, 1L, 0L, 0L);
  /*$endif TRACE*/
  formula = (*link_model)->formula_node;
  if (formula == NULL)
    return;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    sub_insert_offsets(&decomposition_element->left_model, n_offset_list,
		       p_offset_list);
    sub_insert_offsets(&decomposition_element->right_model, n_offset_list,
		       p_offset_list);
    separator = decomposition_element->separator;
    if (separator->node_type != d_complete_node)
      return;
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1726L, 1L, 2L, -1L, separator->UU.d_complete_leaf->a);
    /*$endif TRACE*/
    WITH = separator->UU.d_complete_leaf;
    dummy_ok = return_from_offset_from_list(WITH->a, &WITH->offset, g,
					    &g_offset, &fna, n_offset_list);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1726L, 1L, -2L, WITH->offset);
    /*$endif TRACE*/
    return;
  }
  /* halt */
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1726L, 1L, 2L, 1L, formula->UU.d_complete_leaf->a);
    /*$endif TRACE*/
    WITH = formula->UU.d_complete_leaf;
    dummy_ok = return_from_offset_from_list(WITH->a, &WITH->offset, g,
					    &g_offset, &fna, n_offset_list);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1726L, 1L, -2L, WITH->offset);
    /*$endif TRACE*/
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1726L, 1L, 4L, 1L, formula->UU.d_ips_leaf->a);
    /*$endif TRACE*/
    WITH1 = formula->UU.d_ips_leaf;
    dummy_ok = return_from_offset_from_list(WITH1->a, &WITH1->n_offset, g,
					    &g_offset, &fna, n_offset_list);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1726L, 1L, -4L, WITH1->n_offset);
    /*$endif TRACE*/
    dummy_ok = return_offset_from_ips_list(WITH1->a, &WITH1->p_offset,
					   p_offset_list);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1726L, 1L, -4L, WITH1->p_offset);
    /*$endif TRACE*/
    break;

  case r_ips_node:
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1726L, 1L, 5L, 1L, formula->UU.r_ips_leaf->a);
    /*$endif TRACE*/
    p = formula->UU.r_ips_leaf->ips_list;
    while (p != NULL) {
      dummy_ok = return_from_offset_from_list(p->ips_element.a,
	  &p->ips_element.n_offset, g, &g_offset, &fna, n_offset_list);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1726L, 1L, -5L, p->ips_element.n_offset);
      /*$endif TRACE*/
      dummy_ok = return_offset_from_ips_list(p->ips_element.a,
	  &p->ips_element.p_offset, p_offset_list);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1726L, 1L, -5L, p->ips_element.p_offset);
      /*$endif TRACE*/
      p = p->pointer;
    }
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    /* blank case */
    break;
  }
}  /* sub_insert_offsets */


/*$endif TRACE*/

Local t_long_integer return_p_offset(a, m, tmp_fpa, ok)
long *a;
t_long_integer *m;
t_offset *tmp_fpa;
boolean *ok;
{
  long Result;

  Result = *tmp_fpa;
  *m = marginal_dimension(a);
  if (*m >= MAX_P_CELL_NUMBER_MAX - *tmp_fpa) {
    *ok = false;
    return Result;
  }
  if (!TURBO_PC)
    *ok = space_in_p_array(*m, *tmp_fpa);
  *tmp_fpa += *m;
  *ok = (*tmp_fpa <= max_p_cell_number);
  return Result;
}  /* return_p_offset */

Local Void revers_list_(p)
t_offset_list **p;
{
  t_offset_list *hp1 = NULL;
  t_offset_list *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_list */


Static Void find_em_offsets(link_expression_1, link_ips_list_1,
  link_expression_2, link_ips_list_2, m, bottom, top, find_list, marg_list,
  from_list, model, model_set, model_offset, ok)
t_expression **link_expression_1;
t_list_ips_elements **link_ips_list_1;
t_expression **link_expression_2;
t_list_ips_elements **link_ips_list_2;
t_long_integer *m, *bottom, *top;
t_offset_list **find_list, **marg_list, **from_list;
t_model **model;
long *model_set;
t_offset *model_offset;
boolean *ok;
{
  t_offset first_q, tmp_offset, g_offset;
  t_vertex_set g;
  t_long_integer max = 0;
  t_long_integer m1, m2;
  t_set_list *marginals_to_find = NULL, *list_of_sets = NULL;
  t_offset_list *local_offset_list = NULL;
  t_expression *p_exp;
  t_ips_set_list *p_gc, *tmp_gc;
  t_list_ips_elements *p_ips;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_ips_element *WITH;

  /*$ifdef TRACE*/
  memcpy(tzt, " FindEMOffsets      ", sizeof(pch20));
  ntr(tzt, 20L, 1727L, 1L, 0L, 0L);
  /*$endif TRACE*/
  p_ips = *link_ips_list_1;
  while (p_ips != NULL) {
    insert_clique(p_ips->ips_element.a, &list_of_sets);
    p_ips = p_ips->pointer;
  }
  p_exp = *link_expression_1;
  while (p_exp != NULL) {
    insert_clique(p_exp->vertex_set, &list_of_sets);
    p_exp = p_exp->pointer;
  }
  first_q = fpa;
  *ok = true;
  *find_list = NULL;
  p_ips = *link_ips_list_1;
  while (*ok && p_ips != NULL) {
    p_ips->ips_element.p_offset = return_p_offset(p_ips->ips_element.a, m,
						  &first_q, ok);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1727L, 1L, 2L, first_q, p_ips->ips_element.a);
    ntr(tzt, 20L, 1727L, 1L, -2L, p_ips->ips_element.p_offset);
    /*$endif TRACE*/
    p_ips = p_ips->pointer;
  }
  *bottom = first_q;
  p_exp = *link_expression_1;
  while (*ok && p_exp != NULL) {
    if (!return_from_offset_from_list(p_exp->vertex_set, &tmp_offset, g,
	  &g_offset, &first_q, &local_offset_list)) {
      if (P_setequal(p_exp->vertex_set, model_set) |
	  (contains_an_edge(p_exp->vertex_set, &list_of_sets) &&
	   datastructure == list_file))
	insert_offset(p_exp->vertex_set, tmp_offset, find_list);
      else
	insert_set_in_list_of_marginals_to_find(p_exp->vertex_set,
						&marginals_to_find);
    }
    p_exp->offset = tmp_offset;
    if (!TURBO_PC)
      *ok = space_in_p_array(first_q, 0L);
    *ok = (first_q <= max_p_cell_number);
    p_exp = p_exp->pointer;
  }
  *top = first_q;
  if (datastructure != list_file) {
    if (!return_from_offset_from_list(model_set, model_offset, g, &g_offset,
				      &first_q, &local_offset_list))
      insert_offset(model_set, *model_offset, find_list);
  }
  p_ips = *link_ips_list_1;
  while (*ok && p_ips != NULL) {
    WITH = &p_ips->ips_element;
    if (!return_from_offset_from_list(WITH->a, &tmp_offset, g, &g_offset,
				      &first_q, &local_offset_list)) {
      if (datastructure == list_file)
	insert_offset(WITH->a, tmp_offset, find_list);
      else
	insert_set_in_list_of_marginals_to_find(WITH->a, &marginals_to_find);
    }
    WITH->n_offset = tmp_offset;
    if (!TURBO_PC)
      *ok = space_in_p_array(first_q, 0L);
    *ok = (first_q <= max_p_cell_number);
    p_gc = WITH->gen_class;
    m1 = 0;
    while (p_gc != NULL && *ok) {
      if (!return_from_offset_from_list(p_gc->vertex_set, &tmp_offset, g,
	    &g_offset, &first_q, &local_offset_list))
	insert_set_in_list_of_marginals_to_find(p_gc->vertex_set,
						&marginals_to_find);
      p_gc->n_offset = tmp_offset;
      m2 = marginal_dimension(p_gc->vertex_set);
      if (m2 > m1)
	m1 = m2;
      p_gc = p_gc->pointer;
    }
    if (*m + m1 > max)
      max = *m + m1;
    p_ips = p_ips->pointer;
  }
  dispose_set_list(&list_of_sets);
  *marg_list = NULL;
  *from_list = NULL;
  list_of_sets = marginals_to_find;
  while (marginals_to_find != NULL) {
    if (return_from_offset_from_list(marginals_to_find->vertex_set,
	  &tmp_offset, g, &g_offset, &first_q, &local_offset_list)) {
      insert_offset(marginals_to_find->vertex_set, tmp_offset, marg_list);
      insert_offset(g, g_offset, from_list);
    } else
      write_pch(stdout, " ListFindE", 10L);
    marginals_to_find = marginals_to_find->pointer;
  }

  sub_insert_offsets(model, &local_offset_list, link_ips_list_1);

  dispose_offset_list(&local_offset_list);
  dispose_set_list(&list_of_sets);
  revers_list_(marg_list);
  revers_list_(from_list);
  if (!TURBO_PC)
    *ok = space_in_p_array((first_q - *bottom) * 2 + max, fpa);
  *ok = ((first_q - *bottom) * 2 + max <= max_p_cell_number - fpa);
  if (*ok) {
    *m = first_q - *bottom;
    fpa = first_q + *m;
    p_exp = *link_expression_1;
    *link_expression_2 = NULL;
    while (p_exp != NULL) {
      insert_factor_in_expression(p_exp->vertex_set, p_exp->offset + *m,
				  &p_exp->factor, link_expression_2);
      /* link_expression_2^.offset := p_exp^.offset + m; */
      p_exp = p_exp->pointer;
    }
    p_ips = *link_ips_list_1;
    *link_ips_list_2 = NULL;
    while (p_ips != NULL) {
      WITH = &p_ips->ips_element;
      sub_insert_d_ips_element(link_ips_list_2, NULL, p_ips->ips_element.a,
			       false, p_ips->ips_element.n_offset + *m,
			       p_ips->ips_element.p_offset, NULL);
      p_gc = p_ips->ips_element.gen_class;
      while (p_gc != NULL) {
	tmp_gc = (t_ips_set_list *)Malloc(sizeof(t_ips_set_list));
	if (tmp_gc == NULL)
	  _OutMem();
	P_setcpy(tmp_gc->vertex_set, p_gc->vertex_set);
	tmp_gc->n_offset = p_gc->n_offset + *m;
	tmp_gc->pointer = (*link_ips_list_2)->ips_element.gen_class;
	(*link_ips_list_2)->ips_element.gen_class = tmp_gc;
	p_gc = p_gc->pointer;
      }
      p_ips = p_ips->pointer;
    }
    return;
  }
  dispose_offset_list(find_list);
  dispose_offset_list(from_list);
  dispose_offset_list(marg_list);
  p_exp = *link_expression_1;
  while (p_exp != NULL) {
    p_exp->offset = MAX_OFFSET;
    p_exp = p_exp->pointer;
  }
  p_ips = *link_ips_list_1;
  while (p_ips != NULL) {
    p_ips->ips_element.p_offset = MAX_OFFSET;
    p_ips = p_ips->pointer;
  }
}  /* find_em_offsets */


Local Void write_case(count, p_1, p_2, a, b, i)
t_cell_count *count;
t_long_real p_1, p_2;
long *a, *b;
t_level *i;
{
  t_vertex v;

  write_integer(stdout, *count, 10L);
  if (p_1 == -1)
    write_space(stdout, labs(print_width) + 2);
  else
    write_real(stdout, p_1, labs(print_width) + 2, print_dec + 2);
  if (p_2 == -1)
    write_space(stdout, labs(print_width) + 2);
  else
    write_real(stdout, p_2, labs(print_width) + 2, print_dec + 2);
  write_space(stdout, 2L);
  for (v = first_vertex; v <= last_vertex; v++) {
    write_integer(stdout, i[v - MIN_VERTEX] - FIRST_LEVEL + 1L,
      floor_x(2 + log_10((double)variable_description[v - MIN_VERTEX]->
				 UU.U0.levels)));
    if (P_inset(v, b))
      write_char(stdout, ' ');
    else
      write_char(stdout, '*');
    if (P_inset(v, a))
      write_char(stdout, ' ');
    else
      write_char(stdout, '-');
  }
  write_line(stdout);
}  /* write_case */

Local t_long_integer random_x(dummy, max)
t_long_integer *dummy;
t_level *max;
{
  *dummy = (*dummy * 7141 + 54773L) % 259200L;
  return ((long)(*dummy / 259200.0 * *max) + 1);
}  /* random_x */

Local Void insert_cases(i_, count, a, offset, model_set, constant,
			link_expression, link_ips_list, logl, init_type, seed,
			init_n_table, just_compute_log_l)
t_level *i_;
t_cell_count count;
long *a;
t_offset *offset;
long *model_set;
t_long_real *constant;
t_expression **link_expression;
t_list_ips_elements **link_ips_list;
t_long_real *logl;
t_long_integer *init_type, *seed;
boolean init_n_table, just_compute_log_l;
{
  t_cell i;
  t_vertex v;
  t_long_real p_1, p_2, p_sum;
  t_vertex_set b, c, d, e;
  t_long_integer l_count = 0, l_sum = 0;
  t_long_integer index, m_index, last_level, j;
  long FORLIM;

  memcpy(i, i_, sizeof(t_cell));
  for (v = first_vertex; v <= last_vertex; v++) {
    if (i[v - MIN_VERTEX] <=
	FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1) {
      l_count++;
      l_sum += i[v - MIN_VERTEX];
    }
  }
  P_setcpy(b, empty_set);
  P_setcpy(d, empty_set);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      if (i[v - MIN_VERTEX] <=
	  FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1)
	P_addset(d, v);
    }
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    last_level = FIRST_LEVEL + variable_description[v - MIN_VERTEX]->
			       UU.U0.levels - 1;
    if (P_inset(v, a)) {
      if (i[v - MIN_VERTEX] <= last_level)
	P_addset(b, v);
      else if (init_n_table) {
	if (incomplete_table) {
	  P_addset(d, v);
	  switch (*init_type) {

	  case EM_FIRST:
	    i[v - MIN_VERTEX] = FIRST_LEVEL;
	    while (marginal_zero_cell(d, i, q_tables_offsets) &&
		   i[v - MIN_VERTEX] < last_level)
	      i[v - MIN_VERTEX]++;
	    break;

	  case EM_LAST:
	    i[v - MIN_VERTEX] = last_level;
	    break;

	  case EM_MEAN:
	    if (l_count > 0)
	      i[v - MIN_VERTEX] = (long)floor((double)l_sum / l_count + 0.5);
	    else
	      i[v - MIN_VERTEX] = last_level;
	    break;

	  case EM_RANDOM:
	    i[v - MIN_VERTEX] = FIRST_LEVEL + random_x(seed,
		  &variable_description[v - MIN_VERTEX]->UU.U0.levels) - 1;
	    j = 0;
	    while (marginal_zero_cell(d, i, q_tables_offsets) &&
		   i[v - MIN_VERTEX] > FIRST_LEVEL && j > 100) {
	      i[v - MIN_VERTEX] = FIRST_LEVEL + random_x(seed,
		    &variable_description[v - MIN_VERTEX]->UU.U0.levels) - 1;
	      j++;
	    }
	    break;

	  case EM_INPUT:
	    i[v - MIN_VERTEX] -= variable_description[v - MIN_VERTEX]->
				 UU.U0.levels;
	    break;
	  }
	  /*$ifdef TRACE*/
	  if (trace_flag_set(20L, 1732L, 1L) && init_n_table) {
	    P_addsetr(P_expset(e, 0L), v + 1, last_vertex);
	    P_setunion(e, e, b);
	    write_case(&count, -1.0, -1.0, d, e, i);
	  }
	  /*$endif TRACE*/
	  if (marginal_zero_cell(d, i, q_tables_offsets)) {
	    i[v - MIN_VERTEX] = last_level;
	    while (marginal_zero_cell(d, i, q_tables_offsets) &&
		   i[v - MIN_VERTEX] > FIRST_LEVEL)
	      i[v - MIN_VERTEX]--;
	    if (marginal_zero_cell(d, i, q_tables_offsets)) {
	      write_warning(stdout,
			    " ?: Unable to `initiate complete' in EM.", 40L);
	      write_case(&count, -1.0, -1.0, a, b, i);
	    }
	  }
	} else {
	  switch (*init_type) {

	  case EM_FIRST:
	    i[v - MIN_VERTEX] = FIRST_LEVEL;
	    break;

	  case EM_LAST:
	    i[v - MIN_VERTEX] = last_level;
	    break;

	  case EM_MEAN:
	    if (l_count > 0)
	      i[v - MIN_VERTEX] = (long)floor((double)l_sum / l_count + 0.5);
	    else
	      i[v - MIN_VERTEX] = last_level;
	    break;

	  case EM_RANDOM:
	    i[v - MIN_VERTEX] = FIRST_LEVEL + random_x(seed,
		  &variable_description[v - MIN_VERTEX]->UU.U0.levels) - 1;
	    break;

	  case EM_INPUT:
	    i[v - MIN_VERTEX] -= variable_description[v - MIN_VERTEX]->
				 UU.U0.levels;
	    break;
	  }
	}
      } else {
	i[v - MIN_VERTEX] = FIRST_LEVEL;
	/* if init_n_table */
      }
    } else
      i[v - MIN_VERTEX] = FIRST_LEVEL;
  }
  /* if v in a */
  if (incomplete_table) {
    if (marginal_zero_cell(d, i, q_tables_offsets)) {
      write_warning(stdout, " ?: Unable to `Initiate Complete' in Em.", 40L);
      write_case(&count, -1.0, -1.0, a, b, i);
    }
  }
  if (init_n_table) {
    P_setcpy(b, delta);
    p_2 = -1.0;
  } else {
    p_2 = sub_compute_m_p_em(b, i, model_set, constant, link_expression,
			     link_ips_list);
    if (p_2 > 0)
      *logl += count * log(p_2);
    else if (!just_compute_log_l) {
      write_pch(stdout, " Invalid probability", 20L);
      /* write_real(output, p_2, print_width, print_dec); */
      /* write_integer(output, count, print_width); */
      write_case(&count, -1.0, p_2, a, b, i);
      /* write_line(output) */
    }
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1732L, 1L) && init_n_table)
    write_case(&count, -1.0, p_2, a, b, i);
  /*$endif TRACE*/
  if (just_compute_log_l) {
    if (print_case_list)
      write_case(&count, -1.0, p_2, a, b, i);
    return;
  }
  P_setdiff(d, delta, b);
  P_setdiff(c, a, b);
  P_setunion(e, a, b);
  if (!P_setequal(d, empty_set)) {
    p_sum = 0.0;
    if (fast) {
      FORLIM = marginal_dimension(d);
      for (index = 1; index <= FORLIM; index++) {
	p_1 = sub_compute_m_p_em(delta, i, model_set, constant,
				 link_expression, link_ips_list);
	p_sum += p_1;
	if (print_case_list)
	  write_case(&count, p_1, p_2, a, b, i);
	m_index = *offset + marginal_hash(a, i);
	p[m_index] += count * p_1 / p_2;
	next_marginal_cell(d, i);
      }
    } else {
      FORLIM = marginal_dimension(c);
      for (index = 1; index <= FORLIM; index++) {
	p_1 = sub_compute_m_p_em(e, i, model_set, constant, link_expression,
				 link_ips_list);
	p_sum += p_1;
	if (print_case_list)
	  write_case(&count, p_1, p_2, a, b, i);
	m_index = *offset + marginal_hash(a, i);
	p[m_index] += count * p_1 / p_2;
	next_marginal_cell(c, i);
      }
    }
    if (fabs(p_sum - p_2) > 0.0001)
      write_pch(stdout, " ProbError", 10L);
    return;
  }
  if (print_case_list)
    write_case(&count, -1.0, p_2, a, b, i);
  m_index = *offset + marginal_hash(a, i);
  p[m_index] += count;
}  /* insert_cases */


Static Void sub_find_expected_table(a_, offset, model_set, constant,
  link_expression, link_ips_list, logl, init_n_table, just_compute_log_l)
long *a_;
t_offset offset;
long *model_set;
t_long_real *constant;
t_expression **link_expression;
t_list_ips_elements **link_ips_list;
t_long_real *logl;
boolean init_n_table, just_compute_log_l;
{
  t_vertex_set a;
  t_offset dummy_m_offset;
  t_long_integer index, m, case_number, init_type;   /* , seed */
  t_cell i;
  t_vertex v;
  t_long_real start_clock;
  long FORLIM;

  P_setcpy(a, a_);
  start_clock = my_clock()/1;
  if (print_case_list)
    write_line(stdout);
  if (init_n_table && em_initial == EM_UNIFORM) {
    m = marginal_dimension(a);
    if (!just_compute_log_l) {
      FORLIM = offset + last_index(a);
      for (index = offset; index <= FORLIM; index++)
	p[index] = (double)n[0] / m;
    }
    *logl = 0.0;
  } else {
    m = marginal_dimension(a);
    if (!just_compute_log_l) {
      FORLIM = offset + last_index(a);
      for (index = offset; index <= FORLIM; index++)
	p[index] = 0.0;
    }
    *logl = 0.0;
    init_type = em_initial;
    /* seed := 0; */
    memcpy(i, first_cell, sizeof(t_cell));
    if (print_case_list) {
      write_line(stdout);
      write_pch(stdout, "     Count", 10L);
      write_space(stdout, labs(print_width) - 2);
      write_pch(stdout, "P(j)", 4L);
      write_space(stdout, labs(print_width) - 5);
      write_pch(stdout, "P(i{b})", 7L);
      write_space(stdout, 2L);
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  write_space(stdout,
	    floor_x(1 + log_10((double)variable_description[v - MIN_VERTEX]->
				       UU.U0.levels)));
	  print_vertex_on_file(stdout, v, 0L);
	  write_space(stdout, 2L);
	}
      }
      write_line(stdout);
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1731L, 1L)) {
      dummy_m_offset = fpa;
      write_pch(stdout, "PrintTable", 10L);
      write_line(stdout);   /* !!!! */
      /* print_table(a, nil, 2, false, false, false,
                    offset, n[0], dummy_m_offset, model); */
      write_integer(stdout, n[0], 10L);
      write_integer(stdout, offset, 10L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (datastructure == list_file) {
      reset_level_file(file_read);
      for (case_number = 1; case_number <= n[0]; case_number++) {
	for (v = first_vertex; v <= last_vertex; v++)
	  read_level_file(file_read, &i[v - MIN_VERTEX]);
	insert_cases(i, 1L, a, &offset, model_set, constant, link_expression,
		     link_ips_list, logl, &init_type, &seed, init_n_table,
		     just_compute_log_l);
      }
    } else {
      FORLIM = N_START + marginal_dimension_tf(delta, true, false);
      for (index = N_START; index < FORLIM; index++) {
	if (n[index] != 0)
	  insert_cases(i, n[index], a, &offset, model_set, constant,
		       link_expression, link_ips_list, logl, &init_type,
		       &seed, init_n_table, just_compute_log_l);
	next_cell_total(i);
      }
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1731L, 1L)) {
      dummy_m_offset = fpa;
      write_pch(stdout, "Printtable", 10L);
      write_line(stdout);   /* !!!! */
      /* print_table(a, nil, 2, false, false, false,
                    offset, n[0], dummy_m_offset, model); */
      write_integer(stdout, n[0], 10L);
      write_integer(stdout, offset, 10L);
      write_line(stdout);
    }
    /*$endif TRACE*/
  }
  write_pch_30_text(report_file, " <> .E-Expt  -  Log L: ", 23L);
  write_real_text(report_file, *logl, 13L, 6L);
  write_time_text(report_file, ",  Time: ", 9L, (double)my_clock()/1, start_clock,
		  8L, 3L);
  write_pch_10_text(report_file, "  Table: ", 9L);
  print_vertex_set_on_report(report_file, a);
  write_line_text(report_file);
  fflush(report_file);
  P_ioresult = 0;
}  /* sub_find_expected_table */


Static Void find_expected_table(a, offset, model, log_l, init_n_table,
				just_compute_log_l)
long *a;
t_offset offset;
t_model **model;
t_long_real *log_l;
boolean init_n_table, just_compute_log_l;
{
  t_expression *link_expression;
  t_list_ips_elements *link_ips_list;

  return_expression_and_ips_list(model, &link_expression, &link_ips_list,
				 false);
  sub_find_expected_table(a, offset, (*model)->id->vertices,
    &(*model)->constant, &link_expression, &link_ips_list, log_l,
    init_n_table, just_compute_log_l);
  dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
}  /* find_expected_table */


Static Void find_marginal_expected_table(a, g, off_a, off_g)
long *a, *g;
t_offset off_a, off_g;
{
  t_cell_index index, m_index;
  t_cell i;
  t_vertex_set c_in_a;
  t_vertex l_a_vertex;
  t_v_arr_of_integer prod_1, prod_2, levels;
  t_long_real start_clock;
  t_cell_index FORLIM;

  start_clock = my_clock()/1;
  memcpy(i, first_cell, sizeof(t_cell));
  FORLIM = off_a + last_index(a);
  for (m_index = off_a; m_index <= FORLIM; m_index++)
    p[m_index] = 0.0;
  find_products(g, a, c_in_a, prod_1, prod_2, levels, &l_a_vertex);
  m_index = off_a;
  FORLIM = off_g + last_index(g);
  for (index = off_g; index <= FORLIM; index++) {
    p[m_index] += p[index];
    next_c_offset_in_a(c_in_a, &m_index, prod_1, prod_2, levels, &l_a_vertex,
		       i);
  }
  write_pch_20_text(report_file, " <> .E-Marg  -  ", 16L);
  write_time_text(report_file, " Time: ", 7L, (double)my_clock()/1, start_clock,
		  8L, 3L);
  write_pch_10_text(report_file, "  Table: ", 9L);
  print_vertex_set_on_report(report_file, a);
  write_space_text(report_file, 10 - cardinality(a) % 10);
  write_pch_20_text(report_file, "  From: @@          ", 8L);
  print_vertex_set_on_report(report_file, g);
  write_line_text(report_file);
  fflush(report_file);
  P_ioresult = 0;
}  /* find_marginal_expected_table */


Static Void e_step(model_set, constant, link_expression, link_ips_list,
		   find_list, marg_list, from_list, init_n_table, log_l,
		   old_log_l, m)
long *model_set;
t_long_real *constant;
t_expression **link_expression;
t_list_ips_elements **link_ips_list;
t_offset_list **find_list, **marg_list, **from_list;
boolean *init_n_table;
t_long_real *log_l, *old_log_l;
t_long_integer m;
{
  t_long_real start_clock, tmp_log_l;
  t_offset_list *p_1, *p_2;

  start_clock = my_clock()/1;
  *log_l = -98765.43210987654321;
  if ((*find_list)->pointer != NULL && !*init_n_table) {
    sub_find_expected_table(model_set, (long)(-FIRST_INDEX), model_set,
			    constant, link_expression, link_ips_list, log_l,
			    *init_n_table, true);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1737L, 1L)) {
      write_pch(stdout, " New L:", 7L);
      write_real(stdout, *log_l, 14L, 6L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    write_pch_30_text(report_file, " <> .E-step  -  New L: @@@@   ", 26L);
    write_real_text(report_file, *log_l, 13L, 6L);
    write_time_text(report_file, ",  Time: ", 9L, (double)my_clock()/1,
		    start_clock, 8L, 3L);
    write_line_text(report_file);
    fflush(report_file);
    P_ioresult = 0;
  }
  if (*log_l >= *old_log_l || (*find_list)->pointer == NULL || *init_n_table) {
    p_1 = *find_list;
    while (p_1 != NULL && !interrupt_2) {
      sub_find_expected_table(p_1->vertex_set, p_1->offset + m, model_set,
			      constant, link_expression, link_ips_list,
			      &tmp_log_l, *init_n_table, false);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1737L, 1L)) {
	write_pch(stdout, " Tmp L:", 7L);
	write_real(stdout, tmp_log_l, 14L, 6L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      write_pch_30_text(report_file, " <> .E-step  -  Tmp L: @@@@   ", 26L);
      write_real_text(report_file, tmp_log_l, 13L, 6L);
      write_time_text(report_file, ",  Time: ", 9L, (double)my_clock()/1,
		      start_clock, 8L, 3L);
      write_line_text(report_file);
      fflush(report_file);
      P_ioresult = 0;
      p_1 = p_1->pointer;
    }
    if ((*find_list)->pointer == NULL && !*init_n_table)
      *log_l = tmp_log_l;
    if (*log_l >= *old_log_l || *init_n_table) {
      p_1 = *marg_list;
      p_2 = *from_list;
      while (p_1 != NULL && !interrupt_2) {
	find_marginal_expected_table(p_1->vertex_set, p_2->vertex_set,
				     p_1->offset + m, p_2->offset + m);
	p_2 = p_2->pointer;
	p_1 = p_1->pointer;
      }
    }
  }
  write_pch_30_text(report_file, " <> .E-step  -  Log L: ", 23L);
  write_real_text(report_file, *log_l, 13L, 6L);
  write_time_text(report_file, ",  Time: ", 9L, (double)my_clock()/1, start_clock,
		  8L, 3L);
  write_line_text(report_file);
  fflush(report_file);
  P_ioresult = 0;
}  /* e_step */


Static Void em_estimate(model)
t_model **model;
{
  t_expression *expression[2];
  t_list_ips_elements *p_ips_list;
  t_list_ips_elements *ips_list[2];
  t_long_integer i, m, bottom, top, fpa_;
  boolean init_n_table, first_, ok;
  char flip, flop, flap;
  t_offset_list *find_list, *marg_list, *from_list;
  t_long_real log_l, em_delta, dummy_step_clock;
  t_offset model_offset;
  t_iterate_pack *iterate_pack;
  long FORLIM;
  t_model *WITH;

  iterate_pack = init_iterate_pack(&em_epsilon, &em_max_it, true, true,
				   boolean_option[64]);
  return_expression_and_ips_list(model, expression, ips_list, false);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1738L, 1L)) {
    write_line(stdout);
    write_pch(stdout, " @FirstP: ", 10L);
    write_integer(stdout, fpa, 6L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  fpa_ = fpa;
  find_em_offsets(expression, ips_list, &expression[1], &ips_list[1], &m,
		  &bottom, &top, &find_list, &marg_list, &from_list, model,
		  (*model)->id->vertices, &model_offset, &ok);
  FORLIM = fpa;
  /* Insert offsets in modelformula !!! */
  for (i = fpa_; i <= FORLIM; i++)
    p[i] = -1.0;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1738L, 1L)) {
    write_pch(stdout, " @Bottom: ", 10L);
    write_integer(stdout, bottom, 6L);
    write_line(stdout);
    write_pch(stdout, " @Top:    ", 10L);
    write_integer(stdout, top, 6L);
    write_line(stdout);
    write_pch(stdout, " @m:      ", 10L);
    write_integer(stdout, m, 6L);
    write_line(stdout);
    write_pch(stdout, " @FirstP: ", 10L);
    write_integer(stdout, fpa, 6L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  write_pch_20_text(report_file, " <> EM-start -  ", 16L);
  write_time_text(report_file, "  Time: ", 8L, (double)my_clock()/1,
		  iterate_pack->start_clock, 8L, 3L);
  write_line_text(report_file);
  fflush(report_file);
  P_ioresult = 0;
  dummy_step_clock = my_clock()/1;
  if (ok) {
    flip = 1;
    flop = 2;
    iterate_pack->old_l = -_INFINITY;
    em_delta = 2 * iterate_pack->epsilon;
    init_n_table = true;
    e_step((*model)->id->vertices, &(*model)->constant, expression, ips_list,
	   &find_list, &marg_list, &from_list, &init_n_table, &log_l,
	   &iterate_pack->old_l, 0L);
    write_pch_30_text(report_file, " <> EM-init  -  Log L: ", 23L);
    write_real_text(report_file, log_l, 13L, 6L);
    write_time_text(report_file, ",  Time: ", 9L, (double)my_clock()/1,
		    iterate_pack->start_clock, 8L, 3L);
    write_line_text(report_file);
    fflush(report_file);
    P_ioresult = 0;
    init_n_table = false;
    first_ = true;

    while (em_delta > iterate_pack->epsilon && iterate_pack->bad_count < 5 &&
	   iterate_pack->cycle_number < iterate_pack->max_cycle_number &&
	   !interrupt_2) {
      dummy_step_clock = my_clock()/1;
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1738L, 1L)) {
	write_pch(stdout, " @Flip:", 7L);
	write_integer(stdout, (long)flip, 2L);
	write_pch(stdout, " @Flop:", 7L);
	write_integer(stdout, (long)flop, 2L);
	write_pch(stdout, " @Cycles:", 9L);
	write_integer(stdout, iterate_pack->cycle_number, 3L);
	write_pch(stdout, " @Gentag:", 9L);
	write_integer(stdout, iterate_pack->bad_count, 3L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      p_ips_list = ips_list[flip-1];
      while (p_ips_list != NULL && !interrupt_2) {
	if (first_)
	  ips_em(&p_ips_list->ips_element, n, sqrt(ips_epsilon), &ips_max_it,
		 first_);
	else
	  ips_em(&p_ips_list->ips_element, n, ips_epsilon, &ips_max_it,
		 first_);
	p_ips_list = p_ips_list->pointer;
      }
      first_ = false;
      e_step((*model)->id->vertices, &(*model)->constant, &expression[flip-1],
	     &ips_list[flip-1], &find_list, &marg_list, &from_list,
	     &init_n_table, &log_l, &iterate_pack->old_l, (flop - 1L) * m);

      /*$ifdef TRACE*/
      if (iterate_pack->differences != NULL && boolean_option[64]) {
	/* , iterate_pack^.bad_count */
	find_differences(&iterate_pack->old_l, &log_l, &iterate_pack->epsilon,
			 &iterate_pack->cycle_number,
			 iterate_pack->differences);
      }
      if (trace_iteration(&em_delta, &iterate_pack)) {
	if (iterate_pack->differences != NULL && boolean_option[64])
	  report_differences(_INVALID_REAL, -_INVALID_REAL,
	    &iterate_pack->old_l, &log_l, &iterate_pack->epsilon,
	    &iterate_pack->cycle_number, iterate_pack->differences,
	    iterate_pack->bad_count);
	else {
	  write_pch_30_text(report_file, " <> EM-step  -  Log L: ",
			    23L);
	  write_real_text(report_file, log_l, 13L, 6L);
	  write_pch_10_text(report_file, ";+ Delta:", 9L);
	  write_real_text(report_file, log_l - iterate_pack->old_l, 15L, 10L);
	  write_time_text(report_file, ", Time: ", 8L, (double)my_clock()/1,
			  iterate_pack->start_clock, 8L, 3L);
	  write_line_text(report_file);
	  fflush(report_file);
	  P_ioresult = 0;
	}
      }
      /*$endif TRACE*/

      if ((log_l >= iterate_pack->old_l || iterate_pack->bad_count == 4) &&
	  !interrupt_2) {
	iterate_pack->bad_count = 0;
	em_delta = fabs(log_l - iterate_pack->old_l);
	iterate_pack->old_l = log_l;
	flap = flip;
	flip = flop;
	flop = flap;
      } else
	iterate_pack->bad_count++;
      iterate_pack->cycle_number++;
    }
    if (interrupt_2) {
      interrupt_1 = false;
      interrupt_2 = false;
    }
    dispose_offset_list(&find_list);
    dispose_offset_list(&from_list);
    dispose_offset_list(&marg_list);
    if (flip == 2) {
      for (i = bottom; i < top; i++)
	p[i] = p[i + m];
    }
    (*model)->log_l = log_l;
    WITH = *model;
    WITH->found_expression = true;
    WITH->found_log_l = true;
    WITH->found_ps = true;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1738L, 1L)) {
    write_pch(stdout, " @@ EM end", 10L);
    write_line(stdout);
    write_pch(stdout, " @Flip:", 7L);
    write_integer(stdout, (long)flip, 2L);
    write_pch(stdout, " @Flop:", 7L);
    write_integer(stdout, (long)flop, 2L);
    if (iterate_pack->bad_count > 0) {
      write_pch(stdout, " EqualLogL", 10L);
      write_integer(stdout, iterate_pack->bad_count, 2L);
    }
    write_line(stdout);
  }
  /*$endif TRACE*/
  write_pch_30_text(report_file, " <> EM-total -  Log L: ", 23L);
  write_real_text(report_file, log_l, 13L, 6L);
  write_time_text(report_file, ",  Time: ", 9L, (double)my_clock()/1,
		  iterate_pack->start_clock, 8L, 3L);
  write_line_text(report_file);
  fflush(report_file);
  P_ioresult = 0;
  fpa = top;
  dismiss_expression_and_ips_list(expression, ips_list);
  dispose_expression(&expression[1]);
  dispose_ips_list_blind(&ips_list[1]);
  if (boolean_option[64])
    _Free(iterate_pack->differences);
  _Free(iterate_pack);
}  /* em_estimate */


/*@+"domodel.p"*/


/*

1741:    +++  ++
1742:    +++  ++
1743:    ---  -- p/domodel.p         22     100    1241 p/domodel.p
1744: |    4:    procedure do_discrete_model
1745: |   70:    procedure do_mixed_model
1746: |   90:    procedure do_continuous_model
1747: |  110:    procedure do_model
1748: |  142:    procedure do_em_model
1749: |  148:    procedure do_model_identify
1750: |  159:    procedure do_model_fit_values
1751: |  167:    function ok_model_identify
1752: |  177:    function ok_model_expression
1753: |  187:    function ok_current_expression
1754: |  192:    function ok_base_expression
1755: |  198:    function ok_model_to_test
1756: |  221:    function ok_miss_model
1757: |  233:    function ok_miss
1758: |  241:    function ok_two_to_test
1759: |  260:    function ok_marg_model_silent
1760: |  273:    function ok_log_model
1761: |  317:    function ok_two_log
1762: |  348:    function ok_model_fit_values
1763: |  358:    function ok_model
1764: |  368:    function ok_current
1765: |  373:    function ok_base
1766:    +++  ++
1767:    +++  ++

*/


Static Void do_discrete_model(model, find_marginals, fit_model, ok)
t_model **model;
boolean find_marginals, fit_model, *ok;
{
  t_set_list *link_clique;
  boolean ok_n, ok_p;

  /*$ifdef TRACE*/
  ntr(" DoDiscreteModel    ", 20L, 1744L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if (exclude_missing) {
    if ((*model)->found_expression)
      dispose_formula(model);
  }
  if (!(*model)->found_expression) {
    identify_model(model);
    (*model)->found_expression = true;
    (*model)->found_ps = false;
  }
  *ok = false;
  if (graph_mode) {
    warning_begin(stdout, false);
    write_pch(stdout, " Marginals and prob. not found for      ", 40L);
    link_clique = (*model)->id->UU.g_c_log_linear;
    while (link_clique != NULL) {
      print_vertex_set(link_clique->vertex_set);
      link_clique = link_clique->pointer;
    }
    warning_end(stdout, false);
    write_line(stdout);
    return;
  }
  if ((*model)->found_ps) {
    *ok = (*model)->found_ps;
    return;
  }
  if (!ok_to_find_model_marginals(model)) {
    if (!em)
      *ok = test_model_space(model);
    return;
  }
  if (em) {
    em_estimate(model);
    *ok = (*model)->found_ps;
    return;
  }
  if (!fit_model) {
    *ok = test_model_space(model);
    return;
  }
  find_offsets_and_marginals(model, find_marginals, &ok_n, &ok_p);
  /*$ifdef TRACE*/
  if (!ok_n && (boolean_option[3] || boolean_option[4] || boolean_option[5] ||
		boolean_option[21]))
    write_warning(stdout, " Out of space in DoModel: N.", 28L);
  if (!ok_p && (boolean_option[3] || boolean_option[4] || boolean_option[5] ||
		boolean_option[21]))
    write_warning(stdout, " Out of space in DoModel: P.", 28L);
  /*$endif TRACE*/
  if (ok_n && ok_p) {
    estimate_model(model);
    *ok = true;
  } else
    *ok = test_model_space(model);
}  /* do_discrete_model */


Static Void do_mixed_model(model, fit_model, ok)
t_model **model;
boolean fit_model, *ok;
{
  /* find_marginals, */
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DoMixedModel       ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1745L, 1L, -1L, -1L, model);
  if (trace_flag[TRACE_FLAG_FACTOR * 1745])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  if (exclude_missing) {
    if ((*model)->found_expression)
      dispose_formula(model);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1745L, 1L, -1L, 10L);
  if (trace_flag[TRACE_FLAG_FACTOR * 1745])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  if (!(*model)->found_expression) {
    identify_model(model);
    (*model)->found_expression = true;
    (*model)->found_ps = false;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1745L, 1L, -1L, 20L);
  if (trace_flag[TRACE_FLAG_FACTOR * 1745])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  if (fit_model)
    estimate_model(model);
  *ok = true;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1745L, 1L, 999L, 999L);
  if (trace_flag[TRACE_FLAG_FACTOR * 1745])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
}  /* do_mixed_model */


Static Void do_continuous_model(model, fit_model, ok)
t_model **model;
boolean fit_model, *ok;
{
  /* find_marginals, */
  /*$ifdef TRACE*/
  ntr(" DoContinuousModel  ", 20L, 1746L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if (exclude_missing) {
    if ((*model)->found_expression)
      dispose_formula(model);
  }
  if (!(*model)->found_expression) {
    identify_model(model);
    (*model)->found_expression = true;
    (*model)->found_ps = false;
  }
  if (fit_model)
    estimate_model(model);
  *ok = true;
}  /* do_continuous_model */


Static Void do_model(model, find_marginals, fit_model, ok)
t_model **model;
boolean find_marginals, fit_model, *ok;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DoModel            ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1747L, 1L, -1L, -1L, model);
  if (trace_flag_set(20L, 1747L, 0L)) {
    ntr_boolean(tzt, 20L, 1747L, 1L, -1L, 1L, find_marginals);
    ntr_boolean(tzt, 20L, 1747L, 1L, -1L, 2L, fit_model);
    write_line(stdout);
  }
  if (trace_flag[TRACE_FLAG_FACTOR * 1747])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  if ((*model)->id->model_type == pure_discrete)
    do_discrete_model(model, find_marginals, fit_model, ok);
  else if ((*model)->id->model_type == pure_continuous)
	/* find_marginals, */
	  do_continuous_model(model, fit_model, ok);
  else {
    /*$ifdef TRACE*/
    do_mixed_model(model, fit_model, ok);
    /* find_marginals, */
  }
  if (trace_flag[TRACE_FLAG_FACTOR * 1747])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  if (!trace_flag_set(20L, 1747L, 0L))
    return;
  /*$endif TRACE*/
  ntr_boolean(tzt, 20L, 1747L, 8L, -1L, -1L, *ok);
  ntr_model_numbers(tzt, 20L, 1747L, 8L, -1L, -2L, model);
  ntr_model_g_c(tzt, 20L, 1747L, 8L, -1L, -3L, model);
}  /* do_model */


Static Void do_em_model(model, ok)
t_model **model;
boolean *ok;
{
  do_model(model, true, true, ok);
}  /* do_em_model */


Static Void do_model_identify(model, ok)
t_model **model;
boolean *ok;
{
  if (!(*model)->found_expression) {
    identify_model(model);
    (*model)->found_expression = true;
    (*model)->found_ps = false;
  }
  *ok = true;
}  /* do_model_identify */


Static Void do_model_fit_values(model, ok)
t_model **model;
boolean *ok;
{
  do_model(model, true, true, ok);
  *ok = (*ok && (*model)->found_ps);
}  /* do_model_fit_values */


Static boolean ok_model_identify(model)
t_model **model;
{
  boolean ok = true;

  if (!(*model)->found_expression)
    do_model_identify(model, &ok);
  return ok;
}  /* ok_model_identify */


Static boolean ok_model_expression(model)
t_model **model;
{
  boolean Result, ok;

  ok = ok_model_identify(model);
  Result = ok;
  if (!ok)
    write_pch(stdout, " Out of space: Expression", 25L);
  return Result;
}  /* ok_model_expression */


Static boolean ok_current_expression()
{
  return (ok_model_expression(&link_current->model));
}  /* ok_current_expression */


Static boolean ok_base_expression()
{
  return (ok_model_expression(&link_base->model));
}  /* ok_base_expression */


Static boolean ok_model_to_test(model)
t_model **model;
{
  boolean ok = true;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " OkModelToTest      ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1755L, 1L, -1L, -1L, model);
  ntr_boolean(tzt, 20L, 1755L, 1L, -1L, -1L, (*model)->found_ps);
  if (trace_flag[TRACE_FLAG_FACTOR * 1755])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  if (!(*model)->found_ps)
    do_model(model, true, true, &ok);
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 1755])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  ntr_model_formula(tzt, 20L, 1755L, 8L, -1L, -1L, *model);
  ntr_boolean(tzt, 20L, 1755L, 8L, -1L, -1L, ok);
  /*$endif TRACE*/
  return ((*model)->found_ps || ok);
}  /* ok_model_to_test */


Static boolean ok_miss_model(g, silent)
long *g;
boolean silent;
{
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  if (!exclude_missing || P_subset(g, delta_missing_excluded))
    return true;
  if (silent) {
    if (!P_setequal(g, delta_missing_excluded))
      do_exclude(g);
  } else
    short_print_do_exclude(g);
  return true;
}  /* ok_miss_model */


Static boolean ok_miss()
{
  t_vertex_set vertex_set;

  P_setunion(vertex_set, link_current->model->id->vertices,
	     link_base->model->id->vertices);
  return (ok_miss_model(vertex_set, false));
}  /* ok_miss */


Static boolean ok_two_to_test(current_model, base_model, a, silent,
			      permit_log_l, ifail)
t_model **current_model, **base_model;
long *a;
boolean silent, permit_log_l;
t_integer *ifail;
{
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  P_setunion(a, (*current_model)->id->vertices, (*base_model)->id->vertices);
  if (!ok_miss_model(a, silent)) {
    *ifail = 15;
    return false;
  }
  if (!(ok_model_to_test(base_model) || permit_log_l)) {
    *ifail = 42;
    return false;
  }
  if (ok_model_to_test(current_model) || permit_log_l)
    return true;
  *ifail = 41;
  return false;
}  /* ok_two_to_test */


Static boolean ok_marg_model_silent(current, base)
t_model **current, **base;
{
  boolean ok = true;
  t_vertex_set vertex_set;

  if (datastructure != all && !em && !large) {
    P_setunion(vertex_set, (*current)->id->vertices, (*base)->id->vertices);
    test_expression_marginals(current, base, vertex_set, &ok);
  }
  return ok;
}  /* ok_marg_model_silent */


Static boolean ok_log_model(model, silent)
t_model **model;
boolean silent;
{
  boolean Result, ok;
  t_model_list *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " OkLogModel         ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1760L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  ok = return_model(model, &p);
  if (ok) {
    /*$ifdef TRACE*/
    ntr_model_g_c(tzt, 20L, 1760L, 2L, -1L, -1L, &p->model);
    ntr_model_numbers(tzt, 20L, 1760L, 2L, -1L, -1L, &p->model);
    /*$endif TRACE*/
    (*model)->log_l = compute_log_l(&p->model, p->model->id->vertices);
    /* copy_model(p^.model, model); */
    /* Dim ??? */
    (*model)->found_log_l = true;
    (*model)->dim = p->model->dim;
  }
  /*$ifdef TRACE*/
  ntr_model_numbers(tzt, 20L, 1760L, 3L, -1L, -1L, model);
  /*$endif TRACE*/
  if ((!ok) | is_invalid_real((*model)->log_l)) {
    if (!(*model)->found_log_l) {
      if (!(*model)->found_ps)
	do_model(model, true, false, &ok);
      if (ok || permit_log_l)
	(*model)->log_l = compute_log_l(model, (*model)->id->vertices);
    }
  }
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1760L, 8L, -1L, -1L, model);
  ntr_model_numbers(tzt, 20L, 1760L, 8L, -1L, -1L, model);
  /*$endif TRACE*/
  ok = (ok || permit_log_l);
  Result = ok;
  if (!ok && !silent)
    write_pch(stdout, " Out of space: Log", 18L);
  return Result;
}  /* ok_log_model */


Static boolean ok_two_log(current_model, base_model, silent, ifail)
t_model **current_model, **base_model;
boolean silent;
t_integer *ifail;
{
  boolean Result = false;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  P_setunion(a, (*current_model)->id->vertices, (*base_model)->id->vertices);
  if (ok_miss_model(a, silent)) {
    if (true | ok_marg_model_silent(current_model, base_model)) {
      if (ok_log_model(base_model, silent)) {
	if (ok_log_model(current_model, silent))
	  Result = true;
	else
	  *ifail = 41;
      } else
	*ifail = 42;
    } else
      *ifail = 43;
  } else {
    *ifail = 15;
    /*$ifdef TRACE*/
  }
  memcpy(tzt, " OkTwoLog           ", sizeof(pch20));
  ntr_model_numbers(tzt, 20L, 1761L, 8L, -1L, -1L, current_model);
  ntr_model_numbers(tzt, 20L, 1761L, 8L, -1L, -1L, base_model);
  /*$endif TRACE*/
  return Result;
}  /* ok_two_log */


Static boolean ok_model_fit_values(model)
t_model **model;
{
  boolean ok = true;

  if (!(*model)->found_ps)
    do_model_fit_values(model, &ok);
  return ok;
}  /* ok_model_fit_values */


Static boolean ok_model(model)
t_model **model;
{
  boolean Result, ok;

  ok = ok_model_fit_values(model);
  Result = ok;
  if (!ok && !(permit_log_l && in_test))
    write_pch(stdout, " Out of space: Model", 20L);
  return Result;
}  /* ok_model */


Static boolean ok_current()
{
  return (ok_model(&link_current->model));
}  /* ok_current */


Static boolean ok_base()
{
  return (ok_model(&link_base->model));
}  /* ok_base */


/*@+"df.p"*/


/*

1768:    +++  ++
1769:    +++  ++
1770:    ---  -- p/df.p          14      69     865 p/df.p
1771: |    4:    function is_zero_p_em
1772: |   17:    function is_zero_p_fast
1773: |   41:    function is_zero_p
1774: |   69:    function is_zero_m_p
1775: |   96:    procedure put_dim_factor
1776: |  133:    procedure find_dimension_list
1777: |  158:    function return_dimension_list
1778: |  208:    function count_zeros_in_one_table
1779: |  281:    function count_zeros_in_several_tables
1780: |  435:    function count_zero_par
1781: |  455:    procedure find_several_collaps_sets
1782: |  577:    function count_zero_n
1783: |  690:    procedure return_response_variables
1784: |  699:    function ok_to_f_test
1785:    +++  ++
1786:    +++  ++

*/

Static boolean is_zero_p_em(x)
t_real *x;
{
  t_long_real y;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1771L, 1L)) {
    y = *x;
    write_real(stdout, y, 10L, 5L);
  }
  /*$endif TRACE*/
  return (*x <= 1e-10);   /* ROUND_ERROR */
  /* 1E-10 */
  /* 1E-3 */
}  /* is_zero_p_em */


Static boolean is_zero_p_fast(link_expression, link_ips_list)
t_expression *link_expression;
t_list_ips_elements *link_ips_list;
{
  boolean not_zero = true;

  while (link_expression != NULL && not_zero) {
    if (em) {
      if (is_zero_p_em(&p[link_expression->offset]))
	not_zero = false;
    } else if (n[link_expression->offset] == 0)
      not_zero = false;
    link_expression = link_expression->pointer;
  }
  while (link_ips_list != NULL && not_zero) {
    if (is_zero_p_em(&p[link_ips_list->ips_element.p_offset]))
      not_zero = false;
    link_ips_list = link_ips_list->pointer;
  }
  return (!not_zero);
}  /* is_zero_p_fast */


Static boolean is_zero_p(i, link_expression, link_ips_list)
t_level *i;
t_expression *link_expression;
t_list_ips_elements *link_ips_list;
{
  boolean not_zero = true;

  while (link_expression != NULL && not_zero) {
    if (em) {
      if (is_zero_p_em(&p[marginal_hash(link_expression->vertex_set, i) +
			  link_expression->offset]))
	not_zero = false;
    } else if (n[marginal_hash(link_expression->vertex_set, i) +
		 link_expression->offset] == 0)
      not_zero = false;
    link_expression = link_expression->pointer;
  }
  while (link_ips_list != NULL && not_zero) {
    if (is_zero_p_em(&p[link_ips_list->ips_element.p_offset +
			marginal_hash(link_ips_list->ips_element.a, i)]))
      not_zero = false;
    link_ips_list = link_ips_list->pointer;
  }
  return (!not_zero);
}  /* is_zero_p */


Static boolean is_zero_m_p(a, i, model_set, link_expression, link_ips_list)
long *a;
t_level *i;
long *model_set;
t_expression **link_expression;
t_list_ips_elements **link_ips_list;
{
  t_vertex_set d_a;
  t_vertex v;
  t_cell_count index = 1;
  t_cell_count index_stop;
  boolean p_a;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (!P_inset(v, a))
      i[v - MIN_VERTEX] = FIRST_LEVEL;
  }
  p_a = is_zero_p(i, *link_expression, *link_ips_list);
  P_setdiff(d_a, delta, a);
  P_setint(d_a, d_a, model_set);
  index_stop = marginal_dimension(d_a);
  while (index < index_stop && p_a) {
    index++;
    next_marginal_cell(d_a, i);
    p_a = is_zero_p(i, *link_expression, *link_ips_list);
  }
  return p_a;
}  /* is_zero_m_p */


Static Void put_dim_factor(link_expression, a, factor)
t_expression **link_expression;
long *a;
t_long_integer factor;
{
  t_expression *p, *q;
  boolean b = true;

  if (*link_expression == NULL) {
    insert_factor_in_expression(a, -1L, &factor, link_expression);
    return;
  }
  p = *link_expression;
  q = p;
  while (p != NULL && b) {
    if (P_setequal(a, p->vertex_set))
      b = false;
    else {
      q = p;
      p = p->pointer;
    }
  }
  if (b) {
    insert_factor_in_expression(a, -1L, &factor, &p);
    q->pointer = p;
    return;
  }
  p->factor += factor;
  if (p->factor != 0)
    return;
  if (q == p) {
    *link_expression = p->pointer;
    _Free(p);
  } else {
    q->pointer = p->pointer;
    _Free(p);
  }
}  /* put_dim_factor */


Static Void find_dimension_list(gc, sign, dimension_list)
t_set_list **gc;
t_integer sign;
t_expression **dimension_list;
{
  t_set_list *p;
  t_set_list *gc_e = NULL;
  t_vertex_set c, vertex_set;

  if ((*gc)->pointer == NULL) {
    put_dim_factor(dimension_list, (*gc)->vertex_set, sign);
    return;
  }
  p = (*gc)->pointer;
  P_setcpy(c, (*gc)->vertex_set);
  while (p != NULL) {
    P_setint(vertex_set, c, p->vertex_set);
    insert_clique(vertex_set, &gc_e);
    p = p->pointer;
  }
  put_dim_factor(dimension_list, (*gc)->vertex_set, sign);
  find_dimension_list(&(*gc)->pointer, sign, dimension_list);
  find_dimension_list(&gc_e, -sign, dimension_list);
  dispose_set_list(&gc_e);
}  /* find_dimension_list */


Static t_expression *return_dimension_list(model)
t_model **model;
{
  t_expression *link_1_expression, *link_expression;
  t_expression *q = NULL;
  t_list_ips_elements *link_1_ips_list, *link_ips_list;
  t_list_radim_elements *link_1_radim_list, *link_radim_list;
  t_ips_set_list *link_clique;
  t_set_list *p;
  t_ips_element *WITH;
  t_radim_element *WITH1;

  return_expression(model, &link_expression, &link_ips_list, &link_radim_list,
		    true);
  link_1_expression = link_expression;
  link_1_ips_list = link_ips_list;
  link_1_radim_list = link_radim_list;
  while (link_expression != NULL) {
    put_dim_factor(&q, link_expression->vertex_set, link_expression->factor);
    link_expression = link_expression->pointer;
  }
  while (link_ips_list != NULL) {
    if (!link_ips_list->ips_element.radim_part) {
      p = NULL;
      WITH = &link_ips_list->ips_element;
      link_clique = WITH->gen_class;
      while (link_clique != NULL) {
	insert_clique(link_clique->vertex_set, &p);
	link_clique = link_clique->pointer;
      }
      find_dimension_list(&p, 1L, &q);
      dispose_set_list(&p);
    }
    link_ips_list = link_ips_list->pointer;
  }
  while (link_radim_list != NULL) {
    p = NULL;
    WITH1 = &link_radim_list->radim_element;
    link_clique = WITH1->gen_class;
    while (link_clique != NULL) {
      insert_clique(link_clique->vertex_set, &p);
      link_clique = link_clique->pointer;
    }
    find_dimension_list(&p, 1L, &q);
    dispose_set_list(&p);
    link_radim_list = link_radim_list->pointer;
  }
  dismiss_expression(&link_1_expression, &link_1_ips_list, &link_1_radim_list);
  return q;
}  /* return_dimension_list */


Static t_long_integer count_zeros_in_one_table(a, c, only_one, new_model)
long *a, *c;
boolean only_one;
t_model **new_model;
{
  t_integer pos, index_1, index_2, index_s;
  t_integer count_0 = 0;
  t_cell i;
  t_vertex_set c_a;
  t_product_list *link_prod_list;
  t_v_arr_of_integer levels;
  t_vertex l_a_vertex;
  t_expression *link_expression;
  t_list_ips_elements *link_ips_list;
  long FORLIM;

  memcpy(i, first_cell, sizeof(t_cell));
  if (P_setequal(a, c) && only_one) {
    return_expression_and_ips_list(new_model, &link_expression,
				   &link_ips_list, !em);
    find_product_list(a, &link_expression, &link_ips_list, &link_prod_list,
		      levels, &l_a_vertex);
    add_to_offsets(link_expression, link_ips_list, (long)FIRST_INDEX);
    FORLIM = marginal_dimension(a);
    for (index_1 = 1; index_1 <= FORLIM; index_1++) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1778L, 1L))
	write_integer(stdout, count_0, 4L);
      /*$endif TRACE*/
      if (is_zero_p_fast(link_expression, link_ips_list)) {
	count_0++;
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1778L, 1L))
	  write_pch(stdout, " * ", 3L);
	/*$endif TRACE*/
      }
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1778L, 1L))
	write_line(stdout);
      /*$endif TRACE*/
      next_offset_in_exp_list(&link_expression, &link_ips_list,
			      &link_prod_list, levels, &l_a_vertex, i);
    }
    add_to_offsets(link_expression, link_ips_list, (long)(-FIRST_INDEX));
    dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
    dispose_product_list(&link_prod_list);
    return count_0;
  }
  if (last_index(c) <= max_p_cell_number - fpa) {
    P_setdiff(c_a, c, a);
    index_s = marginal_dimension(c_a);
    FORLIM = marginal_dimension(a);
    for (index_1 = 1; index_1 <= FORLIM; index_1++) {
      pos = fpa + marginal_hash(c, i);
      index_2 = 1;
      while ((index_2 < index_s) & is_zero_p_em(&p[pos])) {
	index_2++;
	next_marginal_cell(c_a, i);
	pos = fpa + marginal_hash(c, i);
      }
      if (is_zero_p_em(&p[pos]))
	count_0++;
      next_marginal_cell(a, i);
    }
    return count_0;
  }
  return_expression_and_ips_list(new_model, &link_expression, &link_ips_list,
				 !em);
  FORLIM = marginal_dimension(a);
  for (index_1 = 1; index_1 <= FORLIM; index_1++) {
    if (is_zero_m_p(a, i, (*new_model)->id->vertices, &link_expression,
		    &link_ips_list))
      count_0++;
    next_marginal_cell(a, i);
  }
  dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
  return count_0;
}  /* count_zeros_in_one_table */


Static t_long_integer count_zeros_in_several_tables(c, set_list, c_model, ok)
long *c;
t_expression **set_list;
t_model **c_model;
boolean *ok;
{
  t_expression *q;
  t_integer index_1;
  t_integer count_0 = 0;
  t_model *tmp_model;
  t_cell i;
  t_product_list *link_prod_list;
  t_v_arr_of_integer levels;
  t_vertex l_a_vertex;
  t_offset n_offset, m_offset;
  t_expression *link_expression;
  t_list_ips_elements *link_ips_list;
  /*$ifdef TRACE*/
  pch20 tzt;
  long FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " CountZerosInSeveral", sizeof(pch20));
  ntr_model_formula(tzt, 20L, 1779L, 1L, -1L, -1L, *c_model);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1779L, 1L)) {
    write_pch(stdout, " CountZerosInSeveralTables, ", 28L);
    write_pch(stdout, " on:", 4L);
    print_vertex_set_table(c);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (!P_setequal(c, empty_set)) {
    if (!P_setequal(c, (*c_model)->id->vertices) && !em) {
      new_model(&tmp_model);
      erase_model(&tmp_model, pure_discrete, true);
      return_restricted_discrete_model(&tmp_model, c_model, c);
      if (!large) {
	/*$ifdef TRACE*/
	do_collapsed_model_from_model(&tmp_model, c_model);
      }
      ntr_model_formula(tzt, 20L, 1779L, 1L, 111L, 1L, *c_model);
      ntr_model_formula(tzt, 20L, 1779L, 1L, 222L, 2L, tmp_model);
      /*$endif TRACE*/
    } else
      tmp_model = *c_model;
    if (large && !tmp_model->found_ps) {
      tmp_model->formula_node = NULL;   /* ????? */
      *ok = ok_model_fit_values(&tmp_model);
      test_expression_marginals_one(&tmp_model, tmp_model->id->vertices, ok);
      /*$ifdef TRACE*/
      if ((!*ok) & trace_flag_set(20L, 1779L, 1L)) {
	/*$endif TRACE*/
	/*$ifdef TRACE*/
	write_warning(stdout, " Out of space in CountZero.", 27L);
      }
      ntr_model_formula(tzt, 20L, 1779L, 1L, 333L, 1L, *c_model);
      ntr_model_formula(tzt, 20L, 1779L, 1L, 444L, 2L, tmp_model);
      /*$endif TRACE*/
    }
    /*$ifdef TRACE*/
    ntr_model_formula(tzt, 20L, 1779L, 1L, 555L, 1L, *c_model);
    ntr_model_formula(tzt, 20L, 1779L, 1L, 666L, 2L, tmp_model);
    /*$endif TRACE*/
    if (*ok) {
      if (!TURBO_PC) {
	space_in_p_array(marginal_dimension(c), fpa);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
      }
      if (last_index(c) <= max_p_cell_number - fpa &&
	  !(P_setequal((*set_list)->vertex_set, c) &&
	    (*set_list)->pointer == NULL)) {
	memcpy(i, first_cell, sizeof(t_cell));
	return_expression_and_ips_list(&tmp_model, &link_expression,
				       &link_ips_list, !em);
	find_product_list(c, &link_expression, &link_ips_list,
			  &link_prod_list, levels, &l_a_vertex);
	add_to_offsets(link_expression, link_ips_list, (long)FIRST_INDEX);
	FORLIM = last_index(c);
	for (index_1 = FIRST_INDEX; index_1 <= FORLIM; index_1++) {
	  if (is_zero_p_fast(link_expression, link_ips_list))
	    p[fpa + index_1] = 0.0;
	  else
	    p[fpa + index_1] = 1.0;
	  next_offset_in_exp_list(&link_expression, &link_ips_list,
				  &link_prod_list, levels, &l_a_vertex, i);
	}
	add_to_offsets(link_expression, link_ips_list, (long)(-FIRST_INDEX));
	dismiss_expression_and_ips_list(&link_expression, &link_ips_list);
	dispose_product_list(&link_prod_list);
      }
      q = *set_list;
      while (q != NULL) {
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1779L, 1L)) {
	  write_pch(stdout, " Several: ", 10L);
	  print_vertex_set_table(q->vertex_set);
	  write_integer(stdout, q->factor, 4L);
	  n_offset = fpa;
	  m_offset = fpa;
	  /* print_table(q^.vertex_set, nil, 0,
	                false, false, false, n_offset,
	                n[0], m_offset, tmp_model); */
	  print_table(q->vertex_set, NULL, 2L, false, false, false, &n_offset,
		      (double)n[0], &m_offset, &tmp_model);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	count_0 += q->factor * count_zeros_in_one_table(q->vertex_set, c,
		     (*set_list)->pointer == NULL, &tmp_model);
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1779L, 1L)) {
	  write_integer(stdout, count_0, 4L);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	q = q->pointer;
      }
    }
    /*$ifdef TRACE*/
    ntr_model_formula(tzt, 20L, 1779L, 1L, 777L, 1L, *c_model);
    /*$endif TRACE*/
    if (!P_setequal(c, (*c_model)->id->vertices) && !em) {   /* ?!?!? */
      /*$ifdef TRACE*/
      ntr_model_formula(tzt, 20L, 1779L, 1L, 111L, 1L, tmp_model);
      /*$endif TRACE*/
      if (!large)
	clear_offsets(&tmp_model, null_node);
      /*$ifdef TRACE*/
      ntr_model_formula(tzt, 20L, 1779L, 1L, 222L, 1L, tmp_model);
      /*$endif TRACE*/
      dispose_model_and_link(&tmp_model);
    }
  }
  /*$ifdef TRACE*/
  ntr_model_formula(tzt, 20L, 1779L, 8L, 999L, 1L, *c_model);
  /*$endif TRACE*/
  return count_0;
}  /* count_zeros_in_several_tables */


typedef struct t_set_set_list {
  t_vertex_set vertex_set;
  t_expression *set_list;
  struct t_set_set_list *pointer;
} t_set_set_list;


/*$endif TRACE*/

Local Void find_several_collaps_sets(p, g, g_c, graphical, collaps_list)
t_expression *p;
long *g;
t_set_list **g_c;
boolean *graphical;
t_set_set_list **collaps_list;
{
  /* var atoms_list : t_link_set_list; */
  t_vertex_set a, r, vertex_set;
  boolean b;
  t_set_set_list *p_coll;

  while (p != NULL) {
    P_setcpy(a, p->vertex_set);
    P_setint(vertex_set, a, g);
    /* atoms_list, */
    return_collaps_set_discrete(vertex_set, g, g_c, graphical, r);
    P_setunion(r, a, r);
    p_coll = *collaps_list;
    b = true;
    while (p_coll != NULL && b) {
      if (P_setequal(r, p_coll->vertex_set))
	b = false;
      else
	p_coll = p_coll->pointer;
    }
    if (p_coll == NULL) {
      p_coll = (t_set_set_list *)Malloc(sizeof(t_set_set_list));
      if (p_coll == NULL)
	_OutMem();
      p_coll->pointer = *collaps_list;
      p_coll->set_list = NULL;
      P_setcpy(p_coll->vertex_set, r);
      *collaps_list = p_coll;
    }
    insert_factor_in_expression(a, -1L, &p->factor, &p_coll->set_list);
    p = p->pointer;
  }
}  /* find_several_collaps_sets */


Static t_long_integer count_zero_par(c_model, b_model)
t_model **c_model, **b_model;
{
  long Result;
  boolean ok = true;
  t_set_set_list *p_coll;
  t_set_set_list *collaps_list = NULL;
  /* atoms_list: t_link_set_list; */
  t_expression *sufficient_marginals;
  t_integer count_0 = 0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$ifdef TRACE*/
  memcpy(tzt, " CountZeroPar       ", sizeof(pch20));
  ntr_model_formula(tzt, 20L, 1780L, 1L, -1L, 1L, *c_model);
  ntr_model_formula(tzt, 20L, 1780L, 1L, -1L, 2L, *b_model);
  /*$endif TRACE*/
  sufficient_marginals = return_dimension_list(b_model);
  /* atoms_list := return_atoms_from_expression(c_model); */
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1780L, 1L)) {
    write_pch(stdout, " # Expected 0-parameters in Base:       ", 40L);
    write_line(stdout);
    write_pch(stdout, " Modelset:", 10L);
    print_vertex_set_table((*c_model)->id->vertices);
    write_line(stdout);
  }
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1780L, 2L, -1L, -1L);
  /*$endif TRACE*/
  /* atoms_list, */
  find_several_collaps_sets(sufficient_marginals, (*b_model)->id->vertices,
			    &(*c_model)->id->UU.g_c_log_linear,
			    &(*c_model)->graphical, &collaps_list);
  /* dispose_set_list(atoms_list); */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1780L, 1L, 3L, 2L);
  ntr_model_formula(tzt, 20L, 1780L, 5L, 666L, 1L, *c_model);
  ntr_model_formula(tzt, 20L, 1780L, 5L, 666L, 2L, *b_model);
  /*$endif TRACE*/
  while (((collaps_list != NULL) & (ok | trace_flag_set(20L, 1780L, 1L))) &&
	 !interrupt_1) {
    /*$ifdef TRACE*/
    /*$endif TRACE*/
    count_0 += count_zeros_in_several_tables(collaps_list->vertex_set,
	&collaps_list->set_list, c_model, &ok);
    dispose_expression(&collaps_list->set_list);
    p_coll = collaps_list;
    collaps_list = collaps_list->pointer;
    _Free(p_coll);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1780L, 1L, 3L, 3L);
  ntr_model_formula(tzt, 20L, 1780L, 6L, 777L, 1L, *c_model);
  ntr_model_formula(tzt, 20L, 1780L, 6L, 777L, 2L, *b_model);
  /*$endif TRACE*/
  if (interrupt_1) {
    interrupt_1 = false;
    write_warning(stdout, " Interrupt in CountZero.", 24L);
  }
  while (collaps_list != NULL) {
    dispose_expression(&collaps_list->set_list);
    p_coll = collaps_list;
    collaps_list = collaps_list->pointer;
    _Free(p_coll);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1780L, 1L, 3L, 4L);
  ntr_model_formula(tzt, 20L, 1780L, 7L, 888L, 1L, *c_model);
  ntr_model_formula(tzt, 20L, 1780L, 7L, 888L, 2L, *b_model);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1780L, 1L))
    write_line(stdout);
  /*$endif TRACE*/
  dispose_expression(&sufficient_marginals);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1780L, 1L, 3L, 5L);
  /*$endif TRACE*/
  if (ok)
    Result = count_0;
  else {
    Result = _INFINITY;
    /*$ifdef TRACE*/
  }
  ntr_model_formula(tzt, 20L, 1780L, 8L, 999L, 1L, *c_model);
  ntr_model_formula(tzt, 20L, 1780L, 8L, 999L, 2L, *b_model);
  /*$endif TRACE*/
  return Result;
}  /* count_zero_par */


Static t_long_integer count_zero_n(model)
t_model **model;
{
  long Result;
  boolean ok = true;
  t_long_real log_l;
  t_long_integer count_zero = 0;
  t_expression *p1, *set_list;
  t_e_cell_index index;
  t_offset m_offset, n_offset;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_e_cell_index FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " CountZeroN         ", sizeof(pch20));
  ntr_model_formula(tzt, 20L, 1782L, 1L, -1L, -1L, *model);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1782L, 1L)) {
    write_pch(stdout, " CountZeroN, ", 13L);
    write_pch(stdout, " # 0-parameters:    ", 20L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  set_list = return_dimension_list(model);
  p1 = set_list;
  if (em) {
    m_offset = fpa;
    if (!TURBO_PC)
      ok = space_in_p_array(last_index((*model)->id->vertices), m_offset);
    if (last_index((*model)->id->vertices) <= max_p_cell_number - m_offset)
      find_expected_table((*model)->id->vertices, m_offset, model, &log_l,
			  false, false);
  }
  while (p1 != NULL && ok && !interrupt_1) {
    if (em) {
      n_offset = m_offset + marginal_dimension((*model)->id->vertices);
      if (!P_setequal((*model)->id->vertices, p1->vertex_set)) {
	if (!TURBO_PC)
	  ok = space_in_p_array(last_index(p1->vertex_set), n_offset);
	if (last_index(p1->vertex_set) <= max_p_cell_number - n_offset) {
	  if (false)
	    find_expected_table(p1->vertex_set, n_offset, model, &log_l,
				false, false);
	  else
	    find_marginal_expected_table(p1->vertex_set,
	      (*model)->id->vertices, n_offset, m_offset);
	} else
	  ok = false;
      } else
	n_offset = m_offset;
      ok = (n_offset + marginal_dimension(p1->vertex_set) < max_p_cell_number);
    } else
      n_offset = return_offset(p1->vertex_set, &ok);
    /*$ifdef TRACE*/
    if ((!ok) & trace_flag_set(20L, 1782L, 1L))
      write_warning(stdout, " Out of space in CountZeroN.", 28L);
    /*$endif TRACE*/
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1782L, 1L)) {
      write_pch(stdout, " Marginal:", 10L);
      print_vertex_set_table(p1->vertex_set);
      write_integer(stdout, p1->factor, 4L);
      print_table(p1->vertex_set, NULL, 0L, false, false, false, &n_offset,
		  (double)n[0], &m_offset, model);
    }
    /*$endif TRACE*/
    if (ok) {
      if (em) {
	FORLIM = n_offset + last_index(p1->vertex_set);
	for (index = n_offset; index <= FORLIM; index++) {
	  if (is_zero_p_em(&p[index]))
	    count_zero += p1->factor;
	}
      } else {
	FORLIM = n_offset + last_index(p1->vertex_set);
	for (index = n_offset; index <= FORLIM; index++) {
	  if (n[index] == 0)
	    count_zero += p1->factor;
	}
      }
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1782L, 1L)) {
      write_integer(stdout, count_zero, 6L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (large)
      dispose_marginals();
    p1 = p1->pointer;
  }
  if (interrupt_1) {
    interrupt_1 = false;
    write_warning(stdout, " Interrupt in CountZeroN.", 25L);
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1782L, 1L))
    write_line(stdout);
  /*$endif TRACE*/
  dispose_expression(&set_list);
  if (ok)
    Result = count_zero;
  else {
    Result = _INFINITY;
    /*$ifdef TRACE*/
  }
  ntr_model_formula(tzt, 20L, 1782L, 8L, -1L, -1L, *model);
  /*$endif TRACE*/
  return Result;
}  /* count_zero_n */


Static Void return_response_variables(response_variables, model)
long *response_variables;
t_model **model;
{
  P_setcpy(response_variables, delta_gamma);
  if ((*model)->id->causal_structure != NULL)
    P_setdiff(response_variables, response_variables,
	      (*model)->id->causal_structure->vertex_set);
}  /* return_response_variables */


Static boolean ok_to_f_test(c_model, b_model, f_df)
t_model **c_model, **b_model;
t_long_integer *f_df;
{
  t_set_list *p;
  t_vertex_set a, b;
  boolean ok = true;
  t_model *collapsed_c_model, *collapsed_b_model;
  t_vertex_set response_variables;

  /* note_mixed(output, ' OkToFTest@@@@@@@@@@', 10); */
  *f_df = _INFINITY;
  return_response_variables(response_variables, c_model);
  P_setint(a, response_variables, (*c_model)->id->vertices);
  P_setint(a, a, gamma_);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1784L, 1L)) {   /* true or */
    write_pch(stdout, " Continuous response:         ", 22L);
    print_vertex_set(a);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (cardinality(a) < 1 || (*c_model)->id->model_type != mixed ||
      (*b_model)->id->model_type != mixed)
    return false;
  p = (*c_model)->id->UU.U1.g_c_quadratic;
  while (p != NULL && ok) {
    if (P_subset(a, p->vertex_set)) {
      P_setint(b, p->vertex_set, delta);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1784L, 1L)) {
	write_pch(stdout, " Discrete in quadratic:       ", 25L);
	print_vertex_set(b);
	write_line(stdout);
      }
      /*$endif TRACE*/
      if (!P_setequal(b, empty_set))
	ok = false;
    }
    p = p->pointer;
  }
  if (!ok)
    return false;
  P_setdiff(a, (*c_model)->id->vertices, a);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1784L, 1L)) {
    write_pch(stdout, " Explanatory:                 ", 20L);
    print_vertex_set(a);
    write_line(stdout);
  }
  /*$endif TRACE*/
  new_model(&collapsed_c_model);
  new_model(&collapsed_b_model);
  collaps_mixed_model(a, c_model, &collapsed_c_model);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  collaps_mixed_model(a, b_model, &collapsed_b_model);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  ok = false;
  if (collapsed_b_model->id->model_type == mixed &&
      collapsed_b_model->id->model_type == mixed) {
    if (test_sub_g_c(collapsed_b_model->id->UU.U1.g_c_discrete,
		     collapsed_c_model->id->UU.U1.g_c_discrete)) {
      /*
               if test_sub_g_c(collapsed_b_model^.id^.g_c_linear,
         collapsed_c_model^.id^.g_c_linear) then
                  if test_sub_g_c(collapsed_b_model^.id^.g_c_quadratic,
            collapsed_c_model^.id^.g_c_quadratic) then */
      *f_df = find_mixed_dimension(collapsed_c_model->id->UU.U1.g_c_discrete,
	  collapsed_c_model->id->UU.U1.g_c_linear,
	  collapsed_c_model->id->UU.U1.g_c_quadratic,
	  (*b_model)->id->UU.U1.full_specified,
	  (*b_model)->id->UU.U1.homogeneous, 0L);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1784L, 1L)) {
	write_pch(stdout, " F-test:  ", 10L);
	P_setint(b, response_variables, (*c_model)->id->vertices);
	P_setint(b, b, gamma_);
	print_vertex_set(b);
	write_space(stdout, 6 - cardinality(b));
	print_vertex_set(a);
	write_space(stdout, 6 - cardinality(a));
	write_integer(stdout, *f_df, 4L);
      }
      /*$endif TRACE*/
      *f_df = find_mixed_dimension(collapsed_b_model->id->UU.U1.g_c_discrete,
	  collapsed_b_model->id->UU.U1.g_c_linear,
	  collapsed_b_model->id->UU.U1.g_c_quadratic,
	  (*b_model)->id->UU.U1.full_specified,
	  (*b_model)->id->UU.U1.homogeneous, 0L);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1784L, 1L))
	write_integer(stdout, *f_df, 4L);
      /*$endif TRACE*/
      dispose_model(&collapsed_b_model);
      erase_mixed_model(&collapsed_b_model);
      p = (t_set_list *)Malloc(sizeof(t_set_list));
      if (p == NULL)
	_OutMem();
      P_setcpy(p->vertex_set, a);   /* collapsed_b_model^.id^.vertices */
      p->pointer = NULL;
      copy_g_c_to_mixed_graphical_model(p, false, true, &collapsed_b_model);
      _Free(p);
      *f_df = find_mixed_dimension(collapsed_b_model->id->UU.U1.g_c_discrete,
	  collapsed_b_model->id->UU.U1.g_c_linear,
	  collapsed_b_model->id->UU.U1.g_c_quadratic,
	  (*b_model)->id->UU.U1.full_specified,
	  (*b_model)->id->UU.U1.homogeneous, 0L);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1784L, 1L))
	write_integer(stdout, *f_df, 4L);
      /*$endif TRACE*/
      ok = true;
    }
  }
  dispose_model_and_link(&collapsed_c_model);
  dispose_model_and_link(&collapsed_b_model);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  return ok;
}  /* ok_to_f_test */


/*@-"exact.c"*/
/*@+"patef.p"*/


Static t_long_integer set_n_of_tables(test, ordinal, n_of_tables)
t_test *test;
boolean ordinal;
t_long_integer *n_of_tables;
{
  long Result;
  t_long_integer i;
  t_two_integers_list *p;

  if (ordinal)
    i = (long)floor(test->mcep_gamma_2 + 0.5);
  else if (!exact_log_l) {
    switch (test_choice) {

    case 1:
      i = (long)floor(test->mcep_deviance + 0.5);
      break;

    case 2:
      i = (long)floor(test->mcep_pearson + 0.5);
      break;

    case 3:
      i = (long)floor(test->mcep_power + 0.5);
      break;
    }
  } else
    i = (long)floor(test->mcep_deviance + 0.5);
  if (link_n_of_tables != NULL) {
    if (*n_of_tables < init_n_of_tables)
      return init_n_of_tables;
    else {
      p = link_n_of_tables;
      while (p->pointer != NULL && p->a < i)
	p = p->pointer;
      if (i <= p->a)
	return (p->b);
      else
	return init_n_of_tables;
    }
  }
  if (i > 8 || *n_of_tables < 20)
    return 20;
  switch (i) {

  case 0:
  case 1:
  case 2:
    Result = 1000;
    break;

  case 3:
  case 4:
  case 5:
    Result = 200;
    break;

  case 6:
  case 7:
  case 8:
    Result = 100;
    break;
  }
  return Result;
}  /* set_n_of_tables */


Static Void trace_add_term(index_1, index_2, n_total, m, n1, n2, p1, p2,
			   ln_p2_p1, x_deviance, x_power, x_pearson)
t_long_integer index_1, index_2, n_total, m, n1, n2;
t_long_real p1, p2, ln_p2_p1, x_deviance, x_power, x_pearson;
{
  write_char(stdout, ':');
  write_char(stdout, '2');
  write_integer(stdout, index_1, 4L);
  write_integer(stdout, index_2, 4L);
  write_integer(stdout, n_total, 10L);
  write_integer(stdout, m, 10L);
  write_integer(stdout, n1, 10L);
  write_integer(stdout, n2, 10L);
  write_space(stdout, 2L);
  write_real(stdout, p1, 8L, 5L);
  write_real(stdout, p2, 8L, 5L);
  write_real(stdout, ln_p2_p1, 10L, 5L);
  write_space(stdout, 2L);
  write_real(stdout, x_deviance, 11L, 6L);
  write_real(stdout, x_power, 11L, 6L);
  write_real(stdout, x_pearson, 11L, 6L);
  write_line(stdout);
}  /* trace_add_term */


#define precision       2e-16


Local t_long_integer find_count(dummy, ia, ib, ic, id, ie, ii, nlm)
t_long_integer *dummy, *ia, *ib, *ic, *id, *ie, *ii, *nlm;
{
  t_long_integer nll, flip;
  boolean up;
  t_long_real rand;
  t_long_real sumprb = 1.0;
  t_long_real x, y, ia_, id_, ii_, nlm_, nll_;

  do {
    rand = sumprb * uniform(dummy);
    *nlm = (long)floor((double)(*ia) / *ie * *id + 0.5);
    sumprb = exp(log_fact(*ia) + log_fact(*ib) + log_fact(*ic) +
		 log_fact(*id) - log_fact(*ie) - log_fact(*nlm) - log_fact(
		   *id - *nlm) - log_fact(*ia - *nlm) - log_fact(*ii + *nlm));
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1793L, 1L)) {
      write_char(stdout, ':');
      write_char(stdout, '1');
      write_integer(stdout, *nlm, 4L);
      write_real(stdout, rand, 12L, 5L);
      write_real(stdout, sumprb, 12L, 5L);
    }
    /*$endif TRACE*/
    if (sumprb < rand) {
      x = sumprb;
      y = x;
      nll = *nlm;
      up = true;
      flip = 0;
      ia_ = *ia;
      id_ = *id;
      ii_ = *ii;
      sumprb -= rand;
      do {
	if (up) {
	  if (flip == 0)
	    up = !up;
	  if (*id == *nlm || *ia == *nlm)
	    flip++;
	  else {
	    /*$ifdef TRACE*/
	    if (trace_flag_set(20L, 1793L, 1L))
	      write_char(stdout, '+');
	    /*$endif TRACE*/
	    nlm_ = *nlm;
	    x *= (id_ - nlm_) * (ia_ - nlm_);
	    nlm_ += 1.0;
	    x /= nlm_ * (ii_ + nlm_);
	    (*nlm)++;
	    /*$ifdef TRACE*/
	    if (trace_flag_set(20L, 1793L, 1L))
	      write_real(stdout, x, 12L, 5L);
	    /*$endif TRACE*/
	    if (x < fabs(sumprb) * precision)
	      flip++;
	    sumprb += x;
	  }
	} else {
	  if (flip == 0)
	    up = !up;
	  if (nll == 0 || *ii + nll == 0)
	    flip++;
	  else {
	    /*$ifdef TRACE*/
	    if (trace_flag_set(20L, 1793L, 1L))
	      write_char(stdout, '-');
	    /*$endif TRACE*/
	    nll_ = nll;
	    y *= nll_ * (ii_ + nll_);
	    nll_ -= 1.0;
	    y /= (id_ - nll_) * (ia_ - nll_);
	    nll--;
	    /*$ifdef TRACE*/
	    if (trace_flag_set(20L, 1793L, 1L))
	      write_real(stdout, y, 12L, 5L);
	    /*$endif TRACE*/
	    if (y < fabs(sumprb) * precision)
	      flip++;
	    sumprb += y;
	  }
	}
      } while (sumprb < 0 && flip != 2);
      sumprb += rand;
      if (flip == 1 && !up || flip == 0 && up)
	*nlm = nll;
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1793L, 1L)) {
      write_char(stdout, ':');
      write_integer(stdout, *nlm, 4L);
      write_line(stdout);
    }
    /*$endif TRACE*/
  } while (sumprb < rand);
  return (*nlm);
}  /* find_count */

/* Local variables for as_159: */
struct LOC_as_159 {
  long *nrowpos, *ncolpos;
  t_integer (*nmatpos)[MAX_LEVEL];
} ;

Local Void add_term(m, n1, n2, n_total, minus_log_q, x_power, x_pearson, LINK)
t_long_integer m, n1, n2, n_total;
t_long_real *minus_log_q, *x_power, *x_pearson;
struct LOC_as_159 *LINK;
{
  t_long_real ln_p2_p1, p1, p2, x;
  double TEMP;

  if (exact_log_l) {
    if (m != 0)
      *minus_log_q += m * log((double)m / n1 * ((double)n_total / n2));
  } else {
    x = 1.0 / n_total;
    p1 = n1 * x;
    p1 *= n2 * x;
    p2 = m * x;
    if (p1 != 0) {
      x = 1 / p1;
      TEMP = p1 - p2;
      *x_pearson += n_total * (TEMP * TEMP) * x;
    }
    if (m != 0) {
      ln_p2_p1 = log(p2 * x);
      *minus_log_q += m * ln_p2_p1;
      *x_power += n_total * p2 * (exp(ln_p2_p1 * lambda) - 1);
    }
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1795L, 1L)) {
    /*$endif TRACE*/
    trace_add_term(-1L, -1L, n_total, m, n1, n2, p1, p2, ln_p2_p1,
		   *minus_log_q, *x_power, *x_pearson);
  }
}  /* add_term */

Local Void apply_count(return_n, index_1, index_2, mcount, ntotal,
		       minus_log_q, x_power, x_pearson, LINK)
boolean return_n;
t_long_integer index_1, index_2, mcount, *ntotal;
t_long_real *minus_log_q, *x_power, *x_pearson;
struct LOC_as_159 *LINK;
{
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1796L, 1L))
    trace_add_term(index_1, index_2, n[LINK->nmatpos[index_1-1][index_2-1]],
		   mcount, n[LINK->nrowpos[index_1-1]],
		   n[LINK->ncolpos[index_2-1]], -1.0, -1.0, -1.0, -1.0, -1.0,
		   -1.0);
  /*$endif TRACE*/
  if (return_n)
    n[LINK->nmatpos[index_1-1][index_2-1]] = mcount;
  else
    add_term(mcount, n[LINK->nrowpos[index_1-1]], n[LINK->ncolpos[index_2-1]],
	     *ntotal, minus_log_q, x_power, x_pearson, LINK);
}  /* apply_count */

Local Void as_159(nrow, ncol, nrowpos_, ncolpos_, nmatpos_, dummy, ntotal,
		  return_n, minus_log_q, x_power, x_pearson)
t_integer *nrow, *ncol;
long *nrowpos_, *ncolpos_;
t_integer (*nmatpos_)[MAX_LEVEL];
t_long_integer *dummy, *ntotal;
boolean return_n;
t_long_real *minus_log_q, *x_power, *x_pearson;
{
  struct LOC_as_159 Local_Var;
  t_integer nrowtl, ncolm, nrowm;
  t_long_integer j, l, m, ia, ib, ic, id, ie, ii, jc, nlm;
  t_level_arr_of_integer jwork;

  Local_Var.nrowpos = nrowpos_;
  Local_Var.ncolpos = ncolpos_;
  Local_Var.nmatpos = nmatpos_;
  *ntotal = 0;
  for (j = 0; j < *ncol; j++)
    *ntotal += n[Local_Var.ncolpos[j]];
  nrowm = *nrow - 1;
  ncolm = *ncol - 1;
  for (j = 0; j < ncolm; j++)
    jwork[j] = n[Local_Var.ncolpos[j]];
  jc = *ntotal;
  for (l = 1; l <= nrowm; l++) {
    nrowtl = n[Local_Var.nrowpos[l-1]];
    ia = nrowtl;
    ic = jc;
    jc -= nrowtl;
    m = 0;
    while (m < ncolm) {
      m++;
      id = jwork[m-1];
      ie = ic;
      ic -= id;
      ib = ie - ia;
      ii = ib - id;
      if (ie == 0) {
	for (j = m; j <= *ncol; j++)
	  apply_count(return_n, l, j, 0L, ntotal, minus_log_q, x_power,
		      x_pearson, &Local_Var);
	m = *ncol;
      } else {
	nlm = find_count(dummy, &ia, &ib, &ic, &id, &ie, &ii, &nlm);
	apply_count(return_n, l, m, nlm, ntotal, minus_log_q, x_power,
		    x_pearson, &Local_Var);
	ia -= nlm;
	jwork[m-1] -= nlm;
      }
    }
    if (ie != 0)
      apply_count(return_n, l, *ncol, ia, ntotal, minus_log_q, x_power,
		  x_pearson, &Local_Var);
  }
  for (m = 1; m <= ncolm; m++)
    apply_count(return_n, *nrow, m, jwork[m-1], ntotal, minus_log_q, x_power,
		x_pearson, &Local_Var);
  apply_count(return_n, *nrow, *ncol, ib - jwork[ncolm-1], ntotal,
	      minus_log_q, x_power, x_pearson, &Local_Var);
}  /* as_159 */

Local Void add_statistics(nrowx, ncolx, nrowpos, ncolpos, nmatpos, n_total,
			  minus_log_q, x_power, x_pearson)
t_integer *nrowx, *ncolx;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
t_long_integer *n_total;
t_long_real *minus_log_q, *x_power, *x_pearson;
{
  t_long_integer m;
  t_long_real ln_p2_p1, p1, p2, x;
  t_cell_index index_1, index_2;
  double TEMP;

  for (index_1 = 1; index_1 <= *nrowx; index_1++) {
    for (index_2 = 1; index_2 <= *ncolx; index_2++) {
      m = n[nmatpos[index_1-1][index_2-1]];
      x = 1.0 / *n_total;
      p1 = n[nrowpos[index_1-1]] * x;
      p1 *= n[ncolpos[index_2-1]];
      p1 *= x;
      p2 = m * x;
      if (p1 != 0) {
	x = 1 / p1;
	TEMP = p1 - p2;
	*x_pearson += *n_total * (TEMP * TEMP) * x;
      }
      if (m != 0) {
	ln_p2_p1 = log(p2 * x);
	*minus_log_q += m * ln_p2_p1;
	*x_power += *n_total * p2 * (exp(ln_p2_p1 * lambda) - 1);
      }
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1797L, 1L)) {
	/*$endif TRACE*/
	trace_add_term(index_1, index_2, *n_total, m, n[nrowpos[index_1-1]],
		       n[ncolpos[index_2-1]], p1, p2, ln_p2_p1, *minus_log_q,
		       *x_power, *x_pearson);
      }
    }
  }
}  /* add_statistics */

Local Void add_deviance(nrowx, ncolx, nrowpos, ncolpos, nmatpos, n_total,
			minus_log_q)
t_integer *nrowx, *ncolx;
long *nrowpos, *ncolpos;
t_integer (*nmatpos)[MAX_LEVEL];
t_long_integer *n_total;
t_long_real *minus_log_q;
{
  t_long_real x;
  t_long_integer m;
  t_cell_index index_1, index_2;

  for (index_1 = 1; index_1 <= *nrowx; index_1++) {
    for (index_2 = 1; index_2 <= *ncolx; index_2++) {
      m = n[nmatpos[index_1-1][index_2-1]];
      if (m != 0) {
	x = (double)(*n_total) / n[nrowpos[index_1-1]];
	x *= (double)m / n[ncolpos[index_2-1]];
	*minus_log_q += m * log(x);
      }
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1798L, 1L)) {
	/*$endif TRACE*/
	trace_add_term(index_1, index_2, *n_total, m, n[nrowpos[index_1-1]],
		       n[ncolpos[index_2-1]], -1.0, -1.0, -1.0, *minus_log_q,
		       -1.0, -1.0);
      }
    }
  }
}  /* add_deviance */


Static Void patefield_as_159_in_n(n_levels_v, n_levels_w, vc_offset,
  wc_offset, vwc_offset, slice_pack, return_n, compute_statistics,
  compute_gamma, x_deviance, x_power, x_pearson, gamma)
t_level *n_levels_v, *n_levels_w;
t_offset *vc_offset, *wc_offset, *vwc_offset;
t_slice_pack *slice_pack;
boolean return_n, compute_statistics, compute_gamma;
t_long_real *x_deviance, *x_power, *x_pearson, *gamma;
{
  t_cell_index index_1, index_2, n_l_w_p_vwc_w, pos_1_vc, pos_2_wc, pos_3_vwc;
  t_cell i;
  boolean ok;
  t_offset i_v, i_w, i_c;
  t_integer nrowx, ncolx, ncolx1;
  t_long_integer n_total;
  t_long_real d_gamma, ppq, pmq, s, s1;
  t_long_real ppqtot = 0.0, pmqtot = 0.0;
  long *ncolpos, *nrowpos;
  t_integer (*nmatpos)[MAX_LEVEL];
  boolean zero_col[MAX_LEVEL];
  t_offset FORLIM;

  nmatpos = (t_integer(*)[MAX_LEVEL])Malloc(sizeof(t_level_2_arr_of_integer));
  if (nmatpos == NULL)
    _OutMem();
  ncolpos = (long *)Malloc(sizeof(t_level_arr_of_integer));
  if (ncolpos == NULL)
    _OutMem();
  nrowpos = (long *)Malloc(sizeof(t_level_arr_of_integer));
  if (nrowpos == NULL)
    _OutMem();
  memcpy(i, first_cell, sizeof(t_cell));
  n_l_w_p_vwc_w = *n_levels_w * slice_pack->p_vwc_w;
  pos_1_vc = *vc_offset;
  pos_2_wc = *wc_offset;
  pos_3_vwc = *vwc_offset;
  FORLIM = slice_pack->marginal_dimension_c;
  for (i_c = 1; i_c <= FORLIM; i_c++) {
    if (return_n || compute_gamma && compute_statistics) {
      index_2 = pos_2_wc;
      ncolx = 0;
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1792L, 1L))
	write_pch_10_text(stdout, " Ncol: ", 7L);
      /*$endif TRACE*/
      for (i_w = 0; i_w <= *n_levels_w - 1; i_w++) {
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1792L, 1L))
	  write_cell_count_text(stdout, &n[index_2], 10L);
	/*$endif TRACE*/
	if (n[index_2] == 0)
	  zero_col[i_w] = true;
	else {
	  zero_col[i_w] = false;
	  ncolx++;
	  ncolpos[ncolx-1] = index_2;
	}
	index_2 += slice_pack->p_wc_w;
      }
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1792L, 1L)) {
	write_integer_text(stdout, ncolx, 4L);
	write_line_text(stdout);
      }
      /*$endif TRACE*/
      index_1 = pos_1_vc;
      index_2 = pos_3_vwc;
      nrowx = 0;
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1792L, 1L))
	write_pch_10_text(stdout, " Nrow: ", 7L);
      /*$endif TRACE*/
      for (i_v = 1; i_v <= *n_levels_v; i_v++) {
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 1792L, 1L))
	  write_cell_count_text(stdout, &n[index_1], 10L);
	/*$endif TRACE*/
	if (n[index_1] == 0) {
	  for (i_w = 1; i_w <= *n_levels_w; i_w++) {
	    n[index_2] = 0;
	    index_2 += slice_pack->p_vwc_w;
	  }
	} else {
	  nrowx++;
	  nrowpos[nrowx-1] = index_1;
	  ncolx1 = 0;
	  for (i_w = 0; i_w <= *n_levels_w - 1; i_w++) {
	    if (zero_col[i_w])
	      n[index_2] = 0;
	    else {
	      ncolx1++;
	      nmatpos[nrowx-1][ncolx1-1] = index_2;
	    }
	    index_2 += slice_pack->p_vwc_w;
	  }
	}
	index_2 += slice_pack->p_vwc_v - n_l_w_p_vwc_w;
	index_1 += slice_pack->p_vc_v;
      }
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1792L, 1L)) {
	write_integer_text(stdout, nrowx, 4L);
	write_line_text(stdout);
      }
      /*$endif TRACE*/
      if (nrowx > 1 && ncolx > 1)
	as_159(&nrowx, &ncolx, nrowpos, ncolpos, nmatpos, &seed, &n_total,
	       true, x_deviance, x_power, x_pearson);
      else {
	n_total = 0;
	if (nrowx > 1) {
	  for (index_2 = 0; index_2 <= nrowx - 1; index_2++) {
	    n_total += n[nrowpos[index_2]];
	    n[nmatpos[index_2][0]] = n[nrowpos[index_2]];
	  }
	} else if (ncolx > 1) {
	  for (index_2 = 0; index_2 <= ncolx - 1; index_2++) {
	    n_total += n[ncolpos[index_2]];
	    n[nmatpos[0][index_2]] = n[ncolpos[index_2]];
	  }
	} else if (nrowx == 1 && ncolx == 1) {
	  n_total = n[nrowpos[0]];
	  n[nmatpos[0][0]] = n[nrowpos[0]];
	} else if (nrowx != 0 || ncolx != 0) {
	  write_pch_40_text(stdout,
			    " Row/Column-Error in Patefield:         ", 32L);
	  write_integer_text(stdout, nrowx, 3L);
	  write_integer_text(stdout, ncolx, 3L);
	  write_integer_text(stdout, ncolx1, 3L);
	  write_line_text(stdout);
	}
      }
      if (compute_statistics) {
	if (exact_log_l)
	  add_deviance(&nrowx, &ncolx, nrowpos, ncolpos, nmatpos, &n_total,
		       x_deviance);
	else {
	  add_statistics(&nrowx, &ncolx, nrowpos, ncolpos, nmatpos, &n_total,
			 x_deviance, x_power, x_pearson);
	  if (compute_gamma) {
	    find_gamma(&n_total, &nrowx, &ncolx, nmatpos, false, &ppq, &pmq,
		       &d_gamma, &s, &s1, &ok);
	    ppqtot += ppq;
	    pmqtot += pmq;
	  }
	}
      }
    } else {
      index_2 = pos_2_wc;
      ncolx = 0;
      for (i_w = 1; i_w <= *n_levels_w; i_w++) {
	if (n[index_2] != 0) {
	  ncolx++;
	  ncolpos[ncolx-1] = index_2;
	}
	index_2 += slice_pack->p_wc_w;
      }
      index_1 = pos_1_vc;
      nrowx = 0;
      for (i_v = 1; i_v <= *n_levels_v; i_v++) {
	if (n[index_1] != 0) {
	  nrowx++;
	  nrowpos[nrowx-1] = index_1;
	}
	index_1 += slice_pack->p_vc_v;
      }
      if (nrowx > 1 && ncolx > 1)
	as_159(&nrowx, &ncolx, nrowpos, ncolpos, nmatpos, &seed, &n_total,
	       false, x_deviance, x_power, x_pearson);
    }
    next_offset_in_slice(slice_pack, &pos_1_vc, &pos_2_wc, &pos_3_vwc, i);
  }
  _Free(nmatpos);
  _Free(ncolpos);
  _Free(nrowpos);
  if (!compute_statistics)
    return;
  if (compute_gamma) {
    if (ppqtot > 0)
      *gamma += pmqtot / ppqtot;
  }
}  /* patefield_as_159_in_n */

#undef precision


Static Void set_exact_test(test, x)
t_test *test;
t_integer x;
{
  test->mcep_deviance = x;
  test->mcep_power = x;
  test->mcep_pearson = x;
  test->mcep_gamma_1 = x;
  test->mcep_gamma_2 = x;
  test->number_of_tables = 0;
}  /* set_exact_test */


Static Void scale_exact_test(test, p_test, number_of_tables, compute_gamma)
t_test *test;
t_test_list **p_test;
t_long_integer *number_of_tables;
boolean compute_gamma;
{
  if (exact_log_l) {
    test->mcep_deviance /= *number_of_tables;
    test->mcep_power = _INVALID_REAL;
    test->mcep_pearson = _INVALID_REAL;
    test->mcep_gamma_1 = _INVALID_REAL;
    test->mcep_gamma_2 = _INVALID_REAL;
  } else {
    test->mcep_deviance /= *number_of_tables;
    test->mcep_power /= *number_of_tables;
    test->mcep_pearson /= *number_of_tables;
    if (compute_gamma) {
      test->mcep_gamma_1 /= *number_of_tables;
      test->mcep_gamma_2 /= *number_of_tables;
    } else {
      test->mcep_gamma_1 = _INVALID_REAL;
      test->mcep_gamma_2 = _INVALID_REAL;
    }
  }
  test->number_of_tables = *number_of_tables;
  (*p_test)->test.mcep_deviance = test->mcep_deviance;
  (*p_test)->test.mcep_power = test->mcep_power;
  (*p_test)->test.mcep_pearson = test->mcep_pearson;
  (*p_test)->test.mcep_gamma_1 = test->mcep_gamma_1;
  (*p_test)->test.mcep_gamma_2 = test->mcep_gamma_2;
  (*p_test)->test.number_of_tables = *number_of_tables;
}  /* scale_exact_test */


Static Void trace_exact_test(i, x_deviance, x_power, x_pearson, gamma, test,
			     compute_gamma)
t_long_integer i;
t_long_real *x_deviance, *x_power, *x_pearson, *gamma;
t_test *test;
boolean compute_gamma;
{
  write_char(stdout, ':');
  write_char(stdout, '3');
  write_integer(stdout, i, 12L);
  write_real(stdout, *x_deviance, 12L, 5L);
  write_real(stdout, *x_power, 12L, 5L);
  write_real(stdout, *x_pearson, 12L, 5L);
  write_real(stdout, *gamma, 12L, 5L);
  write_real(stdout, test->mcep_deviance, 12L, 5L);
  write_real(stdout, test->mcep_power, 12L, 5L);
  write_real(stdout, test->mcep_pearson, 12L, 5L);
  write_real(stdout, test->mcep_gamma_1, 12L, 5L);
  write_real(stdout, test->mcep_gamma_2, 12L, 5L);
  write_line(stdout);
}  /* trace_exact_test */


Static Void adjust_exact_test(x_deviance, x_power, x_pearson, gamma, test,
			      compute_gamma)
t_long_real *x_deviance, *x_power, *x_pearson, *gamma;
t_test *test;
boolean compute_gamma;
{
  if (*x_deviance + exact_epsilon >= test->x_deviance)
    test->mcep_deviance++;
  if (!exact_log_l) {
    if (*x_pearson + exact_epsilon >= test->x_pearson)
      test->mcep_pearson++;
    if (*x_power + exact_epsilon >= test->x_power)
      test->mcep_power++;
  }
  if (!compute_gamma)
    return;
  if (fabs(*gamma) + exact_epsilon >= fabs(test->gamma))
    test->mcep_gamma_2++;
  if (test->gamma < 0 && *gamma - exact_epsilon <= test->gamma ||
      test->gamma > 0 && *gamma + exact_epsilon >= test->gamma)
    test->mcep_gamma_1++;
}  /* adjust_exact_test */


/*@+"dexact.p"*/


/*

1805:    +++  ++
1806:    +++  ++
1807:    ---  -- p/dexact.p         11      51     767 p/dexact.p
1808: |    5:    function find_offset_in_formula
1809: |   20:    procedure replace_offset_in_formula
1810: |   36:    procedure compute_mcep_nested_decomposable
1811: |   63:    procedure sub_copy_offsets_from_fact_list
1812: |  105:    procedure copy_offsets_from_fact_list
1813: |  111:    procedure find_marginals_from_random
1814: |  132:    procedure find_factorization_edges
1815: |  204:    procedure print_fact_list
1816: |  248:    procedure generate_decomposable
1817: |  483:    procedure return_random_vector
1818: |  505:    procedure substitute
1819:    +++  ++
1820:    +++  ++

*/

Static t_offset find_offset_in_formula(model, a, ok)
t_model **model;
long *a;
boolean *ok;
{
  t_offset offset = -1;
  t_model *node;

  sub_find_node_in_model(model, a, &node, ok);
  if (*ok) {
    if (node->formula_node->node_type == d_complete_node)
      offset = node->formula_node->UU.d_complete_leaf->offset;
  }
  return offset;
}  /* find_offset_in_formula */


Static Void replace_offset_in_formula(model, a, keep_offset, new_offset)
t_model **model;
long *a;
t_offset *keep_offset, new_offset;
{
  boolean ok;
  t_model *node;

  sub_find_node_in_model(model, a, &node, &ok);
  if (!ok)
    return;
  if (node->formula_node->node_type == d_complete_node) {
    *keep_offset = node->formula_node->UU.d_complete_leaf->offset;
    node->formula_node->UU.d_complete_leaf->offset = new_offset;
  }
}  /* replace_offset_in_formula */


typedef struct t_fact_list {
  t_vertex v, w;
  t_vertex_set a, b, c, d, a_x, b_x;
  t_offset a_x_offset, b_x_offset, a_offset, b_offset, d_offset;
  t_slice_pack slice_pack;
  boolean find_a, find_b;
  struct t_fact_list *pointer;
} t_fact_list;


/* Local variables for compute_mcep_nested_decomposable: */
struct LOC_compute_mcep_nested_decomposable {
  boolean ok;
} ;

Local Void sub_copy_offsets_from_fact_list(model, link_fact_list, LINK)
t_model **model;
t_fact_list **link_fact_list;
struct LOC_compute_mcep_nested_decomposable *LINK;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;
  t_fact_list *q;
  boolean found = false;
  t_offset offset = -1;

  formula = (*model)->formula_node;
  if (formula == NULL)
    return;
  if (formula->node_type == decomposition_node) {
    decomposition_element = formula->UU.decomposition_node_;
    sub_copy_offsets_from_fact_list(&decomposition_element->left_model,
				    link_fact_list, LINK);
    sub_copy_offsets_from_fact_list(&decomposition_element->right_model,
				    link_fact_list, LINK);
    return;
  }
  q = *link_fact_list;
  while (q != NULL && !found) {
    if (P_setequal((*model)->id->vertices, q->d)) {
      found = true;
      offset = q->d_offset;
    }
    q = q->pointer;
  }
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    /* blank case */
    break;

  case d_complete_node:
    formula->UU.d_complete_leaf->offset = offset;
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    /* blank case */
    break;

  case r_ips_node:
    /* blank case */
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    /* blank case */
    break;
  }
}  /* sub_copy_offsets_from_fact_list */

Local Void copy_offsets_from_fact_list(model, link_fact_list, LINK)
t_model **model;
t_fact_list **link_fact_list;
struct LOC_compute_mcep_nested_decomposable *LINK;
{
  sub_copy_offsets_from_fact_list(model, link_fact_list, LINK);
}  /* copy_offsets_from_fact_list */

Local Void find_marginals_from_random(a, g, off_a, off_g, LINK)
long *a, *g;
t_offset *off_a, *off_g;
struct LOC_compute_mcep_nested_decomposable *LINK;
{
  t_cell_index index, m_index;
  t_cell i;
  t_vertex_set c_in_a;
  t_vertex l_a_vertex;
  t_v_arr_of_integer prod_1, prod_2, levels;
  t_cell_index FORLIM;

  memcpy(i, first_cell, sizeof(t_cell));
  FORLIM = *off_a + last_index(a);
  for (m_index = *off_a; m_index <= FORLIM; m_index++)
    n[m_index] = 0;
  find_products(g, a, c_in_a, prod_1, prod_2, levels, &l_a_vertex);
  m_index = *off_a;
  FORLIM = *off_g + last_index(g);
  for (index = *off_g; index <= FORLIM; index++) {
    n[m_index] += n[index];
    next_c_offset_in_a(c_in_a, &m_index, prod_1, prod_2, levels, &l_a_vertex,
		       i);
  }
}  /* find_marginals_from_random */

Local Void find_factorization_edges(current_g_c, base_g_c, link_fact_list, LINK)
t_set_list **current_g_c, **base_g_c;
t_fact_list **link_fact_list;
struct LOC_compute_mcep_nested_decomposable *LINK;
{
  boolean ok;
  t_vertex u1, u2;
  t_vertex_set g, a, am1, am2;
  t_set_list *g_c;
  t_edge_list *link_edge_list = NULL;
  t_edge_list *p, *q;
  t_v_arr_of_v_sets current_adj_set, base_adj_set;
  t_v_arr_of_v_lists base_adj_list;
  t_fact_list *p_link_fact_list;

  *link_fact_list = NULL;
  hypergraph_sets_to_graph_sets(*current_g_c, g, current_adj_set);
  hypergraph_sets_to_graph_sets(*base_g_c, g, base_adj_set);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  adj_set_to_adj_list(base_adj_set, base_adj_list);
  find_edges(base_adj_list, current_adj_set, &link_edge_list);
  p = (t_edge_list *)Malloc(sizeof(t_edge_list));
  if (p == NULL)
    _OutMem();
  p->pointer = link_edge_list;
  link_edge_list = p;
  copy_set_list(*base_g_c, &g_c);
  dispose_adj_list(base_adj_list);
  while (link_edge_list->pointer != NULL) {
    p = link_edge_list;
    q = p->pointer;
    ok = false;
    while (!ok && q != NULL) {
      u1 = q->v;
      u2 = q->w;
      ok = was_edge_in_one_clique(&u1, &u2, &g_c, a);
      if (ok) {
	p->pointer = q->pointer;
	_Free(q);
      } else {
	p = q;
	q = q->pointer;
      }
    }
    P_setcpy(am1, a);
    P_remset(am1, u1);
    P_setcpy(am2, a);
    P_remset(am2, u2);
    insert_clique(am1, &g_c);
    insert_clique(am2, &g_c);
    p_link_fact_list = (t_fact_list *)Malloc(sizeof(t_fact_list));
    if (p_link_fact_list == NULL)
      _OutMem();
    p_link_fact_list->pointer = *link_fact_list;
    *link_fact_list = p_link_fact_list;
    (*link_fact_list)->v = u1;
    (*link_fact_list)->w = u2;
    P_setcpy((*link_fact_list)->a, am2);
    P_setcpy((*link_fact_list)->b, am1);
    P_setcpy((*link_fact_list)->c, am1);
    P_remset((*link_fact_list)->c, u2);
    P_setcpy((*link_fact_list)->d, a);
    (*link_fact_list)->a_offset = -1;
    (*link_fact_list)->find_a = false;
    (*link_fact_list)->a_x_offset = -1;
    (*link_fact_list)->find_b = false;
    (*link_fact_list)->b_offset = -1;
    (*link_fact_list)->b_x_offset = -1;
    P_setcpy((*link_fact_list)->a_x, empty_set);
    (*link_fact_list)->d_offset = -1;
    P_setcpy((*link_fact_list)->b_x, empty_set);
  }
  _Free(link_edge_list);
  dispose_set_list(&g_c);
}  /* find_factorization_edges */

Local Void print_fact_list(link_fact_list, c, w, LINK)
t_fact_list *link_fact_list;
Char *c;
t_long_integer w;
struct LOC_compute_mcep_nested_decomposable *LINK;
{
  t_fact_list *p;
  t_vertex_set vertex_set;

  write_pch(stdout, c, w);
  write_line(stdout);
  p = link_fact_list;
  while (p != NULL) {
    print_vertex_set(p->a);
    write_space(stdout, 6 - cardinality(p->a));
    write_integer(stdout, p->a_offset, 4L);
    if (p->find_a)
      write_pch(stdout, " find a", 7L);
    else
      write_pch(stdout, " a ok  ", 7L);
    print_vertex_set(p->a_x);
    write_space(stdout, 6 - cardinality(p->a_x));
    write_integer(stdout, p->a_x_offset, 4L);
    write_space(stdout, 1L);
    print_vertex_set(p->b);
    write_space(stdout, 6 - cardinality(p->b));
    write_integer(stdout, p->b_offset, 4L);
    if (p->find_b)
      write_pch(stdout, " find b", 7L);
    else
      write_pch(stdout, " b ok  ", 7L);
    print_vertex_set(p->b_x);
    write_space(stdout, 6 - cardinality(p->b_x));
    write_integer(stdout, p->b_x_offset, 4L);
    write_space(stdout, 1L);
    P_addset(P_expset(vertex_set, 0L), p->v);
    P_addset(vertex_set, p->w);
    print_vertex_set(vertex_set);
    write_space(stdout, 1L);
    print_vertex_set(p->d);
    write_space(stdout, 6 - cardinality(p->d));
    write_integer(stdout, p->d_offset, 4L);
    write_line(stdout);
    p = p->pointer;
  }
}  /* print_fact_list */

Local Void generate_decomposable(number_of_tables, current_model, base_model,
  m2_offset, return_table, compute_statistics, test, link_fact_list,
  x_deviance, x_power, x_pearson, gamma, LINK)
t_long_integer *number_of_tables;
t_model **current_model, **base_model;
t_offset *m2_offset;
boolean return_table, compute_statistics;
t_test *test;
t_fact_list **link_fact_list;
t_long_real *x_deviance, *x_power, *x_pearson, *gamma;
struct LOC_compute_mcep_nested_decomposable *LINK;
{
  t_long_integer i = 1;
  t_fact_list *p;

  set_exact_test(test, 0L);
  while (i <= *number_of_tables && !interrupt_1) {
    if (compute_statistics) {
      *gamma = 0.0;
      *x_deviance = 0.0;
      *x_power = 0.0;
      *x_pearson = 0.0;
    }
    p = *link_fact_list;
    while (p != NULL) {
      if (p->find_a)
	find_marginals_from_random(p->a, p->a_x, &p->a_offset, &p->a_x_offset,
				   LINK);
      if (p->find_b)
	find_marginals_from_random(p->b, p->b_x, &p->b_offset, &p->b_x_offset,
				   LINK);
      patefield_as_159_in_n(
	&variable_description[p->v - MIN_VERTEX]->UU.U0.levels,
	&variable_description[p->w - MIN_VERTEX]->UU.U0.levels, &p->a_offset,
	&p->b_offset, &p->d_offset, &p->slice_pack, true, compute_statistics,
	false, x_deviance, x_power, x_pearson, gamma);
      p = p->pointer;
    }
    if (!return_table) {
      if (compute_statistics) {
	*x_deviance = 2 * *x_deviance;
	*x_power = 2 * *x_power;
	*x_power /= lambda * (lambda + 1);
      } else if (exact_log_l)
	*x_deviance = compute_decomposable_log_l(base_model, &LINK->ok);
      else
	compute_x_deviance_and_x_pearson_g_offset(current_model, base_model,
	  (*base_model)->id->vertices, *m2_offset, x_deviance, x_pearson,
	  x_power);
      adjust_exact_test(x_deviance, x_power, x_pearson, gamma, test, false);
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1816L, 1L))
	trace_exact_test(i, x_deviance, x_power, x_pearson, gamma, test,
			 false);
      /*$endif TRACE*/
      monitor_note_exact("Exact test", 10L,
			 (long)floor(*x_deviance + 0.5), i,
			 *number_of_tables);
    }
    i++;
  }
  if (interrupt_1) {
    *number_of_tables = i - 1;
    interrupt_1 = false;
  }
}  /* generate_decomposable */


Static Void compute_mcep_nested_decomposable(current_model, base_model,
					     return_table, p_test, test)
t_model **current_model, **base_model;
boolean return_table;
t_test_list **p_test;
t_test *test;
{
  struct LOC_compute_mcep_nested_decomposable Local_Var;
  t_long_real base_model_log_l, gamma, x_deviance, x_power, x_pearson;
  t_offset m2_offset, dummy_offset, tmp_fna;
  t_long_integer n_of_tables;
  t_vertex_set dummy_set;
  t_fact_list *p, *q, *link_fact_list;
  t_offset_list *p_offsets = NULL;
  t_offset ab_offset;
  boolean ok_small, compute_statistics;

  Local_Var.ok = true;
  find_factorization_edges(&(*current_model)->id->UU.g_c_log_linear,
			   &(*base_model)->id->UU.g_c_log_linear,
			   &link_fact_list, &Local_Var);
  if (link_fact_list == NULL) {
    set_exact_test(&(*p_test)->test, -3L);
    set_exact_test(test, -2L);
    return;
  }
  p = link_fact_list;
  while (p != NULL && Local_Var.ok) {
    p->find_a = false;
    p->find_b = false;
    q = link_fact_list;
    while (q != p && !(p->find_a && p->find_b)) {
      if (P_subset(p->a, q->d) && (!P_subset(p->a, q->a) || q->find_a) &&
	  (!P_subset(p->a, q->b) || q->find_b))
	p->find_a = true;
      if (P_subset(p->b, q->d) && (!P_subset(p->b, q->a) || q->find_a) &&
	  (!P_subset(p->b, q->b) || q->find_b))
	p->find_b = true;
      q = q->pointer;
    }
    if (!p->find_a)
      p->a_offset = return_offset(p->a, &Local_Var.ok);
    if (!p->find_b)
      p->b_offset = return_offset(p->b, &Local_Var.ok);
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1810L, 1L))
    print_fact_list(link_fact_list, " After a/b offset   ", 20L, &Local_Var);
  /*$endif TRACE*/
  tmp_fna = fna;
  p = link_fact_list;
  if (return_table && Local_Var.ok) {
    Local_Var.ok = return_from_offset_from_list((*base_model)->id->vertices,
	&m2_offset, dummy_set, &dummy_offset, &tmp_fna, &p_offsets);
    Local_Var.ok = true;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1810L, 1L)) {
    write_pch(stdout, " M2-offset          ", 20L);
    print_vertex_set((*base_model)->id->vertices);
    write_integer(stdout, m2_offset, 12L);
    print_vertex_set(dummy_set);
    write_integer(stdout, dummy_offset, 12L);
    write_integer(stdout, tmp_fna, 12L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  while (p != NULL && Local_Var.ok) {
    if (p->find_a) {
      p->find_a = !return_from_offset_from_list(p->a, &ab_offset, dummy_set,
	  &dummy_offset, &tmp_fna, &p_offsets);
      p->a_offset = ab_offset;
      P_setcpy(p->a_x, dummy_set);
      p->a_x_offset = dummy_offset;
    }
    if (p->find_b) {
      p->find_b = !return_from_offset_from_list(p->b, &ab_offset, dummy_set,
	  &dummy_offset, &tmp_fna, &p_offsets);
      p->b_offset = ab_offset;
      P_setcpy(p->b_x, dummy_set);
      p->b_x_offset = dummy_offset;
    }
    if (return_table && P_setequal(p->d, (*base_model)->id->vertices))
      p->d_offset = m2_offset;
    else {
      insert_offset(p->d, tmp_fna, &p_offsets);
      p->d_offset = tmp_fna;
      tmp_fna += marginal_dimension(p->d);
    }
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1810L, 1L))
    print_fact_list(link_fact_list, " After d offset etc.", 20L, &Local_Var);
  /*$endif TRACE*/
  if (Local_Var.ok && !TURBO_PC)
    Local_Var.ok = space_in_n_array(tmp_fna, 0L);
  if (Local_Var.ok && tmp_fna <= max_cell_number) {
    ok_small = return_from_offset_from_list((*base_model)->id->vertices,
	&m2_offset, dummy_set, &dummy_offset, &tmp_fna, &p_offsets);
    compute_statistics = (fast || large || !ok_small);
    base_model_log_l = 0.0;
    if (exact_log_l && !compute_statistics) {
      base_model_log_l = test->x_deviance;
      test->x_deviance = compute_decomposable_log_l(base_model, &Local_Var.ok);
      gamma = _INVALID_REAL;
      x_power = _INVALID_REAL;
      x_pearson = _INVALID_REAL;
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1810L, 1L)) {
      write_pch(stdout, " M2-offset          ", 20L);
      print_vertex_set((*base_model)->id->vertices);
      write_integer(stdout, m2_offset, 12L);
      print_vertex_set(dummy_set);
      write_integer(stdout, dummy_offset, 12L);
      write_integer(stdout, tmp_fna, 12L);
      write_line(stdout);
      trace_exact_test(0L, &x_deviance, &x_power, &x_pearson, &gamma, test,
		       false);
      write_integer(stdout, 0L, 12L);
      write_real(stdout, base_model_log_l, 12L, 5L);
      write_line(stdout);
      if (ok_small)
	write_pch(stdout, " Ok       ", 10L);
      else
	write_pch(stdout, " Not Ok   ", 10L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    copy_offsets_from_fact_list(base_model, &link_fact_list, &Local_Var);
    p = link_fact_list;
    while (p != NULL) {
      find_slice_products(p->c, p->a, p->b, p->d, &p->v, &p->w,
			  &p->slice_pack);
      p = p->pointer;
    }
    if (return_table)
      n_of_tables = 1;
    else if (number_of_tables > 0)
      n_of_tables = number_of_tables;
    else {
      n_of_tables = init_n_of_tables;
      generate_decomposable(&n_of_tables, current_model, base_model,
			    &m2_offset, return_table, compute_statistics,
			    test, &link_fact_list, &x_deviance, &x_power,
			    &x_pearson, &gamma, &Local_Var);
      n_of_tables = set_n_of_tables(test, false, &n_of_tables);
    }
    generate_decomposable(&n_of_tables, current_model, base_model, &m2_offset,
			  return_table, compute_statistics, test,
			  &link_fact_list, &x_deviance, &x_power, &x_pearson,
			  &gamma, &Local_Var);
    if (exact_log_l && !compute_statistics)
      test->x_deviance = base_model_log_l;
    if (!return_table)
      dispose_formula(base_model);
    scale_exact_test(test, p_test, &n_of_tables, false);
  } else {
    write_line(stdout);
    write_pch(stdout, " ExactTest:", 11L);
    write_out_of_space((*current_model)->id->UU.g_c_log_linear,
		       (*base_model)->id->UU.g_c_log_linear, "-",
		       &global_write_options, &global_test_labels, 0L);
  }
  while (link_fact_list != NULL) {
    p = link_fact_list;
    link_fact_list = link_fact_list->pointer;
    _Free(p);
  }
  dispose_offset_list(&p_offsets);
}  /* compute_mcep_nested_decomposable */


Static Void return_random_vector(current_model, a, offset, ok)
t_model **current_model;
long *a;
t_offset *offset;
boolean *ok;
{
  t_model *tmp_model;
  t_test_list *p_test;
  t_test test;

  p_test = (t_test_list *)Malloc(sizeof(t_test_list));
  if (p_test == NULL)
    _OutMem();
  new_model(&tmp_model);
  erase_model(&tmp_model, pure_discrete, true);
  P_setcpy(tmp_model->id->vertices, a);
  insert_set_in_set_list(a, &tmp_model->id->UU.g_c_log_linear);
  *ok = ok_model_fit_values(&tmp_model);
  compute_mcep_nested_decomposable(current_model, &tmp_model, true, &p_test,
				   &test);
  *offset = find_offset_in_formula(current_model, a, ok);
  dispose_model_and_link(&tmp_model);
  _Free(p_test);
}  /* return_random_vector */


Static Void substitute(current_model, ok)
t_model **current_model;
boolean *ok;
{
  t_offset i, offset, FORLIM;

  return_random_vector(current_model, delta, &offset, ok);
  FORLIM = last_index(delta);
  for (i = FIRST_INDEX; i <= FORLIM; i++)
    n[i] = n[i + offset];
}  /* substitute */


/* Local variables for compute_mcep_one_edge_set_old: */
struct LOC_compute_mcep_one_edge_set_old {
  boolean ok;
} ;

Local Void generate_one_edge_old(number_of_tables, c, bv, bw, v, w, a_model,
  b_model, test, compute_gamma, vc_offset, wc_offset, vwc_offset, slice_pack,
  x_deviance, x_power, x_pearson, gamma, LINK)
t_long_integer *number_of_tables;
long *c, *bv, *bw;
t_vertex *v, *w;
t_model **a_model, **b_model;
t_test *test;
boolean *compute_gamma;
t_offset *vc_offset, *wc_offset, *vwc_offset;
t_slice_pack *slice_pack;
t_long_real *x_deviance, *x_power, *x_pearson, *gamma;
struct LOC_compute_mcep_one_edge_set_old *LINK;
{
  t_long_integer i = 1;
  t_vertex_set b;
  t_long_real s, s1;

  set_exact_test(test, 0L);
  P_setint(b, bv, bw);
  while (i <= *number_of_tables && !interrupt_1) {
    if (fast) {
      *x_deviance = 0.0;
      *x_power = 0.0;
      *x_pearson = 0.0;
      *gamma = 0.0;
    }
    patefield_as_159_in_n(&variable_description[*v - MIN_VERTEX]->UU.U0.levels,
      &variable_description[*w - MIN_VERTEX]->UU.U0.levels, vc_offset,
      wc_offset, vwc_offset, slice_pack, !fast || boolean_option[104], fast,
      *compute_gamma, x_deviance, x_power, x_pearson, gamma);
    if (fast) {
      *x_deviance = 2 * *x_deviance;
      *x_power = 2 * *x_power;
      *x_power /= lambda * (lambda + 1);
    } else if (exact_log_l)
      *x_deviance = compute_decomposable_log_l(b_model, &LINK->ok);
    else {
      compute_x_deviance_and_x_pearson_g_offset(a_model, b_model, c,
	*vwc_offset, x_deviance, x_pearson, x_power);
      if (*compute_gamma)
	compute_slice_statistics(v, w,
	  &variable_description[*v - MIN_VERTEX]->UU.U0.levels,
	  &variable_description[*w - MIN_VERTEX]->UU.U0.levels, b, *vc_offset,
	  *wc_offset, *vwc_offset, slice_pack, gamma, &s, &s1, false);
    }
    adjust_exact_test(x_deviance, x_power, x_pearson, gamma, test,
		      *compute_gamma);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1825L, 1L))
      trace_exact_test(i, x_deviance, x_power, x_pearson, gamma, test,
		       *compute_gamma);
    /*$endif TRACE*/
    monitor_note_exact("Exact test", 10L,
		       (long)floor(*x_deviance + 0.5), i, *number_of_tables);
    i++;
  }
  if (interrupt_1) {
    *number_of_tables = i - 1;
    interrupt_1 = false;
  }
}  /* generate_one_edge_old */


/*@+"exact.p"*/


/*

1821:    +++  ++
1822:    +++  ++
1823:    ---  -- p/exact.p          7      30     411 p/exact.p
1824: |    4:    procedure compute_mcep_one_edge_set_old
1825: |   17:    procedure generate_one_edge_old
1826: |  133:    procedure compute_mcep_one_edge_set
1827: |  145:    procedure generate_one_edge_new
1828: |  218:    procedure compute_mcep_one_edge
1829: |  306:    procedure test_exact_test_g_c
1830: |  373:    procedure test_exact_test
1831:    +++  ++
1832:    +++  ++

*/

Static Void compute_mcep_one_edge_set_old(c, bv, bw, v, w, a_model, b_model,
					  p_test, test)
long *c, *bv, *bw;
t_vertex *v, *w;
t_model **a_model, **b_model;
t_test_list **p_test;
t_test *test;
{
  struct LOC_compute_mcep_one_edge_set_old Local_Var;
  t_long_real tmp_x_deviance, gamma, x_deviance, x_power, x_pearson;
  t_long_integer n_of_tables;
  t_offset vc_offset, wc_offset, vwc_offset, tmp_offset;
  boolean compute_gamma = true;
  t_slice_pack slice_pack;
  t_vertex_set b;

  vc_offset = return_offset(bv, &Local_Var.ok);
  wc_offset = return_offset(bw, &Local_Var.ok);
  if (Local_Var.ok && !TURBO_PC)
    Local_Var.ok = space_in_n_array(marginal_dimension(c), fna);
  if (Local_Var.ok & (marginal_dimension(c) <= max_cell_number - fna)) {
    if (exact_log_l && !fast) {
      tmp_x_deviance = test->x_deviance;
      test->x_deviance = compute_decomposable_log_l(b_model, &Local_Var.ok);
      x_pearson = _INVALID_REAL;
      x_power = _INVALID_REAL;
      gamma = _INVALID_REAL;
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 1824L, 1L)) {
	/*$endif TRACE*/
	trace_exact_test(-1L, &test->x_deviance, &x_power, &x_pearson, &gamma,
			 test, compute_gamma);
      }
    }
    vwc_offset = fna;
    replace_offset_in_formula(b_model, c, &tmp_offset, fna);
    compute_gamma = (ordinal_tests && !(em || incomplete_table)) & P_inset(*v,
		      ordinal_factors) & P_inset(*w, ordinal_factors);
    P_setint(b, bv, bw);
    find_slice_products(b, bv, bw, c, v, w, &slice_pack);
    if (number_of_tables > 0)
      n_of_tables = number_of_tables;
    else {
      n_of_tables = init_n_of_tables;
      generate_one_edge_old(&n_of_tables, c, bv, bw, v, w, a_model, b_model,
			    test, &compute_gamma, &vc_offset, &wc_offset,
			    &vwc_offset, &slice_pack, &x_deviance, &x_power,
			    &x_pearson, &gamma, &Local_Var);
      n_of_tables = set_n_of_tables(test, compute_gamma, &n_of_tables);
    }
    generate_one_edge_old(&n_of_tables, c, bv, bw, v, w, a_model, b_model,
			  test, &compute_gamma, &vc_offset, &wc_offset,
			  &vwc_offset, &slice_pack, &x_deviance, &x_power,
			  &x_pearson, &gamma, &Local_Var);
    scale_exact_test(test, p_test, &n_of_tables, compute_gamma);
    if (exact_log_l && !fast)
      test->x_deviance = tmp_x_deviance;
    replace_offset_in_formula(b_model, c, &tmp_offset, tmp_offset);
    return;
  }
  write_line(stdout);
  write_pch(stdout, " ExactTest:", 11L);
  write_out_of_space((*a_model)->id->UU.g_c_log_linear,
		     (*b_model)->id->UU.g_c_log_linear, "-",
		     &global_write_options, &global_test_labels, 0L);
}  /* compute_mcep_one_edge_set_old */


Local Void generate_one_edge_new(number_of_tables, v, w, test, compute_gamma,
				 vc_offset, wc_offset, vwc_offset, slice_pack,
				 x_deviance, x_power, x_pearson, gamma)
t_long_integer *number_of_tables;
t_vertex *v, *w;
t_test *test;
boolean *compute_gamma;
t_offset *vc_offset, *wc_offset, *vwc_offset;
t_slice_pack *slice_pack;
t_long_real *x_deviance, *x_power, *x_pearson, *gamma;
{
  t_long_integer i = 1;

  set_exact_test(test, 0L);
  while (i <= *number_of_tables && !interrupt_1) {
    *x_deviance = 0.0;
    *x_power = 0.0;
    *x_pearson = 0.0;
    *gamma = 0.0;
    patefield_as_159_in_n(&variable_description[*v - MIN_VERTEX]->UU.U0.levels,
      &variable_description[*w - MIN_VERTEX]->UU.U0.levels, vc_offset,
      wc_offset, vwc_offset, slice_pack, false, true, *compute_gamma,
      x_deviance, x_power, x_pearson, gamma);
    *x_deviance = 2 * *x_deviance;
    *x_power = 2 * *x_power;
    *x_power /= lambda * (lambda + 1);
    adjust_exact_test(x_deviance, x_power, x_pearson, gamma, test,
		      *compute_gamma);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1827L, 1L))
      trace_exact_test(i, x_deviance, x_power, x_pearson, gamma, test,
		       *compute_gamma);
    /*$endif TRACE*/
    i++;
  }
  if (interrupt_1) {
    *number_of_tables = i - 1;
    interrupt_1 = false;
  }
}  /* generate_one_edge_new */


Static Void compute_mcep_one_edge_set(c, bv, bw, v, w, p_test, test)
long *c, *bv, *bw;
t_vertex *v, *w;
t_test_list **p_test;
t_test *test;
{
  t_long_real gamma, x_deviance, x_power, x_pearson;
  t_long_integer n_of_tables;
  t_offset vc_offset, wc_offset, vwc_offset;
  boolean compute_gamma, ok;
  t_slice_pack slice_pack;
  t_vertex_set b;

  vc_offset = return_offset(bv, &ok);
  wc_offset = return_offset(bw, &ok);
  if (ok && !TURBO_PC)
    ok = space_in_n_array(marginal_dimension(c), fna);
  if (ok & (marginal_dimension(c) <= max_cell_number - fna)) {
    vwc_offset = fna;
    compute_gamma = (ordinal_tests && !(em || incomplete_table)) & P_inset(*v,
		      ordinal_factors) & P_inset(*w, ordinal_factors);
    P_setint(b, bv, bw);
    find_slice_products(b, bv, bw, c, v, w, &slice_pack);
    if (number_of_tables > 0)
      n_of_tables = number_of_tables;
    else {
      n_of_tables = init_n_of_tables;
      generate_one_edge_new(&n_of_tables, v, w, test, &compute_gamma,
			    &vc_offset, &wc_offset, &vwc_offset, &slice_pack,
			    &x_deviance, &x_power, &x_pearson, &gamma);
      n_of_tables = set_n_of_tables(test, compute_gamma, &n_of_tables);
    }
    generate_one_edge_new(&n_of_tables, v, w, test, &compute_gamma,
			  &vc_offset, &wc_offset, &vwc_offset, &slice_pack,
			  &x_deviance, &x_power, &x_pearson, &gamma);
    scale_exact_test(test, p_test, &n_of_tables, compute_gamma);
    return;
  }
  write_line(stdout);
  write_pch(stdout, " ExactTest:", 11L);
  write_out_of_space(NULL, NULL, " One Edge ", &global_write_options,
		     &global_test_labels, 0L);
}  /* compute_mcep_one_edge_set */


Static Void compute_mcep_one_edge(adj_set, v, w, p_test, test)
t_vertex_set *adj_set;
t_vertex *v, *w;
t_test_list **p_test;
t_test *test;
{
  t_set_list *tmp_cs = NULL;
  t_vertex u;
  t_vertex_set a, b, bv, bw, c;
  t_model *a_model, *b_model;
  boolean ok = true;

  /* CausalStructure !!! */
  P_addset(P_expset(a, 0L), *v);
  P_addset(a, *w);
  P_setcpy(b, empty_set);
  for (u = first_vertex; u <= last_vertex; u++) {
    if (P_subset(a, adj_set[u - MIN_VERTEX]))
      P_addset(b, u);
  }
  P_setcpy(bv, b);
  P_addset(bv, *v);
  P_setcpy(bw, b);
  P_addset(bw, *w);
  P_setunion(c, a, b);
  if (fast && boolean_option[103]) {
    compute_mcep_one_edge_set(c, bv, bw, v, w, p_test, test);
    return;
  }
  if (incomplete_table) {
    write_pch(stdout, " *** warning ***  oneedgecollaps used on", 40L);
    write_pch(stdout, " incomplete table  *** warning ***", 34L);
    write_line(stdout);
  }

  new_model(&a_model);
  erase_model(&a_model, pure_discrete, true);
  insert_set_in_set_list(bv, &a_model->id->UU.g_c_log_linear);
  insert_set_in_set_list(bw, &a_model->id->UU.g_c_log_linear);
  P_setcpy(a_model->id->vertices, c);

  new_model(&b_model);
  erase_model(&b_model, pure_discrete, true);
  insert_set_in_set_list(c, &b_model->id->UU.g_c_log_linear);
  P_setcpy(b_model->id->vertices, c);

  P_setdiff(a, delta, c);
  a_model->constant = 1 / marginal_dimension_real(a);
  b_model->constant = a_model->constant;

  find_formula_for_two_set_model(a_model, bv, bw, &tmp_cs, false,
				 pure_discrete);

  find_formula_for_one_set_model(b_model, c, &tmp_cs, false, pure_discrete);

  if (global_write_options->write_test && !global_write_options->line_form) {
    write_pch(stdout, " collaps onto ", 14L);
    print_vertex_set(c);
    write_line(stdout);
  }
  print_do_exclude(c, &global_write_options, &global_test_labels);
      /* ok ? */
  if (datastructure == all)
    test_expression_marginals(&a_model, &b_model, c, &ok);
  else {
    if (!fast) {
      if (exact_log_l)
	find_decomposable_offsets_and_marginals(&b_model, &ok);
      else {
	find_decomposable_offsets_and_marginals(&a_model, &ok);
	find_decomposable_offsets_and_marginals(&b_model, &ok);
      }
    }
  }
  compute_mcep_one_edge_set_old(c, bv, bw, v, w, &a_model, &b_model, p_test,
				test);
  dispose_marginals_cond();

  /* *** Alternative: Why not use DisposeModel, e.i. keep ..^.id ? *** */
  /* dispose_set_list(a_model^.id^.g_c_log_linear);
  dispose_formula(a_model); */
  /* *** Alternative: End. *** */
  dispose_model_and_link(&a_model);

  /* *** ToDo: Why not use DisposeModel, e.i. keep ..^.id ? *** */
  /* dispose_set_list(b_model^.id^.g_c_log_linear);
  dispose_formula(b_model); */
  /* *** ToDo: End. *** */
  dispose_model_and_link(&b_model);
}  /* compute_mcep_one_edge */


Static Void test_exact_test_g_c(current_g_c, base_g_c, p_test, test)
t_set_list **current_g_c, **base_g_c;
t_test_list **p_test;
t_test *test;
{
  boolean ok;
  t_vertex_set g;
  t_edge_list *link_edge_list = NULL;
  t_edge_list *p;
  t_v_arr_of_v_sets current_adj_set, base_adj_set;
  t_v_arr_of_v_lists base_adj_list;
  t_model *current_model, *base_model;
  t_vertex v, w;

  if (select_asymptotic_p_value(*p_test) >= asymptotic_limit)
    return;
  hypergraph_sets_to_graph_sets(*current_g_c, g, current_adj_set);
  if (!P_subset(g, delta))
    return;
  hypergraph_sets_to_graph_sets(*base_g_c, g, base_adj_set);
  adj_set_to_adj_list(base_adj_set, base_adj_list);
  find_edges(base_adj_list, current_adj_set, &link_edge_list);
  dispose_adj_list(base_adj_list);
  if (link_edge_list == NULL) {
    set_exact_test(test, 1L);
    return;
  }
  if (link_edge_list->pointer == NULL) {
    v = link_edge_list->v;
    w = link_edge_list->w;
    compute_mcep_one_edge(current_adj_set, &v, &w, p_test, &(*p_test)->test);
  } else {
    new_model(&current_model);
    erase_model(&current_model, pure_discrete, true);
    current_model->id->UU.g_c_log_linear = *current_g_c;
    new_model(&base_model);
    erase_model(&base_model, pure_discrete, true);
    base_model->id->UU.g_c_log_linear = *base_g_c;
    ok = ok_model_fit_values(&current_model);
    dispose_marginals_cond();
    ok &= ok_model_fit_values(&base_model);
    dispose_marginals_cond();
    if (ok) {
      if (current_model->graphical && current_model->decomposable &&
	  base_model->graphical && base_model->decomposable)
	compute_mcep_nested_decomposable(&current_model, &base_model, false,
					 p_test, &(*p_test)->test);
    }
    /* *** Alternative: DisposeModelButGC *** */
    base_model->id->UU.g_c_log_linear = NULL;
    dispose_model_and_link(&base_model);
    current_model->id->UU.g_c_log_linear = NULL;
    dispose_model_and_link(&current_model);
    /* *** Alternative: End. *** */
  }
  while (link_edge_list != NULL) {
    p = link_edge_list;
    link_edge_list = link_edge_list->pointer;
    _Free(p);
  }
  test->number_of_tables = (*p_test)->test.number_of_tables;
  test->mcep_deviance = (*p_test)->test.mcep_deviance;
  test->mcep_power = (*p_test)->test.mcep_power;
  test->mcep_pearson = (*p_test)->test.mcep_pearson;
  test->mcep_gamma_1 = (*p_test)->test.mcep_gamma_1;
  test->mcep_gamma_2 = (*p_test)->test.mcep_gamma_2;
}  /* test_exact_test_g_c */


Static Void test_exact_test_id(current_model, base_model, p_test, test)
t_model_specification **current_model, **base_model;
t_test_list **p_test;
t_test *test;
{
  if ((*current_model)->model_type == pure_discrete)
    test_exact_test_g_c(&(*current_model)->UU.g_c_log_linear,
			&(*base_model)->UU.g_c_log_linear, p_test, test);
}  /* test_exact_test_id */


Static Void test_exact_test(current_model, base_model, p_test, test)
t_model **current_model, **base_model;
t_test_list **p_test;
t_test *test;
{
  if ((*current_model)->graphical && (*current_model)->decomposable &&
      (*base_model)->graphical && (*base_model)->decomposable &&
      (*current_model)->id->model_type == pure_discrete)
    test_exact_test_g_c(&(*current_model)->id->UU.g_c_log_linear,
			&(*base_model)->id->UU.g_c_log_linear, p_test, test);
}  /* test_exact_test */


/*@-"test.c"*/
/*@+"wtest.p"*/


/*

1833:    +++  ++
1834:    +++  ++
1835:    ---  -- p/wtest.p         11      57     613 p/wtest.p
1836: |    3:    function find_exact_df
1837: |   40:    procedure write_test_on_dump_file
1838: |  121:    procedure sub_write_test_line
1839: |  325:    procedure sub_write_test_table
1840: |  539:    procedure sub_write_test
1841: |  562:    function b01
1842: |  570:    procedure write_test
1843: |  601:    - procedure write_test
1844: |  617:    procedure _search_write_test
1845: |  647:    procedure search_write_test
1846: |  672:    procedure write_sorted_list
1847:    +++  ++
1848:    +++  ++

*/


Static boolean test_ok(ifail)
t_long_integer ifail;
{
  boolean Result = true;
  t_long_integer i, j;

  if (ifail <= 0)
    return true;
  while (ifail > 0) {
    j = (long)floor(ifail / 1000.0 + 0.5);
    i = ifail - j * 1000;
    ifail = j;
    if (boolean_option[22] && 0 < i && i < 4)
      Result = false;
    if (!boolean_option[23] && 3 < i && i < 7)
      Result = false;
    if (!boolean_option[24] && 4 < i && i < 10)
      Result = false;
    if (!boolean_option[25] && i == 10)
      Result = false;
    if (!boolean_option[26] && i == 11)
      Result = false;
    if (!boolean_option[27] && 12 <= i && i < 20)
      Result = false;
    if (!boolean_option[28] && 20 <= i && i < 40)
      Result = false;
    if (!boolean_option[29] && 40 <= i && i < 99)
      Result = false;
  }
  return Result;
}  /* test_ok */


Static t_long_real find_exact_df(n, df, q, p)
t_long_integer n, df;
t_long_real q, p;
{
  t_long_integer l, m, u;

  if (n > 0) {
    if (p < 1.0 / n)
      p = 0.5 / n;
    else if (p > 1 - 1.0 / n)
      p = 1 - 0.5 / n;
    if (p < 1 - khi(df, q)) {
      l = df;
      u = l * 2;
      while (p < 1 - khi(u, q) && u * 2 < _INFINITY) {
	l = u;
	u = l * 2;
      }
    } else {
      u = df;
      l = u / 2;
      while (p > 1 - khi(l, q) && 1 < l) {
	u = l;
	l = u / 2;
      }
    }
    m = -1;
    while (1 < u - l) {
      m = (l + u) / 2;
      if (p > 1 - khi(m, q))
	u = m;
      else
	l = m;
    }
    return (l + (p - 1 + khi(l, q)) * (u - l) / (khi(l, q) - khi(u, q)));
  } else
    return _INVALID;
}  /* find_exact_df */


Static Void write_test_on_dump_file(test)
t_test *test;
{
  /* ;
                                        reuse : boolean*/
  t_long_integer df_adj;

  if (!(test->in_eh | test->ok | (!is_invalid_real(test->x_deviance))))
    return;
  if (adj_df && test->adj != _INFINITY)
    df_adj = test->df - test->adj;
  else
    df_adj = test->df;
  if (test->df == _INFINITY)
    write_dump_real(test->df_real, labs(print_width) + 5, 0L);
  else
    write_dump_integer(test->df, labs(print_width) + 5);
  write_dump_cond_integer(adj_df && test->adj != _INFINITY, test->adj,
			  print_width);
  write_dump_cond_integer(adj_df && test->adj != _INFINITY, df_adj,
			  print_width);
  write_dump_cond_integer(exact_test && test->mcep_deviance > -1,
			  test->number_of_tables, width);
  write_dump_real(test->x_deviance, print_width, print_dec);
  write_dump_integer(test->test_ifail, print_width);
  if (is_invalid_real(test->x_deviance) ||
      test->x_deviance < -mips_log_l_round_error) {
    if (test_ok(test->test_ifail))
      write_dump_char('?');
    else
      write_dump_char('%');
  } else
    write_dump_char(' ');
  write_dump_real(khi(test->df, test->x_deviance), print_width, print_dec);
  write_dump_cond_real(adj_df && test->adj != _INFINITY,
		       khi(df_adj, test->x_deviance), print_width, print_dec);
  test->ok = (exact_test && test->mcep_deviance > -1);
  write_dump_cond_real(test->ok, test->mcep_deviance, print_width, print_dec);
  write_dump_cond_real(test->ok,
    find_exact_df(test->number_of_tables, test->df, test->x_deviance,
		  test->mcep_deviance), print_width, print_dec);
  if (lambda != 1) {
    write_dump_real(test->x_power, print_width, print_dec);
    write_dump_real(khi(test->df, test->x_power), print_width, print_dec);
    write_dump_cond_real(adj_df && test->adj != _INFINITY,
			 khi(df_adj, test->x_power), print_width, print_dec);
    test->ok = (exact_test && test->mcep_power > -1);
    write_dump_cond_real(test->ok, test->mcep_power, print_width, print_dec);
    write_dump_cond_real(test->ok,
      find_exact_df(test->number_of_tables, test->df, test->x_power,
		    test->mcep_power), print_width, print_dec);
  }
  write_dump_real(test->x_pearson, print_width, print_dec);
  write_dump_real(khi(test->df, test->x_pearson), print_width, print_dec);
  write_dump_cond_real(adj_df && test->adj != _INFINITY,
		       khi(df_adj, test->x_pearson), print_width, print_dec);
  test->ok = (exact_test && test->mcep_pearson > -1);
  write_dump_cond_real(test->ok, test->mcep_pearson, print_width, print_dec);
  write_dump_cond_real(test->ok,
    find_exact_df(test->number_of_tables, test->df, test->x_pearson,
		  test->mcep_pearson), print_width, print_dec);
  if (ordinal_tests & (!is_invalid_real(test->gamma))) {
    write_dump_real(test->gamma, print_width, print_dec);
    if (test->s > 0)
      write_dump_real(2 * pnormal(fabs(test->gamma / sqrt(test->s))),
		      print_width, print_dec);
    else
      write_dump_real(_INVALID_REAL, print_width, print_dec);
    if (exact_test && test->mcep_gamma_1 > -1) {
      write_dump_real(test->mcep_gamma_1, print_width, print_dec);
      write_dump_real(test->mcep_gamma_2, print_width, print_dec);
    }
    if (test->s > 0)
      write_dump_real(sqrt(test->s), print_width, print_dec);
    else
      write_dump_real(_INVALID_REAL, print_width, print_dec);
    if (test->s1 > 0)
      write_dump_real(sqrt(test->s1), print_width, print_dec);
    else
      write_dump_real(_INVALID_REAL, print_width, print_dec);
    if (exact_test && test->mcep_gamma_1 > -1) {
      write_space(stdout, labs(print_width) - 8);
      write_space(stdout, labs(print_width) - 8);
    }
  }
  write_line_text(dump_file);
  flush_file(&dump_file);
}  /* write_test_on_dump_file */


Static Void sub_write_test_line(test, write_options, test_labels, indent_1,
				indent_2)
t_test *test;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_long_integer *indent_1, *indent_2;
{
  t_long_integer stop, df_adj;
  t_long_real f, statistic;

  if (adj_df && test->adj != _INFINITY)
    df_adj = test->df - test->adj;
  else
    df_adj = test->df;
  if (long_names && (*write_options)->write_models) {
    write_line(stdout);
    if ((*test_labels)->short_report)
      write_space(stdout, 3L);
    write_space(stdout, 7L);
  }
  write_char(stdout, ' ');
  if (test->df == _INFINITY)
    write_real(stdout, test->df_real, x_width, 0L);
  else if (true)
    write_integer(stdout, df_adj, x_width);
  else
    write_integer(stdout, df_adj, 4L);
  write_char(stdout, ' ');
  if (adj_df) {
    write_integer(stdout, test->adj, 4L);
    write_char(stdout, ' ');
  }
  if (mixed_data) {
    if (test->f_test_df == _INFINITY)
      write_space(stdout, 4L);
    else
      write_integer(stdout, test->n_count - test->f_test_df, 4L);
    write_char(stdout, ' ');
  }
  if (test_ok(test->test_ifail)) {
    write_real(stdout, test->x_deviance, x_width, x_dec);
    write_char(stdout, ' ');
    write_real(stdout, khi(df_adj, test->x_deviance), prob_width, prob_dec);
    write_char(stdout, ' ');
  } else {
    write_real(stdout, _INVALID_REAL, x_width, x_dec);
    write_char(stdout, ' ');
    write_real(stdout, _INVALID_REAL, x_width, x_dec);
    write_char(stdout, ' ');
  }
  if (lambda != 1) {
    write_real(stdout, test->x_power, x_width, x_dec);
    write_char(stdout, ' ');
    write_real(stdout, khi(df_adj, test->x_power), prob_width, prob_dec);
    write_char(stdout, ' ');
  }
  if (mixed_data & is_invalid_real(test->x_pearson)) {
    if ((test->f_test_df == _INFINITY) | (!test_ok(test->test_ifail)))
      write_space(stdout, x_width + prob_width + 2);
    else {
      f = deviance_to_f_value(test->df, test->n_count, test->f_test_df,
			      test->x_deviance);
      write_real(stdout, f, x_width, x_dec);
      write_char(stdout, ' ');
      if (is_invalid_real(f))
	write_real(stdout, _INVALID_REAL, x_width, x_dec);
      else
	write_real(stdout,
		   1 - ffisher(test->df, test->n_count - test->f_test_df, f),
		   prob_width, prob_dec);
      write_char(stdout, ' ');
    }
  } else {
    write_real(stdout, test->x_pearson, x_width, x_dec);
    write_char(stdout, ' ');
    write_real(stdout, khi(df_adj, test->x_pearson), prob_width, prob_dec);
    write_char(stdout, ' ');
  }

  if (ordinal_tests) {
    write_real(stdout, test->gamma, x_width, prob_dec);
    write_char(stdout, ' ');
    if (test->s > 0)
      write_real(stdout, 2 * pnormal(fabs(test->gamma / sqrt(test->s))),
		 prob_width, prob_dec);
    else
      write_real(stdout, _INVALID_REAL, prob_width, prob_dec);
    write_char(stdout, ' ');
  }
  if (ic) {
    switch (test_choice) {

    case 1:
      statistic = test->x_deviance;
      break;

    case 2:
      statistic = test->x_pearson;
      break;

    case 3:
      statistic = test->x_power;
      break;
    }
    if (bic && exclude_missing) {
      if (test->n_count == _INVALID_COUNT) {
	write_space(stdout, labs(x_width) - 1);
	write_char(stdout, '-');
      } else if (test->df == _INFINITY)
	write_real(stdout,
		   statistic - log((double)test->n_count) * test->df_real,
		   x_width, x_dec);
      else
	write_real(stdout, statistic - log((double)test->n_count) * df_adj,
		   x_width, x_dec);
    } else if (test->df == _INFINITY)
      write_real(stdout, statistic - ic_lambda * test->df_real, x_width,
		 x_dec);
    else
      write_real(stdout, statistic - ic_lambda * df_adj, x_width, x_dec);
    write_char(stdout, ' ');
  }
  if (test->in_eh) {
    switch (test->class_) {

    case 1:
      write_pch(stdout, " Accepted ", 10L);
      break;

    case 2:
      write_pch(stdout, " Rejected ", 10L);
      break;

    case 3:
      write_pch(stdout, " Ignored  ", 10L);
      break;
    }
    if (test->graphical)
      write_char(stdout, 'G');
    else
      write_char(stdout, ' ');
    if (test->decomposable && test->graphical)
      write_char(stdout, 'D');
    else
      write_char(stdout, ' ');
    write_char(stdout, ' ');
    print_id_from_stop(&test->id_1, (*write_options)->write_models,
		       *indent_2 - 1, *indent_2, line_length, &stop);
  } else {
    if ((*test_labels)->reused_test)
      write_pch(stdout, " R ", 3L);
    else
      write_pch(stdout, "   ", 3L);
    if ((*write_options)->write_models) {
      print_id_from_stop(&test->id_2, false, *indent_2 - 1, *indent_2,
			 line_length, &stop);
      if ((stop - *indent_2) * 4 > line_length - *indent_2 &&
	  line_length < MAX_LINE_LENGTH) {
	stop = *indent_2;
	write_line(stdout);
	write_space(stdout, *indent_2 - 1);
	write_char(stdout, '.');
      }
      write_pch(stdout, " // ", 4L);
      print_id_from(&test->id_1, (*write_options)->write_models, stop,
		    *indent_2, line_length);
    }
  }
  /* if (write_options^.write_models and
       (test.id_1^.causal_structure <> nil)) then begin
       write_pch(output, ' | @@@@@@@', 3);
       if (test.id_1^.causal_structure^.pointer = nil) and
          (test.id_1^.causal_structure^.vertex_set = empty_set) then
          write_pch(output, ' ? @@@@@@@', 3)
       else
          print_g_c_from(test.id_1^.causal_structure,
                         stop, indent_2, line_length)
    end; */
  if (!(exact_test && (test->mcep_deviance > -1 || test->mcep_pearson > -1)))
    return;
  write_line(stdout);
  write_pch(stdout, " Exact", 6L);
  write_pch(stdout, " ( ", 3L);
  write_integer(stdout, test->number_of_tables, 6L);
  write_pch(stdout, " ) ", 3L);
  if ((*test_labels)->short_report)
    write_space(stdout, 3L);
  if ((*test_labels)->separators && (*write_options)->write_models)
    write_space(stdout, 11L);
  if (exclude_missing && !(long_names && (*write_options)->write_models))
    write_space(stdout, 8L);
  if (adj_df || (*write_options)->write_models)
    write_space(stdout, 5L);
  write_space(stdout, *indent_1 + labs(x_width) - 9);
  write_real(stdout, test->mcep_deviance, prob_width, prob_dec);
  write_char(stdout, ' ');
  if (lambda != 1) {
    write_space(stdout, labs(x_width) + 1);
    write_real(stdout, test->mcep_power, prob_width, prob_dec);
    write_char(stdout, ' ');
  }
  write_space(stdout, labs(x_width) + 1);
  write_real(stdout, test->mcep_pearson, prob_width, prob_dec);
  if (ordinal_tests) {
    write_space(stdout, labs(x_width) - labs(prob_width) + 1);
    if (!is_invalid_real(test->gamma))
      write_real(stdout, test->mcep_gamma_1, prob_width, prob_dec);
    else
      write_real(stdout, _INVALID_REAL, prob_width, prob_dec);
    write_space(stdout, 1L);
    if (!is_invalid_real(test->gamma))
      write_real(stdout, test->mcep_gamma_2, prob_width, prob_dec);
    else
      write_real(stdout, _INVALID_REAL, prob_width, prob_dec);
  }
  if (!(*write_options)->write_models)
    write_space(stdout, 4L);
}  /* sub_write_test_line */


Static Void sub_write_test_table(test, test_labels)
t_test *test;
t_test_labels **test_labels;
{
  /* var write_options      : t_link_test_write_options; */
  /* ;
  var indent_1, indent_2 : t_long_integer */
  /* stop, */
  t_long_integer df_adj;
  /* , statistic */
  t_long_real f;

  if (adj_df && test->adj != _INFINITY)
    df_adj = test->df - test->adj;
  else
    df_adj = test->df;
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "Test of ", 8L);
  print_id(&test->id_1, false, (*test_labels)->indent + 10, line_length);
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "against ", 8L);
  print_id(&test->id_2, false, (*test_labels)->indent + 10, line_length);
  if ((*test_labels)->reused_test)
    write_pch(stdout, " Re-use", 7L);
  write_line(stdout);
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_space(stdout, labs(print_width) + 1);
  write_pch(stdout, "Statistic", 9L);
  write_space(stdout, labs(print_width) - 3);
  write_pch(stdout, "Asymptotic", 10L);
  if (adj_df) {
    write_space(stdout, labs(print_width) - 3);
    write_pch(stdout, "Adjusted", 8L);
  }
  if (exact_test && test->mcep_deviance > -1) {
    write_space(stdout, labs(print_width));
    write_pch(stdout, "Exact", 5L);
  }
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "-2log(Q) =", 10L);
  write_real(stdout, test->x_deviance, print_width, print_dec);
  write_pch(stdout, "   P = ", 7L);
  write_real(stdout, khi(test->df, test->x_deviance), print_width, print_dec);
  if (adj_df && test->adj != _INFINITY) {
    write_pch(stdout, "  /  ", 5L);
    write_real(stdout, khi(df_adj, test->x_deviance), print_width, print_dec);
  }
  if (exact_test && test->mcep_deviance > -1) {
    write_pch(stdout, "  /  ", 5L);
    write_real(stdout, test->mcep_deviance, print_width, print_dec);
  }
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "Power    =", 10L);
  write_real(stdout, test->x_power, print_width, print_dec);
  write_pch(stdout, "   P = ", 7L);
  write_real(stdout, khi(test->df, test->x_power), print_width, print_dec);
  if (adj_df && test->adj != _INFINITY) {
    write_pch(stdout, "  /  ", 5L);
    write_real(stdout, khi(df_adj, test->x_power), print_width, print_dec);
  }
  if (exact_test && test->mcep_power > -1) {
    write_pch(stdout, "  /  ", 5L);
    write_real(stdout, test->mcep_power, print_width, print_dec);
  }
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "X^2      =", 10L);
  write_real(stdout, test->x_pearson, print_width, print_dec);
  write_pch(stdout, "   P = ", 7L);
  write_real(stdout, khi(test->df, test->x_pearson), print_width, print_dec);
  if (adj_df && test->adj != _INFINITY) {
    write_pch(stdout, "  /  ", 5L);
    write_real(stdout, khi(df_adj, test->x_pearson), print_width, print_dec);
  }
  if (exact_test && test->mcep_pearson > -1) {
    write_pch(stdout, "  /  ", 5L);
    write_real(stdout, test->mcep_pearson, print_width, print_dec);
  }
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "DF.      =", 10L);
  write_space(stdout, labs(print_width) + 7);
  if (test->df == _INFINITY)
    write_real(stdout, test->df_real, print_width, 0L);
  else
    write_integer(stdout, test->df, print_width);
  if (adj_df && test->adj != _INFINITY) {
    write_pch(stdout, "  /  ", 5L);
    write_integer(stdout, df_adj, print_width);
  }
  if (exact_test && test->mcep_pearson > -1) {
    write_pch(stdout, "  /  ", 5L);
    write_space(stdout, labs(print_width) - 8);
    write_char(stdout, '(');
    write_integer(stdout, test->number_of_tables, 6L);
    write_char(stdout, ')');
  }

  if (mixed_data & is_invalid_real(test->x_pearson)) {
    if (test->f_test_df != _INFINITY) {
      write_line(stdout);
      write_space(stdout, (*test_labels)->indent + 1);
      write_pch(stdout, "F-stat.  =", 10L);
      f = deviance_to_f_value(test->df, test->n_count, test->f_test_df,
			      test->x_deviance);
      write_real(stdout, f, print_width, print_dec);
      write_pch(stdout, "  Df = ", 7L);
      write_integer(stdout, test->df, print_dec);
      write_char(stdout, ',');
      write_integer(stdout, test->n_count - test->f_test_df, print_dec);
      write_pch(stdout, "   P = ", 7L);
      if (is_invalid_real(f))
	write_real(stdout, _INVALID_REAL, x_width, x_dec);
      else
	write_real(stdout,
		   1 - ffisher(test->df, test->n_count - test->f_test_df, f),
		   print_width, print_dec);
    }
  }



  if (!is_invalid_real(test->beta)) {
    write_line(stdout);
    write_space(stdout, (*test_labels)->indent + 1);
    write_pch(stdout, "Box-type =", 10L);
    write_real(stdout, test->beta, print_width, print_dec);
    write_pch(stdout, "  Df = ", 7L);
    write_integer(stdout, test->beta_df, print_dec);
    write_pch(stdout, "   P = ", 7L);
    write_real(stdout, _INVALID_REAL, print_width, print_dec);

    write_line(stdout);
    write_space(stdout, (*test_labels)->indent + 1);
    write_pch(stdout, "T-stat.  =", 10L);
    f = test->beta_df * 2 * (1 / test->beta - 1);   /* SLL, page 193 */
    f = sqrt(f);   /* SLL, page 193 */
    write_real(stdout, f, print_width, print_dec);
    write_pch(stdout, "   P = ", 7L);
    write_real(stdout, 1 - student(test->beta_df, f), print_width, print_dec);

    write_line(stdout);
    write_space(stdout, (*test_labels)->indent + 1);
    write_pch(stdout, "F = T^2  =", 10L);
    f = test->beta_df * 2 * (1 / test->beta - 1);   /* SLL, page 193 */
    write_real(stdout, f, print_width, print_dec);
    write_pch(stdout, "   P = ", 7L);
    if (is_invalid_real(f))
      write_real(stdout, _INVALID_REAL, x_width, x_dec);
    else
      write_real(stdout, 1 - ffisher(1L, test->beta_df, f), print_width,
		 print_dec);
  }


  if (em) {
    write_line(stdout);
    write_space(stdout, (*test_labels)->indent + 1);
    write_pch(stdout, "Warning: ", 9L);
    write_pch(stdout, "DF. not correct for latent variables!", 37L);
  }
  if (!(ordinal_tests & (!is_invalid_real(test->gamma))))
    return;
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "Gamma    =", 10L);
  write_real(stdout, test->gamma, print_width, print_dec);
  write_pch(stdout, "   P = ", 7L);
  if (test->s > 0)
    write_real(stdout, 2 * pnormal(fabs(test->gamma / sqrt(test->s))),
	       print_width, print_dec);
  else
    write_real(stdout, _INVALID_REAL, print_width, print_dec);
  if (adj_df)
    write_pch(stdout, "  /  ", 5L);
  if (exact_test && test->mcep_gamma_1 > -1) {
    write_pch(stdout, "  /  ", 5L);
    write_real(stdout, test->mcep_gamma_1, print_width, print_dec);
    write_real(stdout, test->mcep_gamma_2, print_width, print_dec);
  }
  write_line(stdout);
  write_space(stdout, (*test_labels)->indent + 1);
  write_pch(stdout, "S.E.(0)  =", 10L);
  if (test->s > 0)
    write_real(stdout, sqrt(test->s), print_width, print_dec);
  else
    write_real(stdout, _INVALID_REAL, print_width, print_dec);
  write_pch(stdout, " (1) = ", 7L);
  if (test->s1 > 0)
    write_real(stdout, sqrt(test->s1), print_width, print_dec);
  else
    write_real(stdout, _INVALID_REAL, print_width, print_dec);
  if (adj_df)
    write_pch(stdout, "  /  ", 5L);
  if (!(exact_test && test->mcep_gamma_1 > -1))
    return;
  write_pch(stdout, "  /  ", 5L);
  write_space(stdout, labs(print_width) - 8);
  write_pch(stdout, "(1-side)", 8L);
  write_space(stdout, labs(print_width) - 8);
  write_pch(stdout, "(2-side)", 8L);
}  /* sub_write_test_table */


Static Void sub_write_test(test, write_options, test_labels, indent_1,
			   indent_2)
t_test *test;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_long_integer *indent_1, *indent_2;
{
  t_set_list *g_c_1, *g_c_2;

  if (test->test_type != pure_discrete)
    note_mixed(stdout, " Write_Test", 10L);
  if (dump)   /* , test_labels^.reused_test */
    write_test_on_dump_file(test);
  if (test->in_eh | test->ok | (!is_invalid_real(test->x_deviance))) {
    if ((*write_options)->line_form)
      sub_write_test_line(test, write_options, test_labels, indent_1,
			  indent_2);

    else {
      /* ,
                           indent_1, indent_2 */
      sub_write_test_table(test, test_labels);
    }
    return;
  }
  /* write_options, */

  g_c_1 = return_g_c_copy_id(&test->id_1);
  g_c_2 = return_g_c_copy_id(&test->id_2);
  write_out_of_space(g_c_1, g_c_2, "-", write_options, test_labels,
		     *indent_1);
  dispose_set_list(&g_c_1);
  dispose_set_list(&g_c_2);
}  /* sub_write_test */


/* Not used:
function b01(b: boolean): t_integer;
begin
   if b then
      b01 := 1
   else
      b01 := 0
end; */
/* b01 */

Static Void write_test(test, write_options, test_labels)
t_test *test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_long_integer indent, off;

  if ((*write_options)->write_models) {
    off = 0;
    if (exclude_missing && partitioning_output &&
	!(long_names && (*write_options)->write_models))
      off = dimension + 12;
    if (in_fact_inter)
      off += 5;
    if (adj_df)
      off += 5;
    if (true)
      off += labs(x_width) - 4;
  } else
    off = labs(x_width) - 6;
  indent = (labs(x_width) + labs(prob_width) + 2) * 2 + 17;
  if (lambda != 1)
    indent += labs(x_width) + labs(prob_width) + 2;
  if (ic)
    indent += labs(x_width) + 1;
  indent += off;
  sub_write_test(test, write_options, test_labels, &off, &indent);
  if ((*write_options)->write_models)
    write_line(stdout);
}  /* write_test */


/* Not used:
procedure write_test(var test       : t_test;
                       var line_form       : boolean;
                           write_models, reuse : boolean;
                           indent       : t_long_integer);
var
   indent, off : t_long_integer;
   write_options : t_link_test_write_options;
   test_labels : t_link_test_labels;
begin
   write_options := new_test_write_options_do(line_form, write_models);
   test_labels := new_test_labels_reused(indent, reuse);
   write_test(test, write_options, test_labels);
   dispose(write_options);
   dispose(test_labels)
end; */
/* write_test */

Static Void _search_write_test(test, write_options, test_labels)
t_test *test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_long_integer indent;
  t_long_integer off = -5;

  if (exclude_missing && partitioning_output)
    off += dimension + 12;
  if (in_fact_inter)
    off += 5;
  if (adj_df)
    off += 5;
  if (link_eh_pack->link_base != NULL && c_partitioning)
    off += 5;
  if (true)
    off += labs(x_width) - 4;
  indent = (labs(x_width) + labs(prob_width) + 2) * 2 + 17;
  if (lambda != 1)
    indent += labs(x_width) + labs(prob_width) + 2;
  if (ic)
    indent += labs(x_width) + 1;
  indent += off;
  if (link_eh_pack->link_base != NULL && c_partitioning)
    write_space(stdout, 5L);
  sub_write_test(test, write_options, test_labels, &off, &indent);
  write_line(stdout);
}  /* _search_write_test */


Static Void search_write_test(test, graphical, decomposable, class_)
t_test *test;
boolean *graphical, *decomposable;
t_long_integer *class_;
{
  t_long_integer indent = 0;
  boolean reuse = false, local_line_form = true;
  boolean local_write_models;
  t_test_write_options *write_options;
  t_test_labels *test_labels;

  local_write_models = !global_write_options->line_form;
  write_options = new_test_write_options_do(&local_line_form,
					    &local_write_models);
  test_labels = new_test_labels_reused(&indent, &reuse);
  test->in_eh = true;
  test->class_ = *class_;
  test->decomposable = *decomposable;
  test->graphical = *graphical;
  _search_write_test(test, &write_options, &test_labels);
  _Free(write_options);
  _Free(test_labels);
}  /* search_write_test */


Static Void two_sets_from_id(id, a, b)
t_model_specification **id;
long *a, *b;
{
  t_set_list *g_c;

  if ((*id)->model_type == pure_discrete) {
    P_setcpy(a, (*id)->UU.g_c_log_linear->vertex_set);
    P_setcpy(b, (*id)->UU.g_c_log_linear->pointer->vertex_set);
    return;
  }
  if ((*id)->model_type == pure_continuous) {
    P_setcpy(a, (*id)->UU.g_c_covariance->vertex_set);
    P_setcpy(b, (*id)->UU.g_c_covariance->pointer->vertex_set);
    return;
  }
  g_c = return_g_c_copy_id(id);   /* ?!?!? */
  P_setcpy(a, g_c->vertex_set);
  P_setcpy(b, g_c->pointer->vertex_set);
  dispose_set_list(&g_c);
}  /* two_sets_from_id */


Static Void write_sorted_list(link_sort_list, write_options, test_labels)
t_sort_list *link_sort_list;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_part_list *p;
  t_vertex_set g, vertex_set, a, b;
  t_long_integer offset;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " Write_SortedList   ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1846L, 1L, -1L, -1L, (*write_options)->write_test);
  /*$endif TRACE*/
  if ((*test_labels)->separators)
    offset = 11;
  else
    offset = 0;
  write_line(stdout);
  write_pch(stdout, " Sorted list", 12L);
  write_line(stdout);
  if ((*write_options)->line_form) {
    if ((*write_options)->write_models)
      write_test_head(stdout, "  Edge    ", 6L, offset, "Models", 6L,
		      *write_options, *test_labels);
    else
      write_test_head(stdout, "", 0L, -1L, "Edge", 4L,
		      *write_options, *test_labels);
  }
  while (link_sort_list != NULL) {
    if ((*write_options)->write_models) {
      write_space(stdout, 3L);
      print_vertex_set(link_sort_list->vertex_set);
      write_space(stdout, offset);
    }
    p = link_sort_list->link_part_list;
    while (p != NULL) {
      if (exclude_missing && partitioning_output) {
	P_setcpy(g, empty_set);
	add_union_of_id(&p->link_test_list->test.id_1, g);
	add_union_of_id(&p->link_test_list->test.id_2, g);
	print_n_total_exclude(g, write_options, test_labels,
			      p->link_test_list->test.n_count);
      }
      write_test(&p->link_test_list->test, write_options, test_labels);
      p = p->pointer;
      if ((*write_options)->write_models)
	write_space(stdout, 3L);
      if (p != NULL)
	write_char(stdout, '+');
      else
	write_char(stdout, '=');
      if ((*write_options)->write_models)
	write_space(stdout, offset + 3);
      if (!(*write_options)->write_models)
	write_line(stdout);
    }
    if (exclude_missing && partitioning_output) {
      P_setcpy(g, empty_set);
      add_union_of_id(&link_sort_list->link_test_list->test.id_1, g);
      add_union_of_id(&link_sort_list->link_test_list->test.id_2, g);
      print_n_total_exclude(g, write_options, test_labels,
			    link_sort_list->link_test_list->test.n_count);
    }
    write_test(&link_sort_list->link_test_list->test, write_options,
	       test_labels);
    if (!(*write_options)->write_models) {
      print_vertex_set(link_sort_list->vertex_set);
      write_line(stdout);
    }
    p = link_sort_list->link_sepa_list;
    while (p != NULL) {
      two_sets_from_id(&p->link_test_list->test.id_1, a, b);
      if (!(*write_options)->write_models)
	write_test(&p->link_test_list->test, write_options, test_labels);
      if ((*write_options)->write_models)
	write_space(stdout, 3L);
      if ((*write_options)->write_models)
	write_char(stdout, '.');
      else {
	P_setdiff(vertex_set, a, b);
	print_vertex_set(vertex_set);
      }
      write_char(stdout, '^');
      if ((*write_options)->write_models)
	write_char(stdout, '.');
      else {
	P_setdiff(vertex_set, b, a);
	print_vertex_set(vertex_set);
      }
      write_char(stdout, '|');
      P_setint(vertex_set, b, a);
      print_vertex_set_table(vertex_set);
      if ((*write_options)->write_models)
	write_space(stdout, 3L);
      else
	write_line(stdout);
      if ((*write_options)->write_models)
	write_test(&p->link_test_list->test, write_options, test_labels);
      p = p->pointer;
    }
    link_sort_list = link_sort_list->pointer;
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1984L, 8L, -1L, 2L, (*write_options)->write_test);
  /*$endif TRACE*/
}  /* write_sorted_list */


Static Void put_test_values(p_test, edge, test_type, ifail, off_pos_int,
			    off_pos_double, arg_pos_int, arg_pos_double,
			    nargs, arg_int, arg_double)
t_test *p_test;
long *edge;
t_integer test_type, *ifail, *off_pos_int, *off_pos_double, arg_pos_int,
	  arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  /* , sub_code */
  t_integer dummy;
  t_vertex_set a, b, g;
  t_vertex u, v;
  t_long_integer card;

  P_setcpy(g, empty_set);
  add_union_of_id(&p_test->id_1, g);
  add_union_of_id(&p_test->id_2, g);

  if (test_type == 2) {
    two_sets_from_id(&p_test->id_1, a, b);
    P_setdiff(g, a, b);
    P_setdiff(g, b, a);
    P_setint(g, b, a);
  }

  u = first_vertex;
  while (!P_inset(u, edge) && u < last_vertex)
    u++;

  v = u;
  if (v < last_vertex) {
    v++;
    while (!P_inset(v, edge) && v < last_vertex)
      v++;
  }

  card = cardinality(edge);

  if (p_test->ok && *ifail < 1)
    *ifail = 0;
  if (ok_int_arg(ifail, arg_pos_int, *off_pos_int + 5, nargs, arg_int) &
      ok_double_arg(ifail, arg_pos_double, *off_pos_double + 14, nargs,
		    arg_double)) {
    (*arg_int)[*off_pos_int] = p_test->n_count;
    (*arg_int)[*off_pos_int + 1] = p_test->df;
    if (p_test->adj < _INFINITY)   /* Check with Xlisp+CoCo !!!! */
      (*arg_int)[*off_pos_int + 2] = p_test->adj;
    (*arg_int)[*off_pos_int + 3] = p_test->number_of_tables;
    if (ok_int_arg(ifail, arg_pos_int, *off_pos_int + 5, nargs, arg_int) &&
	p_test->f_test_df != _INFINITY)
      (*arg_int)[*off_pos_int + 4] = p_test->f_test_df;
    if (card > 0) {
      if (ok_int_arg(ifail, arg_pos_int, *off_pos_int + 8, nargs, arg_int)) {
	(*arg_int)[*off_pos_int + 5] = u;
	(*arg_int)[*off_pos_int + 6] = v;
	(*arg_int)[*off_pos_int + 7] = card;
      }
    }

    if (is_invalid_real(p_test->x_deviance))
      (*arg_double)[*off_pos_double] = my_var_na_double;
    else if (test_ok(p_test->test_ifail))
      (*arg_double)[*off_pos_double] = p_test->x_deviance;
    else
      (*arg_double)[*off_pos_double] = my_var_na_double;
    if (p_test->mcep_deviance < 0)
      (*arg_double)[*off_pos_double + 1] = my_var_na_double;
    else
      (*arg_double)[*off_pos_double + 1] = p_test->mcep_deviance;
    if (is_invalid_real(p_test->x_pearson))
      (*arg_double)[*off_pos_double + 2] = my_var_na_double;
    else
      (*arg_double)[*off_pos_double + 2] = p_test->x_pearson;
    if (p_test->mcep_pearson < 0)
      (*arg_double)[*off_pos_double + 3] = my_var_na_double;
    else
      (*arg_double)[*off_pos_double + 3] = p_test->mcep_pearson;
    if (is_invalid_real(p_test->x_power))
      (*arg_double)[*off_pos_double + 4] = my_var_na_double;
    else
      (*arg_double)[*off_pos_double + 4] = p_test->x_power;
    if (p_test->mcep_power < 0)
      (*arg_double)[*off_pos_double + 5] = my_var_na_double;
    else
      (*arg_double)[*off_pos_double + 5] = p_test->mcep_power;
    (*arg_double)[*off_pos_double + 6] = p_test->gamma;
    (*arg_double)[*off_pos_double + 7] = p_test->s;
    (*arg_double)[*off_pos_double + 8] = p_test->s1;
    if (p_test->mcep_gamma_1 < 0)
      (*arg_double)[*off_pos_double + 9] = my_var_na_double;
    else
      (*arg_double)[*off_pos_double + 9] = p_test->mcep_gamma_1;
    if (p_test->mcep_gamma_2 < 0)
      (*arg_double)[*off_pos_double + 10] = my_var_na_double;
    else
      (*arg_double)[*off_pos_double + 10] = p_test->mcep_gamma_2;
    if (p_test->df < _INFINITY)
      (*arg_double)[*off_pos_double + 11] = p_test->df;
    else if (is_invalid_real(p_test->df_real))
      (*arg_double)[*off_pos_double + 11] = my_var_na_double;
    else
      (*arg_double)[*off_pos_double + 11] = p_test->df_real;
    if (ok_double_arg(ifail, arg_pos_double, *off_pos_double + 13, nargs,
		      arg_double)) {
      if (p_test->x_f_test < 0)
	(*arg_double)[*off_pos_double + 12] = my_var_na_double;
      else
	(*arg_double)[*off_pos_double + 12] = p_test->x_f_test;
    }
    if (ok_double_arg(ifail, arg_pos_double, *off_pos_double + 14, nargs,
		      arg_double)) {
      if (p_test->mcep_f_test < 0)
	(*arg_double)[*off_pos_double + 13] = my_var_na_double;
      else
	(*arg_double)[*off_pos_double + 13] = p_test->mcep_f_test;
    }
    for (dummy = 6; dummy <= 8; dummy++) {
      if (is_invalid_real((*arg_double)[*off_pos_double + dummy]))
	(*arg_double)[*off_pos_double + dummy] = my_var_na_double;
    }
  }
  *off_pos_int += 8;
  *off_pos_double += 14;
}  /* put_test_values */


Static Void put_sorted_list(link_sort_list, parts, separators, write_options,
			    test_labels, ifail, arg_pos_int, arg_pos_double,
			    nargs, arg_int, arg_double)
t_sort_list *link_sort_list;
boolean parts, separators;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_integer *ifail, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  /* , sub_code */
  t_part_list *p;
  t_integer off_pos_int = 0, off_pos_double = 0;
  t_vertex_set edge;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PutSortedList      ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1846L, 1L, -1L, -1L, (*write_options)->write_test);
  /*$endif TRACE*/
  while (link_sort_list != NULL) {
    P_setcpy(edge, link_sort_list->vertex_set);
    p = link_sort_list->link_part_list;
    if (parts) {
      while (p != NULL) {
	put_test_values(&p->link_test_list->test, empty_set, 1L, ifail,
			&off_pos_int, &off_pos_double, arg_pos_int,
			arg_pos_double, nargs, arg_int, arg_double);
	p = p->pointer;
      }
    }
    put_test_values(&link_sort_list->link_test_list->test, edge, 0L, ifail,
		    &off_pos_int, &off_pos_double, arg_pos_int,
		    arg_pos_double, nargs, arg_int, arg_double);
    p = link_sort_list->link_sepa_list;
    if (separators) {
      while (p != NULL) {
	put_test_values(&p->link_test_list->test, empty_set, 2L, ifail,
			&off_pos_int, &off_pos_double, arg_pos_int,
			arg_pos_double, nargs, arg_int, arg_double);
	p = p->pointer;
      }
    }
    link_sort_list = link_sort_list->pointer;
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1984L, 8L, -1L, 2L, (*write_options)->write_test);
  /*$endif TRACE*/
}  /* put_sorted_list */


/*@+"ctest.p"*/


/*

1849:    +++  ++
1850:    +++  ++
1851:    ---  -- p/ctest.p         13      56     748 p/ctest.p
1852: |    3:    procedure insert_gcs_in_test
1853: |   15:    function return_df
1854: |   81:    procedure find_adjusted_df
1855: |  109:    procedure compute_discrete_test
1856: |  221:    function extract_determinants
1857: |  246:    function return_determinant_vector
1858: |  289:    procedure examin_terms
1859: |  402:    procedure sub_test_one_edge_continuous
1860: |  490:    procedure compute_mixed_test
1861: |  547:    procedure compute_continuous_test
1862: |  565:    procedure compute_test
1863: |  612:    procedure insert_part
1864: |  629:    procedure insert_test_in_sort_list
1865:    +++  ++
1866:    +++  ++

*/

Static Void insert_gcs_in_test(g_c_1, g_c_2, cs, copy, homogeneous,
			       full_specified, test)
t_set_list **g_c_1, **g_c_2, *cs;
boolean copy, homogeneous, full_specified;
t_test *test;
{
  t_set_list *tmp_cs = NULL;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /* clear_test(test); */
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertGcsInTest    ", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 1852L, 1L, 1L, 1L, g_c_1, g_c_2, &tmp_cs);
  /*$endif TRACE*/
  /* full_specified, */
  insert_g_c_in_id(g_c_1, &cs, copy, homogeneous, &test->id_1);
  /* full_specified, */
  insert_g_c_in_id(g_c_2, &cs, copy, homogeneous, &test->id_2);
  test->paritet = return_double_parity(&test->id_1, &test->id_2);
  /*$ifdef TRACE*/
  ntr_triple_g_c(tzt, 20L, 1852L, 1L, 1L, 9L, g_c_1, g_c_2, &tmp_cs);
  ntr(tzt, 20L, 1852L, 1L, 1L, 9L);
  /*$endif TRACE*/
}  /* insert_gcs_in_test */


Static Void copy_gc_and_model_to_test(current_g_c, base_model, test)
t_set_list **current_g_c;
t_model **base_model;
t_test *test;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /* clear_test(test); */
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertGc+ModelToTe ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 1852L, 1L, 2L, 1L, current_g_c);
      /* base_model^.id^.full_specified, */
  /*$endif TRACE*/
  insert_g_c_in_id(current_g_c, &(*base_model)->id->causal_structure, true,
		   (*base_model)->id->UU.U1.homogeneous, &test->id_1);
  copy_identification(&(*base_model)->id, &test->id_2);
  test->paritet = return_double_parity(&test->id_1, &test->id_2);
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 1852L, 1L, 2L, 9L, current_g_c);
  /*$endif TRACE*/
}  /* copy_gc_and_model_to_test */


Static Void copy_test_identification(current_model, base_model, test)
t_model **current_model, **base_model;
t_test *test;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " CopyTestIdentific. ", sizeof(pch20));
  ntr(tzt, 20L, 1852L, 1L, 3L, 1L);
  /*$endif TRACE*/
  copy_identification(&(*current_model)->id, &test->id_1);
  copy_identification(&(*base_model)->id, &test->id_2);
  test->paritet = return_double_parity(&test->id_1, &test->id_2);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1852L, 1L, 3L, 9L);
  /*$endif TRACE*/
}  /* copy_test_identification */


Static t_long_integer return_df(current_model, base_model, df_real)
t_model **current_model, **base_model;
t_long_real *df_real;
{
  t_expression *df_1, *df_2, *q;
  t_vertex_set a, b;
  t_long_integer x, df_integer, sf;

  if (!mixed_data) {
    df_1 = return_dimension_list(current_model);
    df_2 = return_dimension_list(base_model);
    q = df_1;
    while (q != NULL) {
      put_dim_factor(&df_2, q->vertex_set, -q->factor);
      q = q->pointer;
    }
    dispose_expression(&df_1);
    P_setcpy(a, delta);
    q = df_2;
    while (q != NULL) {
      if (!P_setequal(empty_set, q->vertex_set))
	P_setint(a, a, q->vertex_set);
      q = q->pointer;
    }
    x = marginal_dimension(a);
    if (x != _INFINITY) {
      df_integer = 0;
      sf = 0;
      q = df_2;
      while (q != NULL && df_integer != _INFINITY) {
	if (!P_setequal(empty_set, q->vertex_set)) {
	  P_setdiff(b, q->vertex_set, a);
	  x = marginal_dimension(b);
	  sf += q->factor;
	  if (x != _INFINITY)
	    df_integer += q->factor * x;
	  else
	    df_integer = _INFINITY;
	}
	q = q->pointer;
      }
      x = marginal_dimension(a);
      if (x != _INFINITY && df_integer < (double)_INFINITY / x)
	df_integer = x * df_integer - sf;
      else
	df_integer = _INFINITY;
    } else
      df_integer = _INFINITY;
    if (df_integer == _INFINITY) {
      *df_real = 0.0;
      q = df_2;
      while (q != NULL) {
	P_setdiff(b, q->vertex_set, a);
	*df_real += q->factor * (marginal_dimension_real(b) - 1);
	q = q->pointer;
      }
      *df_real = marginal_dimension_real(a) * *df_real;
    } else
      *df_real = df_integer;
    dispose_expression(&df_2);
    return df_integer;
  }
  note_mixed(stdout, " ReturnDF", 9L);
}  /* return_df */


Static Void find_adjusted_df(current_model, base_model, adj)
t_model **current_model, **base_model;
t_long_integer *adj;
{
  t_long_integer a, b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindAdjustedDf     ", sizeof(pch20));
  ntr_model_formula(tzt, 20L, 1854L, 1L, -1L, 1L, *current_model);
  ntr_model_formula(tzt, 20L, 1854L, 1L, -1L, 2L, *base_model);
  /*$endif TRACE*/
  *adj = _INFINITY;
  if (adj_df && !graph_mode) {
    b = count_zero_n(current_model);
    if (b != _INFINITY) {
      a = count_zero_par(current_model, base_model);
      if (a != _INFINITY)
	*adj = a - b;
    }
  }
  /*$ifdef TRACE*/
  ntr_model_formula(tzt, 20L, 1854L, 8L, -1L, 1L, *current_model);
  ntr_model_formula(tzt, 20L, 1854L, 8L, -1L, 2L, *base_model);
  /*$endif TRACE*/
}  /* find_adjusted_df */


Static Void ddiff_ifail(current_model, base_model, x_deviance, ifail)
t_model **current_model, **base_model;
t_long_real *x_deviance;
t_long_integer *ifail;
{
  *ifail = 0;
  if (em) {
    write_warning(stdout, " Deviance difference when EM on!", 33L);
    return;
  }
  if (!(*current_model)->found_log_l)
    (*current_model)->log_l = compute_log_l(current_model,
					    (*current_model)->id->vertices);
  if (!(*base_model)->found_log_l)
    (*base_model)->log_l = compute_log_l(base_model,
					 (*base_model)->id->vertices);
  *x_deviance = ddiff(&(*base_model)->log_l, &(*current_model)->log_l);
  if ((*base_model)->model_ifail != 0)
    *ifail = (*base_model)->model_ifail;
  if ((*current_model)->model_ifail != 0)
    *ifail = (*current_model)->model_ifail;
}  /* ddiff_ifail */


Static Void compute_discrete_test(current_model, base_model, g, p, test)
t_model **current_model, **base_model;
long *g;
t_test_list **p;
t_test *test;
{
  t_long_real x_deviance = _INVALID_REAL, x_pearson = _INVALID_REAL,
	      x_power = _INVALID_REAL;
  t_long_integer ifail = -9;
  boolean ok = true;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeDiscreteTest", sizeof(pch20));
  ntr_model_formula(tzt, 20L, 1855L, 1L, -1L, 1L, *current_model);
  ntr_model_formula(tzt, 20L, 1855L, 1L, -1L, 2L, *base_model);
  /*$endif TRACE*/
  if (!graph_mode) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1855L, 2L, -1L, -1L);
    /*$endif TRACE*/
    if (em) {
      if (!(*current_model)->found_log_l)
	do_em_model(current_model, &ok);
      if (ok && !(*base_model)->found_log_l)
	do_em_model(base_model, &ok);
    } else
      test_expression_marginals(current_model, base_model, g, &ok);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1855L, 7L)) {
      ntr_boolean(tzt, 20L, 1855L, 5L, -1L, -1L, ok);
      write_pch(stdout, " Model:   ", 10L);
      describe_model(current_model, false, true);
      write_line(stdout);
      write_pch(stdout, " Against: ", 10L);
      describe_model(base_model, false, true);
      write_line(stdout);
      print_model_g_c(current_model, 10L);
      print_model_g_c(base_model, 10L);
      print_vertex_set(g);
      write_line(stdout);
    }
    /*$endif TRACE*/
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1855L, 4L, -1L, -1L);
    /*$endif TRACE*/
    if (ok)
      compute_x_deviance_and_x_pearson(current_model, base_model, g,
				       &x_deviance, &x_pearson, &x_power);
    else
      ddiff_ifail(current_model, base_model, &x_deviance, &ifail);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1855L, 3L, -1L, 1L);
  /*$endif TRACE*/
  clear_test(test);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1855L, 3L, -1L, 2L);
  /*$endif TRACE*/
  insert_gcs_in_test(&(*current_model)->id->UU.g_c_log_linear,
    &(*base_model)->id->UU.g_c_log_linear,
    (*current_model)->id->causal_structure, true,
    (*base_model)->id->UU.U1.homogeneous,
    (*base_model)->id->UU.U1.full_specified, test);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1855L, 3L, -1L, 3L);
  /*$endif TRACE*/
  test->df = diff_long_infinity(&(*base_model)->dim, &(*current_model)->dim);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1855L, 3L, -1L, 4L);
  /*$endif TRACE*/
  if (test->df == _INFINITY)
    test->df = return_df(current_model, base_model, &test->df_real);
  if (ok && test->df < _INFINITY)
    find_adjusted_df(current_model, base_model, &test->adj);
  else
    test->adj = _INFINITY;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1855L, 3L, -1L, 5L);
  ntr_model_formula(tzt, 20L, 1855L, 8L, -1L, 995L, *current_model);
  ntr_model_formula(tzt, 20L, 1855L, 8L, -1L, 996L, *base_model);
  ntr_real(tzt, 20L, 1855L, 8L, -1L, 997L, &x_deviance);
  ntr_real(tzt, 20L, 1855L, 8L, -1L, 998L, &x_pearson);
  ntr_real(tzt, 20L, 1855L, 8L, -1L, 999L, &x_power);
  /*$endif TRACE*/
  test->test_ifail = ifail;
  test->x_deviance = x_deviance;
  test->x_pearson = x_pearson;
  test->x_power = x_power;
  test->ok = (ok || permit_log_l);
  test->n_count = n[0];
  if (re_use_test)
    insert_test(p, test);
}  /* compute_discrete_test */


Static boolean extract_determinants(a, m2, n_offset, s_offset, s, r_offset, r)
long *a;
t_integer *m2;
t_offset *n_offset;
t_s_offset *s_offset;
t_s_r **s;
t_t_offset r_offset;
t_t_r **r;
{
  t_integer i, stop;
  t_s_offset x_offset;
  t_vertex_set b;
  t_t_offset r0_offset;

  x_offset = *s_offset + *m2 - 1;
  i = *n_offset;
  P_setint(b, a, delta);
  stop = i + marginal_dimension(b) - 1;
  r0_offset = r_offset;
  while (i <= stop) {
    /*$ifdef TRACE-ARRAY*/
    ntr_s_ref(s, s_offset, x_offset, " ExtractDeterminants", 20L, 1856L, 1L);
    ntr_t_ass(r, &r0_offset, r_offset, (*s)->z[x_offset],
	      " ExtractDeterminants", 20L, 1856L, 1L);
    /*$endif TRACE-ARRAY*/
    (*r)->z[r_offset] = (*s)->z[x_offset];
    r_offset++;
    x_offset += *m2;
    i++;
  }
  return true;
}  /* extract_determinants */


Static boolean return_determinant_vector(a, homogeneous, r_offset, r)
long *a;
boolean *homogeneous;
t_t_offset r_offset;
t_t_r **r;
{
  t_vertex_set b;
  boolean ok;
  t_integer i, m1, m2;
  t_offset n_offset;
  t_s_offset s_offset;
  t_s_r *s = NULL;   /* T_S, find_ssd */
  t_long_real x, y;
  long FORLIM;

  P_setint(b, a, gamma_);
  if (P_setequal(b, empty_set)) {
    P_setint(b, a, delta);
    FORLIM = marginal_dimension(b);
    for (i = 0; i < FORLIM; i++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ass(r, &r_offset, r_offset + i, 1.0, " ReturnDeterminantV.", 20L,
		1857L, 1L);
      /*$endif TRACE-ARRAY*/
      (*r)->z[r_offset + i] = 1.0;
    }
    return true;
  }
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  ok = find_ssd(a, &m1, &m2, &n_offset, &s_offset, &s);
  if (ok) {
    if (*homogeneous)   /* and false */
    {  /* ?!?!? */
      ok = find_determinant_of_sum(a, &m1, &m2, &n_offset, &s_offset, &s, &x,
				   &y);
      if (ok) {
	/*$ifdef TRACE-ARRAY*/
	ntr_t_ass(r, &r_offset, r_offset, exp(x), " ReturnDeterminantV.", 20L,
		  1857L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	(*r)->z[r_offset] = exp(x);
	return true;
      }
      if (note_warnings) {
	write_pch(stdout, " Note-4 (ReturnDetVector): FindDetOfSum.", 40L);
	write_line(stdout);
      }
      return false;
    }
    ok = find_determinants(a, &m1, &m2, &n_offset, &s_offset, &s);
    if (ok)
      ok = extract_determinants(a, &m2, &n_offset, &s_offset, &s, r_offset, r);
    if (ok)
      return true;
    if (note_warnings) {
      write_pch(stdout, " Note-5 (ReturnDetVector): Non-homognus.", 40L);
      write_line(stdout);
    }
    return false;
  }
  if (note_warnings) {
    write_pch(stdout, " Note-1 (ReturnDetrmnntVector): FindSsd.", 40L);
    write_line(stdout);
  }
  return false;
}  /* return_determinant_vector */


Static Void examin_terms(c, bv, bw, v, w, homogeneous, ok)
long *c, *bv, *bw;
t_vertex *v, *w;
boolean *homogeneous, *ok;
{
  t_t_r *workspace = NULL;   /* T_T, return_tmp_t_space */
  t_t_offset workspace_offset;
  /* tmp_offset, */
  t_t_offset x_offset;
  t_offset n_offset;
  t_integer size, i, stop;
  t_long_real x;
  t_long_real y = 0.0;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ExaminTerms        ", sizeof(pch20));
  ntr_3_sets(tzt, 20L, 1858L, 1L, 1L, 1L, c, bv, bw);
  /*$endif TRACE*/

  P_setint(a, bv, bw);
  size = marginal_dimension(a);
  n_offset = find_marginal(a, ok);
  if (*ok)
    *ok = return_tmp_t_space(size * 4, &workspace, &workspace_offset);
  /* malloc_workspace(workspace, tmp_offset, t_1, t_1_offset, size); */
  /*
  i := n_offset + first_index;
  x_offset := workspace_offset;
  stop := i + size - 1;
  write_line(output);
  while (i <= stop) and ok do begin
     workspace^.z^[x_offset + 0 * size] := x_offset + 0 * size;
     workspace^.z^[x_offset + 1 * size] := x_offset + 1 * size;
     workspace^.z^[x_offset + 2 * size] := x_offset + 2 * size;
     workspace^.z^[x_offset + 3 * size] := x_offset + 3 * size;
     write_pch(output, ' :    @@@@', 6);
     write_integer(output, i, 4);
     write_integer(output, size, 4);
     write_integer(output, x_offset, 4);
     write_integer(output, n[i], 5);
     write_real(output, workspace^.z^[x_offset + 0 * size],
                print_width, print_dec);
     write_real(output, workspace^.z^[x_offset + 1 * size],
                print_width, print_dec);
     write_real(output, workspace^.z^[x_offset + 2 * size],
                print_width, print_dec);
     write_real(output, workspace^.z^[x_offset + 3 * size],
                print_width, print_dec);
     write_line(output);
     x_offset := x_offset + 1;
     i := i + 1
  end;
   */
  if (*ok)
    *ok = return_determinant_vector(c, homogeneous, workspace_offset,
				    &workspace);
  if (*ok)
    *ok = return_determinant_vector(a, homogeneous, workspace_offset + size,
				    &workspace);
  if (*ok)
    *ok = return_determinant_vector(bv, homogeneous,
				    workspace_offset + size * 2, &workspace);
  if (*ok)
    *ok = return_determinant_vector(bw, homogeneous,
				    workspace_offset + size * 3, &workspace);
  x_offset = workspace_offset;
  if (*homogeneous) {
    i = 0;
    stop = 0;
  } else {
    i = n_offset;
    stop = i + size - 1;
  }
  write_line(stdout);
  while (i <= stop && *ok) {
    /* Improve output !?!?! */
    write_pch(stdout, " Box-term:", 10L);
    write_integer(stdout, i, 4L);
    write_integer(stdout, n[i], 5L);
    write_real(stdout, workspace->z[x_offset], print_width, print_dec);
    write_real(stdout, workspace->z[x_offset + size], print_width, print_dec);
    write_real(stdout, workspace->z[x_offset + size * 2], print_width,
	       print_dec);
    write_real(stdout, workspace->z[x_offset + size * 3], print_width,
	       print_dec);
    if (n[i] > 0) {
      x = 0.0;
      /*$ifdef TRACE-ARRAY*/
      ntr_t_ref(&workspace, &workspace_offset, x_offset,
		" ExaminTerms        ", 20L, 1858L, 1L);
	  /* ntr */
      ntr_t_ref(&workspace, &workspace_offset, x_offset + size,
		" ExaminTerms        ", 20L, 1858L, 1L);
	  /* ntr */
      ntr_t_ref(&workspace, &workspace_offset, x_offset + size * 2,
		" ExaminTerms        ", 20L, 1858L, 1L);
	  /* ntr */
      ntr_t_ref(&workspace, &workspace_offset, x_offset + size * 3,
		" ExaminTerms        ", 20L, 1858L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      x += log(workspace->z[x_offset]);
      x += log(workspace->z[x_offset + size]);
      x -= log(workspace->z[x_offset + size * 2]);
      x -= log(workspace->z[x_offset + size * 3]);
      write_real(stdout, exp(x), print_width, print_dec);
      x *= n[i];
      write_real(stdout, x, print_width, print_dec);
      y -= x;
    } else
      write_space(stdout, print_width * 2);
    write_real(stdout, y, print_width, print_dec);
    write_line(stdout);
    x_offset++;
    i++;
  }
  write_line(stdout);
  free_tmp_t_space();   /* 4 * size, workspace, workspace_offset */
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
}  /* examin_terms */


Static Void sub_test_one_edge_continuous(current_model, base_model, c, bv, bw,
  v, w, homogeneous, ok, p_test, test, do_examin_terms)
t_model **current_model, **base_model;
long *c, *bv, *bw;
t_vertex *v, *w;
boolean *homogeneous, *ok;
t_test_list **p_test;
t_test *test;
boolean *do_examin_terms;
{
  t_long_real x_deviance = _INVALID_REAL;
  t_long_real x, y, a;
  t_vertex_set vertex_set;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubTestOneEdgeCont.", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1859L, 1L, -1L, 1L, current_model);
  ntr_model_g_c(tzt, 20L, 1859L, 1L, -1L, 2L, base_model);
  /*$endif TRACE*/
  *ok = true;
  if (!graph_mode) {
    if (!em) {
      P_setint(vertex_set, bv, bw);
      a = 0.0;
      *ok = find_det_product(c, homogeneous, &x, &y);
      /* write_real(output, x, print_width, print_dec); */
      a = my_add_long_real(&a, &x);
      *ok = find_det_product(vertex_set, homogeneous, &x, &y);
      /* write_real(output, x, print_width, print_dec); */
      a = my_add_long_real(&a, &x);
      *ok = find_det_product(bv, homogeneous, &x, &y);
      /* write_real(output, x, print_width, print_dec); */
      a = my_sub_long_real(&a, &x);
      *ok = find_det_product(bw, homogeneous, &x, &y);
      /* write_real(output, x, print_width, print_dec);
         write_line(output); */
      x_deviance = ddiff(&x, &a);
      if (*do_examin_terms)
	examin_terms(c, bv, bw, v, w, homogeneous, ok);
    }
    /* Page 192, SLL: */
    if (!*ok)
      write_warning(stdout, " Out of space in `ComputeTest' (2)", 34L);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1859L, 1L, 2L, 0L);
  /*$endif TRACE*/
  clear_test(test);
  copy_test_identification(current_model, base_model, test);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1859L, 1L, 2L, 1L);
  /*$endif TRACE*/
  (*current_model)->dim = find_dimension(current_model, false, *homogeneous);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1859L, 1L, 2L, 2L);
  /*$endif TRACE*/
  (*base_model)->dim = find_dimension(base_model, false, *homogeneous);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1859L, 1L, 2L, 3L);
  /*$endif TRACE*/
  test->df = diff_long_infinity(&(*base_model)->dim, &(*current_model)->dim);
  test->adj = _INFINITY;
  if (test->f_test_df == _INFINITY) {
    if (!ok_to_f_test(current_model, base_model, &test->f_test_df))
      test->f_test_df = _INFINITY;
  }
  test->test_ifail = -2;
  test->x_deviance = x_deviance;
  if (test->f_test_df != _INFINITY)
    test->x_f_test = deviance_to_f_value(test->df, n[0], test->f_test_df,
					 test->x_deviance);
  /* Bartlett correction, Section 5.22, page 144, in SLL !?!?! */
  if (*homogeneous) {
    test->beta = exp(-(x_deviance / n[0]));
    P_setint(vertex_set, vertex_set, delta);
    test->beta_df = n[0] - count_continuous(c) - marginal_dimension(vertex_set) + 1;
  }
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1859L, 8L, -1L, 997L, &x_deviance);
  ntr_real(tzt, 20L, 1859L, 8L, -1L, test->beta_df, &test->beta);
  /*$endif TRACE*/
  test->ok = (*ok || permit_log_l);
  test->n_count = n[0];
  if (re_use_test)
    insert_test(p_test, test);
}  /* sub_test_one_edge_continuous */


Static Void compute_mixed_test(current_model, base_model, p, test)
t_model **current_model, **base_model;
t_test_list **p;
t_test *test;
{
  /* var g  : t_vertex_set; */
  t_long_real x_deviance = _INVALID_REAL;
  t_long_integer ifail = -10;
  boolean ok = true;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeMixedTest   ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1860L, 1L, -1L, 1L, current_model);
  ntr_model_g_c(tzt, 20L, 1860L, 1L, -1L, 2L, base_model);
  /*$endif TRACE*/
  if (!graph_mode) {
    ddiff_ifail(current_model, base_model, &x_deviance, &ifail);
    if (!ok)
      write_warning(stdout, " Out of space in `ComputeTest' (3)", 34L);
  }
  clear_test(test);
  copy_test_identification(current_model, base_model, test);
  test->df = diff_long_infinity(&(*base_model)->dim, &(*current_model)->dim);
      /* !?!?!? */
  test->adj = _INFINITY;
  test->test_ifail = ifail;
  test->x_deviance = x_deviance;
  if (test->f_test_df == _INFINITY) {
    if (!ok_to_f_test(current_model, base_model, &test->f_test_df))
      test->f_test_df = _INFINITY;
  }
  if (test->f_test_df != _INFINITY)
    test->x_f_test = deviance_to_f_value(test->df, n[0], test->f_test_df,
					 test->x_deviance);
  /*$ifdef TRACE*/
  ntr_real(tzt, 20L, 1860L, 8L, -1L, 997L, &x_deviance);
  /*$endif TRACE*/
  test->ok = (ok || permit_log_l);
  test->n_count = n[0];
  if (re_use_test)
    insert_test(p, test);
}  /* compute_mixed_test */


Static Void compute_continuous_test(current_model, base_model, p, test)
t_model **current_model, **base_model;
t_test_list **p;
t_test *test;
{
  /* var g : t_vertex_set; */
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeContinuousT.", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1861L, 1L, -1L, 1L, current_model);
  ntr_model_g_c(tzt, 20L, 1861L, 1L, -1L, 2L, base_model);   /* g, */
  /*$endif TRACE*/
  compute_mixed_test(current_model, base_model, p, test);
}  /* compute_continuous_test */


Static Void compute_test(current_model, base_model, g, p, test)
t_model **current_model, **base_model;
long *g;
t_test_list **p;
t_test *test;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ComputeTest        ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1862L, 1L, -1L, 1L, current_model);
  ntr_model_g_c(tzt, 20L, 1862L, 1L, -1L, 2L, base_model);
  /*$endif TRACE*/
  if (mixed_data) {
    switch ((*base_model)->id->model_type) {

    case pure_discrete:
      if ((*current_model)->id->model_type == pure_discrete)
	compute_discrete_test(current_model, base_model, g, p, test);
      break;

    case mixed:
      if ((*current_model)->id->model_type != pure_discrete) {
	if ((*current_model)->id->model_type != pure_continuous) {
	  /* g, */
	  compute_mixed_test(current_model, base_model, p, test);
	}
      }
      break;

    case pure_continuous:
      if ((*current_model)->id->model_type == pure_continuous) {
	/* g, */
	compute_continuous_test(current_model, base_model, p, test);
      }
      break;
    }
  } else
    compute_discrete_test(current_model, base_model, g, p, test);
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1862L, 8L, -1L, 995L, current_model);
  ntr_model_g_c(tzt, 20L, 1862L, 8L, -1L, 996L, base_model);
  ntr_real(tzt, 20L, 1862L, 8L, -1L, 997L, &test->x_deviance);
  ntr_real(tzt, 20L, 1862L, 8L, -1L, 998L, &test->x_pearson);
  ntr_real(tzt, 20L, 1862L, 8L, -1L, 999L, &test->x_power);
  /*$endif TRACE*/
}  /* compute_test */


Static Void insert_part(p)
t_test_list **p;
{
  t_part_list *q, *r;

  q = (t_part_list *)Malloc(sizeof(t_part_list));
  if (q == NULL)
    _OutMem();
  q->link_test_list = *p;
  q->pointer = NULL;
  if (link_part_list == NULL) {
    link_part_list = q;
    return;
  }
  r = link_part_list;
  while (r->pointer != NULL)
    r = r->pointer;
  r->pointer = q;
}  /* insert_part */


Static Void insert_test_in_sort_list(p, unordered, down, link_sort_list)
t_sort_list **p;
boolean unordered, down;
t_sort_list **link_sort_list;
{
  t_sort_list *q;

  (*p)->x = select_p_value((*p)->link_test_list);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1864L, 1L)) {
    write_real(stdout, (*p)->x, 10L, 6L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (down)
    (*p)->x = -(*p)->x;
  if (*link_sort_list == NULL) {
    *link_sort_list = *p;
    return;
  }
  if ((*p)->x <= (*link_sort_list)->x || unordered) {
    (*p)->pointer = *link_sort_list;
    *link_sort_list = *p;
    return;
  }
  if ((*link_sort_list)->pointer == NULL) {
    (*link_sort_list)->pointer = *p;
    (*p)->pointer = NULL;
    return;
  }
  q = *link_sort_list;
  while ((*p)->x > q->pointer->x && q->pointer->pointer != NULL)
    q = q->pointer;
  if ((*p)->x <= q->pointer->x) {
    (*p)->pointer = q->pointer;
    q->pointer = *p;
  } else {
    q->pointer->pointer = *p;
    (*p)->pointer = NULL;
  }
}  /* insert_test_in_sort_list */


Local boolean found_test(id_a, id_b, test)
t_model_specification **id_a, **id_b;
t_test *test;
{
  boolean ok = true;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1871L, 1L)) {
    memcpy(tzt, " FoundTest          ", sizeof(pch20));
    ntr_boolean(tzt, 20L, 1871L, 1L, -1L, -1L,
		test->test_type == pure_discrete);
    ntr_double_id(tzt, 20L, 1871L, 1L, -1L, -1L, id_a, id_b);
    ntr_double_id(tzt, 20L, 1871L, 1L, -1L, -1L, &test->id_1, &test->id_2);
  }
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1871L, 2L, -1L, -1L, ok);
  /*$endif TRACE*/
  if (ok)
    ok = identical_ids(id_b, &test->id_2);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1871L, 3L, -1L, -1L, ok);
  /*$endif TRACE*/
  if (ok)
    ok = identical_ids(id_a, &test->id_1);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 1871L, 4L, -1L, -1L, ok);
  /*$endif TRACE*/
  return ok;
}  /* found_test */


/*cte@+"rtest.p"*/

/*

1867:    +++  ++
1868:    +++  ++
1869:    ---  -- p/rtest.p          5      30     327 p/rtest.p
1870: |    4:    function sub_return_test
1871: |   17:    function found_test
1872: |  112:    function return_test
1873: |  127:    function return_test_g_c_model
1874: |  140:    procedure test_models
1875:    +++  ++
1876:    +++  ++

*/


Static boolean sub_return_test_id(id_a, id_b, p, test)
t_model_specification **id_a, **id_b;
t_test_list **p;
t_test *test;
{
  boolean found;
  t_long_integer paritet;
  t_2_3_key key;
  t_part_list *q;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1870L, 1L)) {
    write_line(stdout);
    write_pch(stdout, " Return test:", 13L);
    print_id(id_a, true, 10L, line_length);
    write_pch(stdout, " against ", 9L);
    print_id(id_b, true, 10L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (re_use_test) {
    found = false;
    paritet = return_double_parity(id_a, id_b);
    if (!boolean_option[113]) {
      key = paritet;
      find_test_in_2_3_tree(&key, &q);
      while (q != NULL && !found) {
	if (paritet == q->link_test_list->test.paritet)
	  found = found_test(id_a, id_b, &q->link_test_list->test);
	if (found)
	  *p = q->link_test_list;
	else
	  q = q->pointer;
      }
    } else {
      *p = link_test_list;
      while (*p != NULL && !found) {
	if (paritet == (*p)->test.paritet)
	  found = found_test(id_a, id_b, &(*p)->test);
	if (!found)
	  *p = (*p)->pointer;
      }
    }
    if (exact_test && found)
      found = ((*p)->test.number_of_tables == number_of_tables ||
	       number_of_tables == 0 && (*p)->test.number_of_tables > 0);
    if (found)
      *test = (*p)->test;
    return (test->ok && found);
  } else
    return false;
}  /* sub_return_test_id */


Static boolean sub_return_test(g_c_a, g_c_b, causal_structure, homogeneous, p,
			       test)
t_set_list **g_c_a, **g_c_b, **causal_structure;
boolean homogeneous;
t_test_list **p;
t_test *test;
{
  boolean Result, ok;
  t_model_specification *id_a, *id_b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubReturnTest      ", sizeof(pch20));
  ntr_triple_g_c(tzt, 20L, 1870L, 1L, 1L, 1L, g_c_a, g_c_b, causal_structure);
  /*$endif TRACE*/
  /* full_specified, */
  insert_g_c_in_id(g_c_a, causal_structure, true, homogeneous, &id_a);
  /* full_specified, */
  insert_g_c_in_id(g_c_b, causal_structure, true, homogeneous, &id_b);
  ok = sub_return_test_id(&id_a, &id_b, p, test);
  Result = ok;
  dispose_identification(&id_a);
  /*$ifdef TRACE*/
  dispose_identification(&id_b);
  ntr_triple_g_c(tzt, 20L, 1870L, 1L, 1L, 9L, g_c_a, g_c_b, causal_structure);
  ntr_boolean(tzt, 20L, 1870L, 1L, 1L, 9L, ok);
  /*$endif TRACE*/
  return Result;
}  /* sub_return_test */


Static boolean return_test(current_model, base_model, p, test)
t_model **current_model, **base_model;
t_test_list **p;
t_test *test;
{
  boolean Result;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnTest         ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1872L, 1L, 1L, 1L, current_model);
  ntr_model_g_c(tzt, 20L, 1872L, 1L, 1L, 2L, base_model);
  /*$endif TRACE*/
  clear_test(test);
  Result = sub_return_test_id(&(*current_model)->id, &(*base_model)->id, p,
			      test);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1872L, 1L, -1L, -1L);
  /*$endif TRACE*/
  return Result;
}  /* return_test */


Static boolean return_test_g_c_model(g_c, base, p, test)
t_set_list **g_c;
t_model **base;
t_test_list **p;
t_test *test;
{
  boolean Result;
  t_model_specification *current_id;

  /* base^.id^.full_specified, */
  insert_g_c_in_id(g_c, &(*base)->id->causal_structure, true,
		   (*base)->id->UU.U1.homogeneous, &current_id);
  Result = sub_return_test_id(&current_id, &(*base)->id, p, test);
  dispose_identification(&current_id);
  return Result;
}  /* return_test_g_c_model */


Static Void test_models(current, base, g, write_options, test_labels)
t_model **current, **base;
long *g;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_test test;
  t_test_list *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " TestModels         ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1874L, 1L, -1L, 1L, current);
  ntr_model_g_c(tzt, 20L, 1874L, 1L, -1L, 2L, base);
  /*$endif TRACE*/
  /* clear_test(test); */
  if (return_test(current, base, &p, &test))
    (*test_labels)->reused_test = true;
  else {
    (*test_labels)->reused_test = false;
    compute_test(current, base, g, &p, &test);
    if (exact_test && exact_test_for_test_models)
      test_exact_test(current, base, &p, &test);
  }
  if ((*write_options)->write_test)
    write_test(&test, write_options, test_labels);
  /*$ifdef TRACE*/
  insert_part(&p);
  ntr_model_g_c(tzt, 20L, 1874L, 8L, -1L, 998L, current);
  ntr_model_g_c(tzt, 20L, 1874L, 8L, -1L, 999L, base);
  /*$endif TRACE*/
}  /* test_link_models */


/*@+"sumup.p"*/


/*

1877:    +++  ++
1878:    +++  ++
1879:    ---  -- p/sumup.p          3      12     197 p/sumup.p
1880: |    4:    procedure remove_sub_cliques
1881: |   28:    procedure add_not_sub_cliques
1882: |   39:    procedure sum_up_partitioning
1883:    +++  ++
1884:    +++  ++

*/


Static Void sum_up_partitioning(link_sort_list, direction, parted,
				write_options, test_labels, excl)
t_sort_list **link_sort_list;
t_long_integer direction;
boolean *parted;
t_test_write_options **write_options;
t_test_labels **test_labels;
boolean excl;
{
  boolean homogeneous = true, full_specified = false, reuse = false;
  t_test test, ret_test;
  t_set_list *g_c_1 = NULL, *g_c_2 = NULL;
  t_test_list *lpl_ltl;

  /* !!!! */
  *link_sort_list = (t_sort_list *)Malloc(sizeof(t_sort_list));
  if (*link_sort_list == NULL)
    _OutMem();
  /* !!!! */
  (*link_sort_list)->pointer = NULL;
  if (link_part_list->pointer == NULL) {
    (*link_sort_list)->link_sepa_list = NULL;
    (*link_sort_list)->link_part_list = NULL;
    (*link_sort_list)->link_test_list = link_part_list->link_test_list;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1882L, 1L)) {
      write_line(stdout);
      write_pch(stdout, " Df(F*test): ", 13L);
      write_integer(stdout, link_part_list->link_test_list->test.n_count -
			    link_part_list->link_test_list->test.f_test_df,
		    3L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    _Free(link_part_list);
    link_part_list = NULL;
    return;
  }
  (*link_sort_list)->link_sepa_list = NULL;
  (*link_sort_list)->link_part_list = link_part_list;
  clear_test(&test);
  test.ok = true;
  test.n_count = 0;
  test.f_test_df = 0;
  test.df = 0;
  test.adj = 0;
  test.test_ifail = -3;
  test.x_deviance = 0.0;
  test.x_pearson = 0.0;
  test.x_power = 0.0;
  if (link_part_list != NULL) {
    if (link_part_list == NULL) {
      lpl_ltl = link_part_list->link_test_list;
      test.n_count = lpl_ltl->test.n_count;
      test.f_test_df = lpl_ltl->test.f_test_df;
      test.gamma = lpl_ltl->test.gamma;
      test.s = lpl_ltl->test.s;
      test.s1 = lpl_ltl->test.s1;
    }
  }
  while (link_part_list != NULL) {
    lpl_ltl = link_part_list->link_test_list;
    if (lpl_ltl->test.id_2->model_type == mixed) {
      if (!lpl_ltl->test.id_2->UU.U1.homogeneous)   /* !!! */
	homogeneous = false;
      if (!lpl_ltl->test.id_2->UU.U1.full_specified)
	full_specified = true;   /* !!! */
    }
    switch (direction) {

    case -1:
      remove_id_sub_cliques(&lpl_ltl->test.id_2, &g_c_1);
      add_id_cliques(lpl_ltl->test.id_1, &g_c_1);
      break;

    case 0:
      add_id_cliques(lpl_ltl->test.id_1, &g_c_1);
      break;

    case 1:
      add_id_not_sub_cliques(lpl_ltl->test.id_1, &g_c_2, &g_c_1);
      break;
    }
    add_id_cliques(lpl_ltl->test.id_2, &g_c_2);
    test.df += lpl_ltl->test.df;
    if (test.adj == _INFINITY || lpl_ltl->test.adj == _INFINITY)
      test.adj = _INFINITY;
    else
      test.adj += lpl_ltl->test.adj;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1882L, 1L)) {
      write_line(stdout);
      write_pch(stdout, " Df(F-test): ", 13L);
      write_integer(stdout, test.n_count - test.f_test_df, 3L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (lpl_ltl->test.ok) {
      if (test.f_test_df == _INFINITY || lpl_ltl->test.f_test_df == _INFINITY)
	test.f_test_df = _INFINITY;
      else
	test.f_test_df += lpl_ltl->test.f_test_df;
      test.x_deviance += lpl_ltl->test.x_deviance;
      if (em) {
	test.x_pearson = _INVALID_REAL;
	test.x_power = _INVALID_REAL;
      } else {
	test.x_pearson += lpl_ltl->test.x_pearson;
	test.x_power += lpl_ltl->test.x_power;
      }
    } else {
      test.x_deviance = _INVALID_REAL;
      test.x_pearson = _INVALID_REAL;
      test.x_power = _INVALID_REAL;
      test.ok = false;
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1882L, 1L)) {
      write_line(stdout);
      write_pch(stdout, " Df(F test): ", 13L);
      write_integer(stdout, test.n_count - test.f_test_df, 3L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    link_part_list = link_part_list->pointer;
  }
  insert_gcs_in_test(&g_c_1, &g_c_2, NULL, false, homogeneous, full_specified,
		     &test);
  if (exclude_missing)
    test.n_count = _INVALID_COUNT;
  else
    test.n_count = n[0];
  clear_test(&ret_test);
  if (sub_return_test_id(&test.id_1, &test.id_2,
			 &(*link_sort_list)->link_test_list, &ret_test)) {
    if (test.df == ret_test.df && test.f_test_df == ret_test.f_test_df &&
	fabs(test.x_pearson - ret_test.x_pearson) / test.x_pearson < 0.0001) {
      dispose_identification(&test.id_1);
      dispose_identification(&test.id_2);
      test.id_1 = ret_test.id_1;
      test.id_2 = ret_test.id_2;
      reuse = true;
    }
  }
  if (!reuse) {
    insert_test(&(*link_sort_list)->link_test_list, &test);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1882L, 1L)) {
      write_line(stdout);
      write_pch(stdout, " Df(F-test): ", 13L);
      write_integer(stdout, test.n_count - test.f_test_df, 3L);
      write_integer(stdout, (*link_sort_list)->link_test_list->test.n_count -
			    (*link_sort_list)->link_test_list->test.f_test_df,
		    3L);
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (exact_test && exact_test_for_sum_up)
      test_exact_test_id(&test.id_1, &test.id_2,
			 &(*link_sort_list)->link_test_list, &test);
  }
  if (!(*write_options)->write_test)
    return;
  if (excl) {
    if ((*write_options)->line_form) {
      if ((*write_options)->write_models)
	write_pch(stdout, "  Diff. counts ", 15L);
      write_space(stdout, dimension - 4L);
      write_char(stdout, '?');
    } else {
      write_pch(stdout, " Different case-numbers", 23L);
      write_line(stdout);
    }
  }
  write_test(&test, write_options, test_labels);
}  /* sum_up_partitioning */


/*@+"onee.p"*/


/*

1885:    +++  ++
1886:    +++  ++
1887:    ---  -- p/onee.p          9      52     614 p/onee.p
1888: |    4:    procedure test_one_edge_discrete
1889: |  114:    procedure test_generating_classes
1890: |  124:    procedure test_one_edge_default
1891: |  155:    procedure test_one_edge_mixed
1892: |  177:    procedure test_one_edge_continuous
1893: |  263:    procedure one_edge_collaps_set
1894: |  318:    procedure one_edge_collaps
1895: |  342:    function test_if_one_edge_decomposable
1896: |  403:    function test_if_one_edge
1897:    +++  ++
1898:    +++  ++

*/


Static Void test_one_edge_discrete(c, bv, bw, v, w, p_test, write_options,
				   test_labels)
long *c, *bv, *bw;
t_vertex *v, *w;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean ok, reuse;
  t_model *current_model, *base_model;
  t_test test;
  t_long_integer dummy_0 = 0;
  t_vertex_set vertex_set;
  t_offset bv_offset, bw_offset, c_offset;
  t_slice_pack slice_pack;
  t_set_list *tmp_cs;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  tmp_cs = causal_structure;   /* CausalStructure !!! */
  /*$ifdef TRACE*/
  memcpy(tzt, " TestOneEdgeDiscrete", sizeof(pch20));
  ntr_set(tzt, 20L, 1888L, 1L, -1L, -1L, c);
  ntr_set(tzt, 20L, 1888L, 1L, -1L, (long)(*v), bv);
  ntr_set(tzt, 20L, 1888L, 1L, -1L, (long)(*w), bw);
  /*$endif TRACE*/

  /* if write_options^.write_test then  PrintExclude */
  /*    write_char(output, '*')   PrintExclude */
  /* else                               PrintExclude */
  /*    write_char(output, '%');  PrintExclude */

  new_model(&current_model);
  erase_model(&current_model, pure_discrete, true);
  insert_set_in_set_list(bv, &current_model->id->UU.g_c_log_linear);
  insert_set_in_set_list(bw, &current_model->id->UU.g_c_log_linear);
  copy_ordered_set_list(tmp_cs, &current_model->id->causal_structure);
  P_setcpy(current_model->id->vertices, c);

  new_model(&base_model);
  erase_model(&base_model, pure_discrete, true);
  insert_set_in_set_list(c, &base_model->id->UU.g_c_log_linear);
  copy_ordered_set_list(tmp_cs, &base_model->id->causal_structure);
  P_setcpy(base_model->id->vertices, c);

  clear_test(&test);
  if (return_test(&current_model, &base_model, p_test, &test)) {
    if (exclude_missing && (*write_options)->write_test)
      print_n_total_exclude(c, write_options, test_labels, test.n_count);
    reuse = true;
  } else {
    reuse = false;
    /* write_char(output, '1'); PrintExclude */
    if (exclude_missing)
      print_do_exclude(current_model->id->vertices, write_options,
		       test_labels);
    P_setdiff(vertex_set, delta, c);
    current_model->constant = 1 / marginal_dimension_real(vertex_set);
    base_model->constant = current_model->constant;
    find_formula_for_two_set_model(current_model, bv, bw, &tmp_cs, false,
				   pure_discrete);
    find_formula_for_one_set_model(base_model, c, &tmp_cs, false,
				   pure_discrete);
    compute_test(&current_model, &base_model, c, p_test, &test);
  }
  insert_part(p_test);
  if (!reuse) {
    if (ordinal_tests && !(em || incomplete_table)) {
      if (P_inset(*v, ordinal_factors) & P_inset(*w, ordinal_factors)) {
	if (em)
	  write_warning_em(stdout, 1888L, " TestOneEdgeDiscrete");
	P_setint(vertex_set, bv, bw);
	bv_offset = return_offset(bv, &ok);
	if (ok)
	  bw_offset = return_offset(bw, &ok);
	if (ok)
	  c_offset = return_offset(c, &ok);
	if (ok) {
	  find_slice_products(vertex_set, bv, bw, c, v, w, &slice_pack);
	  compute_slice_statistics(v, w,
	    &variable_description[*v - MIN_VERTEX]->UU.U0.levels,
	    &variable_description[*w - MIN_VERTEX]->UU.U0.levels, vertex_set,
	    bv_offset, bw_offset, c_offset, &slice_pack, &test.gamma, &test.s,
	    &test.s1, false);
	  (*p_test)->test.gamma = test.gamma;
	  (*p_test)->test.s = test.s;
	  (*p_test)->test.s1 = test.s1;
	}
      }
    }
  }
  if (!exact_test) {
    if ((*write_options)->write_test)
      write_test(&test, write_options, test_labels);
  } else if (test.ok) {
    if (!TURBO_PC)
      ok = space_in_n_array(marginal_dimension(c), fna);
    if (marginal_dimension(c) <= max_cell_number - fna) {
      if ((!reuse) & (select_asymptotic_p_value(*p_test) < asymptotic_limit)) {
	if (fast && boolean_option[125])
	  compute_mcep_one_edge_set(c, bv, bw, v, w, p_test, &test);
	else
	  compute_mcep_one_edge_set_old(c, bv, bw, v, w, &current_model,
					&base_model, p_test, &test);
      }
      if ((*write_options)->write_test)
	write_test(&test, write_options, test_labels);
    } else {
      if ((*write_options)->write_test)
	write_test(&test, write_options, test_labels);
      write_pch(stdout, " Out of space in Exact Test", 27L);
      write_line(stdout);
    }
  } else {
    if ((*write_options)->write_test)
      write_test(&test, write_options, test_labels);
    write_pch(stdout, " Out of space in One Edge", 25L);
    write_line(stdout);
  }
  dispose_marginals_cond();
  dispose_model_and_link(&current_model);
  /*$ifdef TRACE*/
  dispose_model_and_link(&base_model);
  /*$endif TRACE*/
  ntr(tzt, 20L, 1889L, 1L, -1L, 8L);
}  /* test_one_edge_discrete */


/*Has-forward-1*/

Static Void test_generating_classes PP((t_set_list **current_g_c,
    t_set_list **base_g_c, t_set_list **causal_structure,
    boolean *homogeneous, long *g, t_test_write_options **write_options,
    t_test_labels **test_labels));


/*Has-forward-1*/

Static Void test_one_edge_default(c, bv, bw, v, w, homogeneous, p_test,
				  write_options, test_labels)
long *c, *bv, *bw;
t_vertex *v, *w;
boolean *homogeneous;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_set_list *current_g_c = NULL, *base_g_c = NULL;
  t_set_list *tmp_cs;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  tmp_cs = causal_structure;   /* CausalStructure !!! */
  /*$ifdef TRACE*/
  memcpy(tzt, " TestOneEdgeDefault ", sizeof(pch20));
  ntr_set(tzt, 20L, 1890L, 1L, -1L, -1L, c);
  ntr_set(tzt, 20L, 1890L, 1L, -1L, (long)(*v), bv);
  ntr_set(tzt, 20L, 1890L, 1L, -1L, (long)(*w), bw);
  /*$endif TRACE*/
  insert_set_in_set_list(bv, &current_g_c);
  insert_set_in_set_list(bw, &current_g_c);
  insert_set_in_set_list(c, &base_g_c);
  test_generating_classes(&current_g_c, &base_g_c, &tmp_cs, homogeneous, c,
			  write_options, test_labels);
  *p_test = NULL;   /* ?!?!? */
  dispose_set_list(&current_g_c);
  /*$ifdef TRACE*/
  dispose_set_list(&base_g_c);
  /*$endif TRACE*/
  ntr(tzt, 20L, 1890L, 1L, -1L, 8L);
}  /* test_one_edge_default */


Static Void test_one_edge_mixed(c, bv, bw, v, w, homogeneous, p_test,
				write_options, test_labels)
long *c, *bv, *bw;
t_vertex *v, *w;
boolean *homogeneous;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " TestOneEdgeMixed   ", sizeof(pch20));
  ntr_set(tzt, 20L, 1891L, 1L, -1L, -1L, c);
  ntr_set(tzt, 20L, 1891L, 1L, -1L, (long)(*v), bv);
  ntr_set(tzt, 20L, 1891L, 1L, -1L, (long)(*w), bw);
  /*$endif TRACE*/
  /* Implement page 193, SLL !!!! */
  /*$ifdef TRACE*/
  test_one_edge_default(c, bv, bw, v, w, homogeneous, p_test, write_options,
			test_labels);
  /*$endif TRACE*/
  ntr(tzt, 20L, 1891L, 1L, -1L, 8L);
}  /* test_one_edge_mixed */


Static Void test_one_edge_continuous(c, bv, bw, v, w, homogeneous, p_test,
				     write_options, test_labels)
long *c, *bv, *bw;
t_vertex *v, *w;
boolean *homogeneous;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean ok, reuse;
  t_model *current_model, *base_model;
  t_test test;
  t_set_list *g_c, *tmp_cs;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  tmp_cs = causal_structure;   /* CausalStructure !!! */
  /*$ifdef TRACE*/
  memcpy(tzt, " TestOneEdgeContinu.", sizeof(pch20));
  ntr_set(tzt, 20L, 1892L, 1L, -1L, -1L, c);
  ntr_set(tzt, 20L, 1892L, 1L, -1L, (long)(*v), bv);
  ntr_set(tzt, 20L, 1892L, 1L, -1L, (long)(*w), bw);
  /*$endif TRACE*/
  if (boolean_option[109])
    test_one_edge_default(c, bv, bw, v, w, homogeneous, p_test, write_options,
			  test_labels);
  else {
    g_c = NULL;
    insert_set_in_set_list(bv, &g_c);
    insert_set_in_set_list(bw, &g_c);
    /* Default causal structure !!! */
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 1892L, 1L, -1L, 2L, &g_c);
    /*$endif TRACE*/
    new_model(&current_model);
    insert_g_c_in_model(&g_c, c, &tmp_cs, false, *homogeneous, &current_model);
    insert_set_in_set_list(c, &g_c);
    /*$ifdef TRACE*/
    ntr_g_c(tzt, 20L, 1892L, 1L, -1L, 2L, &g_c);
    /*$endif TRACE*/
    /* Default causal structure !!! */
    new_model(&base_model);
    insert_g_c_in_model(&g_c, c, &tmp_cs, false, *homogeneous, &base_model);
    clear_test(&test);
    if (return_test(&current_model, &base_model, p_test, &test)) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1892L, 1L, 2L, 1L);
      /*$endif TRACE*/
      if (exclude_missing && (*write_options)->write_test)
	print_n_total_exclude(c, write_options, test_labels, test.n_count);
      reuse = true;
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1892L, 1L, 2L, 2L);
      /*$endif TRACE*/
      reuse = false;
      /* write_char(output, '2'); PrintExclude */
      if (exclude_missing)
	print_do_exclude(current_model->id->vertices, write_options,
			 test_labels);
      sub_test_one_edge_continuous(&current_model, &base_model, c, bv, bw, v,
				   w, homogeneous, &ok, p_test, &test,
				   &(*write_options)->examin_terms);
    }
    insert_part(p_test);
    if (!exact_test) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1892L, 1L, 3L, 1L);
      /*$endif TRACE*/
      if ((*write_options)->write_test)
	write_test(&test, write_options, test_labels);
    } else if (test.ok) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1892L, 1L, 3L, 2L);
      /*$endif TRACE*/
      if (ok) {
	if ((!reuse) & (select_asymptotic_p_value(*p_test) < asymptotic_limit)) {
	  /* Monte Carlo */
	  /* compute_mcep_one_edge_set(c, bv, bw, v, w, p_test, test); */
	  if ((*write_options)->write_test)
	    write_test(&test, write_options, test_labels);
	}
      } else {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1892L, 1L, 3L, 4L);
	/*$endif TRACE*/
	if ((*write_options)->write_test)
	  write_test(&test, write_options, test_labels);
	write_pch(stdout, " Out of space in Exact Test", 27L);
	write_line(stdout);
      }
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1892L, 1L, 3L, 5L);
      /*$endif TRACE*/
      if ((*write_options)->write_test)
	write_test(&test, write_options, test_labels);
      write_pch(stdout, " Out of space in One Edge", 25L);
      write_line(stdout);
    }
    dispose_model_and_link(&current_model);
    dispose_model_and_link(&base_model);
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr(tzt, 20L, 1892L, 1L, -1L, 8L);
}  /* test_one_edge_continuous */


Static Void one_edge_collaps_set(c, bv, bw, v, w, homogeneous, p_test,
				 write_options, test_labels)
long *c, *bv, *bw;
t_vertex *v, *w;
boolean *homogeneous;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " OneEdgeCollapsSet  ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1893L, 1L, -1L, -1L, *homogeneous);
  ntr_set(tzt, 20L, 1893L, 1L, -1L, -1L, c);
  ntr_set(tzt, 20L, 1893L, 1L, -1L, (long)(*v), bv);
  ntr_set(tzt, 20L, 1893L, 1L, -1L, (long)(*w), bw);
  /*$endif TRACE*/
  if (incomplete_table) {
    write_pch(stdout, " *** WARNING ***  OneEdgeCollaps used on", 40L);
    write_pch(stdout, " Incomplete Table  *** WARNING ***", 34L);
    write_line(stdout);
  }
  if (!(*write_options)->line_form && (*write_options)->write_test) {
    write_pch(stdout, " Collaps onto ", 14L);
    print_vertex_set(c);
    write_line(stdout);
  }
  if (mixed_data) {
    if (P_inset(*v, delta) & P_inset(*w, delta)) {
      if (P_subset(c, delta))
	test_one_edge_discrete(c, bv, bw, v, w, p_test, write_options,
			       test_labels);
      else
	test_one_edge_default(c, bv, bw, v, w, homogeneous, p_test,
			      write_options, test_labels);
    } else if (P_inset(*v, gamma_) & P_inset(*w, gamma_))
      test_one_edge_continuous(c, bv, bw, v, w, homogeneous, p_test,
			       write_options, test_labels);
    else
      test_one_edge_mixed(c, bv, bw, v, w, homogeneous, p_test, write_options,
			  test_labels);
  } else
    test_one_edge_discrete(c, bv, bw, v, w, p_test, write_options,
			   test_labels);
  if (em) {
    write_pch(stdout, " *** WARNING ***  OneEdgeCollaps used on", 40L);
    write_pch(stdout, " Incomplete Data   *** WARNING ***", 34L);
    write_line(stdout);
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr(tzt, 20L, 1893L, 1L, -1L, 8L);
}  /* one_edge_collaps_set */


Static Void one_edge_collaps(adj_set, v, w, homogeneous, p_test,
			     write_options, test_labels)
t_vertex_set *adj_set;
t_vertex *v, *w;
boolean *homogeneous;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_vertex u;
  t_vertex_set a, b, c, bv, bw;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " OneEdgeCollaps     ", sizeof(pch20));
  ntr_vertex(tzt, 20L, 1894L, 1L, -1L, 1L, v);
  ntr_vertex(tzt, 20L, 1894L, 1L, -1L, 2L, w);
  P_addset(P_expset(a, 0L), *v);
  P_addset(a, *w);
  /*$endif TRACE*/
  P_setcpy(b, empty_set);
  for (u = first_vertex; u <= last_vertex; u++) {
    if (P_subset(a, adj_set[u - MIN_VERTEX]))
      P_addset(b, u);
  }
  P_setcpy(bv, b);
  P_addset(bv, *v);
  P_setcpy(bw, b);
  P_addset(bw, *w);
  P_setunion(c, a, b);
  /*$ifdef TRACE*/
  ntr_4_sets(tzt, 20L, 1894L, 1L, -1L, 3L, a, bv, bw, c);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  one_edge_collaps_set(c, bv, bw, v, w, homogeneous, p_test, write_options,
		       test_labels);
  ntr(tzt, 20L, 1894L, 1L, -1L, 8L);
  /*$endif TRACE*/
}  /* one_edge_collaps */


Static boolean test_if_one_edge_decomposable(current_g_c, base_g_c,
  causal_structure, homogeneous, p_test, write_options, test_labels)
t_set_list **current_g_c, **base_g_c, **causal_structure;
boolean *homogeneous;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean Result = false;
  t_vertex_set a, b, g;
  t_edge_list *link_edge_list, *p;
  t_v_arr_of_v_sets adj_set_1, adj_set_2;
  t_v_arr_of_v_lists adj_list_2;
  t_vertex u, v, w;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " TestIfOneEdgeDeco  ", sizeof(pch20));
  ntr(tzt, 20L, 1895L, 1L, -1L, 1L);
  if (trace_flag_set(20L, 1903L, 1L)) {
    print_g_c(*current_g_c, 0L, line_length);
    print_g_c(*base_g_c, 0L, line_length);
    print_g_c(*causal_structure, 0L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (!incomplete_table && *causal_structure == NULL) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1895L, 1L, -1L, 2L);
    /*$endif TRACE*/
    hypergraph_sets_to_graph_sets(*current_g_c, g, adj_set_1);
    hypergraph_sets_to_graph_sets(*base_g_c, g, adj_set_2);
    link_edge_list = NULL;
    adj_set_to_adj_list(adj_set_2, adj_list_2);
    find_edges(adj_list_2, adj_set_1, &link_edge_list);
    dispose_adj_list(adj_list_2);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1895L, 1L, -1L, 3L);
    /*$endif TRACE*/
    if (link_edge_list != NULL) {
      if (link_edge_list->pointer == NULL) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1895L, 1L, -1L, 5L);
	/*$endif TRACE*/
	Result = true;
	v = link_edge_list->v;
	w = link_edge_list->w;
	if (mixed_data) {
	  /*$ifdef TRACE*/
	  ntr(tzt, 20L, 1895L, 1L, -1L, 6L);
	  /*$endif TRACE*/
	  Result = false;
	  if (P_inset(v, delta) & P_inset(w, delta)) {
	    /*$ifdef TRACE*/
	    ntr(tzt, 20L, 1895L, 1L, 4L, 1L);
	    P_addset(P_expset(a, 0L), v);
	    P_addset(a, w);
	    /*$endif TRACE*/
	    P_setcpy(b, empty_set);
	    for (u = first_vertex; u <= last_vertex; u++) {
	      if (P_subset(a, adj_set_1[u - MIN_VERTEX]))
		P_addset(b, u);
	    }
	    P_setint(b, gamma_, b);
	    /*$ifdef TRACE*/
	    ntr(tzt, 20L, 1895L, 1L, 4L, 2L);
	    /*$endif TRACE*/
	    if (P_setequal(b, empty_set)) {
	      /*$ifdef TRACE*/
	      ntr(tzt, 20L, 1895L, 1L, 5L, 1L);
	      /*$endif TRACE*/
	      Result = true;
	      /*$ifdef TRACE*/
	      one_edge_collaps(adj_set_1, &v, &w, homogeneous, p_test,
			       write_options, test_labels);
	      ntr(tzt, 20L, 1895L, 1L, 5L, 2L);
	      /*$endif TRACE*/
	    }
	  } else {
	    if (P_inset(v, gamma_) & P_inset(w, gamma_)) {
	      /*$ifdef TRACE*/
	      ntr(tzt, 20L, 1895L, 1L, 6L, 1L);
	      /*$endif TRACE*/
	      Result = true;
	      /*$ifdef TRACE*/
	      one_edge_collaps(adj_set_1, &v, &w, homogeneous, p_test,
			       write_options, test_labels);
	      ntr(tzt, 20L, 1895L, 1L, 6L, 2L);
	      /*$endif TRACE*/
	    } else {
	      /*$ifdef TRACE*/
	      ntr(tzt, 20L, 1895L, 1L, 7L, 1L);
	      /*$endif TRACE*/
	      /* Mixed pair, not implemented !?!?! */
	    }
	  }
	} else {
	  /*$ifdef TRACE*/
	  ntr(tzt, 20L, 1895L, 1L, 2L, 1L);
	  /*$endif TRACE*/
	  /*$ifdef TRACE*/
	  one_edge_collaps(adj_set_1, &v, &w, homogeneous, p_test,
			   write_options, test_labels);
	  ntr(tzt, 20L, 1895L, 1L, 2L, 2L);
	  /*$endif TRACE*/
	}
      }
      while (link_edge_list != NULL) {
	p = link_edge_list;
	link_edge_list = link_edge_list->pointer;
	_Free(p);
      }
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1895L, 1L, 8L, 8L);
  /*$endif TRACE*/
  return Result;
}  /* test_if_one_edge_decomposable */


Static boolean test_if_one_edge(g_c_current, g_c_base, causal_structure,
  homogeneous, p_test, write_options, test_labels)
t_set_list **g_c_current, **g_c_base, **causal_structure;
boolean *homogeneous;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  /* if write_options^.write_test then  PrintExclude */
  /*    write_char(output, '+')   PrintExclude */
  /* else                               PrintExclude */
  /*    write_char(output, '-');  PrintExclude */
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  if (*g_c_base == NULL || *g_c_current == NULL)
    return false;
  if ((*g_c_current)->pointer != NULL && *causal_structure == NULL) {
    if ((*g_c_base)->pointer == NULL &&
	(*g_c_current)->pointer->pointer == NULL)
      return (test_if_one_edge_decomposable(g_c_current, g_c_base,
		causal_structure, homogeneous, p_test, write_options,
		test_labels));
  }
  return false;
}  /* test_if_one_edge */


/*@+"part.p"*/


/*

1899:    +++  ++
1900:    +++  ++
1901:    ---  -- p/part.p          9      28     454 p/part.p
1902: |    5:    procedure test_generating_classes
1903: |   11:    procedure test_generating_classes
1904: |  116:    procedure print_partitioning
1905: |  178:    procedure write_partitioning
1906: |  217:    procedure partitioning_hierarchical
1907: |  339:    procedure do_partitioning
1908: |  402:    procedure silent_partitioning
1909: |  455:    procedure return_test_and_write
1910: |  488:    procedure factorization_one_edge_exact
1911:    +++  ++
1912:    +++  ++

*/

/*Has-forward-2*/

Static Void test_generating_classes(current_g_c, base_g_c, causal_structure,
  homogeneous, g, write_options, test_labels)
t_set_list **current_g_c, **base_g_c, **causal_structure;
boolean *homogeneous;
long *g;
t_test_write_options **write_options;
t_test_labels **test_labels;
{

  /*Has-forward-2*/

  /* No-forward

procedure test_generating_classes
(var current_g_c, base_g_c, causal_structure : t_link_set_list;
   var homogeneous     : boolean;
   var g     : t_vertex_set;
   var write_options     : t_link_test_write_options;
   var test_labels     : t_link_test_labels);

    No-forward */
  boolean force_contionuous, do_insert;
  /* reuse, */
  boolean ok, keep_write_test;
  t_model *current_model, *base_model;
  t_vertex_set a;
  t_test_list *p = NULL;
  t_test_list *link_test;
  t_model_list *p_model;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " TestGeneratingCla. ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 1903L, 1L, -1L, 1L, *homogeneous);
  if (trace_flag_set(20L, 1903L, 1L)) {
    print_g_c(*current_g_c, 0L, line_length);
    print_g_c(*base_g_c, 0L, line_length);
    print_g_c(*causal_structure, 0L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  if (trace_flag[TRACE_FLAG_FACTOR * 1903])
    visit_2_3_tree_preorder(0L, &model_2_3_tree);
  /*$endif TRACE*/
  /* if write_options^.write_test then  PrintExclude */
  /*    write_char(output, '*')   PrintExclude */
  /* else                               PrintExclude */
  /*    write_char(output, '%');  PrintExclude */
  new_test(&link_test);
  keep_write_test = (*write_options)->write_test;
  if (sub_return_test(current_g_c, base_g_c, causal_structure, *homogeneous,
		      &p, &link_test->test)) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1903L, 1L, 2L, 1L);
    /*$endif TRACE*/
    /* reuse := true; */
    if ((*write_options)->write_test) {
      if (exclude_missing) {
	/* write_char(output, '[');  PrintExclude */
	print_n_total_exclude(g, write_options, test_labels,
			      link_test->test.n_count);
	/* write_char(output, ']');  PrintExclude */
      }
      write_test(&link_test->test, write_options, test_labels);
    }
    insert_part(&p);
  } else {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1903L, 1L, 3L, 1L);
    /*$endif TRACE*/
    /* reuse := false; */
    (*write_options)->write_test = false;
    if (test_if_one_edge(current_g_c, base_g_c, causal_structure, homogeneous,
			 &p, write_options, test_labels)) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1903L, 1L, 4L, 1L);
      /*$endif TRACE*/
      (*write_options)->write_test = keep_write_test;
      /* write_char(output, '[');  PrintExclude */
      if (exclude_missing)
	print_do_exclude(g, write_options, test_labels);
      /* write_char(output, ']');  PrintExclude */
      link_test->test = p->test;
      /* write_char(output, '#');  PrintExclude */
      do_insert = false;
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1903L, 1L, 5L, 1L);
      /*$endif TRACE*/
      (*write_options)->write_test = keep_write_test;
      /* write_char(output, '(');  PrintExclude */
      if (exclude_missing)
	print_do_exclude(g, write_options, test_labels);
      /* write_char(output, ')');  PrintExclude */
      new_model(&current_model);
      P_setcpy(a, empty_set);
      add_union_of_gc(*base_g_c, a);
      force_contionuous = P_subset(a, gamma_);
      P_setcpy(a, empty_set);
      add_union_of_gc(*current_g_c, a);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1903L, 1L, 5L, 101L);
      if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	visit_2_3_tree_preorder(0L, &model_2_3_tree);
      /*$endif TRACE*/
      sub_insert_g_c_in_model(current_g_c, a, causal_structure, false,
			      *homogeneous, force_contionuous,
			      &current_model);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1903L, 1L, 5L, 102L);
      if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	visit_2_3_tree_preorder(0L, &model_2_3_tree);
      /*$endif TRACE*/
      ok = return_model(&current_model, &p_model);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1903L, 1L, 5L, 103L);
      if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	visit_2_3_tree_preorder(0L, &model_2_3_tree);
      /*$endif TRACE*/
      if (!ok)
	ok = ok_model_to_test(&current_model);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1903L, 1L, 5L, 104L);
      if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	visit_2_3_tree_preorder(0L, &model_2_3_tree);
      ntr(tzt, 20L, 1903L, 1L, 5L, 2L);
      ntr_model_formula(tzt, 20L, 1903L, 2L, -1L, -1L, current_model);
      /*$endif TRACE*/
      dispose_marginals_cond();
      link_test->test.ok = false;
      if (ok) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1903L, 1L, 5L, 30L);
	if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	  visit_2_3_tree_preorder(0L, &model_2_3_tree);
	/*$endif TRACE*/
	new_model(&base_model);
	sub_insert_g_c_in_model(base_g_c, g, causal_structure, false,
				*homogeneous, false, &base_model);
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1903L, 1L, 5L, 40L);
	if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	  visit_2_3_tree_preorder(0L, &model_2_3_tree);
	/*$endif TRACE*/
	ok = return_model(&base_model, &p_model);
	/*$ifdef TRACE*/
	ntr_boolean(tzt, 20L, 1903L, 1L, 5L, 50L, ok);
	if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	  visit_2_3_tree_preorder(0L, &model_2_3_tree);
	/*$endif TRACE*/
	if (!ok)
	  ok = ok_model_to_test(&base_model);
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1903L, 1L, 5L, 3L);
	ntr_model_formula(tzt, 20L, 1903L, 3L, -1L, -1L, base_model);
	if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	  visit_2_3_tree_preorder(0L, &model_2_3_tree);
	/*$endif TRACE*/
	dispose_marginals_cond();
	if (ok)
	  compute_test(&current_model, &base_model, g, &p, &link_test->test);
	/*$ifdef TRACE*/
	if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	  visit_2_3_tree_preorder(0L, &model_2_3_tree);
	/*$endif TRACE*/
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1903L, 1L, 5L, 4L);
	ntr_model_formula(tzt, 20L, 1903L, 4L, -1L, 1L, current_model);
	ntr_model_formula(tzt, 20L, 1903L, 4L, -1L, 2L, base_model);
	/*$endif TRACE*/
	if (exact_test && exact_test_for_partitioning)
	  test_exact_test(&current_model, &base_model, &p, &link_test->test);
	dispose_marginals_cond();
	dispose_model_but_gc(&base_model);
	dispose_model_link(&base_model);
      }
      dispose_model_but_gc(&current_model);
      dispose_model_link(&current_model);
      /*$ifdef TRACE*/
      if (trace_flag[TRACE_FLAG_FACTOR * 1903])
	visit_2_3_tree_preorder(0L, &model_2_3_tree);
      /*$endif TRACE*/
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1903L, 1L, 5L, 5L);
      /*$endif TRACE*/
      if (fpa < P_START - FIRST_INDEX)
	fpa = P_START - FIRST_INDEX;
      do_insert = true;
    }
    if (!link_test->test.ok && re_use_test) {
      insert_gcs_in_test(current_g_c, base_g_c, *causal_structure, true,
			 *homogeneous, false, &link_test->test);
      link_test->test.n_count = n[0];
      insert_test(&p, &link_test->test);
    } else if (!link_test->test.ok)
      insert_gcs_in_test(current_g_c, base_g_c, NULL, false, *homogeneous,
			 false, &link_test->test);
    if ((*write_options)->write_test)
      write_test(&link_test->test, write_options, test_labels);
    if (do_insert)
      insert_part(&p);
  }
  (*write_options)->write_test = keep_write_test;
  /*$ifdef TRACE*/
  _Free(link_test);
  ntr(tzt, 20L, 1903L, 1L, -1L, 8L);
  /*$endif TRACE*/
}  /* test_generating_classes */


Static Void print_partitioning(adj_list, g, list_of_sets, indent)
t_vertex_list **adj_list;
long *g;
t_set_list *list_of_sets;
t_integer indent;
{
  t_set_list *p;
  t_vertex_set a, d, b, vertex_set;
  t_vertex u;

  if (list_of_sets == NULL)
    return;
  p = list_of_sets;
  write_space(stdout, indent + 1);
  write_pch(stdout, "Decompositions:  ", 17L);
  write_line(stdout);
  while (list_of_sets != NULL) {
    u = first_vertex;
    P_setdiff(vertex_set, g, list_of_sets->vertex_set);
    while (!P_inset(u, vertex_set))
      u++;
    find_connected_component(g, list_of_sets->vertex_set, a, &u, adj_list);
    write_space(stdout, indent + 1);
    P_setunion(vertex_set, a, list_of_sets->vertex_set);
    print_vertex_set_table(vertex_set);
    write_char(stdout, '(');
    write_integer(stdout, cardinality(vertex_set), 3L);
    write_pch(stdout, ") / ", 4L);
    print_vertex_set_table(list_of_sets->vertex_set);
    write_char(stdout, '(');
    write_integer(stdout, cardinality(list_of_sets->vertex_set), 3L);
    write_pch(stdout, ") / ", 4L);
    P_setdiff(vertex_set, g, a);
    print_vertex_set_table(vertex_set);
    write_char(stdout, '(');
    write_integer(stdout, cardinality(vertex_set), 3L);
    write_char(stdout, ')');
    write_line(stdout);
    list_of_sets = list_of_sets->pointer;
  }
  list_of_sets = p;
  write_space(stdout, indent + 1);
  write_pch(stdout, "Selected: ", 10L);
  write_line(stdout);
  pick_partitioning(adj_list, g, list_of_sets, a, d, b);
  write_space(stdout, indent + 1);
  P_setunion(vertex_set, a, d);
  print_vertex_set_table(vertex_set);
  write_char(stdout, '(');
  write_integer(stdout, cardinality(vertex_set), 3L);
  write_pch(stdout, ") / ", 4L);
  print_vertex_set_table(d);
  write_char(stdout, '(');
  write_integer(stdout, cardinality(d), 3L);
  write_pch(stdout, ") / ", 4L);
  P_setunion(vertex_set, d, b);
  print_vertex_set_table(vertex_set);
  write_char(stdout, '(');
  write_integer(stdout, cardinality(vertex_set), 3L);
  write_char(stdout, ')');
  write_line(stdout);
}  /* print_partitioning */


Static Void write_partitioning(current_model, base_model)
t_model **current_model, **base_model;
{
  t_set_list *list_of_sets, *current_g_c, *base_g_c, *q_current_g_c,
	     *q_base_g_c;
  t_vertex_set g;
  t_v_arr_of_v_lists adj_list;
  t_v_arr_of_v_sets adj_set;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_false();
  local_test_labels = new_test_labels_empty();
  current_g_c = return_g_c_copy_for_mixed_model(current_model);
  base_g_c = return_g_c_copy_for_mixed_model(base_model);
  if ((*current_model)->id->model_type == mixed)
    q_current_g_c = (*current_model)->id->UU.U1.g_c_quadratic;
  else
    q_current_g_c = NULL;   /* current_model^.id^.g_c_quadratic */
  if ((*base_model)->id->model_type == mixed)
    q_base_g_c = (*base_model)->id->UU.U1.g_c_quadratic;
  else
    q_base_g_c = NULL;   /* base_model^.id^.g_c_quadratic */
  if (sub_is_hier_subm(&current_g_c, &base_g_c, q_current_g_c, q_base_g_c,
		       &local_write_options, &local_test_labels, false)) {
    hypergraph_sets_to_graph_sets(base_g_c, g, adj_set);
    adj_set_to_adj_list(adj_set, adj_list);
    find_partitioning(&base_g_c, &base_g_c, adj_list, adj_set, g, true,
		      &list_of_sets);
    print_partitioning(adj_list, g, list_of_sets, 1L);
    dispose_adj_list(adj_list);
    dispose_set_list(&list_of_sets);
  }
  dispose_g_c_copy_for_mixed_model(current_model, &current_g_c);
  dispose_g_c_copy_for_mixed_model(base_model, &base_g_c);
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* write_partitioning */


Static Void partitioning_hierarchical(current_g_c, base_g_c, causal_structure,
  homogeneous, write_options, test_labels, number_of_tests)
t_set_list **current_g_c, **base_g_c, **causal_structure;
boolean *homogeneous;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_long_integer *number_of_tests;
{
  t_v_arr_of_v_lists adj_list;
  t_v_arr_of_v_sets adj_set;
  t_vertex_set a, b, d, g, apd, bpd;
  t_set_list *list_of_sets, *g_c_a1, *g_c_a2, *g_c_b1, *g_c_b2;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PartitioningHierarc", sizeof(pch20));
  if (trace_flag_set(20L, 1906L, 1L)) {
    write_space(stdout, (*test_labels)->indent);
    ntr(" < PartitioningHier ", 20L, 1906L, 1L, -1L, *number_of_tests);
    write_space(stdout, (*test_labels)->indent);
    print_g_c(*current_g_c, 0L, line_length);
    print_g_c(*base_g_c, 0L, line_length);
    print_g_c(*causal_structure, 0L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (sub_is_hier_subm(current_g_c, base_g_c, NULL, NULL, write_options,
		       test_labels, false)) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1906L, 1L, 1L, 1L);
    /*$endif TRACE*/
    hypergraph_sets_to_graph_sets(*base_g_c, g, adj_set);
    adj_set_to_adj_list(adj_set, adj_list);
    ok = false;
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1906L, 1L, 1L, 2L, g);
    /*$endif TRACE*/
    find_partitioning(current_g_c, base_g_c, adj_list, adj_set, g, true,
		      &list_of_sets);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1906L, 1L, 1L, 3L);
    /*$endif TRACE*/
    if (report && !global_write_options->line_form)
      print_partitioning(adj_list, g, list_of_sets, (*test_labels)->indent);
    /*$ifdef TRACE*/
    ntr_4_sets(tzt, 20L, 1906L, 1L, 1L, 4L, a, d, b, g);
    /*$endif TRACE*/
    if (list_of_sets != NULL) {
      pick_partitioning(adj_list, g, list_of_sets, a, d, b);
      dispose_set_list(&list_of_sets);
      P_setunion(apd, a, d);
      P_setunion(bpd, b, d);
      test_decomposable_hypergraph(current_g_c, apd, bpd, d, &g_c_a1, &g_c_b1);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
      ok = test_decomposable_hypergraph(base_g_c, apd, bpd, d, &g_c_a2,
					&g_c_b2);
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1906L, 1L, 1L, 5L);
    /*$endif TRACE*/
    dispose_adj_list(adj_list);
    if (ok) {
      if (!(*write_options)->line_form && (*write_options)->write_test) {
	write_space(stdout, (*test_labels)->indent + 1);
	write_pch(stdout, "Test of ", 8L);
	print_g_c(*current_g_c, (*test_labels)->indent + 10, line_length);
	write_line(stdout);
	write_space(stdout, (*test_labels)->indent + 1);
	write_pch(stdout, "against ", 8L);
	print_g_c(*base_g_c, (*test_labels)->indent + 10, line_length);
	write_line(stdout);
	write_space(stdout, (*test_labels)->indent + 1);
	write_pch(stdout, "Partition of ", 13L);
	print_vertex_set(g);
	write_pch(stdout, " in ", 4L);
	print_vertex_set(apd);
	write_char(stdout, ',');
	print_vertex_set(bpd);
	write_pch(stdout, " by ", 4L);
	print_vertex_set(d);
	write_line(stdout);
      }
      (*test_labels)->indent += 2;
      partitioning_hierarchical(&g_c_a1, &g_c_a2, causal_structure,
				homogeneous, write_options, test_labels,
				number_of_tests);
      dispose_set_list(&g_c_a1);
      dispose_set_list(&g_c_a2);
      partitioning_hierarchical(&g_c_b1, &g_c_b2, causal_structure,
				homogeneous, write_options, test_labels,
				number_of_tests);
      dispose_set_list(&g_c_b1);
      dispose_set_list(&g_c_b2);
      (*test_labels)->indent -= 2;
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1906L, 1L, 2L, 1L);
      /*$endif TRACE*/
      if ((*write_options)->write_test) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 1906L, 1L, 3L, 1L);
	/*$endif TRACE*/
	if (!(*write_options)->line_form) {
	  write_space(stdout, (*test_labels)->indent + 1);
	  write_pch(stdout, "Test on ", 8L);
	  print_vertex_set(g);
	  write_line(stdout);
	} else {
	  if (*number_of_tests != 0) {
	    if ((*write_options)->write_models)
	      write_space(stdout, 3L);
	    write_char(stdout, '+');
	    if ((*write_options)->write_models)
	      write_space(stdout, 3L);
	    if ((*write_options)->write_models) {
	      if ((*test_labels)->separators)
		write_space(stdout, 11L);
	    } else
	      write_line(stdout);
	  }
	}
      }
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 1906L, 1L, 2L, 2L);
      /*$endif TRACE*/
      (*number_of_tests)++;
      test_generating_classes(current_g_c, base_g_c, causal_structure,
			      homogeneous, g, write_options, test_labels);
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 1906L, 1L, 1L, 8L);
    /*$endif TRACE*/
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 1906L, 1L))
    return;
  /*$endif TRACE*/
  write_space(stdout, (*test_labels)->indent);
  ntr(" PartitioningHier > ", 20L, 1906L, 8L, -1L, *number_of_tests);
  write_space(stdout, (*test_labels)->indent);
  print_g_c(*current_g_c, 0L, line_length);
  print_g_c(*base_g_c, 0L, line_length);
  print_g_c(*causal_structure, 0L, line_length);
  write_line(stdout);
}  /* partitioning_hierarchical */


Static Void do_partitioning(d, current_model, base_model)
long *d;
t_model **current_model, **base_model;
{
  t_set_list *causal_structure, *g_c_a1, *g_c_a2, *g_c_b1, *g_c_b2,
	     *current_g_c, *base_g_c;
  t_v_arr_of_v_lists adj_list_2;
  t_v_arr_of_v_sets adj_set_2;
  t_vertex_set a, b, a0, g, vertex_set;
  t_vertex u;
  boolean full_specified, homogeneous;
  boolean ok = false;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_false();
  local_test_labels = new_test_labels_empty();
  current_g_c = return_g_c_copy_for_mixed_model(current_model);
  base_g_c = return_g_c_copy_for_mixed_model(base_model);
  if (sub_is_hier_subm(&current_g_c, &base_g_c, NULL, NULL,
		       &local_write_options, &local_test_labels, false)) {
    hypergraph_sets_to_graph_sets(base_g_c, g, adj_set_2);
    if (!P_setequal(g, d)) {
      adj_set_to_adj_list(adj_set_2, adj_list_2);
      u = first_vertex;
      P_setdiff(vertex_set, g, d);
      while ((u < last_vertex) & (!P_inset(u, vertex_set)))
	u++;
      find_connected_component(g, d, a0, &u, adj_list_2);
      dispose_adj_list(adj_list_2);
      P_setunion(a, a0, d);
      P_setdiff(b, g, a0);
      if (!P_setequal(g, a)) {
	if (test_decomposable_hypergraph(&current_g_c, a, b, d, &g_c_a1,
					 &g_c_b1)) {
	  if (test_decomposable_hypergraph(&base_g_c, a, b, d, &g_c_a2,
					   &g_c_b2)) {
	    ok = true;
	    copy_set_list((*current_model)->id->causal_structure,
			  &causal_structure);
	    full_specified = (*current_model)->id->UU.U1.full_specified;
	    homogeneous = (*current_model)->id->UU.U1.homogeneous;
	    insert_g_c_in_new_model(&g_c_a1, a, &causal_structure,
				    full_specified, homogeneous);
	    insert_g_c_in_new_model(&g_c_b1, b, &causal_structure,
				    full_specified, homogeneous);
	    full_specified = (*base_model)->id->UU.U1.full_specified;
	    homogeneous = (*base_model)->id->UU.U1.homogeneous;
	    insert_g_c_in_new_model(&g_c_a2, a, &causal_structure,
				    full_specified, homogeneous);
	    insert_g_c_in_new_model(&g_c_b2, b, &causal_structure,
				    full_specified, homogeneous);
	    dispose_set_list(&causal_structure);
	  } else {
	    dispose_set_list(&g_c_a1);
	    dispose_set_list(&g_c_b1);
	  }
	}
      }
    }
  }
  dispose_g_c_copy_for_mixed_model(current_model, &current_g_c);
  dispose_g_c_copy_for_mixed_model(base_model, &base_g_c);
  _Free(local_write_options);
  _Free(local_test_labels);
  if (!ok) {
    write_pch(stdout, " No partitioning", 16L);
    write_line(stdout);
  }
}  /* do_partitioning */


Static Void silent_partitioning(current_model, base_model, p, test,
				write_options, test_labels)
t_model **current_model, **base_model;
t_test_list **p;
t_test *test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_part_list *tmp_link_part_list;
  t_sort_list *link_sort_list = NULL;
  t_long_integer dummy = 0;
  boolean homogeneous, keep_write_test, tmp_exact;
  t_set_list *g_c_current, *g_c_base;

  tmp_link_part_list = link_part_list;
  keep_write_test = (*write_options)->write_test;
  tmp_exact = exact_test;
  exact_test = false;
  link_part_list = NULL;
  *p = NULL;
  g_c_current = return_g_c_copy_for_mixed_model(current_model);
  g_c_base = return_g_c_copy_for_mixed_model(base_model);
  if ((*current_model)->id->model_type == mixed)
    homogeneous = (*current_model)->id->UU.U1.homogeneous;
  else
    homogeneous = false;
  partitioning_hierarchical(&g_c_current, &g_c_base,
			    &(*current_model)->id->causal_structure,
			    &homogeneous, write_options, test_labels, &dummy);
  dispose_g_c_copy_for_mixed_model(current_model, &g_c_current);
  dispose_g_c_copy_for_mixed_model(base_model, &g_c_base);
  if (link_part_list != NULL) {
    if (link_part_list->pointer != NULL) {
      sum_up_partitioning(&link_sort_list, 0L, &c_partitioning, write_options,
			  test_labels,
			  exclude_missing && partitioning_output);
      *p = link_sort_list->link_test_list;
      link_sort_list->link_test_list = NULL;
    } else {
      *p = link_part_list->link_test_list;
      link_part_list->link_test_list = NULL;
    }
    dispose_sort_list(&link_sort_list);
    dispose_part_list(&link_part_list);
  }
  if (*p != NULL)
    *test = (*p)->test;
  link_part_list = tmp_link_part_list;
  (*write_options)->write_test = keep_write_test;
  exact_test = tmp_exact;
}  /* silent_partitioning */


Static Void return_test_and_write(current_model, base_model, g, write_options,
				  test_labels, exclude, reuse, p, test)
t_model **current_model, **base_model;
long *g;
t_test_write_options **write_options;
t_test_labels **test_labels;
boolean exclude, *reuse;
t_test_list **p;
t_test *test;
{
  /* var
     tmp : boolean; */
  clear_test(test);
  /* tmp := write_options^.write_test;
  write_options^.write_test := false; */
  if (return_test(current_model, base_model, p, test)) {
    /* write_char(output, '.');  PrintExclude */
    if (exclude && (*write_options)->write_test)
      print_n_total_exclude(g, write_options, test_labels, test->n_count);
    /* write_char(output, '.');  PrintExclude */
    *reuse = true;
  } else {
    *reuse = false;
    /* write_char(output, ':');  PrintExclude */
    if (exclude && (*write_options)->write_test)
      print_do_exclude((*current_model)->id->vertices, write_options,
		       test_labels);
    /* write_char(output, ':');  PrintExclude */
    compute_test(current_model, base_model, g, p, test);
  }
  if ((*write_options)->write_test)
    write_test(test, write_options, test_labels);
  /* write_options^.write_test := tmp; */
  insert_part(p);
}  /* return_test_and_write */


Static Void factorization_one_edge_exact(current_model, base_model, p_test,
					 write_options, test_labels)
t_model **current_model, **base_model;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean reuse;
  t_test test;
  t_vertex_set vertex_set;

  P_setunion(vertex_set, (*current_model)->id->vertices,
	     (*base_model)->id->vertices);
  return_test_and_write(current_model, base_model, vertex_set, write_options,
			test_labels, false, &reuse, p_test, &test);
  if (test.ok) {
    if (is_invalid_real(test.x_deviance))
      silent_partitioning(current_model, base_model, p_test, &test,
			  write_options, test_labels);
    if (!reuse)
      compute_mcep_nested_decomposable(current_model, base_model, false,
				       p_test, &test);
    if ((*write_options)->write_test)
      write_test(&test, write_options, test_labels);
    return;
  }
  write_pch(stdout, " Out of space in ExactTest of ", 30L);
      /* 8 + 0 + 30, */
  print_model_g_c(current_model, 8L);
  write_line(stdout);
  write_space(stdout, 7L);
  write_pch(stdout, " against ", 9L);   /* 8 + 0 + 9, */
  print_model_g_c(base_model, 8L);
  write_line(stdout);
}  /* factorization_one_edge_exact */


/*@-"edit.c"*/
/*@+"drop.p"*/


/*

1913:    +++  ++
1914:    +++  ++
1915:    ---  -- p/drop.p         47     198    2973 p/drop.p
1916: |    4:    procedure sub_drop_edge_from_g_c
1917: |   41:    procedure new_drop_edges_from_g_c
1918: |   71:    procedure old_drop_edges_from_g_c
1919: |  100:    procedure drop_edges_from_g_c
1920: |  109:    procedure drop_edge_from_g_c
1921: |  120:    procedure drop_edge
1922: |  143:    procedure sub_add_edge_to_g_c
1923: |  180:    procedure new_add_edges_to_g_c
1924: |  212:    procedure old_add_edges_to_g_c
1925: |  244:    procedure add_edges_to_g_c
1926: |  253:    procedure add_edge_to_g_c
1927: |  265:    procedure add_edge
1928: |  288:    procedure drop_interactions_from_g_c
1929: |  317:    procedure drop_interactions
1930: |  402:    procedure drop_interaction_from_g_c
1931: |  413:    procedure add_interactions_to_g_c
1932: |  427:    procedure add_interactions
1933: |  482:    procedure add_interaction_to_g_c
1934: |  492:    procedure meet_models
1935: |  544:    procedure join
1936: |  556:    procedure join_models
1937: |  615:    procedure edge_minus
1938: |  632:    procedure g_c_minus
1939: |  650:    procedure difference_models
1940: |  669:    procedure drop_total_generator
1941: |  720:    procedure remove_generator
1942: |  756:    procedure reduce_generator
1943: |  815:    procedure drop_factor
1944: |  857:    procedure generate_discrete_decomposable_model
1945: |  865:    procedure generate_continuous_decomposable_model
1946: |  873:    procedure generate_mixed_decomposable_model
1947: |  912:    procedure generate_decomposable_model
1948: |  941:    procedure generate_mixed_graphical_model
1949: |  958:    procedure generate_discrete_graphical_model
1950: |  983:    procedure generate_continuous_graphical_model
1951: | 1008:    procedure generate_graphical_model
1952: | 1020:    function is_decomposable_after_dropping_edge
1953: | 1057:    function is_decomposable_after_adding_edge
1954: | 1082:    function return_sub_g_c
1955: | 1137:    procedure generate_mixed_graphical_submodel
1956: | 1195:    procedure generate_discrete_graphical_submodel
1957: | 1213:    procedure generate_continuous_graphical_submodel
1958: | 1231:    procedure generate_graphical_submodel
1959: | 1242:    procedure generate_decomposable_submodel
1960: | 1272:    procedure min_max_log_l_of_model
1961: | 1339:    procedure set_min_max_log_l_of_mixed_item
1962: | 1345:    procedure set_min_max_log_l_of_mixed_item
1963:    +++  ++
1964:    +++  ++

*/

Static Void sub_drop_edge_from_g_c(new_g_c, old_g_c, v, w)
t_set_list **new_g_c, **old_g_c;
t_vertex v, w;
{
  t_vertex_set a, b;
  t_set_list *tmp_g_c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubDropEdgeFromGC  ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 1916L, 1L, (long)v, (long)w, old_g_c);
  ntr_g_c(tzt, 20L, 1916L, 1L, -1L, -1L, new_g_c);
  P_addset(P_expset(a, 0L), v);
  P_addset(a, w);
  /*$endif TRACE*/
  if (subset_of_an_edge(a, old_g_c)) {
    *new_g_c = NULL;
    tmp_g_c = *old_g_c;
    while (tmp_g_c != NULL) {
      if (P_subset(a, tmp_g_c->vertex_set)) {
	P_setcpy(b, tmp_g_c->vertex_set);
	P_remset(b, v);
	insert_clique(b, new_g_c);
	P_setcpy(b, tmp_g_c->vertex_set);
	P_remset(b, w);
	insert_clique(b, new_g_c);
      } else
	insert_clique(tmp_g_c->vertex_set, new_g_c);
      tmp_g_c = tmp_g_c->pointer;
    }
  } else {
    /*$ifdef TRACE*/
    copy_set_list(*old_g_c, new_g_c);
  }
  /*$endif TRACE*/
  ntr_g_c(tzt, 20L, 1916L, 8L, (long)v, (long)w, new_g_c);
}  /* sub_drop_edge_from_g_c */


Static Void new_drop_edges_from_g_c(new_g_c, old_g_c, drop_g_c)
t_set_list **new_g_c, **old_g_c, **drop_g_c;
{
  t_vertex v, w;
  t_vertex_set g, a;
  t_edge_list *p;
  t_edge_list *edge_list = NULL;
  t_set_list *tmp_g_c;

  P_setcpy(g, empty_set);
  add_union_of_gc(*old_g_c, g);
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    for (w = v + 1; w <= last_vertex; w++) {
      P_addset(P_expset(a, 0L), v);
      P_addset(a, w);
      if (P_subset(a, g)) {
	if (subset_of_an_edge(a, drop_g_c)) {
	  if (subset_of_an_edge(a, old_g_c))
	    insert_edge_in_edge_list(v, w, &edge_list);
	}
      }
    }
  }
  copy_set_list(*old_g_c, new_g_c);
  while (edge_list != NULL) {
    p = edge_list;
    tmp_g_c = *new_g_c;
    sub_drop_edge_from_g_c(new_g_c, &tmp_g_c, p->v, p->w);
    dispose_set_list(&tmp_g_c);
    edge_list = edge_list->pointer;
    _Free(p);
  }
}  /* new_drop_edges_from_g_c */


Static Void old_drop_edges_from_g_c(new_g_c, old_g_c, drop_g_c)
t_set_list **new_g_c, **old_g_c, **drop_g_c;
{
  t_edge_list *p;
  t_edge_list *edge_list = NULL;
  t_vertex v, w;
  t_vertex_set g, a;
  t_v_arr_of_v_sets old_adj_set, new_adj_set;

  hypergraph_sets_to_graph_sets(*old_g_c, g, old_adj_set);
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    for (w = v + 1; w <= last_vertex; w++) {
      P_addset(P_expset(a, 0L), v);
      P_addset(a, w);
      if (P_subset(a, g) & P_inset(w, old_adj_set[v - MIN_VERTEX])) {
	if (!subset_of_an_edge(a, drop_g_c))
	  insert_edge_in_edge_list(v, w, &edge_list);
      }
    }
  }
  for (v = first_vertex; v <= last_vertex; v++)
    P_setcpy(new_adj_set[v - MIN_VERTEX], empty_set);
  while (edge_list != NULL) {
    p = edge_list;
    P_addset(new_adj_set[p->v - MIN_VERTEX], p->w);
    P_addset(new_adj_set[p->w - MIN_VERTEX], p->v);
    edge_list = edge_list->pointer;
    _Free(p);
  }
  find_cliques(new_adj_set, g, new_g_c);
}  /* old_drop_edges_from_g_c */


Static Void drop_edges_from_g_c(new_g_c, old_g_c, drop_g_c)
t_set_list **new_g_c, **old_g_c, **drop_g_c;
{
  if (boolean_option[102])
    old_drop_edges_from_g_c(new_g_c, old_g_c, drop_g_c);
  else
    new_drop_edges_from_g_c(new_g_c, old_g_c, drop_g_c);
}  /* drop_edges_from_g_c */


Static Void drop_edge_from_g_c(new_g_c, old_g_c, a)
t_set_list **new_g_c, **old_g_c;
long *a;
{
  t_set_list *p = NULL;

  insert_set_in_set_list(a, &p);
  drop_edges_from_g_c(new_g_c, old_g_c, &p);
  dispose_set_list(&p);
}  /* drop_edge_from_g_c */


Static Void drop_edge(new__model, old_model, drop_g_c)
t_model **new__model, **old_model;
t_set_list **drop_g_c;
{
  t_set_list *g_c_old, *g_c_new;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DropEdge           ", sizeof(pch20));
  ntr_model(tzt, 20L, 1921L, 1L, -1L, -1L, *old_model);
  /*$endif TRACE*/
  g_c_old = return_g_c_copy_for_mixed_model(old_model);
  drop_edges_from_g_c(&g_c_new, &g_c_old, drop_g_c);
  insert_g_c_in_model(&g_c_new, (*old_model)->id->vertices,
		      &(*old_model)->id->causal_structure, false,
		      (*old_model)->id->UU.U1.homogeneous, new__model);
  /*$ifdef TRACE*/
  dispose_g_c_copy_for_mixed_model(old_model, &g_c_old);
  /*$endif TRACE*/
  ntr_model(tzt, 20L, 1921L, 8L, -1L, -1L, *new__model);
}  /* drop_edge */


Static Void sub_add_edge_to_g_c(new_g_c, old_g_c, v, w)
t_set_list **new_g_c, **old_g_c;
t_vertex v, w;
{
  t_vertex_set a, b;
  t_set_list *qv, *qw;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubAddEdgeToGC     ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 1922L, 1L, (long)v, (long)w, old_g_c);
  ntr_g_c(tzt, 20L, 1922L, 1L, -1L, -1L, new_g_c);
  /*$endif TRACE*/
  copy_set_list(*old_g_c, new_g_c);
  P_addset(P_expset(a, 0L), v);
  P_addset(a, w);
  insert_clique(a, new_g_c);
  qv = *old_g_c;
  while (qv != NULL) {
    if (P_inset(v, qv->vertex_set)) {
      qw = *old_g_c;
      while (qw != NULL) {
	if (P_inset(w, qw->vertex_set)) {
	  P_setint(b, qv->vertex_set, qw->vertex_set);
	  P_setunion(b, b, a);
	  insert_clique(b, new_g_c);
	}
	qw = qw->pointer;
      }
    }
    qv = qv->pointer;
  }
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  ntr_g_c(tzt, 20L, 1922L, 8L, (long)v, (long)w, new_g_c);
}  /* sub_add_edge_to_g_c */


Static Void new_add_edges_to_g_c(new_g_c, old_g_c, add_g_c, new_g)
t_set_list **new_g_c, **old_g_c, **add_g_c;
long *new_g;
{
  t_vertex v, w;
  t_vertex_set a;
  t_edge_list *p;
  t_edge_list *edge_list = NULL;
  t_set_list *tmp_g_c;

  P_setcpy(new_g, empty_set);
  add_union_of_gc(*add_g_c, new_g);
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    for (w = v + 1; w <= last_vertex; w++) {
      P_addset(P_expset(a, 0L), v);
      P_addset(a, w);
      if (P_subset(a, new_g)) {
	if (subset_of_an_edge(a, add_g_c)) {
	  if (!subset_of_an_edge(a, old_g_c))
	    insert_edge_in_edge_list(v, w, &edge_list);
	}
      }
    }
  }
  add_union_of_gc(*old_g_c, new_g);
  copy_set_list(*old_g_c, new_g_c);
  while (edge_list != NULL) {
    p = edge_list;
    tmp_g_c = *new_g_c;
    sub_add_edge_to_g_c(new_g_c, &tmp_g_c, p->v, p->w);
    dispose_set_list(&tmp_g_c);
    edge_list = edge_list->pointer;
    _Free(p);
  }
}  /* new_add_edges_to_g_c */


Static Void old_add_edges_to_g_c(new_g_c, old_g_c, add_g_c, new_g)
t_set_list **new_g_c, **old_g_c, **add_g_c;
long *new_g;
{
  t_edge_list *p;
  t_edge_list *edge_list = NULL;
  t_vertex v, w;
  t_vertex_set old_g, a;
  t_v_arr_of_v_sets old_adj_set, new_adj_set;

  hypergraph_sets_to_graph_sets(*old_g_c, old_g, old_adj_set);
  P_setcpy(new_g, old_g);
  add_union_of_gc(*add_g_c, new_g);
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    for (w = v + 1; w <= last_vertex; w++) {
      P_addset(P_expset(a, 0L), v);
      P_addset(a, w);
      if ((P_subset(a, old_g) & P_inset(w, old_adj_set[v - MIN_VERTEX])) |
	  subset_of_an_edge(a, add_g_c))
	insert_edge_in_edge_list(v, w, &edge_list);
    }
  }
  for (v = first_vertex; v <= last_vertex; v++)
    P_setcpy(new_adj_set[v - MIN_VERTEX], empty_set);
  while (edge_list != NULL) {
    p = edge_list;
    P_addset(new_adj_set[p->v - MIN_VERTEX], p->w);
    P_addset(new_adj_set[p->w - MIN_VERTEX], p->v);
    edge_list = edge_list->pointer;
    _Free(p);
  }
  find_cliques(new_adj_set, new_g, new_g_c);
}  /* old_add_edges_to_g_c */


Static Void add_edges_to_g_c(new_g_c, old_g_c, add_g_c, new_g)
t_set_list **new_g_c, **old_g_c, **add_g_c;
long *new_g;
{
  if (boolean_option[102])
    old_add_edges_to_g_c(new_g_c, old_g_c, add_g_c, new_g);
  else
    new_add_edges_to_g_c(new_g_c, old_g_c, add_g_c, new_g);
}  /* add_edges_to_g_c */


Static Void add_edge_to_g_c(new_g_c, old_g_c, a)
t_set_list **new_g_c, **old_g_c;
long *a;
{
  t_set_list *p = NULL;
  t_vertex_set new_g;

  insert_set_in_set_list(a, &p);
  add_edges_to_g_c(new_g_c, old_g_c, &p, new_g);
  dispose_set_list(&p);
}  /* add_edge_to_g_c */


Static Void add_edge(new__model, old_model, add_g_c)
t_model **new__model, **old_model;
t_set_list **add_g_c;
{
  t_set_list *g_c_old, *g_c_new;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " AddIEdge           ", sizeof(pch20));
  ntr_model(tzt, 20L, 1927L, 1L, -1L, -1L, *old_model);
  /*$endif TRACE*/
  g_c_old = return_g_c_copy_for_mixed_model(old_model);
  add_edges_to_g_c(&g_c_new, &g_c_old, add_g_c, (*new__model)->id->vertices);
  insert_g_c_in_model(&g_c_new, (*new__model)->id->vertices,
		      &(*old_model)->id->causal_structure, false,
		      (*old_model)->id->UU.U1.homogeneous, new__model);
  /*$ifdef TRACE*/
  dispose_g_c_copy_for_mixed_model(old_model, &g_c_old);
  /*$endif TRACE*/
  ntr_model(tzt, 20L, 1927L, 8L, -1L, -1L, *new__model);
}  /* add_edge */


Static Void drop_interactions_from_g_c(new_g_c, old_g_c, interactions, new_g)
t_set_list **new_g_c, **old_g_c, **interactions;
long *new_g;
{
  t_set_list *p, *alt_rep;
  t_vertex_set old_g;

  P_setcpy(old_g, empty_set);
  add_union_of_gc(*old_g_c, old_g);
  P_setcpy(new_g, old_g);
  if ((*old_g_c)->pointer == NULL && P_setequal((*old_g_c)->vertex_set, old_g))
    alt_rep = NULL;
  else
    normal_to_dual(*old_g_c, old_g, &alt_rep);
  p = *interactions;
  while (p != NULL) {
    insert_set_minimal(p->vertex_set, &alt_rep);
    p = p->pointer;
  }
  dispose_set_list(interactions);
  if (alt_rep == NULL) {
    write_pch(stdout, " (Empty dual repr.) ", 20L);
    write_line(stdout);
    *new_g_c = (t_set_list *)Malloc(sizeof(t_set_list));
    if (*new_g_c == NULL)
      _OutMem();
    P_setcpy((*new_g_c)->vertex_set, old_g);
    (*new_g_c)->pointer = NULL;
  } else
    dual_to_normal(alt_rep, old_g, new_g_c);
  if (*new_g_c != NULL) {
    P_setcpy(new_g, empty_set);
    add_union_of_gc(*new_g_c, new_g);
  } else
    P_setcpy(new_g, empty_set);
  dispose_set_list(&alt_rep);
}  /* drop_interactions_from_g_c */


Static Void split_drop_g_c(gc, discrete_g_c, linear_g_c, quadratic_g_c,
			   sub_code)
t_set_list *gc, **discrete_g_c, **linear_g_c, **quadratic_g_c;
t_long_integer *sub_code;
{
  t_vertex_set a;

  *discrete_g_c = NULL;
  *linear_g_c = NULL;
  *quadratic_g_c = NULL;
  while (gc != NULL) {
    P_setint(a, gc->vertex_set, gamma_);
    if (!P_setequal(a, empty_set)) {
      if (cardinality(a) == 1) {
	if (*sub_code == 0 || *sub_code == 2)
	  insert_clique(gc->vertex_set, linear_g_c);
      }
      if (*sub_code == 0 || *sub_code == 3)
	insert_clique(gc->vertex_set, quadratic_g_c);
    } else {
      if (*sub_code == 0 || *sub_code == 1)
	insert_clique(gc->vertex_set, discrete_g_c);
      if (*sub_code == 0 || *sub_code == 2)
	insert_clique(gc->vertex_set, linear_g_c);
      if (*sub_code == 0 || *sub_code == 3)
	insert_clique(gc->vertex_set, quadratic_g_c);
    }
    gc = gc->pointer;
  }
}  /* split_drop_g_c */


Static Void drop_interactions(new__model, old_model, interactions, sub_code)
t_model **new__model, **old_model;
t_set_list **interactions;
t_long_integer *sub_code;
{
  t_set_list *tmp_discrete_g_c, *tmp_linear_g_c, *tmp_quadratic_g_c;
  t_vertex_set a;
  t_set_list *g_c_old, *g_c_new;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DropInterFrom      ", sizeof(pch20));
  ntr_model(tzt, 20L, 1929L, 1L, -1L, -1L, *old_model);
  /*$endif TRACE*/
  erase_model(new__model, (*old_model)->id->model_type, false);
  if (mixed_data && (*old_model)->id->model_type == mixed) {
    erase_mixed_model(new__model);
    do_model(old_model, false, false, &ok);
    if ((*old_model)->graphical) {
      g_c_old = return_g_c_copy(old_model);
      P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
      drop_interactions_from_g_c(&g_c_new, &g_c_old, interactions,
				 (*new__model)->id->vertices);
      dispose_set_list(&g_c_old);
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 1929L, 4L, -1L, -1L, &g_c_new);
      /*$endif TRACE*/
      copy_g_c_to_mixed_graphical_model(g_c_new, false,
	(*old_model)->id->UU.U1.homogeneous, new__model);
      check_mixed_model(new__model, " DropInteractions", 17L, true);
	  /*ntr*/
      /*$ifdef TRACE*/
      /*ntr*/
      ntr_triple_g_c(tzt, 20L, 1929L, 5L, -1L, -1L,
		     &(*new__model)->id->UU.U1.g_c_discrete,
		     &(*new__model)->id->UU.U1.g_c_linear,
		     &(*new__model)->id->UU.U1.g_c_quadratic);
	  /*ntr*/
      ntr_set(tzt, 20L, 1929L, 5L, -1L, -1L, (*new__model)->id->vertices);
      /*$endif TRACE*/
      dispose_set_list(&g_c_new);
    } else {   /*ntr*/
      split_drop_g_c(*interactions, &tmp_discrete_g_c, &tmp_linear_g_c,
		     &tmp_quadratic_g_c, sub_code);
      /*$ifdef TRACE*/
      ntr_triple_g_c(tzt, 20L, 1929L, 6L, -1L, -1L, &tmp_discrete_g_c,
		     &tmp_linear_g_c, &tmp_quadratic_g_c);
      /*$endif TRACE*/
      dispose_set_list(interactions);
      drop_interactions_from_g_c(&(*new__model)->id->UU.U1.g_c_discrete,
				 &(*old_model)->id->UU.U1.g_c_discrete,
				 &tmp_discrete_g_c, a);
      P_setcpy((*new__model)->id->vertices, a);
      drop_interactions_from_g_c(&(*new__model)->id->UU.U1.g_c_linear,
	&(*old_model)->id->UU.U1.g_c_linear, &tmp_linear_g_c, a);
      P_setunion((*new__model)->id->vertices, (*new__model)->id->vertices, a);
      drop_interactions_from_g_c(&(*new__model)->id->UU.U1.g_c_quadratic,
	&(*old_model)->id->UU.U1.g_c_quadratic, &tmp_quadratic_g_c, a);
      P_setunion((*new__model)->id->vertices, (*new__model)->id->vertices, a);
      /*$ifdef TRACE*/
      check_mixed_model(new__model, " DropInteractions", 17L, true);
	  /*ntr*/
      /*ntr*/
      ntr_triple_g_c(tzt, 20L, 1929L, 7L, -1L, 1L,
		     &(*new__model)->id->UU.U1.g_c_discrete,
		     &(*new__model)->id->UU.U1.g_c_linear,
		     &(*new__model)->id->UU.U1.g_c_quadratic);
	  /*ntr*/
      /*$endif TRACE*/
      ntr_set(tzt, 20L, 1929L, 7L, -1L, 2L, (*new__model)->id->vertices);
    }
  } else if ((*old_model)->id->model_type == pure_continuous)
    drop_interactions_from_g_c(&(*new__model)->id->UU.g_c_covariance,
			       &(*old_model)->id->UU.g_c_covariance,
			       interactions, (*new__model)->id->vertices);
  else if ((*old_model)->id->model_type == pure_discrete)
    drop_interactions_from_g_c(&(*new__model)->id->UU.g_c_log_linear,
			       &(*old_model)->id->UU.g_c_log_linear,
			       interactions, (*new__model)->id->vertices);
  /*$ifdef TRACE*/
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new__model)->id->causal_structure);
  /*$endif TRACE*/
  ntr_model(tzt, 20L, 1929L, 8L, -1L, -1L, *new__model);
}  /* drop_interactions */


Static Void drop_interaction_from_g_c(new_g_c, old_g_c, a)
t_set_list **new_g_c, **old_g_c;
long *a;
{
  t_set_list *p = NULL;
  t_vertex_set new_g;

  insert_set_in_set_list(a, &p);
  drop_interactions_from_g_c(new_g_c, old_g_c, &p, new_g);
}  /* drop_interaction_from_g_c */


Static Void add_interactions_to_g_c(new_g_c, old_g_c, interactions)
t_set_list **new_g_c, **old_g_c, **interactions;
{
  t_set_list *p;

  copy_set_list(*old_g_c, new_g_c);
  p = *interactions;
  while (p != NULL) {
    insert_clique(p->vertex_set, new_g_c);
    p = p->pointer;
  }
  dispose_set_list(interactions);
}  /* add_interactions_to_g_c */


Static Void add_interactions(new__model, old_model, interactions)
t_model **new__model, **old_model;
t_set_list **interactions;
{
  t_set_list *tmp_discrete_g_c, *tmp_linear_g_c, *tmp_quadratic_g_c, *g_c_old,
	     *g_c_new;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " AddInteractions    ", sizeof(pch20));
  ntr_model(tzt, 20L, 1932L, 1L, -1L, -1L, *old_model);
  /*$endif TRACE*/
  erase_model(new__model, (*old_model)->id->model_type, false);
  if (mixed_data && (*old_model)->id->model_type == mixed) {
    erase_mixed_model(new__model);
    do_model(old_model, false, false, &ok);
    if ((*old_model)->graphical) {
      g_c_old = return_g_c_copy(old_model);
      P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
      add_interactions_to_g_c(&g_c_new, &g_c_old, interactions);
      dispose_set_list(&g_c_old);
      copy_g_c_to_mixed_graphical_model(g_c_new, false,
	(*old_model)->id->UU.U1.homogeneous, new__model);
      check_mixed_model(new__model, " AddInteractions", 16L, true);
      dispose_set_list(&g_c_new);
    } else {
      split_g_c_in_mixed_terms(*interactions,
	(*old_model)->id->UU.U1.full_specified,
	(*old_model)->id->UU.U1.homogeneous, &tmp_discrete_g_c,
	&tmp_linear_g_c, &tmp_quadratic_g_c);
      dispose_set_list(interactions);
      add_interactions_to_g_c(&(*new__model)->id->UU.U1.g_c_discrete,
			      &(*old_model)->id->UU.U1.g_c_discrete,
			      &tmp_discrete_g_c);
      add_interactions_to_g_c(&(*new__model)->id->UU.U1.g_c_linear,
			      &(*old_model)->id->UU.U1.g_c_linear,
			      &tmp_linear_g_c);
      add_interactions_to_g_c(&(*new__model)->id->UU.U1.g_c_quadratic,
			      &(*old_model)->id->UU.U1.g_c_quadratic,
			      &tmp_quadratic_g_c);
      P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
      check_mixed_model(new__model, " AddInteractions", 16L, true);
    }
  } else if ((*old_model)->id->model_type == pure_continuous) {
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
    add_interactions_to_g_c(&(*new__model)->id->UU.g_c_covariance,
			    &(*old_model)->id->UU.g_c_covariance,
			    interactions);
  } else if ((*old_model)->id->model_type == pure_discrete) {
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
    add_interactions_to_g_c(&(*new__model)->id->UU.g_c_log_linear,
			    &(*old_model)->id->UU.g_c_log_linear,
			    interactions);
  }
  /*$ifdef TRACE*/
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new__model)->id->causal_structure);
  /*$endif TRACE*/
  ntr_model(tzt, 20L, 1932L, 8L, -1L, -1L, *new__model);
}  /* add_interactions */


Static Void add_interaction_to_g_c(new_g_c, old_g_c, a)
t_set_list **new_g_c, **old_g_c;
long *a;
{
  t_set_list *p = NULL;

  insert_set_in_set_list(a, &p);
  add_interactions_to_g_c(new_g_c, old_g_c, &p);
}  /* add_interaction_to_g_c */


/*Has-forward-2*/

Static Void meet_models(new__model, model_1, model_2, identify)
t_model **new__model, **model_1, **model_2;
boolean identify;
{

  /*Has-forward-2*/

  /* No-forward

procedure meet_models(var new__model, model_1, model_2: t_link_model;
                            identify: boolean);

    No-forward */
  t_set_list *g_c_discrete, *g_c_1_discrete, *g_c_2_discrete, *g_c_linear,
	     *g_c_1_linear, *g_c_2_linear, *g_c_quadratic, *g_c_1_quadratic,
	     *g_c_2_quadratic, *g_c_1, *g_c_2, *g_c_new;
  t_set_list *causal_structure = NULL;
  boolean full_specified = false;
  boolean homogeneous_1, homogeneous_2, ok;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " MeetModels         ", sizeof(pch20));
  ntr(tzt, 20L, 1934L, 1L, 1L, 1L);
  if (trace_flag_set(20L, 1934L, 1L)) {
    print_model_g_c_and_type(model_1, 2L);
    print_model_g_c_and_type(model_2, 2L);
  }
  /*$endif TRACE*/
  if ((*model_1)->id->model_type == pure_continuous)
    full_specified = true;
  if ((*model_2)->id->model_type == pure_continuous)
    full_specified = true;
  if (!full_specified && mixed_data && (*model_1)->id->model_type == mixed) {
    full_specified = (*model_1)->id->UU.U1.full_specified;
    if (!full_specified)
      full_specified = subset_of_an_edge(double_vertex_set,
	  &(*model_1)->id->UU.U1.g_c_quadratic);
  }
  if (!full_specified && mixed_data && (*model_2)->id->model_type == mixed) {
    full_specified = (*model_2)->id->UU.U1.full_specified;
    if (!full_specified)
      full_specified = subset_of_an_edge(double_vertex_set,
	  &(*model_2)->id->UU.U1.g_c_quadratic);
  }
  P_setcpy(a, (*model_1)->id->vertices);
  P_setint(a, a, (*model_2)->id->vertices);
  if (mixed_data)
    note_mixed(stdout, " MeetModels", 11L);
  erase_model(new__model, (*model_1)->id->model_type, false);
  if ((*model_1)->id->model_type == pure_discrete &&
      (*model_2)->id->model_type == pure_discrete)
    find_g_c_intersection_maximal((*model_1)->id->UU.g_c_log_linear,
				  &(*model_2)->id->UU.g_c_log_linear,
				  &(*new__model)->id->UU.g_c_log_linear);
  else if ((*model_1)->id->model_type == pure_continuous &&
	   (*model_2)->id->model_type == pure_continuous)
    find_g_c_intersection_maximal((*model_1)->id->UU.g_c_covariance,
				  &(*model_2)->id->UU.g_c_covariance,
				  &(*new__model)->id->UU.g_c_covariance);
  else {
    if (mixed_data) {
      erase_mixed_model(new__model);
      if (identify) {
	do_model(model_1, false, false, &ok);
	do_model(model_2, false, false, &ok);
      }
      if (identify && (*model_1)->graphical && (*model_2)->graphical) {
	g_c_1 = return_g_c_copy(model_1);
	g_c_2 = return_g_c_copy(model_2);
	find_g_c_intersection_maximal(g_c_1, &g_c_2, &g_c_new);
	dispose_set_list(&g_c_1);
	dispose_set_list(&g_c_2);
	(*new__model)->id->UU.U1.homogeneous =
	  ((*model_1)->id->UU.U1.homogeneous ||
	   (*model_2)->id->UU.U1.homogeneous);
	copy_g_c_to_mixed_graphical_model(g_c_new, false,
	  (*new__model)->id->UU.U1.homogeneous, new__model);
	dispose_set_list(&g_c_new);
      } else {
	homogeneous_1 = true;
	homogeneous_2 = true;
	g_c_1_discrete = NULL;
	g_c_1_linear = NULL;
	g_c_1_quadratic = NULL;
	g_c_2_discrete = NULL;
	g_c_2_linear = NULL;
	g_c_2_quadratic = NULL;
	if ((*model_1)->id->model_type == pure_discrete)
	  g_c_1_discrete = (*model_1)->id->UU.g_c_log_linear;
	else {
	  if ((*model_1)->id->model_type == pure_continuous)
	    g_c_1_quadratic = (*model_1)->id->UU.g_c_covariance;
	  else {
	    if ((*model_1)->id->model_type == mixed) {
	      homogeneous_1 = (*model_1)->id->UU.U1.homogeneous;
	      g_c_1_discrete = (*model_1)->id->UU.U1.g_c_discrete;
	      g_c_1_linear = (*model_1)->id->UU.U1.g_c_linear;
	      g_c_1_quadratic = (*model_1)->id->UU.U1.g_c_quadratic;
	    }
	  }
	}
	if ((*model_2)->id->model_type == pure_discrete)
	  g_c_2_discrete = (*model_2)->id->UU.g_c_log_linear;
	else {
	  if ((*model_2)->id->model_type == pure_continuous)
	    g_c_2_quadratic = (*model_2)->id->UU.g_c_covariance;
	  else {
	    if ((*model_2)->id->model_type == mixed) {
	      homogeneous_2 = (*model_2)->id->UU.U1.homogeneous;
	      g_c_2_discrete = (*model_2)->id->UU.U1.g_c_discrete;
	      g_c_2_linear = (*model_2)->id->UU.U1.g_c_linear;
	      g_c_2_quadratic = (*model_2)->id->UU.U1.g_c_quadratic;
	    }
	  }
	}
	find_g_c_intersection_maximal(g_c_1_discrete, &g_c_2_discrete,
				      &g_c_discrete);
	find_g_c_intersection_maximal(g_c_1_linear, &g_c_2_linear,
				      &g_c_linear);
	find_g_c_intersection_maximal(g_c_1_quadratic, &g_c_2_quadratic,
				      &g_c_quadratic);
	if (g_c_discrete == NULL) {
	  erase_model(new__model, pure_continuous, false);
	  if (full_specified)
	    (*new__model)->id->UU.g_c_covariance = g_c_quadratic;
	  else
	    insert_g_c_in_model(&g_c_quadratic, a, &causal_structure,
				full_specified, true, new__model);
	} else {
	  if (g_c_linear == NULL) {
	    erase_model(new__model, pure_discrete, false);
	    insert_g_c_in_model(&g_c_discrete, a, &causal_structure,
				full_specified, true, new__model);
	  } else {
	    (*new__model)->id->UU.U1.g_c_discrete = g_c_discrete;
	    (*new__model)->id->UU.U1.g_c_linear = g_c_linear;
	    (*new__model)->id->UU.U1.g_c_quadratic = g_c_quadratic;
	    (*new__model)->id->UU.U1.full_specified = full_specified;
	    (*new__model)->id->UU.U1.homogeneous = (homogeneous_1 &&
						    homogeneous_2);
	    check_mixed_model(new__model, " MeetModels@@@@@@@@ ", 12L, true);
	  }
	}
      }
    }
  }
  P_setcpy((*new__model)->id->vertices, a);
  /*$ifdef TRACE*/
  copy_ordered_set_list((*model_1)->id->causal_structure,
			&(*new__model)->id->causal_structure);
  if (trace_flag_set(20L, 1934L, 1L))
    print_model_g_c_and_type(new__model, 2L);
  /*$endif TRACE*/
  ntr(tzt, 20L, 1934L, 1L, 1L, 9L);
}  /* meet_models */


/*Has-forward-2*/

Static Void restrict_model(new__model, current_model, homogeneous, a)
t_model **new__model, **current_model;
boolean homogeneous;
long *a;
{

  /*Has-forward-2*/

  /* No-forward

procedure restrict_model(var new__model, current_model : t_link_model;
                               homogeneous       : boolean;
                           var a       : t_vertex_set);

    No-forward */
  t_model *model;
  t_set_list *g_c_discrete, *g_c_linear, *g_c_quadratic;
  t_set_list *g_c = NULL, *causal_structure = NULL;
  boolean full_specified = false;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " RestrictModels     ", sizeof(pch20));
  ntr(tzt, 20L, 1935L, 1L, 1L, 1L);
  if (trace_flag_set(20L, 1935L, 1L))
    print_model_g_c_and_type(current_model, 2L);
  /*$endif TRACE*/
  insert_clique(a, &g_c);
  new_model(&model);
  if ((*current_model)->id->model_type == pure_continuous)
    full_specified = true;
  if (mixed_data && (*current_model)->id->model_type == mixed) {
    full_specified = (*current_model)->id->UU.U1.full_specified;
    if (!full_specified)
      full_specified = subset_of_an_edge(double_vertex_set,
	  &(*current_model)->id->UU.U1.g_c_quadratic);
  }
  if (P_subset(a, gamma_) && full_specified) {
    split_g_c_in_mixed_terms(g_c, true, true, &g_c_discrete, &g_c_linear,
			     &g_c_quadratic);
    dispose_set_list(&g_c_discrete);
    dispose_set_list(&g_c_linear);
    dispose_set_list(&g_c);
    /* insert_g_c_in_model(g_c_quadratic, a, causal_structure,
                          true, true, model) */
    erase_continuous_model(&model);
    model->id->UU.g_c_covariance = g_c_quadratic;
    P_setcpy(model->id->vertices, a);
    model->constant = _INVALID_REAL;
    copy_ordered_set_list(causal_structure, &model->id->causal_structure);
  } else
    insert_g_c_in_model(&g_c, a, &causal_structure, full_specified,
			homogeneous, &model);
  erase_model(new__model, (*current_model)->id->model_type, false);
  meet_models(new__model, current_model, &model, false);
  dispose_model_and_link(&model);
  /*$ifdef TRACE*/
  dispose_set_list(&g_c);
  if (trace_flag_set(20L, 1935L, 1L))
    print_model_g_c_and_type(new__model, 2L);
  /*$endif TRACE*/
  ntr(tzt, 20L, 1934L, 1L, 1L, 9L);
}  /* restrict_model */


Static Void join(current_g_c, base_g_c, new_g_c)
t_set_list **current_g_c, **base_g_c, **new_g_c;
{
  t_set_list *p;

  copy_set_list(*current_g_c, new_g_c);
  p = *base_g_c;
  while (p != NULL) {
    insert_clique(p->vertex_set, new_g_c);
    p = p->pointer;
  }
}  /* join */


/*Has-forward-2*/

Static Void join_models(new__model, model_1, model_2, identify)
t_model **new__model, **model_1, **model_2;
boolean identify;
{

  /*Has-forward-2*/

  /* No-forward

   procedure join_models(var new__model, model_1, model_2: t_link_model;
                             identify: boolean);


    No-forward */
  t_set_list *g_c_1_discrete, *g_c_2_discrete, *g_c_1_linear, *g_c_2_linear,
	     *g_c_1_quadratic, *g_c_2_quadratic, *g_c_1, *g_c_2, *g_c_new, *p;
  boolean full_specified = false;
  boolean homogeneous_1, homogeneous_2, ok;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " JoinModels         ", sizeof(pch20));
  ntr(tzt, 20L, 1936L, 1L, 1L, 1L);
  if (trace_flag_set(20L, 1936L, 1L)) {
    print_model_g_c_and_type(model_1, 2L);
    print_model_g_c_and_type(model_2, 2L);
  }
  /*$endif TRACE*/
  if ((*model_1)->id->model_type == pure_continuous)
    full_specified = true;
  if ((*model_2)->id->model_type == pure_continuous)
    full_specified = true;
  if (!full_specified && mixed_data && (*model_1)->id->model_type == mixed) {
    full_specified = (*model_1)->id->UU.U1.full_specified;
    if (!full_specified)
      full_specified = subset_of_an_edge(double_vertex_set,
	  &(*model_1)->id->UU.U1.g_c_quadratic);
  }
  if (!full_specified && mixed_data && (*model_2)->id->model_type == mixed) {
    full_specified = (*model_2)->id->UU.U1.full_specified;
    if (!full_specified)
      full_specified = subset_of_an_edge(double_vertex_set,
	  &(*model_2)->id->UU.U1.g_c_quadratic);
  }
  P_setcpy(a, (*model_1)->id->vertices);
  P_setunion(a, a, (*model_2)->id->vertices);
  if (mixed_data)
    note_mixed(stdout, " JoinModels", 11L);
  erase_model(new__model, (*model_1)->id->model_type, false);
  if ((*model_1)->id->model_type == pure_discrete &&
      (*model_2)->id->model_type == pure_discrete) {
    copy_set_list((*model_1)->id->UU.g_c_log_linear,
		  &(*new__model)->id->UU.g_c_log_linear);
    p = (*model_2)->id->UU.g_c_log_linear;
    while (p != NULL) {
      insert_clique(p->vertex_set, &(*new__model)->id->UU.g_c_log_linear);
      p = p->pointer;
    }
  } else if ((*model_1)->id->model_type == pure_continuous &&
	     (*model_2)->id->model_type == pure_continuous) {
    copy_set_list((*model_1)->id->UU.g_c_covariance,
		  &(*new__model)->id->UU.g_c_covariance);
    p = (*model_2)->id->UU.g_c_covariance;
    while (p != NULL) {
      insert_clique(p->vertex_set, &(*new__model)->id->UU.g_c_covariance);
      p = p->pointer;
    }
  } else {
    if (mixed_data) {
      erase_mixed_model(new__model);
      if (identify) {
	do_model(model_1, false, false, &ok);
	do_model(model_2, false, false, &ok);
      }
      if (identify && (*model_1)->graphical && (*model_2)->graphical) {
	g_c_1 = return_g_c_copy(model_1);
	g_c_2 = return_g_c_copy(model_2);
	copy_set_list(g_c_1, &g_c_new);
	p = g_c_2;
	while (p != NULL) {
	  insert_clique(p->vertex_set, &g_c_new);
	  p = p->pointer;
	}
	dispose_set_list(&g_c_1);
	dispose_set_list(&g_c_2);
	(*new__model)->id->UU.U1.homogeneous =
	  ((*model_1)->id->UU.U1.homogeneous &&
	   (*model_2)->id->UU.U1.homogeneous);
	copy_g_c_to_mixed_graphical_model(g_c_new, false,
	  (*new__model)->id->UU.U1.homogeneous, new__model);
	dispose_set_list(&g_c_new);
      } else {
	homogeneous_1 = true;
	homogeneous_2 = true;
	g_c_1_discrete = NULL;
	g_c_1_linear = NULL;
	g_c_1_quadratic = NULL;
	g_c_2_discrete = NULL;
	g_c_2_linear = NULL;
	g_c_2_quadratic = NULL;
	if ((*model_1)->id->model_type == pure_discrete)
	  g_c_1_discrete = (*model_1)->id->UU.g_c_log_linear;
	else {
	  if ((*model_1)->id->model_type == pure_continuous) {
	    g_c_1_quadratic = (*model_1)->id->UU.g_c_covariance;
	    /* Extract variables to linear!!! */
	  } else {
	    if ((*model_1)->id->model_type == mixed) {
	      homogeneous_1 = (*model_1)->id->UU.U1.homogeneous;
	      g_c_1_discrete = (*model_1)->id->UU.U1.g_c_discrete;
	      g_c_1_linear = (*model_1)->id->UU.U1.g_c_linear;
	      g_c_1_quadratic = (*model_1)->id->UU.U1.g_c_quadratic;
	    }
	  }
	}
	if ((*model_2)->id->model_type == pure_discrete)
	  g_c_2_discrete = (*model_2)->id->UU.g_c_log_linear;
	else {
	  if ((*model_2)->id->model_type == pure_continuous) {
	    g_c_2_quadratic = (*model_2)->id->UU.g_c_covariance;
	    /* Extract variables to linear!!! */
	  } else {
	    if ((*model_2)->id->model_type == mixed) {
	      homogeneous_2 = (*model_2)->id->UU.U1.homogeneous;
	      g_c_2_discrete = (*model_2)->id->UU.U1.g_c_discrete;
	      g_c_2_linear = (*model_2)->id->UU.U1.g_c_linear;
	      g_c_2_quadratic = (*model_2)->id->UU.U1.g_c_quadratic;
	    }
	  }
	}
	join(&g_c_1_discrete, &g_c_2_discrete,
	     &(*new__model)->id->UU.U1.g_c_discrete);
	join(&g_c_1_linear, &g_c_2_linear,
	     &(*new__model)->id->UU.U1.g_c_linear);
	join(&g_c_1_quadratic, &g_c_2_quadratic,
	     &(*new__model)->id->UU.U1.g_c_quadratic);
	(*new__model)->id->UU.U1.full_specified = full_specified;
	(*new__model)->id->UU.U1.homogeneous = (homogeneous_1 &&
						homogeneous_2);
	check_mixed_model(new__model, " JoinModels@@@@@@@@ ", 12L, true);
      }
    }
  }
  P_setcpy((*new__model)->id->vertices, a);
  /*$ifdef TRACE*/
  copy_ordered_set_list((*model_1)->id->causal_structure,
			&(*new__model)->id->causal_structure);
  if (trace_flag_set(20L, 1936L, 1L))
    print_model_g_c_and_type(new__model, 2L);
  /*$endif TRACE*/
  ntr(tzt, 20L, 1936L, 1L, 1L, 9L);
}  /* join_models */


Static Void edge_minus(new_edges, g_c_a, g_c_b)
t_set_list **new_edges, **g_c_a, **g_c_b;
{
  t_set_list *p_g_c = NULL;
  t_vertex_set a;

  drop_edges_from_g_c(&p_g_c, g_c_a, g_c_b);
  *new_edges = NULL;
  while (p_g_c != NULL) {
    P_setcpy(a, p_g_c->vertex_set);
    if (cardinality(a) > 1)
      insert_set_minimal(a, new_edges);
    p_g_c = p_g_c->pointer;
  }
  dispose_set_list(&p_g_c);
}  /* edge_minus */


Static Void g_c_minus(new_g_c, g_c_a, g_c_b)
t_set_list **new_g_c, **g_c_a, **g_c_b;
{
  t_set_list *g_c_dual_b;
  t_vertex_set a, g;

  P_setcpy(g, empty_set);
  add_union_of_gc(*g_c_a, g);
  normal_to_dual(*g_c_b, g, &g_c_dual_b);
  *new_g_c = NULL;
  while (g_c_dual_b != NULL) {
    P_setcpy(a, g_c_dual_b->vertex_set);
    if (subset_of_an_edge(a, g_c_a))
      insert_set_minimal(a, new_g_c);
    g_c_dual_b = g_c_dual_b->pointer;
  }
  dispose_set_list(&g_c_dual_b);
}  /* g_c_minus */


Static Void g_c_minus_id(new_g_c, id_a, id_b)
t_set_list **new_g_c;
t_model_specification *id_a, *id_b;
{
  t_set_list *g_c_a, *g_c_b;

  g_c_a = return_g_c_copy_id(&id_a);
  g_c_b = return_g_c_copy_id(&id_b);
  g_c_minus(new_g_c, &g_c_a, &g_c_b);
  dispose_set_list(&g_c_a);
  dispose_set_list(&g_c_b);
}  /* g_c_minus_id */


Static Void edge_minus_id(new_g_c, id_a, id_b)
t_set_list **new_g_c;
t_model_specification *id_a, *id_b;
{
  t_set_list *g_c_a, *g_c_b;

  g_c_a = return_g_c_copy_id(&id_a);
  g_c_b = return_g_c_copy_id(&id_b);
  edge_minus(new_g_c, &g_c_a, &g_c_b);
  dispose_set_list(&g_c_a);
  dispose_set_list(&g_c_b);
}  /* edge_minus_id */


Static Void difference_models(new_model, current_model, base_model, edges)
t_model **new_model, **current_model, **base_model;
boolean edges;
{
  P_setunion((*new_model)->id->vertices, (*current_model)->id->vertices,
	     (*base_model)->id->vertices);
  if (mixed_data) {
    note_mixed(stdout, " DifferenceModels   ", 20L);
    return;
  }
  if (edges)
    edge_minus(&(*new_model)->id->UU.g_c_log_linear,
	       &(*current_model)->id->UU.g_c_log_linear,
	       &(*base_model)->id->UU.g_c_log_linear);
  else
    g_c_minus(&(*new_model)->id->UU.g_c_log_linear,
	      &(*current_model)->id->UU.g_c_log_linear,
	      &(*base_model)->id->UU.g_c_log_linear);
}  /* difference_models */


Static Void drop_total_generator(new__model, old_model, a)
t_model **new__model, **old_model;
long *a;
{
  t_set_list *p;
  t_vertex v;
  t_vertex_set b, c;
  t_set_list *g_c_old, *g_c_new;

  if (mixed_data)
    note_mixed(stdout, " DropTotalGenerator", 19L);
  if (mixed_data && (*old_model)->id->model_type != pure_discrete) {
    g_c_old = return_g_c_copy(old_model);
    erase_mixed_model(new__model);
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);

    p = g_c_old;
    g_c_new = NULL;
    while (p != NULL) {
      P_setdiff(c, p->vertex_set, a);
      insert_clique(c, &g_c_new);
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a) & P_inset(v, p->vertex_set)) {
	  P_setcpy(b, c);
	  P_addset(b, v);
	  insert_clique(b, &g_c_new);
	}
      }
      p = p->pointer;
    }
    dispose_set_list(&g_c_old);
    copy_g_c_to_mixed_graphical_model(g_c_new, false,
      (*old_model)->id->UU.U1.homogeneous, new__model);
    dispose_set_list(&g_c_new);
  } else {
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
    p = (*old_model)->id->UU.g_c_log_linear;
    while (p != NULL) {
      P_setdiff(c, p->vertex_set, a);
      insert_clique(c, &(*new__model)->id->UU.g_c_log_linear);
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a) & P_inset(v, p->vertex_set)) {
	  P_setcpy(b, c);
	  P_addset(b, v);
	  insert_clique(b, &(*new__model)->id->UU.g_c_log_linear);
	}
      }
      p = p->pointer;
    }
  }
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new__model)->id->causal_structure);
}  /* drop_total_generator */


Static Void remove_generator(new__model, old_model, a)
t_model **new__model, **old_model;
long *a;
{
  t_set_list *p, *g_c_old, *g_c_new;

  if (mixed_data)
    note_mixed(stdout, " RemoveGenerator", 16L);
  if (mixed_data && (*old_model)->id->model_type != pure_discrete) {
    g_c_old = return_g_c_copy(old_model);
    erase_mixed_model(new__model);
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
    p = g_c_old;
    g_c_new = NULL;
    while (p != NULL) {
      if (!P_setequal(p->vertex_set, a))
	insert_clique(p->vertex_set, &g_c_new);
      p = p->pointer;
    }
    dispose_set_list(&g_c_old);
    copy_g_c_to_mixed_graphical_model(g_c_new, false,
      (*old_model)->id->UU.U1.homogeneous, new__model);
    dispose_set_list(&g_c_new);
  } else {
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
    p = (*old_model)->id->UU.g_c_log_linear;
    while (p != NULL) {
      if (!P_setequal(p->vertex_set, a))
	insert_clique(p->vertex_set, &(*new__model)->id->UU.g_c_log_linear);
      p = p->pointer;
    }
  }
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new__model)->id->causal_structure);
}  /* remove_generator */


Static Void reduce_generator(new__model, old_model, a)
t_model **new__model, **old_model;
long *a;
{
  t_set_list *p;
  t_vertex v;
  boolean b;
  t_vertex_set c;
  t_set_list *g_c_old, *g_c_new;

  if (mixed_data)
    note_mixed(stdout, " ReduceGenerator", 16L);
  if (mixed_data && (*old_model)->id->model_type != pure_discrete) {
    g_c_old = return_g_c_copy(old_model);
    erase_mixed_model(new__model);
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
    p = g_c_old;
    b = false;
    g_c_new = NULL;
    while (p != NULL) {
      if (!P_setequal(p->vertex_set, a))
	insert_clique(p->vertex_set, &g_c_new);
      else
	b = true;
      p = p->pointer;
    }
    if (b) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  P_setcpy(c, a);
	  P_remset(c, v);
	  insert_clique(c, &g_c_new);
	}
      }
    }
    dispose_set_list(&g_c_old);
    copy_g_c_to_mixed_graphical_model(g_c_new, false,
      (*old_model)->id->UU.U1.homogeneous, new__model);
    dispose_set_list(&g_c_new);
  } else {
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
    p = (*old_model)->id->UU.g_c_log_linear;
    b = false;
    while (p != NULL) {
      if (!P_setequal(p->vertex_set, a))
	insert_clique(p->vertex_set, &(*new__model)->id->UU.g_c_log_linear);
      else
	b = true;
      p = p->pointer;
    }
    if (b) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, a)) {
	  P_setcpy(c, a);
	  P_remset(c, v);
	  insert_clique(c, &(*new__model)->id->UU.g_c_log_linear);
	}
      }
    }
  }
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new__model)->id->causal_structure);
}  /* reduce_generator */


Static Void drop_factor(new__model, old_model, v)
t_model **new__model, **old_model;
t_vertex *v;
{
  t_set_list *p;
  t_vertex_set c;
  t_set_list *g_c_old, *g_c_new;

  if (mixed_data)
    note_mixed(stdout, " DropFactor", 11L);
  if (mixed_data && (*old_model)->id->model_type != pure_discrete) {
    g_c_old = return_g_c_copy(old_model);
    erase_mixed_model(new__model);
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
    P_remset((*new__model)->id->vertices, *v);
    p = g_c_old;
    g_c_new = NULL;
    while (p != NULL) {
      P_setcpy(c, p->vertex_set);
      P_remset(c, *v);
      insert_clique(c, &g_c_new);
      p = p->pointer;
    }
    dispose_set_list(&g_c_old);
    copy_g_c_to_mixed_graphical_model(g_c_new, false,
      (*old_model)->id->UU.U1.homogeneous, new__model);
    dispose_set_list(&g_c_new);
  } else {
    P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
    p = (*old_model)->id->UU.g_c_log_linear;
    while (p != NULL) {
      P_setcpy(c, p->vertex_set);
      P_remset(c, *v);
      insert_clique(c, &(*new__model)->id->UU.g_c_log_linear);
      p = p->pointer;
    }
  }
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new__model)->id->causal_structure);
}  /* drop_factor */


/*@-"factorizes.c"*/


Static Void generate_discrete_decomposable_model(new__model, old_model)
t_model **new__model, **old_model;
{
  P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
  (*new__model)->id->UU.g_c_log_linear = find_fill_in(&(*old_model)->id->
						       UU.g_c_log_linear);
}  /* generate_discrete_decomposable_model */


Static Void generate_continuous_decomposable_model(new__model, old_model)
t_model **new__model, **old_model;
{
  P_setcpy((*new__model)->id->vertices, (*old_model)->id->vertices);
  (*new__model)->id->UU.g_c_covariance = find_fill_in(&(*old_model)->id->
						       UU.g_c_covariance);
}  /* generate_continuous_decomposable_model */


Static Void generate_mixed_decomposable_model(new__model, old_model)
t_model **new__model, **old_model;
{
  boolean homogeneous;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_lists fill_in_adj_list, adj_list;
  t_v_arr_of_v_sets adj_set;
  t_vertex v;
  t_set_list *g_c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  for (v = first_vertex; v <= last_vertex; v++) {
    order[v - MIN_VERTEX] = 1;
    fill_in_adj_list[v - MIN_VERTEX] = NULL;
  }
  g_c = return_g_c_copy(old_model);
  erase_mixed_model(new__model);
  (*new__model)->id->UU.U1.decompose = true;
  hypergraph_sets_to_graph_sets(g_c, (*new__model)->id->vertices, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  marked_lex_m(delta, adj_list, order, invers_order, fill_in_adj_list);
  dispose_adj_list(adj_list);
  dispose_set_list(&g_c);
  find_cliques_decomposable((*new__model)->id->vertices, fill_in_adj_list,
			    order, invers_order, &g_c);
  dispose_adj_list(fill_in_adj_list);
  /*$ifdef TRACE*/
  memcpy(tzt, " GenMixedDecmpModel ", sizeof(pch20));
  ntr_set(tzt, 20L, 1946L, 1L, -1L, -1L, delta);
  ntr_g_c(tzt, 20L, 1946L, 1L, -1L, -1L,
	  &(*old_model)->id->UU.U1.g_c_quadratic);
  /*$endif TRACE*/
  homogeneous = !g_c_intersects_set(delta,
				    (*old_model)->id->UU.U1.g_c_quadratic);
  copy_g_c_to_mixed_graphical_model(g_c, false, homogeneous, new__model);
  dispose_set_list(&g_c);
}  /* generate_mixed_decomposable_model */


Static Void generate_decomposable_model(new_model, old_model)
t_model **new_model, **old_model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GenerateDecomposab ", sizeof(pch20));
  ntr_set(tzt, 20L, 1947L, 1L, -1L, -1L, (*old_model)->id->vertices);
  /*$endif TRACE*/
  if ((*old_model)->id->model_type == pure_discrete)
    generate_discrete_decomposable_model(new_model, old_model);
  else if ((*old_model)->id->model_type == pure_continuous)
    generate_continuous_decomposable_model(new_model, old_model);
  else
    generate_mixed_decomposable_model(new_model, old_model);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1947L, 8L, -1L, 1L, (*old_model)->id->vertices);
  ntr_set(tzt, 20L, 1947L, 8L, -1L, 2L, (*new_model)->id->vertices);
  ntr_model_g_c(tzt, 20L, 1947L, 8L, -1L, 3L, new_model);
  /*$endif TRACE*/
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new_model)->id->causal_structure);
}  /* generate_decomposable_model */


/* Not used:
procedure generate_mixed_graphical_model
(var new_model, old_model: t_link_model);
var
   homogeneous : boolean;
   adj_set     : t_v_arr_of_v_sets;
   g_c       : t_link_set_list;
begin
   g_c := return_g_c_copy(old_model);
   erase_mixed_model(new_model);
   new_model^.id^.decompose := true;
   hypergraph_sets_to_graph_sets(g_c, new_model^.id^.vertices, adj_set);
   dispose_set_list(g_c);
   find_cliques(adj_set, new_model^.id^.vertices, g_c);
   homogeneous := not g_c_intersects_set(delta, old_model^.id^.g_c_quadratic);
   copy_g_c_to_mixed_graphical_model(g_c, false, homogeneous, new_model);
   dispose_set_list(g_c)
end; */
/* generate_mixed_graphical_model */

Static Void generate_discrete_graphical_model(new_model, old_model)
t_model **new_model, **old_model;
{
  t_set_list *sets_g_g_c;
  t_set_list *sets_d_g_c = NULL;
  boolean decomposable = false, graphical = false;
  boolean ok;

  P_setcpy((*new_model)->id->vertices, (*old_model)->id->vertices);
  do_model(old_model, false, false, &ok);
  if (!((*old_model)->found_expression && (*old_model)->graphical))
    find_graphical_and_decomposable_gc(&(*old_model)->id->UU.g_c_log_linear,
      &sets_d_g_c, &sets_g_g_c, &decomposable, &graphical);
  if ((*old_model)->graphical || graphical)
    copy_set_list((*old_model)->id->UU.g_c_log_linear,
		  &(*new_model)->id->UU.g_c_log_linear);
  else
    (*new_model)->id->UU.g_c_log_linear = sets_g_g_c;
  if (!((*old_model)->decomposable || decomposable))
    dispose_set_list(&sets_d_g_c);
}  /* generate_discrete_graphical_model */


Static Void generate_continuous_graphical_model(new_model, old_model)
t_model **new_model, **old_model;
{
  t_set_list *sets_g_g_c;
  t_set_list *sets_d_g_c = NULL;
  boolean decomposable = false, graphical = false;
  boolean ok;

  P_setcpy((*new_model)->id->vertices, (*old_model)->id->vertices);
  do_model(old_model, false, false, &ok);
  if (!((*old_model)->found_expression && (*old_model)->graphical))
    find_graphical_and_decomposable_gc(&(*old_model)->id->UU.g_c_covariance,
      &sets_d_g_c, &sets_g_g_c, &decomposable, &graphical);
  if ((*old_model)->graphical || graphical)
    copy_set_list((*old_model)->id->UU.g_c_covariance,
		  &(*new_model)->id->UU.g_c_covariance);
  else
    (*new_model)->id->UU.g_c_covariance = sets_g_g_c;
  if (!((*old_model)->decomposable || decomposable))
    dispose_set_list(&sets_d_g_c);
}  /* generate_continuous_graphical_model */


Static Void generate_graphical_model(new_model, old_model)
t_model **new_model, **old_model;
{
  if ((*old_model)->id->model_type == pure_discrete)
    generate_discrete_graphical_model(new_model, old_model);
  else if ((*old_model)->id->model_type == pure_continuous)
    generate_continuous_graphical_model(new_model, old_model);
  else
    generate_discrete_graphical_model(new_model, old_model);
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new_model)->id->causal_structure);
}  /* generate_graphical_model */


Static boolean is_decomposable_after_dropping_edge(g_c, v, w, a)
t_set_list **g_c;
t_vertex *v, *w;
long *a;
{
  boolean ok;
  /* b   : t_vertex_set; */
  t_set_list *tmp_g_c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IsDecAfterDropping ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 1952L, 1L, -1L, -1L, g_c);
  ntr_g_c(tzt, 20L, 1952L, 1L, (long)(*v), (long)(*w), g_c);
  /*$endif TRACE*/
  copy_set_list(*g_c, &tmp_g_c);
  ok = was_edge_in_one_clique(v, w, &tmp_g_c, a);
  if (ok && mixed_data) {
    /* Lemma 2.19, SLL: */
    if (P_inset(*v, delta) & P_inset(*w, delta))
      ok = P_subset(a, delta);
    /*
    b := a;
    b := b * gamma_;
    if b <> empty_set then begin
       b := b - [w];
       b := b - [v];
       if b <> empty_set then
          ok := (v in gamma_) or (w in gamma_)
    end
     */
  }
  /*$ifdef TRACE*/
  ntr_set_and_boolean(tzt, 20L, 1952L, 8L, 1L, 1L, a, ok);
  /*$endif TRACE*/
  dispose_set_list(&tmp_g_c);
  return ok;
}  /* is_decomposable_after_dropping_edge */


Static boolean is_decomposable_after_adding_edge(g_c, v, w, a)
t_set_list **g_c;
t_vertex *v, *w;
long *a;
{
  boolean decomposable;
  t_v_arr_of_v_sets adj_set;
  t_vertex u;
  t_vertex_set g, b;

  /* if mixed_data then
       note_mixed(output, ' TestDecomposableA..', 20); */
  hypergraph_sets_to_graph_sets(*g_c, g, adj_set);
  P_addset(adj_set[*v - MIN_VERTEX], *w);
  P_addset(adj_set[*w - MIN_VERTEX], *v);
  decomposable = adj_set_decomposable(adj_set);
  P_setcpy(a, empty_set);
  if (!decomposable)
    return false;
  P_addset(P_expset(b, 0L), *v);
  P_addset(b, *w);
  for (u = first_vertex; u <= last_vertex; u++) {
    if (P_subset(b, adj_set[u - MIN_VERTEX]))
      P_addset(a, u);
  }
  return true;
}  /* is_decomposable_after_adding_edge */


Static t_set_list *return_sub_g_c(old_g_c, vertex_set, decomposable)
t_set_list **old_g_c;
long *vertex_set;
boolean decomposable;
{
  boolean ok;
  t_vertex v, w;
  t_vertex_set a;
  t_set_list *g_c = NULL;
  t_set_list *new_g_c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnSubGC        ", sizeof(pch20));
  ntr_set(tzt, 20L, 1954L, 1L, -1L, -1L, vertex_set);
  ntr_g_c(tzt, 20L, 1954L, 1L, -1L, -1L, old_g_c);
  /*$endif TRACE*/
  v = first_vertex;
  while (v <= last_vertex) {
    P_addset(P_expset(a, 0L), v);   /* empty_set + */
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 1954L, 2L, -1L, -1L, a);
    /*$endif TRACE*/
    if (P_inset(v, vertex_set))
      insert_clique(a, &g_c);
    v++;
  }
  v = first_vertex;
  while ((v < last_vertex) & P_inset(v, vertex_set)) {
    w = v + 1;
    while ((w <= last_vertex) & P_inset(w, vertex_set)) {
      if (decomposable)
	ok = is_decomposable_after_adding_edge(&g_c, &v, &w, a);
      else
	ok = true;
      if (ok) {
	new_g_c = NULL;
	sub_add_edge_to_g_c(&new_g_c, &g_c, v, w);
	if (test_sub_g_c(new_g_c, *old_g_c)) {
	  dispose_set_list(&g_c);
	  g_c = new_g_c;
	} else
	  dispose_set_list(&new_g_c);
      }
      w++;
    }
    v++;
  }
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 1954L, 8L, -1L, -1L, &g_c);
  /*$endif TRACE*/
  return g_c;
}  /* return_sub_g_c */


Static Void generate_mixed_graphical_submodel(new_model, old_model, decomposable)
t_model **new_model, **old_model;
boolean decomposable;
{
  t_set_list *p, *g_c, *new_g_c;
  boolean homogeneous, ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  do_model(old_model, false, false, &ok);
  if ((*old_model)->graphical && ((*old_model)->decomposable || !decomposable))
    copy_model(old_model, new_model);
  else {
    /* g_c := return_g_c_copy(old_model); */

    g_c = NULL;
    p = (*old_model)->id->UU.U1.g_c_discrete;
    while (p != NULL) {
      insert_set_in_set_list(p->vertex_set, &g_c);
      p = p->pointer;
    }
    p = (*old_model)->id->UU.U1.g_c_linear;
    while (p != NULL) {
      insert_set_in_set_list(p->vertex_set, &g_c);
      p = p->pointer;
    }
    p = (*old_model)->id->UU.U1.g_c_quadratic;
    while (p != NULL) {
      insert_set_in_set_list(p->vertex_set, &g_c);
      p = p->pointer;
    }

    new_g_c = return_sub_g_c(&g_c, (*old_model)->id->vertices, decomposable);
    dispose_set_list(&g_c);

    /*$ifdef TRACE*/
    memcpy(tzt, " GenMixedGraphiSubM ", sizeof(pch20));
    ntr_set(tzt, 20L, 1955L, 1L, -1L, -1L, delta);
    ntr_g_c(tzt, 20L, 1955L, 1L, -1L, -1L,
	    &(*old_model)->id->UU.U1.g_c_quadratic);
    /*$endif TRACE*/
    homogeneous = !g_c_intersects_set(delta,
				      (*old_model)->id->UU.U1.g_c_quadratic);

    homogeneous = true;

    split_g_c_in_mixed_terms(new_g_c, false, homogeneous,
      &(*new_model)->id->UU.U1.g_c_discrete,
      &(*new_model)->id->UU.U1.g_c_linear,
      &(*new_model)->id->UU.U1.g_c_quadratic);


    dispose_set_list(&new_g_c);
  }

  (*new_model)->id->UU.U1.decompose = true;
  P_setcpy((*new_model)->id->vertices, (*old_model)->id->vertices);
}  /* generate_mixed_graphical_submodel */


Static Void generate_discrete_graphical_submodel(new_model, old_model,
						 decomposable)
t_model **new_model, **old_model;
boolean decomposable;
{
  boolean ok;

  do_model(old_model, false, false, &ok);
  if ((*old_model)->graphical && ((*old_model)->decomposable || !decomposable))
    copy_model(old_model, new_model);
  else
    (*new_model)->id->UU.g_c_log_linear = return_sub_g_c(
	&(*old_model)->id->UU.g_c_log_linear, (*old_model)->id->vertices,
	decomposable);
  P_setcpy((*new_model)->id->vertices, (*old_model)->id->vertices);
}  /* generate_discrete_graphical_submodel */


Static Void generate_continuous_graphical_submodel(new_model, old_model,
						   decomposable)
t_model **new_model, **old_model;
boolean decomposable;
{
  boolean ok;

  do_model(old_model, false, false, &ok);
  if ((*old_model)->graphical && ((*old_model)->decomposable || !decomposable))
    copy_model(old_model, new_model);
  else
    (*new_model)->id->UU.g_c_log_linear = return_sub_g_c(
	&(*old_model)->id->UU.g_c_covariance, (*old_model)->id->vertices,
	decomposable);
  P_setcpy((*new_model)->id->vertices, (*old_model)->id->vertices);
}  /* generate_continuous_graphical_submodel */


/* Not used:
procedure generate_graphical_submodel(var new_model, old_model: t_link_model);
begin
   if old_model^.id^.model_type = pure_discrete then
      generate_discrete_graphical_submodel(new_model, old_model, false)
   else if old_model^.id^.model_type = pure_continuous then
      generate_continuous_graphical_submodel(new_model, old_model, false)
   else
      generate_mixed_graphical_submodel(new_model, old_model, false);
   copy_ordered_set_list(old_model^.id^.causal_structure, new_model^.id^.causal_structure)
end; */
/* generate_graphical_submodel */

Static Void generate_decomposable_submodel(new_model, old_model)
t_model **new_model, **old_model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GenerateSubmodel   ", sizeof(pch20));
  ntr_set(tzt, 20L, 1959L, 1L, -1L, -1L, (*old_model)->id->vertices);
  /*$endif TRACE*/
  if ((*old_model)->id->model_type == pure_discrete)
    generate_discrete_graphical_submodel(new_model, old_model, true);
  else if ((*old_model)->id->model_type == pure_continuous)
    generate_continuous_graphical_submodel(new_model, old_model, true);
  else
    generate_mixed_graphical_submodel(new_model, old_model, true);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 1959L, 1L, -1L, -1L, (*old_model)->id->vertices);
  ntr_set(tzt, 20L, 1959L, 1L, 1L, 2L, (*new_model)->id->vertices);
  ntr_model_g_c(tzt, 20L, 1959L, 1L, 1L, 3L, new_model);
  /*$endif TRACE*/
  copy_ordered_set_list((*old_model)->id->causal_structure,
			&(*new_model)->id->causal_structure);
}  /* generate_decomposable_submodel */


Static Void min_max_log_l_of_model(model, min_l, max_l)
t_model **model;
t_long_real *min_l, *max_l;
{
  t_model *sub_model, *super_model;
  boolean ok;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " MinMaxLogL         ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 1960L, 1L, 1L, 0L, model);
  /*$endif TRACE*/

  new_model(&sub_model);
  erase_model(&sub_model, (*model)->id->model_type, false);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1960L, 1L, -1L, 1L);
  /*$endif TRACE*/
  generate_decomposable_submodel(&sub_model, model);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1960L, 1L, -1L, 2L);
  /*$endif TRACE*/
  ok = ok_log_model(&sub_model, true);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1960L, 1L, -1L, 3L);
  /*$endif TRACE*/
  if (ok)
    *min_l = sub_model->log_l;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1960L, 1L, -1L, 4L);
  /*$endif TRACE*/

  new_model(&super_model);
  erase_model(&super_model, (*model)->id->model_type, false);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1960L, 7L, -1L, 1L);
  /*$endif TRACE*/
  generate_decomposable_model(&super_model, model);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1960L, 7L, -1L, 2L);
  /*$endif TRACE*/
  ok = ok_log_model(&super_model, true);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1960L, 7L, -1L, 3L);
  /*$endif TRACE*/
  if (ok)
    *max_l = super_model->log_l;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1960L, 7L, -1L, 4L);
  /*$endif TRACE*/

  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 1960L, 8L, -1L, 998L, &sub_model);
  ntr_model_numbers(tzt, 20L, 1960L, 8L, -1L, 998L, &sub_model);
  ntr_model_g_c(tzt, 20L, 1960L, 8L, -1L, 999L, &super_model);
  ntr_model_numbers(tzt, 20L, 1960L, 8L, -1L, 999L, &super_model);
  /*$endif TRACE*/

  dispose_model_and_link(&sub_model);

  dispose_model_and_link(&super_model);
}  /* min_max_log_l_of_model */


/*Has-forward-2*/

Static Void set_min_max_log_l_of_mixed_item(mixed_item)
t_mips_element *mixed_item;
{

  /*Has-forward-2*/

  /* No-forward

procedure set_min_max_log_l_of_mixed_item(var mixed_item : t_mips_element);

    No-forward */
  t_model *model;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " MinMaxLogLMixedItem", sizeof(pch20));
  ntr(tzt, 20L, 1962L, 1L, -1L, -1L);
  /*$endif TRACE*/

  new_model(&model);
  erase_mixed_model(&model);
  model->id->UU.U1.decompose = true;
  model->model_number = -1;

  /*$ifdef TRACE*/
  ntr_triple_g_c(tzt, 20L, 1962L, 2L, -1L, -1L, &mixed_item->discrete_,
		 &mixed_item->linear, &mixed_item->quadratic);
      /*ntr*/
  /*$endif TRACE*/

  /* model^.id^.g_c_discrete  := mixed_item.discrete;
  model^.id^.g_c_linear    := mixed_item.linear;
  model^.id^.g_c_quadratic := mixed_item.quadratic; */

  copy_set_list(mixed_item->discrete_, &model->id->UU.U1.g_c_discrete);
  copy_set_list(mixed_item->linear, &model->id->UU.U1.g_c_linear);
  copy_set_list(mixed_item->quadratic, &model->id->UU.U1.g_c_quadratic);

  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1962L, 4L, -1L, -1L);
  /*$endif TRACE*/

  P_setcpy(model->id->vertices, empty_set);
  add_union_of_gc(model->id->UU.U1.g_c_discrete, model->id->vertices);
  add_union_of_gc(model->id->UU.U1.g_c_linear, model->id->vertices);
  add_union_of_gc(model->id->UU.U1.g_c_quadratic, model->id->vertices);
  P_remset(model->id->vertices, double_vertex);

  /*$ifdef TRACE*/
  ntr(tzt, 20L, 1962L, 5L, -1L, -1L);
  /*$endif TRACE*/

  /* Loops:

  # ..., ok_log_model

  # min_max_log_l_of_model, set_min_max_log_l_of_mixed_item, mips,
  # sub_sub_estimate_model, sub_sub_compute_log_l, sub_compute_log_l,
  # compute_log_l_, compute_log_l, ok_log_model

  # min_max_log_l_of_model, set_min_max_log_l_of_mixed_item, mips,
  # sub_sub_estimate_model, sub_sub_compute_log_l, sub_compute_log_l,
  # compute_log_l_, compute_log_l, ok_log_model

  # proc_log_l, ...

  when no decomposition (boolean_option[121]) prevented by
  'model^.id^.decompose := true;'.

  */

  min_max_log_l_of_model(&model, &mixed_item->min_l, &mixed_item->max_l);

  /* model^.id^.g_c_discrete  := nil;
     model^.id^.g_c_linear    := nil;
     model^.id^.g_c_quadratic := nil; */


  dispose_model_and_link(&model);
}  /* set_min_max_log_l_of_mixed_item */


/* Local variables for test_one_inter_part: */
struct LOC_test_one_inter_part {
  t_model **base_model;
  t_test_write_options **write_options;
  t_test_labels **test_labels;
  t_set_list *current_g_c, *base_g_c;
  t_vertex_set g;
} ;

Local Void insert_d(d, LINK)
long *d;
struct LOC_test_one_inter_part *LINK;
{
  t_long_integer number_of_tests;
  t_set_list *new_base_g_c;

  new_base_g_c = return_g_c_copy_for_mixed_model(LINK->base_model);
  if (subset_of_an_edge(d, &new_base_g_c) && !interrupt_2) {
    insert_clique(d, &LINK->base_g_c);
    if (!test_sub_g_c(LINK->base_g_c, LINK->current_g_c)) {
      if ((*LINK->write_options)->write_models) {
	if ((*LINK->write_options)->line_form) {
	  write_space(stdout, 3L);
	  print_vertex_set_table(d);
	} else {
	  write_pch(stdout, " Edge: ", 7L);
	  print_vertex_set(d);
	  write_line(stdout);
	}
      }
      number_of_tests = 0;   /* HomMode */
      partitioning_hierarchical(&LINK->current_g_c, &LINK->base_g_c,
	&(*LINK->base_model)->id->causal_structure,
	&(*LINK->base_model)->id->UU.U1.homogeneous, LINK->write_options,
	LINK->test_labels, &number_of_tests);
      if (!(*LINK->write_options)->write_models) {
	if ((*LINK->write_options)->line_form) {
	  print_vertex_set_table(d);
	  write_line(stdout);
	}
      }
      dispose_set_list(&LINK->current_g_c);
      copy_set_list(LINK->base_g_c, &LINK->current_g_c);
    }
  }
  dispose_g_c_copy_for_mixed_model(LINK->base_model, &new_base_g_c);
}  /* insert_d */

Local Void find_d_(v1, v2, d, LINK)
t_vertex v1, v2;
long *d;
struct LOC_test_one_inter_part *LINK;
{
  t_vertex v;
  t_vertex_set b;

  if (v2 == last_vertex) {
    for (v = v1; v <= v2; v++) {
      if (P_inset(v, LINK->g)) {
	P_setcpy(b, d);
	P_addset(b, v);
	insert_d(b, LINK);
      }
    }
    return;
  }
  for (v = v1; v <= v2; v++) {
    if (P_inset(v, LINK->g)) {
      P_setcpy(b, d);
      P_addset(b, v);
      find_d_(v + 1, v2 + 1, b, LINK);
    }
  }
}  /* find_d */


/*@+"facti.p"*/


/*

1965:    +++  ++
1966:    +++  ++
1967:    ---  -- p/facti.p          8      35     426 p/facti.p
1968: |    4:    procedure test_one_inter_part
1969: |   13:    procedure insert_d
1970: |   50:    procedure find_d
1971: |   90:    procedure test_one_inter_fast
1972: |  100:    function subset_of_an_edge
1973: |  116:    procedure fit_model
1974: |  133:    procedure insert_d
1975: |  172:    procedure find_d
1976:    +++  ++
1977:    +++  ++

*/

Static Void test_one_inter_part(current_model, base_model_, vertex_order,
				write_options_, test_labels_)
t_model **current_model, **base_model_;
t_vertex_list *vertex_order;
t_test_write_options **write_options_;
t_test_labels **test_labels_;
{
  struct LOC_test_one_inter_part Local_Var;
  t_vertex v;

  Local_Var.base_model = base_model_;
  Local_Var.write_options = write_options_;
  Local_Var.test_labels = test_labels_;
  Local_Var.current_g_c = return_g_c_copy(current_model);
  copy_set_list(Local_Var.current_g_c, &Local_Var.base_g_c);
  P_setcpy(Local_Var.g, empty_set);
  while (vertex_order != NULL) {
    P_addset(Local_Var.g, vertex_order->vertex);
    for (v = last_vertex; v >= first_vertex; v--)
      find_d_(first_vertex, v, empty_set, &Local_Var);
    vertex_order = vertex_order->pointer;
  }
  P_setcpy(Local_Var.g, delta_gamma);
  for (v = last_vertex; v >= first_vertex; v--)
    find_d_(first_vertex, v, empty_set, &Local_Var);
  dispose_set_list(&Local_Var.current_g_c);
  dispose_set_list(&Local_Var.base_g_c);
}  /* test_one_inter_part */


/* Local variables for test_one_inter_fast: */
struct LOC_test_one_inter_fast {
  t_model **current_model, **base_model;
  t_test_write_options **write_options;
  t_test_labels **test_labels;
  t_model_list *link_model, *link_current_model, *link_base_model;
  boolean ok;
  t_vertex_set g;
} ;

Local boolean subset_of_an_edge_(a, list_of_cliques, LINK)
long *a;
t_set_list *list_of_cliques;
struct LOC_test_one_inter_fast *LINK;
{
  t_set_list *p = list_of_cliques;
  boolean b = true;

  while (p != NULL && b) {
    if (P_subset(a, p->vertex_set))
      b = false;
    else
      p = p->pointer;
  }
  return (!b);
}  /* subset_of_an_edge */

Local Void fit_model(model, ok, LINK)
t_model **model;
boolean *ok;
struct LOC_test_one_inter_fast *LINK;
{
  t_set_list *g_c;
  t_model_list *p_model;

  g_c = (*model)->id->UU.g_c_log_linear;
  (*model)->id->UU.g_c_log_linear = NULL;
  erase_model(model, pure_discrete, true);
  copy_ordered_set_list((*LINK->current_model)->id->causal_structure,
			&(*model)->id->causal_structure);
  (*model)->id->UU.g_c_log_linear = g_c;
  identify_model(model);
  *ok = return_model(model, &p_model);
  if (!*ok)
    *ok = ok_model_to_test(model);
}  /* fit_model */

Local Void insert_d_(d, LINK)
long *d;
struct LOC_test_one_inter_fast *LINK;
{
  if (!(subset_of_an_edge_(d, (*LINK->base_model)->id->UU.g_c_log_linear,
			   LINK) && LINK->ok) || interrupt_2)
    return;
  insert_clique(d, &LINK->link_base_model->model->id->UU.g_c_log_linear);
  if (test_sub_g_c(LINK->link_base_model->model->id->UU.g_c_log_linear,
		   LINK->link_current_model->model->id->UU.g_c_log_linear))
    return;
  if ((*LINK->write_options)->write_models) {
    if ((*LINK->write_options)->line_form) {
      write_space(stdout, 3L);
      print_vertex_set_table(d);
    } else {
      write_pch(stdout, " Edge: ", 7L);
      print_vertex_set(d);
      write_line(stdout);
    }
  }
  fit_model(&LINK->link_base_model->model, &LINK->ok, LINK);
  if (LINK->ok) {
    test_models(&LINK->link_current_model->model,
		&LINK->link_base_model->model, delta, LINK->write_options,
		LINK->test_labels);
    link_model_list = LINK->link_base_model;
    link_model_list->pointer = NULL;
    dispose_model(&LINK->link_current_model->model);
    LINK->link_model = LINK->link_current_model;
    LINK->link_current_model = LINK->link_base_model;
    LINK->link_base_model = LINK->link_model;
    erase_model(&LINK->link_base_model->model, pure_discrete, true);
    copy_set_list(LINK->link_current_model->model->id->UU.g_c_log_linear,
		  &LINK->link_base_model->model->id->UU.g_c_log_linear);
  }
  if ((*LINK->write_options)->write_models)
    return;
  if ((*LINK->write_options)->line_form) {
    print_vertex_set_table(d);
    write_line(stdout);
  }
}  /* insert_d */

Local Void find_d__(v1, v2, d, LINK)
t_vertex v1, v2;
long *d;
struct LOC_test_one_inter_fast *LINK;
{
  t_vertex v;
  t_vertex_set b;

  if (v2 == last_vertex) {
    for (v = v1; v <= v2; v++) {
      if (P_inset(v, LINK->g)) {
	P_setcpy(b, d);
	P_addset(b, v);
	insert_d_(b, LINK);
      }
    }
    return;
  }
  for (v = v1; v <= v2; v++) {
    if (P_inset(v, LINK->g)) {
      P_setcpy(b, d);
      P_addset(b, v);
      find_d__(v + 1, v2 + 1, b, LINK);
    }
  }
}  /* find_d */


Static Void test_one_inter_fast(current_model_, base_model_, vertex_order,
				write_options_, test_labels_)
t_model **current_model_, **base_model_;
t_vertex_list *vertex_order;
t_test_write_options **write_options_;
t_test_labels **test_labels_;
{
  struct LOC_test_one_inter_fast Local_Var;
  t_model_list *l_m_l;
  t_vertex v;

  Local_Var.current_model = current_model_;
  Local_Var.base_model = base_model_;
  Local_Var.write_options = write_options_;
  Local_Var.test_labels = test_labels_;
  if (mixed_data &&
      ((*Local_Var.current_model)->id->model_type != pure_discrete ||
       (*Local_Var.base_model)->id->model_type != pure_discrete)) {
    note_mixed(stdout, " EdgeFactorizes", 13L);
    return;
  }
  Local_Var.link_current_model = (t_model_list *)Malloc(sizeof(t_model_list));
  if (Local_Var.link_current_model == NULL)
    _OutMem();
  Local_Var.link_base_model = (t_model_list *)Malloc(sizeof(t_model_list));
  if (Local_Var.link_base_model == NULL)
    _OutMem();
  new_model(&Local_Var.link_current_model->model);
  new_model(&Local_Var.link_base_model->model);
  erase_model(&Local_Var.link_current_model->model, pure_discrete, true);
  erase_model(&Local_Var.link_base_model->model, pure_discrete, true);
  l_m_l = link_model_list;
  copy_set_list((*Local_Var.current_model)->id->UU.g_c_log_linear,
		&Local_Var.link_current_model->model->id->UU.g_c_log_linear);
  copy_set_list(Local_Var.link_current_model->model->id->UU.g_c_log_linear,
		&Local_Var.link_base_model->model->id->UU.g_c_log_linear);
  fit_model(&Local_Var.link_current_model->model, &Local_Var.ok, &Local_Var);
  P_setcpy(Local_Var.g, empty_set);
  while (vertex_order != NULL) {
    P_addset(Local_Var.g, vertex_order->vertex);
    for (v = last_vertex; v >= first_vertex; v--)
      find_d__(first_vertex, v, empty_set, &Local_Var);
    vertex_order = vertex_order->pointer;
  }
  P_setcpy(Local_Var.g, delta);
  for (v = last_vertex; v >= first_vertex; v--)
    find_d__(first_vertex, v, empty_set, &Local_Var);
  if (!Local_Var.ok) {
    write_pch(stdout, " Out of space", 13L);
    write_line(stdout);
  }
  dispose_model(&Local_Var.link_current_model->model);
  dispose_model(&Local_Var.link_base_model->model);
  _Free(Local_Var.link_current_model);
  _Free(Local_Var.link_base_model);
  link_model_list = l_m_l;
}  /* test_one_inter_fast */


/*@+"facte.p"*/


/*

1978:    +++  ++
1979:    +++  ++
1980:    ---  -- p/facte.p          5      29     365 p/facte.p
1981: |    4:    procedure move_formula_after_dispose
1982: |   13:    procedure conditional_dispose_formula
1983: |   20:    procedure factorizes_c
1984: |  177:    procedure factorizes_b
1985: |  351:    procedure factorizes_a
1986:    +++  ++
1987:    +++  ++

*/

Static Void move_formula_after_dispose(a_model, b_model)
t_model **a_model, **b_model;
{
  dispose_formula(b_model);
  (*b_model)->constant = (*a_model)->constant;
  (*b_model)->dim = (*a_model)->dim;
  (*b_model)->formula_node = (*a_model)->formula_node;
  (*a_model)->formula_node = NULL;
}  /* move_formula_after_dispose */


Static Void conditional_dispose_formula(do_dispose, model)
boolean do_dispose;
t_model **model;
{
  if (do_dispose)
    dispose_formula(model);
}  /* conditional_dispose_formula */


Static Void factorizes_c(current_model, base_model, vertex_order,
			 partitioning, write_options, test_labels)
t_model **current_model, **base_model;
t_vertex_list *vertex_order;
boolean partitioning;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean homogeneous, ok;
  t_vertex u1, u2;
  t_vertex_set g, a, b, am1, am2;
  t_model *a_model, *b_model;
  t_set_list *g_c, *g_c_a, *g_c_b;
  t_edge_list *link_edge_list, *p, *q;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_sets adj_set_a, adj_set_b;
  t_v_arr_of_v_lists adj_list_a, adj_list_b;
  t_long_integer dummy_0;
  t_test_list *p_test;

  partitioning = (partitioning || incomplete_table || mixed_data);
  if (!partitioning) {
    new_model(&a_model);
    erase_model(&a_model, pure_discrete, true);
    new_model(&b_model);
    erase_model(&b_model, pure_discrete, true);
    copy_ordered_set_list((*current_model)->id->causal_structure,
			  &a_model->id->causal_structure);
    copy_ordered_set_list((*current_model)->id->causal_structure,
			  &b_model->id->causal_structure);
    a_model->found_expression = true;
    b_model->found_expression = true;
    a_model->found_ps = !em;
    b_model->found_ps = !em;
  }
  if (test_grap_submodel(current_model, base_model, adj_set_a, adj_set_b, g)) {
    ok = true;
    link_edge_list = NULL;
    adj_set_to_adj_list(adj_set_b, adj_list_b);
    find_edges(adj_list_b, adj_set_a, &link_edge_list);
    p = (t_edge_list *)Malloc(sizeof(t_edge_list));
    if (p == NULL)
      _OutMem();
    p->pointer = link_edge_list;
    link_edge_list = p;
    g_c = return_g_c_copy(base_model);
    g_c_b = return_g_c_copy(base_model);
    if (!partitioning) {
      clear_expression_and_set_model_set(&a_model, g);
      clear_expression_and_set_model_set(&b_model, g);
      b_model->id->UU.g_c_log_linear = g_c_b;   /* 1 */
      decompose_decomposable(&b_model, &b_model->id->UU.g_c_log_linear, g,
			     adj_list_b, false, order, invers_order,
			     &b_model->constant, &b_model->dim);
    }
    dispose_adj_list(adj_list_b);
    memcpy(adj_set_a, adj_set_b, sizeof(t_v_arr_of_v_sets));
    P_setcpy(b, empty_set);
    if (vertex_order == NULL)
      P_setcpy(b, g);
    else {
      P_addset(b, vertex_order->vertex);
      vertex_order = vertex_order->pointer;
    }
    if (vertex_order == NULL)
      P_setcpy(b, g);
    else {
      P_addset(b, vertex_order->vertex);
      vertex_order = vertex_order->pointer;
    }
    while (link_edge_list->pointer != NULL && !interrupt_2) {
      do {
	p = link_edge_list;
	q = p->pointer;
	ok = false;
	while (!ok && q != NULL) {
	  u1 = q->v;
	  u2 = q->w;
	  if (P_inset(u1, b) & P_inset(u2, b))
	    ok = was_edge_in_one_clique(&u1, &u2, &g_c, a);
	  if (ok) {
	    p->pointer = q->pointer;
	    _Free(q);
	  } else {
	    p = q;
	    q = q->pointer;
	  }
	}
	if (!ok) {
	  if (vertex_order == NULL)
	    P_setcpy(b, g);
	  else {
	    P_addset(b, vertex_order->vertex);
	    vertex_order = vertex_order->pointer;
	  }
	}
      } while (!ok);
      P_remset(adj_set_a[u1 - MIN_VERTEX], u2);
      P_remset(adj_set_a[u2 - MIN_VERTEX], u1);
      P_setcpy(am1, a);
      P_remset(am1, u1);
      insert_clique(am1, &g_c);
      P_setcpy(am2, a);
      P_remset(am2, u2);
      insert_clique(am2, &g_c);
      if ((*write_options)->write_models)
	print_edge(stdout, write_options, test_labels, u1, u2);
      homogeneous = false;
      if ((*current_model)->id->model_type == mixed)
	homogeneous = (*current_model)->id->UU.U1.homogeneous;
      if (partitioning && !(incomplete_table || mixed_data))
	one_edge_collaps(adj_set_a, &u1, &u2, &homogeneous, &p_test,
			 write_options, test_labels);
      else {
	g_c_a = g_c;
	dummy_0 = 0;
	if (incomplete_table || mixed_data)
	  partitioning_hierarchical(&g_c_a, &g_c_b,
	    &(*current_model)->id->causal_structure, &homogeneous,
	    write_options, test_labels, &dummy_0);
	else {
	  adj_set_to_adj_list(adj_set_a, adj_list_a);
	  dispose_adj_list(adj_list_a);
	  a_model->id->UU.g_c_log_linear = g_c_a;
	  b_model->id->UU.g_c_log_linear = g_c_b;
	  /* 2 */
	  decompose_decomposable(&a_model, &a_model->id->UU.g_c_log_linear, g,
				 adj_list_a, false, order, invers_order,
				 &a_model->constant, &a_model->dim);
	  test_models(&a_model, &b_model, g, write_options, test_labels);
	  dispose_marginals_cond();
	  move_formula_after_dispose(&a_model, &b_model);
	}
	dispose_set_list(&g_c_b);
	copy_set_list(g_c_a, &g_c_b);
      }
      if (!(*write_options)->write_models) {
	print_edge(stdout, write_options, test_labels, u1, u2);
	write_line(stdout);
      }
    }
    if (interrupt_2) {
      interrupt_1 = false;
      interrupt_2 = false;
    }
    _Free(link_edge_list);
    if (!partitioning) {
      dispose_set_list(&a_model->id->causal_structure);
      dispose_set_list(&b_model->id->causal_structure);
      conditional_dispose_formula(true, &b_model);
    }
    dispose_set_list(&g_c);
  }
  if (!partitioning) {
    dispose_model_link(&a_model);
    dispose_model_link(&b_model);
  }
}  /* factorizes_c */


Static Void factorizes_b(current_model, base_model, vertex_order,
			 partitioning, write_options, test_labels)
t_model **current_model, **base_model;
t_vertex_list *vertex_order;
boolean partitioning;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean homogeneous, ok;
  t_vertex u1, u2;
  t_vertex_set g, b;
  t_model *a_model, *b_model;
  t_set_list *g_c_a, *g_c_b;
  t_edge_list *link_edge_list, *p, *q;
  t_vertex_list *a1, *a2;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_sets adj_set_a, adj_set_b;
  t_v_arr_of_v_lists adj_list_b;
  t_long_integer dummy_0;
  t_test_list *p_test;

  partitioning = (partitioning || incomplete_table || mixed_data);
  if (!partitioning || incomplete_table || mixed_data)
    g_c_a = return_g_c_copy(current_model);
  if (!partitioning) {
    new_model(&a_model);
    erase_model(&a_model, pure_discrete, true);
    new_model(&b_model);
    erase_model(&b_model, pure_discrete, true);
    copy_ordered_set_list((*current_model)->id->causal_structure,
			  &a_model->id->causal_structure);
    copy_ordered_set_list((*current_model)->id->causal_structure,
			  &b_model->id->causal_structure);
    a_model->found_expression = true;
    b_model->found_expression = true;
    a_model->found_ps = !em;
    b_model->found_ps = !em;
  }
  if (test_grap_submodel(current_model, base_model, adj_set_a, adj_set_b, g)) {
    ok = true;
    link_edge_list = NULL;
    adj_set_to_adj_list(adj_set_b, adj_list_b);
    find_edges(adj_list_b, adj_set_a, &link_edge_list);
    p = (t_edge_list *)Malloc(sizeof(t_edge_list));
    if (p == NULL)
      _OutMem();
    p->pointer = link_edge_list;
    link_edge_list = p;
    dispose_adj_list(adj_list_b);
    adj_set_to_adj_list(adj_set_a, adj_list_b);
    memcpy(adj_set_b, adj_set_a, sizeof(t_v_arr_of_v_sets));
	/* Is it used ? */
    if (!partitioning) {
      clear_expression_and_set_model_set(&a_model, g);
      clear_expression_and_set_model_set(&b_model, g);
      a_model->id->UU.g_c_log_linear = g_c_a;   /* 3 */
      decompose_decomposable(&a_model, &a_model->id->UU.g_c_log_linear, g,
			     adj_list_b, false, order, invers_order,
			     &a_model->constant, &a_model->dim);
    }
    P_setcpy(b, empty_set);
    if (vertex_order == NULL)
      P_setcpy(b, g);
    else {
      P_addset(b, vertex_order->vertex);
      vertex_order = vertex_order->pointer;
    }
    if (vertex_order == NULL)
      P_setcpy(b, g);
    else {
      P_addset(b, vertex_order->vertex);
      vertex_order = vertex_order->pointer;
    }
    while (link_edge_list->pointer != NULL && !interrupt_2) {
      a1 = (t_vertex_list *)Malloc(sizeof(t_vertex_list));
      if (a1 == NULL)
	_OutMem();
      a2 = (t_vertex_list *)Malloc(sizeof(t_vertex_list));
      if (a2 == NULL)
	_OutMem();
      ok = false;
      do {
	p = link_edge_list;
	q = p->pointer;
	while (!ok && q != NULL) {
	  u1 = q->v;
	  u2 = q->w;
	  if (!(P_inset(u1, b) & P_inset(u2, b))) {
	    p = q;
	    q = q->pointer;
	    continue;
	  }
	  a1->vertex = u1;
	  a1->pointer = adj_list_b[u2 - MIN_VERTEX];
	  adj_list_b[u2 - MIN_VERTEX] = a1;
	  a2->vertex = u2;
	  a2->pointer = adj_list_b[u1 - MIN_VERTEX];
	  adj_list_b[u1 - MIN_VERTEX] = a2;
	  /* Do better for mixed models !!! */
	  maximum_cardinality_search(adj_list_b, order, invers_order);
	  ok = test_for_zero_fill_in(adj_list_b, order, invers_order);
	  if (ok) {
	    p->pointer = q->pointer;
	    _Free(q);
	  } else {
	    adj_list_b[u1 - MIN_VERTEX] = adj_list_b[u1 - MIN_VERTEX]->pointer;
	    adj_list_b[u2 - MIN_VERTEX] = adj_list_b[u2 - MIN_VERTEX]->pointer;
	    p = q;
	    q = q->pointer;
	  }
	}
	if (!ok) {
	  if (vertex_order == NULL)
	    P_setcpy(b, g);
	  else {
	    P_addset(b, vertex_order->vertex);
	    vertex_order = vertex_order->pointer;
	  }
	}
      } while (!ok);
      if ((*current_model)->id->model_type == mixed)
	homogeneous = link_current->model->id->UU.U1.homogeneous;
      else
	homogeneous = false;
      if ((*write_options)->write_models)
	print_edge(stdout, write_options, test_labels, u1, u2);
      if (partitioning && !(incomplete_table || mixed_data)) {
	/* !?!?! */
	one_edge_collaps(adj_set_a, &u1, &u2, &homogeneous, &p_test,
			 write_options, test_labels);
	P_addset(adj_set_a[u1 - MIN_VERTEX], u2);
	P_addset(adj_set_a[u2 - MIN_VERTEX], u1);
      } else {
	P_addset(adj_set_a[u1 - MIN_VERTEX], u2);
	P_addset(adj_set_a[u2 - MIN_VERTEX], u1);
	find_cliques(adj_set_a, g, &g_c_b);
	/*$ifdef TRACE*/
	ntr_g_c(" Factorize-B, GC/A  ", 20L, 1984L, 1L, -1L, 1L, &g_c_a);
	ntr_g_c(" Factorize-B, GC/B  ", 20L, 1984L, 1L, -1L, 2L, &g_c_b);
	/*$endif TRACE*/
	dummy_0 = 0;
	if (incomplete_table || mixed_data)
	  partitioning_hierarchical(&g_c_a, &g_c_b,
	    &(*current_model)->id->causal_structure, &homogeneous,
	    write_options, test_labels, &dummy_0);
	else {
	  a_model->id->UU.g_c_log_linear = g_c_a;
	  b_model->id->UU.g_c_log_linear = g_c_b;
	  /* 4 */
	  decompose_decomposable(&b_model, &b_model->id->UU.g_c_log_linear, g,
				 adj_list_b, true, order, invers_order,
				 &b_model->constant, &b_model->dim);
	  test_models(&a_model, &b_model, g, write_options, test_labels);
	  dispose_marginals_cond();
	  move_formula_after_dispose(&b_model, &a_model);
	}
	dispose_set_list(&g_c_a);
	g_c_a = g_c_b;
      }
      if (!(*write_options)->write_models) {
	print_edge(stdout, write_options, test_labels, u1, u2);
	write_line(stdout);
      }
    }
    if (interrupt_2) {
      interrupt_1 = false;
      interrupt_2 = false;
    }
    dispose_adj_list(adj_list_b);
    _Free(link_edge_list);
    if (!partitioning || incomplete_table || mixed_data)
      dispose_set_list(&g_c_a);
    conditional_dispose_formula(!partitioning || incomplete_table, &a_model);
  }
  if (!partitioning) {
    dispose_model_link(&a_model);
    dispose_model_link(&b_model);
  }
}  /* factorizes_b */


Static Void factorizes_a(current_model, base_model, vertex_order,
			 partitioning, write_options, test_labels)
t_model **current_model, **base_model;
t_vertex_list *vertex_order;
boolean partitioning;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean homogeneous, ok;
  t_vertex u1, u2;
  t_vertex_set g, b;
  t_model *a_model, *b_model;
  t_long_integer dummy_0;
  t_set_list *g_c_a, *g_c_b;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order;
  t_v_arr_of_v_sets current_adj_set, base_adj_set;
  t_v_arr_of_v_lists adj_list_a, adj_list_b;

  if ((*current_model)->id->model_type == mixed)
    homogeneous = link_current->model->id->UU.U1.homogeneous;
  else
    homogeneous = false;
  partitioning = (partitioning || incomplete_table || mixed_data);
  if (!partitioning) {
    new_model(&a_model);
    erase_model(&a_model, pure_discrete, true);
    new_model(&b_model);
    erase_model(&b_model, pure_discrete, true);
    copy_ordered_set_list((*current_model)->id->causal_structure,
			  &a_model->id->causal_structure);
    copy_ordered_set_list((*current_model)->id->causal_structure,
			  &b_model->id->causal_structure);
    a_model->found_expression = true;
    b_model->found_expression = true;
    a_model->found_ps = !em;
    b_model->found_ps = !em;
  }
  if (test_grap_submodel(current_model, base_model, current_adj_set,
			 base_adj_set, g)) {
    ok = true;
    g_c_a = return_g_c_copy(current_model);
    if (!partitioning) {
      clear_expression_and_set_model_set(&a_model, g);
      clear_expression_and_set_model_set(&b_model, g);
      adj_set_to_adj_list(current_adj_set, adj_list_a);
      a_model->id->UU.g_c_log_linear = g_c_a;   /* 5 */
      decompose_decomposable(&a_model, &a_model->id->UU.g_c_log_linear, g,
			     adj_list_a, false, order, invers_order,
			     &a_model->constant, &a_model->dim);
      dispose_adj_list(adj_list_a);
    }
    P_setcpy(b, empty_set);
    if (vertex_order == NULL)
      P_setcpy(b, g);
    else {
      P_addset(b, vertex_order->vertex);
      vertex_order = vertex_order->pointer;
    }
    if (vertex_order == NULL)
      P_setcpy(b, g);
    else {
      P_addset(b, vertex_order->vertex);
      vertex_order = vertex_order->pointer;
    }
    while (ok && !interrupt_2) {
      do {
	u1 = first_vertex;
	ok = false;
	while (!ok && u1 < last_vertex) {
	  if (P_inset(u1, b)) {
	    u2 = u1;
	    do {
	      u2++;
	      if (P_inset(u2, base_adj_set[u1 - MIN_VERTEX]) & (!P_inset(u2,
		      current_adj_set[u1 - MIN_VERTEX])) & P_inset(u2, b)) {
		adj_set_to_adj_list(current_adj_set, adj_list_b);
		insert_edge_in_adj_list(adj_list_b, &u1, &u2);
		/* Do better for mixed data !!! */
		maximum_cardinality_search(adj_list_b, order, invers_order);
		ok = test_for_zero_fill_in(adj_list_b, order, invers_order);
		if (!ok)
		  dispose_adj_list(adj_list_b);
	      }
	    } while (!(ok || u2 == last_vertex));
	  }
	  if (!ok)
	    u1++;
	}
	if (!ok) {
	  if (!P_setequal(b, g)) {
	    u1 = first_vertex;
	    if (vertex_order == NULL)
	      P_setcpy(b, g);
	    else {
	      P_addset(b, vertex_order->vertex);
	      vertex_order = vertex_order->pointer;
	    }
	  }
	}
      } while (!(ok || u1 == last_vertex));
      if (!ok)
	break;
      if ((*write_options)->write_models)
	print_edge(stdout, write_options, test_labels, u1, u2);
      P_addset(current_adj_set[u1 - MIN_VERTEX], u2);
      P_addset(current_adj_set[u2 - MIN_VERTEX], u1);
      find_cliques(current_adj_set, g, &g_c_b);
      dummy_0 = 0;
      if (partitioning)
	partitioning_hierarchical(&g_c_a, &g_c_b,
	  &(*current_model)->id->causal_structure, &homogeneous,
	  write_options, test_labels, &dummy_0);
      else {
	a_model->id->UU.g_c_log_linear = g_c_a;
	b_model->id->UU.g_c_log_linear = g_c_b;
	/* 6 */
	decompose_decomposable(&b_model, &b_model->id->UU.g_c_log_linear, g,
			       adj_list_b, true, order, invers_order,
			       &b_model->constant, &b_model->dim);
	test_models(&a_model, &b_model, g, write_options, test_labels);
	dispose_marginals_cond();
	move_formula_after_dispose(&b_model, &a_model);
      }
      dispose_set_list(&g_c_a);
      g_c_a = g_c_b;
      if (!(*write_options)->write_models) {
	print_edge(stdout, write_options, test_labels, u1, u2);
	write_line(stdout);
      }
      dispose_adj_list(adj_list_b);
    }
    if (interrupt_2) {
      interrupt_1 = false;
      interrupt_2 = false;
    }
    dispose_set_list(&g_c_a);
    conditional_dispose_formula(!partitioning, &a_model);
  }
  if (!partitioning) {
    dispose_set_list(&a_model->id->causal_structure);
    dispose_set_list(&b_model->id->causal_structure);
  }
  if (!partitioning) {
    dispose_model_link(&a_model);
    dispose_model_link(&b_model);
  }
}  /* factorizes_a */


/*@-"stepwise.c"*/
/*@+"stepwise.p"*/


/*

1988:    +++  ++
1989:    +++  ++
1990:    ---  -- p/stepwise.p        15      67     865 p/stepwise.p
1991: |    4:    function g_c_decomposable
1992: |   38:    function g_c_conformal
1993: |   56:    procedure find_shortest_path
1994: |   62:    procedure find_set
1995: |   90:    procedure find_minimal_cut_sets
1996: |  132:    procedure test_all_cut_sets
1997: |  187:    procedure select_and_update
1998: |  269:    procedure shuffle_edges
1999: |  299:    procedure return_first_and_last
2000: |  310:    procedure write_stepwise_head
2001: |  327:    procedure write_not_decomposable
2002: |  382:    procedure end_stepwise_step
2003: |  437:    procedure note_edge
2004: |  474:    procedure report_stepwise
2005: |  577:    procedure report_last_test
2006:    +++  ++
2007:    +++  ++

*/

Static boolean g_c_decomposable(g_c)
t_set_list **g_c;
{
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_order order, beta;
  t_offset_list *r;
  t_adjacency_matrix gc_adjacency_matrix;
  boolean decomposable;
  t_v_arr_of_v_sets adj_set;
  t_vertex_set a;

  /* if mixed_data then
       note_mixed(output, ' GCDecomposable@@@@@', 15)
    else */
  create_adjacency_matrix(&gc_adjacency_matrix, *g_c);
  restricted_maximim_cardinality_search_on_hypergraph(&gc_adjacency_matrix,
    empty_set, &decomposable, order, beta, invers_order, &r);
  revers_offset_list(&r);
  if (decomposable)
    decomposable = test_acyclic_hypergraph(beta, &r);
  dispose_offset_list(&r);
  delete_edges_with_vertices(&gc_adjacency_matrix, delta_gamma);
  if (!mixed_data)
    return decomposable;
  if (decomposable) {
    hypergraph_sets_to_graph_sets(*g_c, a, adj_set);
    decomposable = adj_set_decomposable(adj_set);
  }
  return decomposable;
}  /* g_c_decomposable */


Static boolean g_c_conformal(g_c)
t_set_list **g_c;
{
  t_v_arr_of_v_sets adj_set;
  t_vertex_set a;

  if (mixed_data) {
    if (trace_flag_set(20L, 1992L, 2L))
      note_mixed(stdout, " GCConformal", 12L);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1992L, 1L)) {
      print_g_c(*g_c, 0L, line_length);
      write_line(stdout);
    }
    /*$endif TRACE*/
  }
  hypergraph_sets_to_graph_sets(*g_c, a, adj_set);
  return (test_graphical(adj_set, g_c));
}  /* g_c_conformal */


/* Local variables for find_shortest_path: */
struct LOC_find_shortest_path {
  t_vertex *b;
  t_vertex_list **adj_list;
  t_set_list **paths;
} ;

Local Void find_set(v, path, LINK)
t_vertex v;
long *path;
struct LOC_find_shortest_path *LINK;
{
  t_vertex_set new_path;
  t_vertex_list *p;

  if (v == *LINK->b) {
    insert_set_minimal(path, LINK->paths);
    return;
  }
  p = LINK->adj_list[v - MIN_VERTEX];
  P_setcpy(new_path, path);
  P_addset(new_path, v);
  while (p != NULL) {
    if (!P_inset(p->vertex, path))
      find_set(p->vertex, new_path, LINK);
    p = p->pointer;
  }
}  /* find_set */


Static Void find_shortest_path(a, b_, adj_list_, paths_)
t_vertex *a, *b_;
t_vertex_list **adj_list_;
t_set_list **paths_;
{
  struct LOC_find_shortest_path Local_Var;
  t_vertex_list *p;

  Local_Var.b = b_;
  Local_Var.adj_list = adj_list_;
  Local_Var.paths = paths_;
  p = Local_Var.adj_list[*a - MIN_VERTEX];
  while (p != NULL) {
    find_set(p->vertex, empty_set, &Local_Var);
    p = p->pointer;
  }
}  /* find_shortest_path */


Static Void find_minimal_cut_sets(a, b, adj_list, cut_sets)
t_vertex *a, *b;
t_vertex_list **adj_list;
t_set_list **cut_sets;
{
  t_set_list *p;
  t_set_list *paths = NULL;

  find_shortest_path(a, b, adj_list, &paths);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1995L, 1L)) {
    write_pch(stdout, "Paths :   ", 10L);
    if (paths != NULL)
      print_g_c(paths, 10L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (paths == NULL) {
    *cut_sets = NULL;
    return;
  }
  p = paths;
  while (p != NULL) {
    P_setdiff(p->vertex_set, delta_gamma, p->vertex_set);
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1995L, 1L)) {
    write_pch(stdout, "*\\Paths : ", 10L);
    print_g_c(paths, 10L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  normal_to_dual(paths, delta_gamma, cut_sets);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1995L, 1L)) {
    write_pch(stdout, "Cut Sets: ", 10L);
    print_g_c(*cut_sets, 10L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  dispose_set_list(&paths);
}  /* find_minimal_cut_sets */


Static Void test_all_cut_sets(g_c, v, w, homogeneous, p_test, write_options,
			      test_labels)
t_set_list **g_c;
t_vertex *v, *w;
boolean *homogeneous;
t_test_list **p_test;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean ok_mixed;
  t_v_arr_of_v_sets adj_set;
  t_set_list *p, *cut_sets;
  t_v_arr_of_v_lists adj_list;
  t_vertex_set a, bv, bw, d, SET;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1996L, 1L)) {
    print_g_c(*g_c, 10L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  hypergraph_sets_to_graph_sets(*g_c, a, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  find_minimal_cut_sets(v, w, adj_list, &cut_sets);
  dispose_adj_list(adj_list);
  p = cut_sets;
  while (p != NULL) {
    P_setcpy(bv, p->vertex_set);
    P_addset(bv, *v);
    P_setcpy(bw, p->vertex_set);
    P_addset(bw, *w);
    P_setcpy(d, bv);
    P_setunion(d, d, bw);
    ok_mixed = ((P_inset(*v, delta) & P_inset(*w, delta)) &&
		P_setequal(p->vertex_set, empty_set));
    /* Do something when not OkMixed !?!?! */
    if (!(*write_options)->write_models && ok_mixed)
      one_edge_collaps_set(d, bv, bw, v, w, homogeneous, p_test,
			   write_options, test_labels);
    if ((*write_options)->write_models)
      write_space(stdout, 3L);
    print_vertex_on_file(stdout, *v, 0L);
    write_char(stdout, '^');
    print_vertex_on_file(stdout, *w, 0L);
    write_char(stdout, '|');
    print_vertex_set_table(p->vertex_set);
    if ((*write_options)->write_models)
      write_space(stdout, 3L);
    else
      write_line(stdout);
    if ((*write_options)->write_models && ok_mixed)
      one_edge_collaps_set(d, bv, bw, v, w, homogeneous, p_test,
			   write_options, test_labels);
    p = p->pointer;
  }
  dispose_set_list(&cut_sets);
}  /* test_all_cut_sets */


Static Void select_and_update(link_sort_list, p_test, rejected_edges,
			      accepted_edges, edge, p_edge, coherent, follow,
			      in_forward)
t_sort_list *link_sort_list;
t_test_list **p_test;
t_set_list **rejected_edges, **accepted_edges;
long *edge;
t_long_real *p_edge;
boolean coherent, follow, in_forward;
{
  t_long_real select_limit, p_value;
  t_vertex_set a;
  boolean reject;
  t_part_list *p;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1997L, 1L))
    write_real(stdout, *p_edge, 10L, 6L);
  /*$endif TRACE*/
  if (ic && !exact_test) {
    if (!follow && !in_forward)
      select_limit = *p_edge;
    else
      select_limit = 0 + alfa_reject;
  } else
    select_limit = alfa_reject;
  if (in_forward)
    *p_edge = _INFINITY;
  else if (!ic || exact_test || follow)
    *p_edge = -_INFINITY;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1997L, 1L))
    write_real(stdout, *p_edge, 10L, 6L);
  /*$endif TRACE*/
  P_setcpy(edge, empty_set);
  while (link_sort_list != NULL) {
    P_setcpy(a, link_sort_list->vertex_set);
    p_value = select_p_value(link_sort_list->link_test_list);
    if (is_invalid_real(p_value))
      reject = false;
    else
      reject = (p_value <= select_limit);
    if (parts_limit < 1 && !reject) {
      p = link_sort_list->link_part_list;
      while (!reject && p != NULL) {
	reject = (select_p_value(p->link_test_list) < parts_limit);
	p = p->pointer;
      }
    }
    if (separators_limit < 1 && !reject) {
      p = link_sort_list->link_sepa_list;
      while (!reject && p != NULL) {
	reject = (select_p_value(p->link_test_list) < separators_limit);
	p = p->pointer;
      }
    }
    if (reject) {
      if (in_forward && p_value <= *p_edge) {
	*p_test = link_sort_list->link_test_list;
	*p_edge = p_value;
	P_setcpy(edge, a);
      }
      if (coherent || in_forward)
	insert_clique(a, rejected_edges);
    } else if (!is_invalid_real(p_value)) {
      if (!in_forward && p_value >= *p_edge) {
	*p_test = link_sort_list->link_test_list;
	*p_edge = p_value;
	P_setcpy(edge, a);
      }
      if ((coherent || !in_forward) && p_value >= alfa_)
	insert_clique(a, accepted_edges);
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 1997L, 1L))
      write_real(stdout, *p_edge, 10L, 6L);
    /*$endif TRACE*/
    link_sort_list = link_sort_list->pointer;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 1997L, 1L)) {
    /*$endif TRACE*/
    write_line(stdout);
  }
}  /* select_and_update */


Static Void shuffle_edges(p_edges)
t_set_list **p_edges;
{
  t_set_list *p, *q;
  t_set_list *new_edges = NULL;
  t_integer number_of_edges = 0;
  t_integer selected, i, j;

  p = *p_edges;
  while (p != NULL) {
    number_of_edges++;
    p = p->pointer;
  }
  for (j = number_of_edges; j >= 1; j--) {
    selected = floor_x(j * uniform(&seed));
    if (selected == 0) {
      q = *p_edges;
      *p_edges = (*p_edges)->pointer;
    } else {
      p = *p_edges;
      for (i = 1; i < selected; i++)
	p = p->pointer;
      q = p->pointer;
      p->pointer = p->pointer->pointer;
    }
    q->pointer = new_edges;
    new_edges = q;
  }
  *p_edges = new_edges;
}  /* shuffle_edges */


Static Void return_first_and_last(a, v, w)
long *a;
t_vertex *v, *w;
{
  *v = first_vertex;
  while (!P_inset(*v, a) && *v < last_vertex)
    (*v)++;
  *w = last_vertex;
  while (!P_inset(*w, a) && first_vertex < *w)
    (*w)--;
}  /* return_first_and_last */


Static Void write_stepwise_head(v, w, c, hierarchical_search, separators,
				write_options, test_labels)
t_vertex *v, *w;
long *c;
boolean *hierarchical_search, *separators;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  if ((*write_options)->write_models) {
    if (*hierarchical_search) {
      write_space(stdout, 3L);
      print_vertex_set_table(c);
      write_space(stdout, 1L);
    } else
      print_edge(stdout, write_options, test_labels, *v, *w);
  }
  if (*separators && (*write_options)->write_models)
    write_space(stdout, 11L);
}  /* write_stepwise_head */


Static Void write_not_decomposable(tmp_g_c, from_g_c, v, w, c, model_set,
  forward_selection, graphical_model, hierarchical_search, no_writing,
  separators, write_options, test_labels)
t_set_list *tmp_g_c, **from_g_c;
t_vertex *v, *w;
long *c, *model_set;
boolean forward_selection, *graphical_model, *hierarchical_search,
	*no_writing, *separators;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  if (*no_writing)
    return;
  if (!(*write_options)->write_test)
    write_stepwise_head(v, w, c, hierarchical_search, separators,
			write_options, test_labels);
  write_space(stdout, 2L);
  if (tmp_g_c == NULL) {
    if (cardinality(model_set) < 10 && (*write_options)->write_models) {
      if (!*graphical_model || *hierarchical_search) {
	if (forward_selection)
	  add_interaction_to_g_c(&tmp_g_c, from_g_c, c);
	else
	  drop_interaction_from_g_c(&tmp_g_c, from_g_c, c);
      } else if (forward_selection) {
	if (boolean_option[101])
	  add_edge_to_g_c(&tmp_g_c, from_g_c, c);
	else
	  sub_add_edge_to_g_c(&tmp_g_c, from_g_c, *v, *w);
      } else if (boolean_option[101])
	drop_edge_from_g_c(&tmp_g_c, from_g_c, c);
      else
	sub_drop_edge_from_g_c(&tmp_g_c, from_g_c, *v, *w);
      print_g_c(tmp_g_c, 10L, line_length);
      dispose_set_list(&tmp_g_c);
    } else {
      if (!(*write_options)->write_models)
	write_space(stdout, 16L);
      write_pch(stdout, " Resulting model", 16L);
    }
  } else
    print_g_c(tmp_g_c, 10L, line_length);
  write_pch(stdout, " is not decomposable", 20L);
  if ((*write_options)->write_models) {
    write_line(stdout);
    return;
  }
  write_char(stdout, ':');
  write_char(stdout, ' ');
  print_vertex_set_table(c);
  write_line(stdout);
}  /* write_not_decomposable */


Static Void end_stepwise_step(g_c, v, w, c, homogeneous, p, link_sort_list,
  p_test, hierarchical_search, reversed, sorted_list, unordered_list,
  short_report, separators, write_options, test_labels, partitioning)
t_set_list **g_c;
t_vertex *v, *w;
long *c;
boolean *homogeneous;
t_sort_list **p, **link_sort_list;
t_test_list **p_test;
boolean hierarchical_search, reversed, sorted_list, unordered_list,
	short_report, *separators;
t_test_write_options **write_options;
t_test_labels **test_labels;
boolean *partitioning;
{
  /* forward_selection, */
  dispose_marginals_cond();
  if (link_part_list != NULL) {
    sum_up_partitioning(p, 0L, &c_partitioning, write_options, test_labels,
			exclude_missing && *partitioning);
    if (!(*write_options)->write_models && !short_report &&
	(*write_options)->write_test) {
      if (hierarchical_search) {
	write_space(stdout, 3L);
	print_vertex_set_table(c);
	write_space(stdout, 1L);
      } else
	print_edge(stdout, write_options, test_labels, *v, *w);
      write_line(stdout);
    }
    if (*separators && !mixed_data)
      test_all_cut_sets(g_c, v, w, homogeneous, p_test, write_options,
			test_labels);
    (*p)->link_sepa_list = link_part_list;
    link_part_list = NULL;
    if (sorted_list) {
      P_setcpy((*p)->vertex_set, c);
      insert_test_in_sort_list(p, unordered_list, reversed, link_sort_list);
    } else
      dispose_sort_list(p);
    return;
  }
  if (!*separators || mixed_data)
    return;
  if (!(*write_options)->write_models && !short_report &&
      (*write_options)->write_test) {
    if (hierarchical_search) {
      write_space(stdout, 3L);
      print_vertex_set_table(c);
      write_space(stdout, 1L);
    } else
      print_edge(stdout, write_options, test_labels, *v, *w);
    write_line(stdout);
  }
  test_all_cut_sets(g_c, v, w, homogeneous, p_test, write_options,
		    test_labels);
  dispose_part_list(&link_part_list);
}  /* end_stepwise_step */


Static Void note_edge(current, rejected, accepted, eligible, coherent, edge)
t_set_list **current, **rejected, **accepted, **eligible;
boolean *coherent;
long *edge;
{
  boolean ok = true;

  if (default_dump_set || dump_set) {
    flush_file(&dump_file);
    close_file(dump_file);
    unlink_tmp_file(&dump_file, dump_name, dump_set || !default_dump_set);
  }
  assign_write(&dump_file, dump_name, &ok);
  rewrite_text_file(dump_file);
  write_pch_20_text(dump_file, " Current edge:      ", 20L);
  print_vertex_set_on_report(dump_file, edge);
  write_line_text(dump_file);
  if (*coherent) {
    write_pch_20_text(dump_file, " Rejected edges:    ", 20L);
    print_set_list_on_report(dump_file, *rejected);
    write_line_text(dump_file);
  }
  write_pch_20_text(dump_file, " Accepted edges:    ", 20L);
  print_set_list_on_report(dump_file, *accepted);
  write_line_text(dump_file);
  write_pch_20_text(dump_file, " Model:             ", 20L);
  print_set_list_on_report(dump_file, *current);
  write_line_text(dump_file);
  if (*eligible != NULL) {
    write_pch_20_text(dump_file, " Edges eligible:    ", 20L);
    print_set_list_on_report(dump_file, *eligible);
    write_line_text(dump_file);
  }
  flush_file(&dump_file);
}  /* note_edge */


Static Void report_stepwise(current, rejected, accepted, eligible, edge, test,
  forward_selection, offset, sorted_list, short_report, alternative, coherent,
  write_options, test_labels)
t_set_list **current, **rejected, **accepted, **eligible;
long *edge;
t_test *test;
boolean forward_selection;
t_long_integer *offset;
boolean *sorted_list, *short_report, *alternative, *coherent;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  /* headlong, */
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReportStepwise     ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 2004L, 1L, -1L, -1L, (*write_options)->write_test);
  /*$endif TRACE*/
  if (*short_report) {
    if (dump)
      note_edge(current, rejected, accepted, eligible, coherent, edge);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2004L, 2L, -1L, -1L);
    /*$endif TRACE*/
    /* if alternative or not headlong then null else ... */
    if (*alternative == !forward_selection) {   /* or nor headlong +> 3 */
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2004L, 3L, -1L, -11L);
      /*$endif TRACE*/
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2004L, 3L, -1L, 1L);
      /*$endif TRACE*/
      if (!(*write_options)->write_models) {
	if (exclude_missing)
	  print_n_total_exclude(empty_set, write_options, test_labels,
				test->n_count);
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2004L, 4L, -1L, -1L);
	/*$endif TRACE*/
	write_test(test, write_options, test_labels);
      }
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2004L, 3L, -1L, 2L);
      /*$endif TRACE*/
      if ((*write_options)->line_form) {
	if ((*write_options)->write_models)
	  write_space(stdout, 3L);
	print_vertex_set(edge);
	write_space(stdout, 3L);
      }
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2004L, 3L, -1L, 3L);
      /*$endif TRACE*/
      if (!(*write_options)->write_models)
	write_line(stdout);
      if ((*write_options)->write_models) {
	if (exclude_missing)
	  print_n_total_exclude(empty_set, write_options, test_labels,
				test->n_count);
	write_test(test, write_options, test_labels);
      }
    }
  } else if ((*write_options)->write_test || *sorted_list) {
    /*$ifdef TRACE*/
    if ((*write_options)->line_form)
      write_line(stdout);
    write_pch(stdout, " Edge selected:     ", 20L);
    print_vertex_set(edge);
    write_line(stdout);
    write_pch(stdout, " Rejected edges:    ", 20L);
    print_g_c(*rejected, 20L, line_length);
    write_line(stdout);
    write_pch(stdout, " Accepted edges:    ", 20L);
    print_g_c(*accepted, 20L, line_length);
    write_line(stdout);
    write_pch(stdout, " Model:             ", 20L);
    print_g_c(*current, 20L, line_length);
    write_line(stdout);
    write_pch(stdout, " Edges eligible:    ", 20L);
    if (*eligible == NULL)
      write_pch(stdout, "Empty", 5L);
    else
      print_g_c(*eligible, 20L, line_length);
    write_line(stdout);
    if ((*write_options)->line_form && (*write_options)->write_test &&
	*eligible != NULL) {
      if (forward_selection)
	write_test_head_stepwise(stdout, " Adding   ", *offset,
				 *write_options, *test_labels, *short_report);
      else
	write_test_head_stepwise(stdout, " Removing ", *offset,
				 *write_options, *test_labels, *short_report);
    } else
      write_line(stdout);
  }
  /*$endif TRACE*/
  ntr_boolean(tzt, 20L, 2004L, 8L, -1L, -1L, (*write_options)->write_test);
}  /* report_stepwise */


Static Void report_last_test(forward_selection, p, p_edge_list,
  headlong_p_value, headlong_select_limit, start_clock, short_report,
  alternative, headlong, write_options, test_labels)
boolean forward_selection;
t_sort_list **p;
t_set_list **p_edge_list;
t_long_real *headlong_p_value, *headlong_select_limit, *start_clock;
boolean *short_report, *alternative, *headlong;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReportLastTest     ", sizeof(pch20));
  ntr_boolean(tzt, 20L, 2005L, 1L, -1L, -1L, (*write_options)->write_test);
  ntr(tzt, 20L, 2005L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if (*p != NULL && (*headlong || *short_report)) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2005L, 1L, 2L, -1L);
    /*$endif TRACE*/
    *headlong_p_value = select_p_value((*p)->link_test_list);
    if (dump && *short_report) {
      write_pch_20_text(dump_file, " Current_edge: ", 15L);
      print_vertex_set_on_report(dump_file, (*p_edge_list)->vertex_set);
      write_pch_10_text(dump_file, " P-value: ", 10L);
      write_real_text(dump_file, *headlong_p_value, 14L, 6L);
      write_time_text(dump_file, " Time: ", 7L, (double)my_clock()/1,
		      *start_clock, 14L, 3L);
      write_line_text(dump_file);
      flush_file(&dump_file);
    }
    if ((!forward_selection && *headlong_p_value > *headlong_select_limit) |
	((forward_selection && *headlong_p_value < *headlong_select_limit &&
	  !*headlong &&
	  *short_report) & (!is_invalid_real(*headlong_p_value)))) {
      if (!forward_selection && *alternative ||
	  forward_selection && !*alternative) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2005L, 4L, -1L, -1L);
	/*$endif TRACE*/
	if (!(*write_options)->write_models)
	  write_test(&(*p)->link_test_list->test, write_options, test_labels);
	if ((*write_options)->line_form) {
	  write_space(stdout, 3L);
	  print_vertex_set((*p_edge_list)->vertex_set);
	  write_space(stdout, 3L);
	}
	if ((*write_options)->write_models)
	  write_test(&(*p)->link_test_list->test, write_options, test_labels);
      }
    }
    /*$ifdef TRACE*/
    /*$endif TRACE*/
    ntr_real(tzt, 20L, 2005L, 7L, -1L, -1L, headlong_p_value);
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2005L, 8L, -1L, -1L, (*write_options)->write_test);
  /*$endif TRACE*/
}  /* report_last_test */


/*@+"backward.p"*/


/*

2008:    +++  ++
2009:    +++  ++
2010:    ---  -- p/backward.p        11      37     615 p/backward.p
2011: |    4:    procedure backward_parted
2012: |  103:    procedure backward_non_parted
2013: |  141:    procedure backward_try_one_edge
2014: |  194:    procedure backward_return_terms
2015: |  214:    procedure backward_one_step
2016: |  283:    procedure backward_update_model
2017: |  331:    procedure backward_update_edges
2018: |  355:    procedure backward_many_steps
2019: |  500:    procedure blockwise_backward
2020: |  570:    procedure backward_elimination
2021: |  646:    procedure proc_backward
2022:    +++  ++
2023:    +++  ++

*/

Static Void backward_parted(g_c_current, g_c_base, g_c, v, w, c, local_delta,
			    p_test, offset, ok_to_collaps, graphical_model,
			    homogeneous, no_writing, separators,
			    hierarchical_search, write_options, test_labels)
t_set_list **g_c_current, **g_c_base, **g_c;
t_vertex *v, *w;
long *c, *local_delta;
t_test_list **p_test;
t_long_integer *offset;
boolean *ok_to_collaps, *graphical_model, *homogeneous, *no_writing,
	*separators, *hierarchical_search;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean ok;
  t_vertex_set a, bv, bw;
  t_long_integer number_of_tests = 0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " BackwardParted     ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 2011L, 1L, -1L, -1L, g_c_current);
  ntr_boolean(tzt, 20L, 2011L, 1L, -1L, 0L, *ok_to_collaps);
  /*$endif TRACE*/
  *g_c = NULL;
  if (*hierarchical_search || incomplete_table)
    ok = false;
  else if (*graphical_model) {
    ok = is_decomposable_after_dropping_edge(g_c_current, v, w, a);
    /* Until OneEdgeCollaps implemented for mixed: */
    /* if ok and mixed_data then
         ok := a <= delta */
  } else
    ok = false;
  if (*ok_to_collaps && ok) {
    P_setcpy(bv, a);
    P_remset(bv, *w);
    P_setcpy(bw, a);
    P_remset(bw, *v);
    insert_set_in_set_list(bv, g_c);
    insert_set_in_set_list(bw, g_c);
    note_mixed(stdout, " BackwardParted: A/", 19L);   /**/
    one_edge_collaps_set(a, bv, bw, v, w, homogeneous, p_test, write_options,
			 test_labels);
    return;
  }
  if (*graphical_model && !*hierarchical_search) {
    if (*ok_to_collaps) {
      note_mixed(stdout, " BackwardParted: B/", 19L);   /**/
      if (ok || !decomposable_mode) {
	if (boolean_option[101])
	  drop_edge_from_g_c(g_c, g_c_current, c);
	else
	  sub_drop_edge_from_g_c(g_c, g_c_current, *v, *w);
      } else
	*g_c = NULL;
    } else {
      note_mixed(stdout, " BackwardParted: C/", 19L);   /**/
      if (boolean_option[101])
	drop_edge_from_g_c(g_c, g_c_current, c);
      else
	sub_drop_edge_from_g_c(g_c, g_c_current, *v, *w);
      if (decomposable_mode)
	ok = g_c_decomposable(g_c);
      else
	ok = true;
    }
  } else {
    note_mixed(stdout, " BackwardParted: E/", 19L);   /**/
    drop_interaction_from_g_c(g_c, g_c_current, c);
    if (decomposable_mode)
      ok = g_c_decomposable(g_c);
    else
      ok = true;
  }
  if ((!ok || incomplete_table) && decomposable_mode) {
    write_not_decomposable(*g_c, g_c_current, v, w, c, local_delta, false,
			   graphical_model, hierarchical_search, no_writing,
			   separators, write_options, test_labels);
    return;
  }
  partitioning_hierarchical(g_c, g_c_base, &causal_structure, homogeneous,
			    write_options, test_labels, &number_of_tests);
  /* Default !!! */
  if (!((*write_options)->line_form && (*write_options)->write_test &&
	link_part_list != NULL))
    return;
  if (link_part_list->pointer == NULL)
    return;
  if ((*write_options)->write_models)
    write_space(stdout, 3L);
  write_char(stdout, '=');
  if ((*write_options)->write_models)
    write_space(stdout, *offset + 3);
  else
    write_line(stdout);
}  /* backward_parted */


Static Void backward_non_parted(g_c_current, g_c_base, g_c, v, w, c,
  local_delta, graphical_model, homogeneous, no_writing, separators,
  hierarchical_search, write_options, test_labels)
t_set_list **g_c_current, **g_c_base, **g_c;
t_vertex *v, *w;
long *c, *local_delta;
boolean *graphical_model, *homogeneous, *no_writing, *separators,
	*hierarchical_search;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean ok;

  if (*graphical_model && !*hierarchical_search) {
    if (boolean_option[101])
      drop_edge_from_g_c(g_c, g_c_current, c);
    else
      sub_drop_edge_from_g_c(g_c, g_c_current, *v, *w);
  } else
    drop_interaction_from_g_c(g_c, g_c_current, c);
  if (!sub_is_hier_subm(g_c, g_c_base, NULL, NULL, write_options, test_labels,
			false))
    return;
  if (decomposable_mode)
    ok = g_c_decomposable(g_c);
  else
    ok = true;
  if (ok)
    test_generating_classes(g_c, g_c_base, &causal_structure, homogeneous,
			    local_delta, write_options, test_labels);
  else {
    /* Default !!! */
    write_not_decomposable(*g_c, g_c_current, v, w, c, local_delta, false,
			   graphical_model, hierarchical_search, no_writing,
			   separators, write_options, test_labels);
  }
}  /* backward_non_parted */


Static Void backward_try_one_edge(g_c_current, g_c_base, graphical_model,
  homogeneous, ok_to_collaps, link_sort_list, link_last_test, c, local_delta,
  offset, stepwise_options, write_options, test_labels)
t_set_list **g_c_current, **g_c_base;
boolean *graphical_model, *homogeneous, *ok_to_collaps;
t_sort_list **link_sort_list, **link_last_test;
long *c, *local_delta;
t_long_integer *offset;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_test_list *p_test;
  t_vertex v, w;
  t_set_list *tmp_g_c;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_stepwise_options *WITH;
  FILE *TEMP;
  boolean TEMP1;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " BackwardTryOneEdge ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 2013L, 1L, -1L, -1L, g_c_current);
  ntr_boolean(tzt, 20L, 2013L, 1L, -1L, 0L, *ok_to_collaps);
  /*$endif TRACE*/
  WITH = *stepwise_options;
  if (!WITH->hierarchical)
    return_first_and_last(c, &v, &w);
  if ((*write_options)->write_test)
    write_stepwise_head(&v, &w, c, &WITH->hierarchical, &WITH->separators,
			write_options, test_labels);
  TEMP = stdout;
  flush_file(&TEMP);
  flush_file(&diary_file);
  /* if mixed_data then
   note_mixed(output, ' BackwardTryOneEdge@', 19); */
  if (WITH->partitioning) {
    TEMP1 = (WITH->short_report ||
	     WITH->export_list && !(*write_options)->write_test);
    backward_parted(g_c_current, g_c_base, &tmp_g_c, &v, &w, c, local_delta,
		    &p_test, offset, ok_to_collaps, graphical_model,
		    homogeneous, &TEMP1, &WITH->separators,
		    &WITH->hierarchical, write_options, test_labels);
  } else {
    TEMP1 = (WITH->short_report ||
	     WITH->export_list && !(*write_options)->write_test);
    backward_non_parted(g_c_current, g_c_base, &tmp_g_c, &v, &w, c,
			local_delta, graphical_model, homogeneous, &TEMP1,
			&WITH->separators, &WITH->hierarchical, write_options,
			test_labels);
  }
  /* false, */
  end_stepwise_step(&tmp_g_c, &v, &w, c, homogeneous, link_last_test,
		    link_sort_list, &p_test, WITH->hierarchical,
		    WITH->reversed, true, WITH->unordered_list,
		    WITH->short_report, &WITH->separators, write_options,
		    test_labels, &WITH->partitioning);
  dispose_set_list(&tmp_g_c);
}  /* backward_try_one_edge */


Static Void backward_return_terms(g_c, eligible_edges)
t_set_list **g_c, **eligible_edges;
{
  t_set_list *main_continuous = NULL;
  t_vertex_set a;
  t_vertex v;
  _PROCEDURE TEMP;

  dispose_set_list(eligible_edges);
  copy_set_list(*g_c, eligible_edges);

  TEMP.proc = (Anyptr)subset_of_an_edge;
  TEMP.link = (Anyptr)NULL;
  exclude_vertex_sets_in_list(eligible_edges, TEMP, &fix_edges_gc);

  /*$ifdef On-DOS
     exclude_sub_vertex_sets_in_list(eligible_edges, fix_edges_gc);
   $endif On-DOS*/
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, gamma_)) {
      P_addset(P_expset(a, 0L), v);
      insert_set_in_set_list(a, &main_continuous);
    }
  }

  TEMP.proc = (Anyptr)subset_of_an_edge;
  TEMP.link = (Anyptr)NULL;
  exclude_vertex_sets_in_list(eligible_edges, TEMP, &main_continuous);

  /*$ifdef On-DOS
     exclude_sub_vertex_sets_in_list(eligible_edges, main_continuous);
   $endif On-DOS*/
  dispose_set_list(&main_continuous);
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 2014L, 1L))
    return;
  /*$endif TRACE*/
  write_pch(stdout, " Hierarchical search", 20L);
  print_g_c(*eligible_edges, 0L, line_length);
  write_line(stdout);
}  /* backward_return_terms */


Static Void backward_one_step(g_c_current, g_c_base, link_sort_list,
  local_delta, offset, graphical_model, homogeneous, stepwise_options,
  write_options, test_labels)
t_set_list **g_c_current, **g_c_base;
t_sort_list **link_sort_list;
long *local_delta;
t_long_integer *offset;
boolean *graphical_model, *homogeneous;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean ok_to_collaps;
  t_vertex v, w;
  t_sort_list *link_last_test;
  t_vertex_set a, edge;
  t_long_real p_edge = 0.0;
  t_test_list *selected_test;
  t_set_list *rejected_edges = NULL, *accepted_edges = NULL;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_stepwise_options *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " BackwardOneStep    ", sizeof(pch20));
  ntr(tzt, 20L, 2015L, 1L, -1L, 1L);
  /*$endif TRACE*/
  WITH = *stepwise_options;
  *link_sort_list = NULL;
  if (WITH->follow && !WITH->recursive)
    *g_c_base = *g_c_current;
  ok_to_collaps = !WITH->hierarchical;
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2015L, 1L, -1L, 0L, ok_to_collaps);
  /*$endif TRACE*/
  if (ok_to_collaps)
    ok_to_collaps = g_c_conformal(g_c_base);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2015L, 1L, -1L, 1L, ok_to_collaps);
  /*$endif TRACE*/
  if (ok_to_collaps)
    ok_to_collaps = g_c_decomposable(g_c_base);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2015L, 1L, -1L, 2L, ok_to_collaps);
  /*$endif TRACE*/
  if (ok_to_collaps && !WITH->follow)
    ok_to_collaps = test_sub_g_c(*g_c_base, *g_c_current);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2015L, 1L, -1L, 3L, ok_to_collaps);
  /*$endif TRACE*/
  v = first_vertex;
  while (v < last_vertex && !interrupt_2) {
    w = v + 1;
    while (w <= last_vertex && !interrupt_2) {
      P_addset(P_expset(a, 0L), v);
      P_addset(a, w);
      if (P_subset(a, local_delta) & subset_of_an_edge(a, g_c_current) &
	  (!P_inset(w, fix_edges_adj_set[v - MIN_VERTEX])))
	backward_try_one_edge(g_c_current, g_c_base, graphical_model,
			      homogeneous, &ok_to_collaps, link_sort_list,
			      &link_last_test, a, local_delta, offset,
			      stepwise_options, write_options, test_labels);
      w++;
    }
    v++;
  }
  P_setcpy(edge, empty_set);
  select_and_update(*link_sort_list, &selected_test, &rejected_edges,
		    &accepted_edges, edge, &p_edge, WITH->coherent,
		    WITH->follow, false);
  if ((*write_options)->write_test) {
    write_line(stdout);
    write_pch(stdout, " Accepted edges:    ", 20L);
    print_g_c(accepted_edges, 16L, line_length);
    write_line(stdout);
  }
  dispose_set_list(&rejected_edges);
  drop_edges_from_g_c(&rejected_edges, g_c_current, &accepted_edges);
  /* full_specified */
  insert_g_c_in_new_model(&rejected_edges, local_delta, &causal_structure,
			  false, *homogeneous);
  dispose_set_list(&accepted_edges);
}  /* backward_one_step */


Static Void backward_update_model(g_c_current, graphical_model, homogeneous,
  ok_to_collaps, edge, local_delta, accepted_edges, alternative, no_new_model,
  hierarchical_search)
t_set_list **g_c_current;
boolean *graphical_model, *homogeneous, *ok_to_collaps;
long *edge, *local_delta;
t_set_list **accepted_edges;
boolean *alternative, no_new_model, *hierarchical_search;
{
  t_set_list *tmp_g_c, *tmp_set_list;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " BackwardUpdateMode ", sizeof(pch20));
  ntr_set_and_g_c(tzt, 20L, 2016L, 1L, -1L, -1L, local_delta, g_c_current);
  /*$endif TRACE*/
  if (*alternative) {
    if (*graphical_model && !*hierarchical_search)
      drop_edges_from_g_c(&tmp_g_c, g_c_current, accepted_edges);
    else {
      copy_set_list(*accepted_edges, &tmp_set_list);
      drop_interactions_from_g_c(&tmp_g_c, g_c_current, &tmp_set_list,
				 local_delta);
    }
  } else if (*ok_to_collaps || *graphical_model && !*hierarchical_search)
    drop_edge_from_g_c(&tmp_g_c, g_c_current, edge);
  else
    drop_interaction_from_g_c(&tmp_g_c, g_c_current, edge);
  if (no_new_model) {   /* blockwise and not last_step (keep_models) */
    dispose_set_list(g_c_current);
    *g_c_current = tmp_g_c;
  } else {
    if (P_subset(local_delta, delta) ||
	P_subset(local_delta, gamma_) && !boolean_option[104])
      *g_c_current = tmp_g_c;
    else {
      dispose_set_list(g_c_current);
      copy_set_list(tmp_g_c, g_c_current);
    }
    /* full_specified */
    insert_g_c_in_new_model(&tmp_g_c, local_delta, &causal_structure, false,
			    *homogeneous);
  }
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 2016L, 8L, -1L, -1L, g_c_current);
  /*$endif TRACE*/
}  /* backward_update_model*/


Static Void backward_update_edges(rejected_edges, accepted_edges,
				  eligible_edges, edge, alternative)
t_set_list **rejected_edges, **accepted_edges, **eligible_edges;
long *edge;
boolean *alternative;
{
  t_set_list *p_edge_list, *q_edge_list;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " BackwardUpdteEdges ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 2017L, 1L, -1L, 1L, rejected_edges);
  ntr_g_c(tzt, 20L, 2017L, 1L, -1L, 2L, accepted_edges);
  ntr_g_c(tzt, 20L, 2017L, 1L, -1L, 3L, eligible_edges);
  /*$endif TRACE*/
  q_edge_list = *eligible_edges;
  *eligible_edges = NULL;
  while (q_edge_list != NULL) {
    p_edge_list = q_edge_list;
    P_setcpy(a, q_edge_list->vertex_set);
    q_edge_list = q_edge_list->pointer;
    if ((((*alternative) & contains_an_edge(a, accepted_edges)) |
	 subset_of_an_edge(a, rejected_edges)) || P_subset(edge, a))
      _Free(p_edge_list);
    else {
      p_edge_list->pointer = *eligible_edges;
      *eligible_edges = p_edge_list;
    }
  }
}  /* backward_update_edges */


Static Void backward_many_steps(g_c_current, g_c_base, local_delta, offset,
  last_step, graphical_model, homogeneous, stepwise_options, write_options,
  test_labels)
t_set_list **g_c_current, *g_c_base;
long *local_delta;
t_long_integer *offset;
boolean last_step, *graphical_model, *homogeneous;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean ok_to_collaps, stop_recursive;
  t_long_real headlong_p_value, headlong_select_limit;
  t_long_real p_edge = 0.0;
  t_long_real start_clock;
  t_vertex v, w;
  t_vertex_set a, edge;
  t_set_list *g_c_copy;
  t_set_list *eligible_edges = NULL;
  t_set_list *p_edge_list;
  t_set_list *rejected_edges = NULL, *accepted_edges = NULL;
  t_sort_list *link_last_test, *link_sort_list;
  t_test_list *selected_test;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_stepwise_options *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " BackwardManySteps  ", sizeof(pch20));
  ntr_set_and_g_c(tzt, 20L, 2018L, 1L, -1L, -1L, local_delta, g_c_current);
  /*$endif TRACE*/
  WITH = *stepwise_options;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2018L, 1L) && WITH->hierarchical) {
    write_pch(stdout, " Hierarchical search", 20L);
    write_pch(stdout, ": BackwardManySteps.", 20L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  WITH->separators = (WITH->separators && !WITH->hierarchical);
  if (WITH->hierarchical)
    *offset += 5;
  if (WITH->hierarchical)
    backward_return_terms(g_c_current, &eligible_edges);
  else {
    for (v = first_vertex; v <= last_vertex - 1; v++) {
      for (w = v + 1; w <= last_vertex; w++) {
	P_addset(P_expset(a, 0L), v);
	P_addset(a, w);
	if (P_subset(a, local_delta) & subset_of_an_edge(a, g_c_current) &
	    (!P_inset(w, fix_edges_adj_set[v - MIN_VERTEX])))
	  insert_set_in_set_list(a, &eligible_edges);
      }
    }
  }
  start_clock = my_clock()/1;
  do {
    if (WITH->hierarchical)
      *graphical_model = g_c_conformal(g_c_current);
    else
      *graphical_model = true;
    if (WITH->follow)
      g_c_base = *g_c_current;
    ok_to_collaps = !WITH->hierarchical;
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2018L, 1L, -1L, 0L, ok_to_collaps);
    /*$endif TRACE*/
    if (ok_to_collaps) {
      /* and not follow then
         if hierarchical */
      ok_to_collaps = g_c_conformal(&g_c_base);
    }
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2018L, 1L, -1L, 1L, ok_to_collaps);
    /*$endif TRACE*/
    if (ok_to_collaps)
      ok_to_collaps = g_c_decomposable(&g_c_base);
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2018L, 1L, -1L, 2L, ok_to_collaps);
    /*$endif TRACE*/
    if (ok_to_collaps && !WITH->follow)
      ok_to_collaps = test_sub_g_c(g_c_base, *g_c_current);
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2018L, 1L, -1L, 3L, ok_to_collaps);
    /*$endif TRACE*/
    if (ic && !exact_test) {
      if (!WITH->follow)
	headlong_select_limit = p_edge;
      else
	headlong_select_limit = 0 + alfa_;
    } else
      headlong_select_limit = alfa_;
    headlong_p_value = headlong_select_limit - ROUND_ERROR;
    if (WITH->headlong)
      shuffle_edges(&eligible_edges);
    link_sort_list = NULL;
    p_edge_list = eligible_edges;
    while ((!interrupt_2 && p_edge_list != NULL) &
	   (!((WITH->headlong && headlong_p_value > headlong_select_limit) &
	      (!is_invalid_real(headlong_p_value))))) {
      link_last_test = NULL;
      backward_try_one_edge(g_c_current, &g_c_base, graphical_model,
	homogeneous, &ok_to_collaps, &link_sort_list, &link_last_test,
	p_edge_list->vertex_set, local_delta, offset, stepwise_options,
	write_options, test_labels);
      report_last_test(false, &link_last_test, &p_edge_list,
		       &headlong_p_value, &headlong_select_limit,
		       &start_clock, &WITH->short_report, &WITH->alternative,
		       &WITH->headlong, write_options, test_labels);
      p_edge_list = p_edge_list->pointer;
    }
    if (timer && !WITH->short_report && (*write_options)->write_test)
      write_used_time(stdout, start_clock);
    select_and_update(link_sort_list, &selected_test, &rejected_edges,
		      &accepted_edges, edge, &p_edge, WITH->coherent,
		      WITH->follow, false);
    if (WITH->sorted_list) {
      if (link_sort_list != NULL)
	write_sorted_list(link_sort_list, write_options, test_labels);
      dispose_sort_list(&link_sort_list);
    } else
      dispose_sort_list(&link_sort_list);
    stop_recursive = false;
    if (p_edge >= alfa_ && !P_setequal(edge, empty_set) &&
	accepted_edges != NULL) {
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 2018L, 1L, 1L, 1L, g_c_current);
      /*$endif TRACE*/
      copy_set_list(*g_c_current, &g_c_copy);
      backward_update_model(g_c_current, graphical_model, homogeneous,
	&ok_to_collaps, edge, local_delta, &accepted_edges,
	&WITH->alternative, WITH->blockwise && !last_step,
	&WITH->hierarchical);
      stop_recursive = test_sub_g_c(g_c_copy, *g_c_current);
      dispose_set_list(&g_c_copy);
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 2018L, 2L, 1L, 1L, g_c_current);
      ntr_g_c(tzt, 20L, 2018L, 2L, 1L, 1L, &g_c_copy);
      /*$endif TRACE*/
      if (WITH->hierarchical)
	backward_return_terms(g_c_current, &eligible_edges);
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 2018L, 3L, 1L, 1L, g_c_current);
      /*$endif TRACE*/
      backward_update_edges(&rejected_edges, &accepted_edges, &eligible_edges,
			    edge, &WITH->alternative);
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 2018L, 4L, 1L, 1L, g_c_current);
      /*$endif TRACE*/
      /* headlong, */
      /*$ifdef TRACE*/
      report_stepwise(g_c_current, &rejected_edges, &accepted_edges,
		      &eligible_edges, edge, &selected_test->test, false,
		      offset, &WITH->sorted_list, &WITH->short_report,
		      &WITH->alternative, &WITH->coherent, write_options,
		      test_labels);
      ntr_g_c(tzt, 20L, 2018L, 5L, 1L, 1L, g_c_current);
      /*$endif TRACE*/
    } else
      stop_recursive = true;
  } while (!(!WITH->recursive || stop_recursive || eligible_edges == NULL ||
	     interrupt_2));
  dispose_set_list(&rejected_edges);
  dispose_set_list(&accepted_edges);
  dispose_set_list(&eligible_edges);
}  /* backward_many_steps */


Static Void blockwise_backward(g_c_current, g_c_base, local_delta, offset,
  graphical_model, homogeneous, stepwise_options, write_options, test_labels)
t_set_list *g_c_current, *g_c_base;
long *local_delta;
t_long_integer *offset;
boolean *graphical_model, *homogeneous;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_set_list *tmp_g_c_current, *tmp_g_c_base, *tmp_causal_structure,
	     *tmp_fix_edges_gc, *q, *p;
  t_vertex_set history, present;
  boolean keep_models;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " BlockwiseBackward  ", sizeof(pch20));
  ntr_set_and_g_c(tzt, 20L, 2019L, 1L, 1L, 1L, local_delta, &g_c_current);
  ntr_g_c(tzt, 20L, 2019L, 1L, 1L, 2L, &g_c_base);
  /*$endif TRACE*/
  copy_set_list(fix_edges_gc, &tmp_fix_edges_gc);
  p = causal_structure;
  tmp_causal_structure = causal_structure;
  causal_structure = NULL;
  P_setcpy(present, empty_set);
  while (p != NULL) {
    P_setcpy(history, present);
    P_setunion(present, present, p->vertex_set);
    write_line(stdout);
    write_pch(stdout, " Blockwise backward,", 20L);
    write_pch(stdout, " History: ", 10L);
    print_vertex_set(history);
    write_char(stdout, ',');
    write_pch(stdout, " New block: ", 12L);
    print_vertex_set(p->vertex_set);
    write_char(stdout, ',');
    write_pch(stdout, " Present: ", 10L);
    print_vertex_set(present);
    write_line(stdout);
    tmp_g_c_current = return_restricted_g_c(&g_c_current, present);
    tmp_g_c_base = return_restricted_g_c(&g_c_base, present);
    if (!mixed_data)   /* 9. sept 2000 */
      insert_clique(history, &tmp_g_c_base);
    /* if not mixed_data then
         insert_clique(history, tmp_g_c_current); */
    keep_models = (p->pointer == NULL);
    if (!P_setequal(history, empty_set))   /* => 4 */
      write_test_head_stepwise(stdout, "Removing  ", *offset, *write_options,
	*test_labels,
	(*stepwise_options)->short_report && (*stepwise_options)->recursive);
    backward_many_steps(&tmp_g_c_current, tmp_g_c_base, local_delta, offset,
			keep_models, graphical_model, homogeneous,
			stepwise_options, write_options, test_labels);
    if (keep_models) {
      /* full_specified */
      insert_g_c_in_new_model(&tmp_g_c_current, local_delta,
			      &causal_structure, false, *homogeneous);
    } else
      dispose_set_list(&tmp_g_c_current);
    dispose_set_list(&tmp_g_c_base);
    if (p->pointer != NULL) {
      q = (t_set_list *)Malloc(sizeof(t_set_list));
      if (q == NULL)
	_OutMem();
      q->pointer = NULL;
      P_setunion(q->vertex_set, history, p->vertex_set);
      and_fix_edges_argument(&q);
    }
    p = p->pointer;
  }
  dispose_set_list(&causal_structure);
  causal_structure = tmp_causal_structure;
  dispose_set_list(&fix_edges_gc);
  fix_edges_argument(&tmp_fix_edges_gc);
}  /* blockwise_backward */


Static Void backward_elimination(link_curr, link_base, stepwise_options,
  write_options, test_labels, ifail, arg_pos_int, arg_pos_double, nargs,
  arg_int, arg_double)
t_model_list *link_curr, *link_base;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_integer *ifail, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  /* , sub_code */
  t_sort_list *link_sort_list;
  boolean graphical_model;
  boolean homogeneous = false;
  t_vertex_set local_delta;
  t_long_integer offset = 0;
  t_set_list *g_c_current, *g_c_base;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_stepwise_options *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " BackwardEliminatio ", sizeof(pch20));
  /*$endif TRACE*/
  if (link_curr->model->id->model_type == mixed)
    homogeneous = link_curr->model->id->UU.U1.homogeneous;
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2020L, 1L, -1L, -1L, homogeneous);
  /*$endif TRACE*/
  WITH = *stepwise_options;
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2020L, 1L, -1L, -1L, WITH->graphical);
  ntr_boolean(tzt, 20L, 2020L, 1L, -1L, -1L, WITH->hierarchical);
  /*$endif TRACE*/
  P_setcpy(local_delta, link_curr->model->id->vertices);
  g_c_current = return_g_c_copy_for_mixed_model(&link_curr->model);
  g_c_base = return_g_c_copy_for_mixed_model(&link_base->model);
  /*$ifdef TRACE*/
  ntr_set_and_g_c(tzt, 20L, 2020L, 2L, -1L, 1L, local_delta, &g_c_current);
  ntr_g_c(tzt, 20L, 2020L, 2L, -1L, 2L, &g_c_base);
  /*$endif TRACE*/
  if (WITH->short_report)
    sorted = false;
  if (WITH->short_report)
    WITH->reversed = false;
  if (WITH->separators && (*write_options)->write_models)
    offset = 11;
  if (WITH->follow | test_sub_g_c(g_c_current, g_c_base)) {
    graphical_model = g_c_conformal(&g_c_current);
    WITH->hierarchical = (WITH->hierarchical ||
			  (!graphical_model &&
			   link_curr->model->id->model_type != mixed));
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2020L, 3L, -1L, -1L, WITH->hierarchical);
    /*$endif TRACE*/
    if (WITH->blockwise && causal_structure != NULL)
      blockwise_backward(g_c_current, g_c_base, local_delta, &offset,
			 &graphical_model, &homogeneous, stepwise_options,
			 write_options, test_labels);
    else if (WITH->recursive || WITH->hierarchical)
      backward_many_steps(&g_c_current, g_c_base, local_delta, &offset, false,
			  &graphical_model, &homogeneous, stepwise_options,
			  write_options, test_labels);
    else {
      link_sort_list = NULL;
      backward_one_step(&g_c_current, &g_c_base, &link_sort_list, local_delta,
			&offset, &graphical_model, &homogeneous,
			stepwise_options, write_options, test_labels);
      if ((*stepwise_options)->sorted_list)
	write_sorted_list(link_sort_list, write_options, test_labels);
      if ((*stepwise_options)->export_list)
	put_sorted_list(link_sort_list, false, false, write_options,
			test_labels, ifail, arg_pos_int, arg_pos_double,
			nargs, arg_int, arg_double);
      dispose_sort_list(&link_sort_list);
    }
    if (interrupt_2) {
      interrupt_1 = false;
      interrupt_2 = false;
    }
  } else {
    write_space(stdout, 3L);
    print_g_c(g_c_current, 11L, line_length);
    write_pch(stdout, " not submodel of ", 17L);
    write_line(stdout);
    write_space(stdout, 3L);
    print_g_c(g_c_base, 11L, line_length);
    write_line(stdout);
  }
  dispose_g_c_copy_for_mixed_model(&link_curr->model, &g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_base->model, &g_c_base);
}  /* backward_elimination */


Static Void proc_backward(code, ifail, arg_pos_int, arg_pos_double, nargs,
			  arg_int, arg_double)
t_long_integer *code;
t_integer *ifail, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  /* , sub_code */
  boolean tmp_re_use;
  boolean ok = true;
  t_test_list *p;
  t_long_integer offset;
  t_model_list *link_model;
  t_set_list *tmp_causal_structure;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;
  t_stepwise_options *local_stepwise_options;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ProcBackward       ", sizeof(pch20));
  ntr(tzt, 20L, 2021L, 1L, -1L, *code);
  /*$endif TRACE*/
  if (!test_current_submodel_of_base(true))
    return;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2021L, 1L, -1L, -2L);
  /*$endif TRACE*/
  local_write_options = new_test_write_options_true();
  local_write_options->write_models = !global_write_options->line_form;
  local_write_options->write_test = (global_write_options->write_test &&
				     !global_stepwise_options->short_report);
  /* => 2 */
  local_test_labels = new_test_labels_empty();
  local_stepwise_options = copy_stepwise_options();
  local_stepwise_options->unordered_list = !negative_flag_set(code, 8L);
  local_stepwise_options->export_list = !negative_flag_set(code, 4L);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2021L, 1L, -1L, -3L);
  /*$endif TRACE*/
  if (!local_stepwise_options->partitioning)
    ok = ok_base();
  if (ok) {
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 2021L, 1L, -1L, -4L, link_current->model->id->vertices);
    /*$endif TRACE*/
    link_model = link_current;
    tmp_causal_structure = causal_structure;
    causal_structure = link_current->model->id->causal_structure;
    if (!link_model->model->found_expression)
      identify_model(&link_model->model);
    if (!link_model->model->graphical && *code == 1) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2021L, 1L, -1L, 1L);
      /*$endif TRACE*/
      new_model_in_list(&link_model_list, &first_model_available);
      generate_graphical_model(&link_model_list->model, &link_model->model);
      link_model = link_model_list;
      identify_model(&link_model->model);
    }
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 2021L, 1L, -1L, -5L, link_model->model->id->vertices);
    /*$endif TRACE*/
    local_stepwise_options->hierarchical = (*code == 2 ||
	*code == 3 && !link_model->model->graphical && !incomplete_table);
    local_stepwise_options->separators = (local_stepwise_options->separators &&
	!local_stepwise_options->hierarchical);
    if (local_stepwise_options->separators &&
	local_write_options->write_models)
      offset = 11;
    else
      offset = 0;
    if (local_stepwise_options->hierarchical)
      offset += 5;
    local_test_labels->short_report = local_stepwise_options->short_report;
    local_test_labels->separators = local_stepwise_options->separators;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2021L, 1L, -1L, -6L);
    /*$endif TRACE*/
    if (!local_stepwise_options->blockwise)   /* => 4 */
      write_test_head_stepwise(stdout, "Removing  ", offset,
	local_write_options, local_test_labels,
	local_stepwise_options->short_report &&
	local_stepwise_options->recursive);
    if (!re_use_test &&
	(local_stepwise_options->recursive ||
	 local_stepwise_options->sorted_list ||
	 local_stepwise_options->headlong)) {
      p = link_test_list;
      link_test_list = NULL;
      re_use_test = true;
      tmp_re_use = true;
    } else
      tmp_re_use = false;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2021L, 1L, -1L, -6L);
    /*$endif TRACE*/
    backward_elimination(link_model, link_base, &local_stepwise_options,
			 &local_write_options, &local_test_labels, ifail,
			 arg_pos_int, arg_pos_double, nargs, arg_int,
			 arg_double);
    if (tmp_re_use) {
      dispose_tests();
      link_test_list = p;
      re_use_test = false;
    }
    causal_structure = tmp_causal_structure;
    global_write_options->write_test = true;
    note_command_end_pch(stdout, " Test computed", 14L);
  }
  _Free(local_stepwise_options);
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* proc_backward */


/*@+"forward.p"*/


/*

2024:    +++  ++
2025:    +++  ++
2026:    ---  -- p/forward.p         11      52     753 p/forward.p
2027: |    4:    procedure forward_parted
2028: |  101:    procedure forward_non_parted
2029: |  137:    procedure forward_try_one_edge
2030: |  181:    procedure forward_return_terms
2031: |  195:    procedure forward_one_step
2032: |  258:    procedure forward_update_model
2033: |  294:    procedure forward_update_edges
2034: |  318:    procedure forward_many_steps
2035: |  425:    procedure blockwise_forward
2036: |  490:    procedure forward_selection
2037: |  536:    procedure proc_forward
2038:    +++  ++
2039:    +++  ++

*/

Static Void forward_parted(g_c_current, v, w, c, local_delta, p_test, offset,
			   decomposable_model, graphical_model, homogeneous,
			   no_writing, separators, hierarchical_search,
			   write_options, test_labels)
t_set_list **g_c_current;
t_vertex *v, *w;
long *c, *local_delta;
t_test_list **p_test;
t_long_integer *offset;
boolean *decomposable_model, *graphical_model, *homogeneous, *no_writing,
	*separators, *hierarchical_search;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean ok;
  boolean ok_mixed = true;
  t_vertex_set a, bv, bw;
  t_long_integer number_of_tests;
  t_set_list *tmp_g_c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ForwardParted      ", sizeof(pch20));
  ntr(tzt, 20L, 2027L, 1L, -1L, 1L);
  /*$endif TRACE*/
  if (*hierarchical_search || incomplete_table)
    ok = false;
  else if (*graphical_model)
    ok = is_decomposable_after_adding_edge(g_c_current, v, w, a);
  else
    ok = false;
  if (ok && mixed_data) {
    P_setint(bw, a, gamma_);
    if (!P_setequal(bw, empty_set))   /* ?!?!? */
      ok = P_inset(*v, gamma_) | P_inset(*w, gamma_);
    if (ok)
      ok_mixed = ((P_inset(*v, delta) & P_inset(*w, delta)) &&
		  P_setequal(bw, empty_set));
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2027L, 1L, -1L, 2L);
  /*$endif TRACE*/
  if (*decomposable_model && ok && ok_mixed) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2027L, 1L, 2L, 1L);
    /*$endif TRACE*/
    P_setcpy(bv, a);
    P_addset(bv, *v);
    P_setcpy(bw, a);
    P_addset(bw, *w);
    P_setunion(a, bv, bw);
    note_mixed(stdout, " ForwardParted:  A/", 19L);   /**/
    one_edge_collaps_set(a, bv, bw, v, w, homogeneous, p_test, write_options,
			 test_labels);
  } else {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2027L, 1L, 3L, 1L);
    /*$endif TRACE*/
    tmp_g_c = NULL;
    if (*graphical_model && !*hierarchical_search) {
      if (*decomposable_model) {
	if (ok || !decomposable_mode) {
	  note_mixed(stdout, " ForwardParted:  B/", 19L);   /**/
	  if (boolean_option[101])
	    add_edge_to_g_c(&tmp_g_c, g_c_current, c);
	  else
	    sub_add_edge_to_g_c(&tmp_g_c, g_c_current, *v, *w);
	} else {
	  /* null */
	  note_mixed(stdout, " ForwardParted:  %/", 19L);
	}
      } else {
	/**/
	note_mixed(stdout, " ForwardParted:  D/", 19L);   /**/
	if (boolean_option[101])
	  add_edge_to_g_c(&tmp_g_c, g_c_current, c);
	else
	  sub_add_edge_to_g_c(&tmp_g_c, g_c_current, *v, *w);
	if (decomposable_mode)
	  ok = g_c_decomposable(&tmp_g_c);
	else
	  ok = true;
      }
    } else {
      note_mixed(stdout, " ForwardParted:  E/", 19L);   /**/
      add_interaction_to_g_c(&tmp_g_c, g_c_current, c);
      if (decomposable_mode)
	ok = g_c_decomposable(&tmp_g_c);
      else
	ok = true;
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2027L, 1L, 3L, 2L);
    /*$endif TRACE*/
    if (ok && !incomplete_table || !decomposable_mode) {
      number_of_tests = 0;
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2027L, 1L, 4L, 1L);
      /*$endif TRACE*/
      partitioning_hierarchical(g_c_current, &tmp_g_c, &causal_structure,
				homogeneous, write_options, test_labels,
				&number_of_tests);
      /* Default !!! */
      if ((*write_options)->line_form && (*write_options)->write_test &&
	  link_part_list != NULL) {
	if (link_part_list->pointer != NULL) {
	  if ((*write_options)->write_models)
	    write_space(stdout, 3L);
	  write_char(stdout, '=');
	  if ((*write_options)->write_models)
	    write_space(stdout, *offset + 3);
	  else
	    write_line(stdout);
	}
      }
    } else
      write_not_decomposable(NULL, g_c_current, v, w, c, local_delta, true,
			     graphical_model, hierarchical_search, no_writing,
			     separators, write_options, test_labels);
    dispose_set_list(&tmp_g_c);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2027L, 1L, -1L, 8L);
  /*$endif TRACE*/
}  /* forward_parted */


Static Void forward_non_parted(g_c_current, v, w, c, local_delta,
  graphical_model, homogeneous, no_writing, separators, hierarchical_search,
  write_options, test_labels)
t_set_list **g_c_current;
t_vertex *v, *w;
long *c, *local_delta;
boolean *graphical_model, *homogeneous, *no_writing, *separators,
	*hierarchical_search;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean ok;
  t_set_list *tmp_g_c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ForwardNonParted   ", sizeof(pch20));
  ntr(tzt, 20L, 2028L, 1L, -1L, 1L);
  /*$endif TRACE*/
  if (*graphical_model && !*hierarchical_search) {
    if (boolean_option[101])
      add_edge_to_g_c(&tmp_g_c, g_c_current, c);
    else
      sub_add_edge_to_g_c(&tmp_g_c, g_c_current, *v, *w);
  } else
    add_interaction_to_g_c(&tmp_g_c, g_c_current, c);
  if (decomposable_mode)
    ok = g_c_decomposable(&tmp_g_c);
  else
    ok = true;
  if (ok) {
    /* Default !!! */
    test_generating_classes(g_c_current, &tmp_g_c, &causal_structure,
			    homogeneous, local_delta, write_options,
			    test_labels);
  } else
    write_not_decomposable(tmp_g_c, g_c_current, v, w, c, local_delta, true,
			   graphical_model, hierarchical_search, no_writing,
			   separators, write_options, test_labels);
  dispose_set_list(&tmp_g_c);
}  /* forward_non_parted */


Static Void forward_try_one_edge(g_c_current, decomposable_model,
  graphical_model, homogeneous, link_sort_list, link_last_test, c,
  local_delta, offset, stepwise_options, write_options, test_labels)
t_set_list **g_c_current;
boolean *decomposable_model, *graphical_model, *homogeneous;
t_sort_list **link_sort_list, **link_last_test;
long *c, *local_delta;
t_long_integer *offset;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_test_list *p_test;
  t_vertex v, w;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_stepwise_options *WITH;
  FILE *TEMP;
  boolean TEMP1;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ForwardTryOneEdge  ", sizeof(pch20));
  ntr(tzt, 20L, 2029L, 1L, -1L, 1L);
  /*$endif TRACE*/
  WITH = *stepwise_options;
  if (!WITH->hierarchical)
    return_first_and_last(c, &v, &w);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2029L, 1L, -1L, 2L);
  /*$endif TRACE*/
  if ((*write_options)->write_test)
    write_stepwise_head(&v, &w, c, &WITH->hierarchical, &WITH->separators,
			write_options, test_labels);
  TEMP = stdout;
  flush_file(&TEMP);
  flush_file(&diary_file);
  /* if mixed_data then
   note_mixed(output, ' ForwardTryOneEdge@@', 18); */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2029L, 1L, -1L, 3L);
  /*$endif TRACE*/
  if (WITH->partitioning) {
    TEMP1 = (WITH->short_report ||
	     WITH->export_list && !(*write_options)->write_test);
    forward_parted(g_c_current, &v, &w, c, local_delta, &p_test, offset,
		   decomposable_model, graphical_model, homogeneous, &TEMP1,
		   &WITH->separators, &WITH->hierarchical, write_options,
		   test_labels);
  } else {
    TEMP1 = (WITH->short_report ||
	     WITH->export_list && !(*write_options)->write_test);
    forward_non_parted(g_c_current, &v, &w, c, local_delta, graphical_model,
		       homogeneous, &TEMP1, &WITH->separators,
		       &WITH->hierarchical, write_options, test_labels);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2029L, 1L, -1L, 4L);   /* true, */
  /*$endif TRACE*/
  end_stepwise_step(g_c_current, &v, &w, c, homogeneous, link_last_test,
		    link_sort_list, &p_test, WITH->hierarchical,
		    !WITH->reversed, true, WITH->unordered_list,
		    WITH->short_report, &WITH->separators, write_options,
		    test_labels, &WITH->partitioning);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2029L, 1L, -1L, 8L);
  /*$endif TRACE*/
}  /* forward_try_one_edge */


Static Void forward_return_terms(model_set, g_c, eligible_edges)
long *model_set;
t_set_list **g_c, **eligible_edges;
{
  /*$ifdef TRACE*/
  pch20 tzt;
  _PROCEDURE TEMP;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ForwardReturnTerms ", sizeof(pch20));
  ntr(tzt, 20L, 2030L, 1L, -1L, 1L);
  /*$endif TRACE*/
  dispose_set_list(eligible_edges);
  normal_to_dual(*g_c, model_set, eligible_edges);

  TEMP.proc = (Anyptr)contains_an_edge;
  TEMP.link = (Anyptr)NULL;

  /*$ifdef On-DOS
  exclude_super_vertex_sets_in_list(eligible_edges, fix_edges_gc)
   $endif On-DOS*/
  exclude_vertex_sets_in_list(eligible_edges, TEMP, &fix_edges_gc);
}  /* forward_return_terms */


Static Void forward_one_step(g_c_current, link_sort_list, local_delta, offset,
			     graphical_model, homogeneous, stepwise_options,
			     write_options, test_labels)
t_set_list **g_c_current;
t_sort_list **link_sort_list;
long *local_delta;
t_long_integer *offset;
boolean *graphical_model, *homogeneous;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean decomposable_model;
  t_vertex v, w;
  t_sort_list *link_last_test;
  t_vertex_set a, edge;
  t_long_real p_edge = 0.0;
  t_test_list *selected_test;
  t_set_list *rejected_edges = NULL, *accepted_edges = NULL;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_stepwise_options *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ForwardOneStep     ", sizeof(pch20));
  ntr(tzt, 20L, 2031L, 1L, -1L, 1L);
  /*$endif TRACE*/
  WITH = *stepwise_options;
  *link_sort_list = NULL;
  if (*graphical_model)
    decomposable_model = g_c_decomposable(g_c_current);
  else
    decomposable_model = false;
  v = first_vertex;
  while (v < last_vertex && !interrupt_2) {
    w = v + 1;
    while (w <= last_vertex && !interrupt_2) {
      P_addset(P_expset(a, 0L), v);
      P_addset(a, w);
      if (P_subset(a, local_delta) & (!subset_of_an_edge(a, g_c_current)) &
	  (!P_inset(w, fix_edges_adj_set[v - MIN_VERTEX])))
	forward_try_one_edge(g_c_current, &decomposable_model,
			     graphical_model, homogeneous, link_sort_list,
			     &link_last_test, a, local_delta, offset,
			     stepwise_options, write_options, test_labels);
      w++;
    }
    v++;
  }
  P_setcpy(edge, empty_set);
  select_and_update(*link_sort_list, &selected_test, &rejected_edges,
		    &accepted_edges, edge, &p_edge, WITH->coherent, true,
		    true);
  if ((*write_options)->write_test) {
    write_line(stdout);
    write_pch(stdout, " Rejected edges:    ", 20L);
    print_g_c(rejected_edges, 16L, line_length);
    write_line(stdout);
  }
  dispose_set_list(&accepted_edges);
  add_edges_to_g_c(&accepted_edges, g_c_current, &rejected_edges, local_delta);
  /* full_specified */
  insert_g_c_in_new_model(&accepted_edges, local_delta, &causal_structure,
			  false, *homogeneous);
  dispose_set_list(&rejected_edges);
}  /* forward_one_step */


Static Void forward_update_model(g_c_current, graphical_model, homogeneous,
  edge, local_delta, rejected_edges, alternative, no_new_model, hierarchical)
t_set_list **g_c_current;
boolean *graphical_model, *homogeneous;
long *edge, *local_delta;
t_set_list **rejected_edges;
boolean *alternative, no_new_model, *hierarchical;
{
  t_set_list *tmp_g_c, *tmp_set_list;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ForwardUpdateModel ", sizeof(pch20));
  ntr(tzt, 20L, 2032L, 1L, -1L, 1L);
  /*$endif TRACE*/
  if (!*alternative) {
    if (*graphical_model && !*hierarchical)
      add_edges_to_g_c(&tmp_g_c, g_c_current, rejected_edges, local_delta);
    else {
      copy_set_list(*rejected_edges, &tmp_set_list);
      add_interactions_to_g_c(&tmp_g_c, g_c_current, &tmp_set_list);
    }
  } else if (*graphical_model && !*hierarchical)
    add_edge_to_g_c(&tmp_g_c, g_c_current, edge);
  else
    add_interaction_to_g_c(&tmp_g_c, g_c_current, edge);
  if (no_new_model) {   /* blockwise and not last_step (keep_models) */
    dispose_set_list(g_c_current);
    *g_c_current = tmp_g_c;
    return;
  }
  if (P_subset(local_delta, delta) ||
      P_subset(local_delta, gamma_) && !boolean_option[104])
    *g_c_current = tmp_g_c;
  else {
    dispose_set_list(g_c_current);
    copy_set_list(tmp_g_c, g_c_current);
  }
  /* full_specified */
  insert_g_c_in_new_model(&tmp_g_c, local_delta, &causal_structure, false,
			  *homogeneous);
}  /* forward_update_model */


Static Void forward_update_edges(rejected_edges, accepted_edges,
				 eligible_edges, edge, alternative)
t_set_list **rejected_edges, **accepted_edges, **eligible_edges;
long *edge;
boolean *alternative;
{
  t_set_list *p_edge_list, *q_edge_list;
  t_vertex_set a;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ForwardUpdateEdges ", sizeof(pch20));
  ntr(tzt, 20L, 2033L, 1L, -1L, 1L);
  /*$endif TRACE*/
  q_edge_list = *eligible_edges;
  *eligible_edges = NULL;
  while (q_edge_list != NULL) {
    p_edge_list = q_edge_list;
    P_setcpy(a, q_edge_list->vertex_set);
    q_edge_list = q_edge_list->pointer;
    if ((((!*alternative) & subset_of_an_edge(a, rejected_edges)) |
	 contains_an_edge(a, accepted_edges)) || P_subset(a, edge))
      _Free(p_edge_list);
    else {
      p_edge_list->pointer = *eligible_edges;
      *eligible_edges = p_edge_list;
    }
  }
}  /* forward_update_edges */


Static Void forward_many_steps(g_c_current, local_delta, offset, last_step,
  graphical_model, homogeneous, stepwise_options, write_options, test_labels)
t_set_list **g_c_current;
long *local_delta;
t_long_integer *offset;
boolean last_step, *graphical_model, *homogeneous;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  boolean decomposable_model, stop_recursive;
  t_vertex v, w;
  t_long_real headlong_p_value, headlong_select_limit;
  t_long_real p_edge = 0.0;
  t_long_real start_clock;
  t_vertex_set a, edge;
  t_set_list *g_c_copy;
  t_set_list *eligible_edges = NULL;
  t_set_list *p_edge_list;
  t_set_list *rejected_edges = NULL, *accepted_edges = NULL;
  t_sort_list *link_last_test, *link_sort_list;
  t_test_list *selected_test;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_stepwise_options *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ForwardManySteps   ", sizeof(pch20));
  ntr(tzt, 20L, 2034L, 1L, -1L, 1L);
  /*$endif TRACE*/
  WITH = *stepwise_options;
  WITH->separators = (WITH->separators && !WITH->hierarchical);
  if (WITH->hierarchical)
    *offset += 5;
  if (WITH->hierarchical)
    forward_return_terms(local_delta, g_c_current, &eligible_edges);
  else {
    for (v = first_vertex; v <= last_vertex - 1; v++) {
      for (w = v + 1; w <= last_vertex; w++) {
	P_addset(P_expset(a, 0L), v);
	P_addset(a, w);
	if (P_subset(a, local_delta) & (!subset_of_an_edge(a, g_c_current)) &
	    (!P_inset(w, fix_edges_adj_set[v - MIN_VERTEX])))
	  insert_set_in_set_list(a, &eligible_edges);
      }
    }
  }
  start_clock = my_clock()/1;
  do {
    if (WITH->hierarchical)
      *graphical_model = g_c_conformal(g_c_current);
    else
      *graphical_model = true;
    if (*graphical_model)
      decomposable_model = g_c_decomposable(g_c_current);
    else
      decomposable_model = false;
    if (ic && !exact_test)
      headlong_select_limit = 0 + alfa_reject;
    else
      headlong_select_limit = alfa_reject;
    headlong_p_value = headlong_select_limit + ROUND_ERROR;
    if (WITH->headlong)
      shuffle_edges(&eligible_edges);
    link_sort_list = NULL;
    p_edge_list = eligible_edges;
    while ((!interrupt_2 && p_edge_list != NULL) &
	   (!((WITH->headlong && headlong_p_value < headlong_select_limit) &
	      (!is_invalid_real(headlong_p_value))))) {
      link_last_test = NULL;
      forward_try_one_edge(g_c_current, &decomposable_model, graphical_model,
			   homogeneous, &link_sort_list, &link_last_test,
			   p_edge_list->vertex_set, local_delta, offset,
			   stepwise_options, write_options, test_labels);
      report_last_test(true, &link_last_test, &p_edge_list, &headlong_p_value,
		       &headlong_select_limit, &start_clock,
		       &WITH->short_report, &WITH->alternative,
		       &WITH->headlong, write_options, test_labels);
      p_edge_list = p_edge_list->pointer;
    }
    if (timer && !WITH->short_report && (*write_options)->write_test)
      write_used_time(stdout, start_clock);
    select_and_update(link_sort_list, &selected_test, &rejected_edges,
		      &accepted_edges, edge, &p_edge, WITH->coherent,
		      WITH->follow, true);
    if (WITH->sorted_list) {
      if (link_sort_list != NULL)
	write_sorted_list(link_sort_list, write_options, test_labels);
      dispose_sort_list(&link_sort_list);
    } else
      dispose_sort_list(&link_sort_list);
    stop_recursive = false;
    if (p_edge < alfa_reject && !P_setequal(edge, empty_set) &&
	rejected_edges != NULL) {
      copy_set_list(*g_c_current, &g_c_copy);
      forward_update_model(g_c_current, graphical_model, homogeneous, edge,
			   local_delta, &rejected_edges, &WITH->alternative,
			   WITH->blockwise && !last_step,
			   &WITH->hierarchical);
      stop_recursive = test_sub_g_c(*g_c_current, g_c_copy);
      dispose_set_list(&g_c_copy);
      if (WITH->hierarchical)
	forward_return_terms(local_delta, g_c_current, &eligible_edges);
      forward_update_edges(&rejected_edges, &accepted_edges, &eligible_edges,
			   edge, &WITH->alternative);
	  /* headlong, */
      report_stepwise(g_c_current, &rejected_edges, &accepted_edges,
		      &eligible_edges, edge, &selected_test->test, true,
		      offset, &WITH->sorted_list, &WITH->short_report,
		      &WITH->alternative, &WITH->coherent, write_options,
		      test_labels);
    } else
      stop_recursive = true;
  } while (!(!WITH->recursive || stop_recursive || eligible_edges == NULL ||
	     interrupt_2));
  dispose_set_list(&rejected_edges);
  dispose_set_list(&accepted_edges);
  dispose_set_list(&eligible_edges);
}  /* forward_many_steps */


Static Void blockwise_forward(g_c_current, local_delta, offset,
  graphical_model, homogeneous, stepwise_options, write_options, test_labels)
t_set_list *g_c_current;
long *local_delta;
t_long_integer *offset;
boolean *graphical_model, *homogeneous;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
{
  t_set_list *tmp_g_c_current, *tmp_causal_structure, *tmp_fix_edges_gc, *q,
	     *p;
  t_vertex_set history, present;
  boolean keep_models;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " BlockwiseForward   ", sizeof(pch20));
  ntr(tzt, 20L, 2035L, 1L, -1L, 1L);
  /*$endif TRACE*/
  copy_set_list(fix_edges_gc, &tmp_fix_edges_gc);
  p = causal_structure;
  tmp_causal_structure = causal_structure;
  causal_structure = NULL;
  P_setcpy(present, empty_set);
  while (p != NULL) {
    P_setcpy(history, present);
    P_setunion(present, present, p->vertex_set);
    write_line(stdout);
    write_pch(stdout, " Blockwise forward, ", 20L);
    write_pch(stdout, " History: ", 10L);
    print_vertex_set(history);
    write_char(stdout, ',');
    write_pch(stdout, " New block: ", 12L);
    print_vertex_set(p->vertex_set);
    write_char(stdout, ',');
    write_pch(stdout, " Present: ", 10L);
    print_vertex_set(present);
    write_line(stdout);
    tmp_g_c_current = return_restricted_g_c(&g_c_current, present);
    if (!mixed_data)
      insert_clique(history, &tmp_g_c_current);
    keep_models = (p->pointer == NULL);
    if (!P_setequal(history, empty_set))   /* => 4 */
      write_test_head_stepwise(stdout, "Removing  ", *offset, *write_options,
	*test_labels,
	(*stepwise_options)->short_report && (*stepwise_options)->recursive);
    forward_many_steps(&tmp_g_c_current, local_delta, offset, keep_models,
		       graphical_model, homogeneous, stepwise_options,
		       write_options, test_labels);
    if (keep_models) {
      /* full_specified */
      insert_g_c_in_new_model(&tmp_g_c_current, local_delta,
			      &causal_structure, false, *homogeneous);
    } else
      dispose_set_list(&tmp_g_c_current);
    if (p->pointer != NULL) {
      q = (t_set_list *)Malloc(sizeof(t_set_list));
      if (q == NULL)
	_OutMem();
      q->pointer = NULL;
      P_setunion(q->vertex_set, history, p->vertex_set);
      and_fix_edges_argument(&q);
    }
    p = p->pointer;
  }
  dispose_set_list(&causal_structure);
  causal_structure = tmp_causal_structure;
  dispose_set_list(&fix_edges_gc);
  fix_edges_argument(&tmp_fix_edges_gc);
}  /* blockwise_forward */


Static Void forward_selection(link_curr, stepwise_options, write_options,
			      test_labels, ifail, arg_pos_int, arg_pos_double,
			      nargs, arg_int, arg_double)
t_model_list **link_curr;
t_stepwise_options **stepwise_options;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_integer *ifail, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  /* , sub_code */
  t_sort_list *link_sort_list;
  boolean graphical_model;
  boolean homogeneous = false;
  t_vertex_set local_delta;
  t_long_integer offset = 0;
  t_set_list *g_c_current;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_stepwise_options *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ForwardSelection   ", sizeof(pch20));
  ntr(tzt, 20L, 2036L, 1L, -1L, 1L);
  /*$endif TRACE*/
  if ((*link_curr)->model->id->model_type == mixed)
    homogeneous = (*link_curr)->model->id->UU.U1.homogeneous;
  WITH = *stepwise_options;
  P_setcpy(local_delta, (*link_curr)->model->id->vertices);
  g_c_current = return_g_c_copy_for_mixed_model(&(*link_curr)->model);
  if (WITH->short_report)
    sorted = false;
  if (WITH->short_report)
    WITH->reversed = false;
  if (WITH->separators && (*write_options)->write_models)
    offset = 11;
  graphical_model = g_c_conformal(&g_c_current);
  WITH->hierarchical = (WITH->hierarchical ||
			(!graphical_model &&
			 (*link_curr)->model->id->model_type != mixed));
  if (WITH->blockwise && causal_structure != NULL)
    blockwise_forward(g_c_current, local_delta, &offset, &graphical_model,
		      &homogeneous, stepwise_options, write_options,
		      test_labels);
  else if (WITH->recursive || WITH->hierarchical)
    forward_many_steps(&g_c_current, local_delta, &offset, false,
		       &graphical_model, &homogeneous, stepwise_options,
		       write_options, test_labels);
  else {
    link_sort_list = NULL;
    forward_one_step(&g_c_current, &link_sort_list, local_delta, &offset,
		     &graphical_model, &homogeneous, stepwise_options,
		     write_options, test_labels);
    if ((*stepwise_options)->sorted_list)
      write_sorted_list(link_sort_list, write_options, test_labels);
    if ((*stepwise_options)->export_list)
      put_sorted_list(link_sort_list, false, false, write_options,
		      test_labels, ifail, arg_pos_int, arg_pos_double, nargs,
		      arg_int, arg_double);
    dispose_sort_list(&link_sort_list);
  }
  dispose_g_c_copy_for_mixed_model(&(*link_curr)->model, &g_c_current);
  if (interrupt_2) {
    interrupt_1 = false;
    interrupt_2 = false;
  }
}  /* forward_selection */


Static Void proc_forward(code, ifail, arg_pos_int, arg_pos_double, nargs,
			 arg_int, arg_double)
t_long_integer *code;
t_integer *ifail, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  /* , sub_code */
  boolean tmp_re_use, ok;
  t_test_list *p;
  t_long_integer offset;
  t_model_list *link_model;
  t_set_list *tmp_causal_structure;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;
  t_stepwise_options *local_stepwise_options;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ProcForward        ", sizeof(pch20));
  ntr(tzt, 20L, 2037L, 1L, -1L, 1L);
      /* test_current_submodel_of_base(true) */
  /*$endif TRACE*/
  if (true) {
    local_write_options = new_test_write_options_true();
    local_write_options->write_models = !global_write_options->line_form;
    local_write_options->write_test = (global_write_options->write_test &&
	!global_stepwise_options->short_report);
    /* => 2 */
    local_test_labels = new_test_labels_empty();
    local_stepwise_options = copy_stepwise_options();
    local_stepwise_options->unordered_list = neg_pos_flag_set(code, 8L);
    local_stepwise_options->export_list = neg_pos_flag_set(code, 4L);
    ok = true;
    if (ok) {
      link_model = link_current;
      tmp_causal_structure = causal_structure;
      causal_structure = link_current->model->id->causal_structure;
      if (!link_model->model->found_expression)
	identify_model(&link_model->model);
      if (!link_model->model->graphical && *code == 1) {
	new_model_in_list(&link_model_list, &first_model_available);
	generate_graphical_model(&link_model_list->model, &link_model->model);
	link_model = link_model_list;
	identify_model(&link_model->model);
      }
      local_stepwise_options->hierarchical = (*code == 2 ||
	  *code == 3 && !link_model->model->graphical && !incomplete_table);
      local_stepwise_options->separators = (local_stepwise_options->separators &&
	  !local_stepwise_options->hierarchical);
      if (local_stepwise_options->separators &&
	  local_write_options->write_models)
	offset = 11;
      else
	offset = 0;
      if (local_stepwise_options->hierarchical)
	offset += 5;
      if (!local_stepwise_options->blockwise)   /* => 4 */
	write_test_head_stepwise(stdout, "Adding    ", offset,
	  local_write_options, local_test_labels,
	  local_stepwise_options->short_report &&
	  local_stepwise_options->recursive);
      if (!re_use_test &&
	  (local_stepwise_options->recursive ||
	   local_stepwise_options->sorted_list ||
	   local_stepwise_options->headlong)) {
	p = link_test_list;
	link_test_list = NULL;
	re_use_test = true;
	tmp_re_use = true;
      } else
	tmp_re_use = false;
      local_test_labels->short_report = local_stepwise_options->short_report;
      local_test_labels->separators = local_stepwise_options->separators;
      forward_selection(&link_model, &local_stepwise_options,
			&local_write_options, &local_test_labels, ifail,
			arg_pos_int, arg_pos_double, nargs, arg_int,
			arg_double);
      if (tmp_re_use) {
	dispose_tests();
	link_test_list = p;
	re_use_test = false;
      }
      causal_structure = tmp_causal_structure;
      global_write_options->write_test = true;
      note_command_end_pch(stdout, " Test computed", 14L);
    }
    _Free(local_stepwise_options);
  }
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* proc_forward */


/*@-"eh.c"*/
/*@+"ehinsert.p"*/


Static Void add_set_list_maximal(p, out_g_c)
t_set_list *p, **out_g_c;
{
  while (p != NULL) {
    insert_clique(p->vertex_set, out_g_c);
    p = p->pointer;
  }
}  /* add_set_list_maximal */


Static Void first_order_to_graph_sets(p_g_c, adj_set)
t_set_list *p_g_c;
t_vertex_set *adj_set;
{
  t_vertex v1, v2;
  t_vertex_set a, b;

  for (v1 = first_vertex; v1 <= last_vertex; v1++)
    P_setcpy(adj_set[v1 - MIN_VERTEX], empty_set);
  while (p_g_c != NULL) {
    P_setcpy(a, p_g_c->vertex_set);
    if (cardinality(a) == 2) {
      for (v1 = first_vertex; v1 <= last_vertex - 1; v1++) {
	for (v2 = v1 + 1; v2 <= last_vertex; v2++) {
	  P_addset(P_expset(b, 0L), v1);
	  P_addset(b, v2);
	  if (P_subset(b, a)) {
	    P_addset(adj_set[v1 - MIN_VERTEX], v2);
	    P_addset(adj_set[v2 - MIN_VERTEX], v1);
	  }
	}
      }
    }
    p_g_c = p_g_c->pointer;
  }
}  /* first_order_to_graph_sets */


Static boolean test_sub_g_c_dual(link_1, link_2)
t_set_list *link_1, *link_2;
{
  t_set_list *p;
  boolean ok = true;
  t_vertex_set a;

  while (link_2 != NULL && ok) {
    P_setcpy(a, link_2->vertex_set);
    ok = false;
    p = link_1;
    while (p != NULL && !ok) {
      if (P_subset(p->vertex_set, a))
	ok = true;
      else
	p = p->pointer;
    }
    link_2 = link_2->pointer;
  }
  return ok;
}  /* test_sub_g_c_dual */


Static Void insert_maximal_dual(g_c, list_of_models)
t_set_list **g_c;
t_g_c_list **list_of_models;
{
  t_g_c_list *p, *q;
  boolean b = true;

  p = *list_of_models;
  while (p != NULL && b) {
    if (test_sub_g_c_dual(*g_c, p->g_c))
      b = false;
    else
      p = p->pointer;
  }
  if (!b) {
    dispose_set_list(g_c);
    return;
  }
  p = *list_of_models;
  insert_g_c_in_g_c_list(*g_c, list_of_models);
  q = *list_of_models;
  while (p != NULL) {
    if (test_sub_g_c_dual(p->g_c, *g_c)) {
      q->pointer = p->pointer;
      dispose_set_list(&p->g_c);
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* insert_maximal_dual */


Static Void insert_maximal(g_c, list_of_models)
t_set_list **g_c;
t_g_c_list **list_of_models;
{
  t_g_c_list *p, *q;
  boolean b = true;

  p = *list_of_models;
  while (p != NULL && b) {
    if (test_sub_g_c(*g_c, p->g_c))
      b = false;
    else
      p = p->pointer;
  }
  if (!b) {
    dispose_set_list(g_c);
    return;
  }
  p = *list_of_models;
  insert_g_c_in_g_c_list(*g_c, list_of_models);
  q = *list_of_models;
  while (p != NULL) {
    if (test_sub_g_c(p->g_c, *g_c)) {
      q->pointer = p->pointer;
      dispose_set_list(&p->g_c);
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* insert_maximal */


Static Void insert_minimal(g_c, list_of_models)
t_set_list **g_c;
t_g_c_list **list_of_models;
{
  t_g_c_list *p, *q;
  boolean b = true;

  p = *list_of_models;
  while (p != NULL && b) {
    if (test_sub_g_c(p->g_c, *g_c))
      b = false;
    else
      p = p->pointer;
  }
  if (!b) {
    dispose_set_list(g_c);
    return;
  }
  p = *list_of_models;
  insert_g_c_in_g_c_list(*g_c, list_of_models);
  q = *list_of_models;
  while (p != NULL) {
    if (test_sub_g_c(*g_c, p->g_c)) {
      q->pointer = p->pointer;
      dispose_set_list(&p->g_c);
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* insert_minimal */


/*@+"plus.p"*/


Static Void plus_to_normal(edge_list, g, g_c)
t_edge_list *edge_list;
long *g;
t_set_list **g_c;
{
  t_v_arr_of_v_sets adj_set;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++)
    P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  while (edge_list != NULL) {
    P_addset(adj_set[edge_list->v - MIN_VERTEX], edge_list->w);
    P_addset(adj_set[edge_list->w - MIN_VERTEX], edge_list->v);
    edge_list = edge_list->pointer;
  }
  find_cliques(adj_set, g, g_c);
}  /* plus_to_normal */


Static Void normal_to_plus(g_c, g, edge_list)
t_set_list **g_c;
long *g;
t_edge_list **edge_list;
{
  t_v_arr_of_v_sets adj_set;
  t_vertex_set a;
  t_vertex v, w;

  hypergraph_sets_to_graph_sets(*g_c, a, adj_set);
  *edge_list = NULL;
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    if (P_inset(v, g)) {
      for (w = v + 1; w <= last_vertex; w++) {
	if (P_inset(w, g) & P_inset(w, adj_set[v - MIN_VERTEX]))
	  insert_edge_in_edge_list(v, w, edge_list);
      }
    }
  }
}  /* normal_to_plus */


Static Void minus_to_normal(edge_list, g, g_c)
t_edge_list *edge_list;
long *g;
t_set_list **g_c;
{
  t_v_arr_of_v_sets adj_set;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, g))
      P_setcpy(adj_set[v - MIN_VERTEX], g);
    else
      P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  }
  while (edge_list != NULL) {
    P_remset(adj_set[edge_list->v - MIN_VERTEX], edge_list->w);
    P_remset(adj_set[edge_list->w - MIN_VERTEX], edge_list->v);
    edge_list = edge_list->pointer;
  }
  find_cliques(adj_set, g, g_c);
}  /* minus_to_normal */


Static Void normal_to_minus(g_c, g, edge_list)
t_set_list **g_c;
long *g;
t_edge_list **edge_list;
{
  t_v_arr_of_v_sets adj_set;
  t_vertex_set a;
  t_vertex v, w;

  hypergraph_sets_to_graph_sets(*g_c, a, adj_set);
  *edge_list = NULL;
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    if (P_inset(v, g)) {
      for (w = v + 1; w <= last_vertex; w++) {
	if (P_inset(w, g) & (!P_inset(w, adj_set[v - MIN_VERTEX])))
	  insert_edge_in_edge_list(v, w, edge_list);
      }
    }
  }
}  /* normal_to_minus */


/*@+"updateg.p"*/


Static Void update_d_r_graphical(m, g, d_r)
t_set_list **m;
long *g;
t_g_c_list **d_r;
{
  t_edge_list *p, *m_edge_list, *edge_list, *edge_list_insert;
  t_g_c_list *p_1, *p_0;
  t_set_list *g_c_insert;

  normal_to_plus(m, g, &m_edge_list);
  edge_list_insert = (t_edge_list *)Malloc(sizeof(t_edge_list));
  if (edge_list_insert == NULL)
    _OutMem();
  p_1 = *d_r;
  *d_r = NULL;
  if (p_1 != NULL) {
    while (p_1 != NULL) {
      normal_to_minus(&p_1->g_c, g, &edge_list);
      edge_list_insert->pointer = edge_list;
      p = m_edge_list;
      while (p != NULL) {
	edge_list_insert->v = p->v;
	edge_list_insert->w = p->w;
	minus_to_normal(edge_list_insert, g, &g_c_insert);
	insert_maximal(&g_c_insert, d_r);
	p = p->pointer;
      }
      dispose_edge_list(&edge_list);
      p_0 = p_1;
      p_1 = p_1->pointer;
      dispose_set_list(&p_0->g_c);
      _Free(p_0);
    }
  } else {
    edge_list_insert->pointer = NULL;
    p = m_edge_list;
    while (p != NULL) {
      edge_list_insert->v = p->v;
      edge_list_insert->w = p->w;
      minus_to_normal(edge_list_insert, g, &g_c_insert);
      insert_maximal(&g_c_insert, d_r);
      p = p->pointer;
    }
  }
  dispose_edge_list(&m_edge_list);
  _Free(edge_list_insert);
}  /* update_d_r_graphical */


Static Void update_d_a_graphical(m, g, d_a)
t_set_list **m;
long *g;
t_g_c_list **d_a;
{
  t_edge_list *p, *m_edge_list, *edge_list, *edge_list_insert;
  t_g_c_list *p_1, *p_0;
  t_set_list *g_c_insert;

  normal_to_minus(m, g, &m_edge_list);
  edge_list_insert = (t_edge_list *)Malloc(sizeof(t_edge_list));
  if (edge_list_insert == NULL)
    _OutMem();
  p_1 = *d_a;
  *d_a = NULL;
  if (p_1 != NULL) {
    while (p_1 != NULL) {
      normal_to_plus(&p_1->g_c, g, &edge_list);
      edge_list_insert->pointer = edge_list;
      p = m_edge_list;
      while (p != NULL) {
	edge_list_insert->v = p->v;
	edge_list_insert->w = p->w;
	plus_to_normal(edge_list_insert, g, &g_c_insert);
	insert_minimal(&g_c_insert, d_a);
	p = p->pointer;
      }
      dispose_edge_list(&edge_list);
      p_0 = p_1;
      p_1 = p_1->pointer;
      dispose_set_list(&p_0->g_c);
      _Free(p_0);
    }
  } else {
    edge_list_insert->pointer = NULL;
    p = m_edge_list;
    while (p != NULL) {
      edge_list_insert->v = p->v;
      edge_list_insert->w = p->w;
      plus_to_normal(edge_list_insert, g, &g_c_insert);
      insert_minimal(&g_c_insert, d_a);
      p = p->pointer;
    }
  }
  dispose_edge_list(&m_edge_list);
  _Free(edge_list_insert);
}  /* update_d_a_graphical */


/*@+"updateh.p"*/


Static Void update_d_r_hierarchical(m, g, d_r)
t_set_list **m;
long *g;
t_g_c_list **d_r;
{
  t_g_c_list *p_0;
  t_g_c_list *p_1 = NULL;
  t_set_list *g_c_insert, *p, *model_d, *model_d_insert;

  if (*d_r != NULL) {
    while (*d_r != NULL) {
      normal_to_dual((*d_r)->g_c, g, &model_d);
      p = *m;
      while (p != NULL) {
	if (cardinality(p->vertex_set) == 1) {
	  p = p->pointer;
	  continue;
	}
	copy_set_list(model_d, &model_d_insert);
	insert_set_minimal(p->vertex_set, &model_d_insert);
	dual_to_normal(model_d_insert, g, &g_c_insert);
	dispose_set_list(&model_d_insert);
	insert_maximal(&g_c_insert, &p_1);
	p = p->pointer;
      }
      dispose_set_list(&model_d);
      p_0 = *d_r;
      *d_r = (*d_r)->pointer;
      dispose_set_list(&p_0->g_c);
      _Free(p_0);
    }
  } else {
    p = *m;
    while (p != NULL) {
      if (cardinality(p->vertex_set) == 1) {
	p = p->pointer;
	continue;
      }
      model_d_insert = (t_set_list *)Malloc(sizeof(t_set_list));
      if (model_d_insert == NULL)
	_OutMem();
      model_d_insert->pointer = NULL;
      P_setcpy(model_d_insert->vertex_set, p->vertex_set);
      dual_to_normal(model_d_insert, g, &g_c_insert);
      _Free(model_d_insert);
      insert_maximal(&g_c_insert, &p_1);
      p = p->pointer;
    }
  }
  *d_r = p_1;
}  /* update_d_r_hierarchical */


Static Void update_d_a_hierarchical(m, g, d_a)
t_set_list **m;
long *g;
t_g_c_list **d_a;
{
  t_g_c_list *p_0;
  t_g_c_list *p_1 = NULL;
  t_set_list *m_dual, *p, *g_c_insert;
  t_vertex v;
  t_vertex_set vertex_set;

  normal_to_dual(*m, g, &m_dual);
  if (*d_a != NULL) {
    while (*d_a != NULL) {
      p = m_dual;
      while (p != NULL) {
	copy_set_list((*d_a)->g_c, &g_c_insert);
	insert_clique(p->vertex_set, &g_c_insert);
	insert_minimal(&g_c_insert, &p_1);
	p = p->pointer;
      }
      p_0 = *d_a;
      *d_a = (*d_a)->pointer;
      dispose_set_list(&p_0->g_c);
      _Free(p_0);
    }
  } else {
    p = m_dual;
    while (p != NULL) {
      g_c_insert = (t_set_list *)Malloc(sizeof(t_set_list));
      if (g_c_insert == NULL)
	_OutMem();
      g_c_insert->pointer = NULL;
      P_setcpy(g_c_insert->vertex_set, p->vertex_set);
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, g)) {
	  P_addset(P_expset(vertex_set, 0L), v);   /* empty_set + */
	  insert_clique(vertex_set, &g_c_insert);
	}
      }
      insert_minimal(&g_c_insert, &p_1);
      p = p->pointer;
    }
  }
  dispose_set_list(&m_dual);
  *d_a = p_1;
}  /* update_d_a_hierarchical */


/*@+"findg.p"*/


/*

2074:    +++  ++
2075:    +++  ++
2076:    ---  -- p/findg.p          6      25     394 p/findg.p
2077: |    4:    procedure dispose_adj_set_list
2078: |   15:    function test_sub_adj_set
2079: |   32:    procedure insert_minimal_adj_set
2080: |   65:    procedure exclude_edges_in_adj_set
2081: |   96:    procedure find_d_r_graphical
2082: |  179:    procedure find_d_a_graphical
2083:    +++  ++
2084:    +++  ++

*/


Static Void dispose_adj_set_list(p)
t_adj_set_list **p;
{
  t_adj_set_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_adj_set_list */


Static boolean test_sub_adj_set(adj_set_1, adj_set_2)
t_vertex_set *adj_set_1, *adj_set_2;
{
  boolean ok = true;
  t_vertex v;

  v = first_vertex;
  while (ok && v < last_vertex) {
    ok = P_subset(adj_set_1[v - MIN_VERTEX], adj_set_2[v - MIN_VERTEX]);
    v++;
  }
  if (ok)
    ok = P_subset(adj_set_1[last_vertex - MIN_VERTEX],
		  adj_set_2[last_vertex - MIN_VERTEX]);
  return ok;
}  /* test_sub_adj_set */


Static Void insert_minimal_adj_set(adj_set, list_of_models)
t_vertex_set *adj_set;
t_adj_set_list **list_of_models;
{
  t_adj_set_list *p, *q;
  boolean b = true;
  t_vertex v;

  p = *list_of_models;
  while (p != NULL && b) {
    if (test_sub_adj_set(p->adj_set, adj_set))
      b = false;
    else
      p = p->pointer;
  }
  if (!b)
    return;
  p = *list_of_models;
  *list_of_models = (t_adj_set_list *)Malloc(sizeof(t_adj_set_list));
  if (*list_of_models == NULL)
    _OutMem();
  q = *list_of_models;
  for (v = first_vertex; v <= last_vertex; v++)
    P_setcpy(q->adj_set[v - MIN_VERTEX], adj_set[v - MIN_VERTEX]);
  q->pointer = p;
  while (p != NULL) {
    if (test_sub_adj_set(adj_set, p->adj_set)) {
      q->pointer = p->pointer;
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* insert_minimal_adj_set */


Static Void exclude_edges_in_adj_set(edge_list, adj_set)
t_edge_list **edge_list;
t_vertex_set *adj_set;
{
  boolean cont = true;
  t_edge_list *p, *q;

  while (*edge_list != NULL && cont) {
    if (!P_inset((*edge_list)->v, adj_set[(*edge_list)->w - MIN_VERTEX])) {
      cont = false;
      break;
    }
    p = *edge_list;
    *edge_list = (*edge_list)->pointer;
    _Free(p);
  }
  if (*edge_list == NULL)
    return;
  p = *edge_list;
  q = (*edge_list)->pointer;
  while (q != NULL) {
    if (P_inset(q->v, adj_set[q->w - MIN_VERTEX])) {
      p->pointer = q->pointer;
      _Free(q);
      q = p->pointer;
    } else {
      p = q;
      q = p->pointer;
    }
  }
}  /* exclude_edges_in_adj_set */


Static Void find_d_r_graphical(s, g, d_r)
t_g_c_list **s;
long *g;
t_g_c_list **d_r;
{
  t_adj_set_list *q;
  t_adj_set_list *d_r_minus = NULL;
  t_adj_set_list *d_r_minus_x;
  t_g_c_list *p, *r;
  t_vertex v;
  t_edge_list *el, *edge_list;
  t_v_arr_of_v_sets tmp_model;
  boolean not_there;
  t_vertex_set a, SET;

  if (*s != NULL) {
    p = *s;
    if (link_eh_pack->fix_out) {
      d_r_minus = (t_adj_set_list *)Malloc(sizeof(t_adj_set_list));
      if (d_r_minus == NULL)
	_OutMem();
      d_r_minus->pointer = NULL;
      for (v = first_vertex; v <= last_vertex; v++)
	P_setcpy(d_r_minus->adj_set[v - MIN_VERTEX],
		 link_eh_pack->fix_out_adj_set[v - MIN_VERTEX]);
    } else {
      normal_to_plus(&p->g_c, g, &edge_list);
      if (link_eh_pack->fix_in)
	exclude_edges_in_adj_set(&edge_list, link_eh_pack->fix_in_adj_set);
      el = edge_list;
      while (el != NULL) {
	q = (t_adj_set_list *)Malloc(sizeof(t_adj_set_list));
	if (q == NULL)
	  _OutMem();
	for (v = first_vertex; v <= last_vertex; v++)
	  P_setcpy(q->adj_set[v - MIN_VERTEX], empty_set);
	P_addset(P_expset(q->adj_set[el->w - MIN_VERTEX], 0L), el->v);
	    /* empty_set + */
	P_addset(P_expset(q->adj_set[el->v - MIN_VERTEX], 0L), el->w);
	    /* empty_set + */
	q->pointer = d_r_minus;
	d_r_minus = q;
	el = el->pointer;
      }
      dispose_edge_list(&edge_list);
      p = p->pointer;
    }
    while (p != NULL && !interrupt_2) {
      d_r_minus_x = NULL;
      normal_to_plus(&p->g_c, g, &edge_list);
      if (link_eh_pack->fix_in)
	exclude_edges_in_adj_set(&edge_list, link_eh_pack->fix_in_adj_set);
      while (d_r_minus != NULL && !interrupt_3) {
	el = edge_list;
	not_there = true;
	while (el != NULL) {
	  if (!P_inset(el->v, d_r_minus->adj_set[el->w - MIN_VERTEX])) {
	    for (v = first_vertex; v <= last_vertex; v++)
	      P_setcpy(tmp_model[v - MIN_VERTEX],
		       d_r_minus->adj_set[v - MIN_VERTEX]);
	    P_addset(tmp_model[el->w - MIN_VERTEX], el->v);
	    P_addset(tmp_model[el->v - MIN_VERTEX], el->w);
	    insert_minimal_adj_set(tmp_model, &d_r_minus_x);
	  } else if (not_there) {
	    not_there = false;
	    insert_minimal_adj_set(d_r_minus->adj_set, &d_r_minus_x);
	  }
	  el = el->pointer;
	}
	q = d_r_minus;
	d_r_minus = d_r_minus->pointer;
	_Free(q);
      }
      if (interrupt_3)
	dispose_adj_set_list(&d_r_minus_x);
      dispose_edge_list(&edge_list);
      d_r_minus = d_r_minus_x;
      p = p->pointer;
    }
  }
  *d_r = NULL;
  while (d_r_minus != NULL) {
    r = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (r == NULL)
      _OutMem();
    r->pointer = *d_r;
    *d_r = r;
    for (v = first_vertex; v <= last_vertex; v++) {
      P_setcpy(a, d_r_minus->adj_set[v - MIN_VERTEX]);
      P_setdiff(a, g, a);
      P_setcpy(d_r_minus->adj_set[v - MIN_VERTEX], a);
    }
    find_cliques(d_r_minus->adj_set, g, &(*d_r)->g_c);
    q = d_r_minus;
    d_r_minus = d_r_minus->pointer;
    _Free(q);
  }
}  /* find_d_r_graphical */


Static Void find_d_a_graphical(s, g, d_a)
t_g_c_list **s;
long *g;
t_g_c_list **d_a;
{
  t_adj_set_list *q;
  t_adj_set_list *d_a_plus = NULL;
  t_adj_set_list *d_a_plus_x;
  t_g_c_list *p, *r;
  t_vertex v;
  boolean not_there;
  t_edge_list *el, *edge_list;
  t_v_arr_of_v_sets tmp_model;

  p = *s;
  if (link_eh_pack->fix_in) {
    d_a_plus = (t_adj_set_list *)Malloc(sizeof(t_adj_set_list));
    if (d_a_plus == NULL)
      _OutMem();
    d_a_plus->pointer = NULL;
    for (v = first_vertex; v <= last_vertex; v++)
      P_setcpy(d_a_plus->adj_set[v - MIN_VERTEX],
	       link_eh_pack->fix_in_adj_set[v - MIN_VERTEX]);
  } else {
    normal_to_minus(&p->g_c, g, &edge_list);
    if (link_eh_pack->fix_out)
      exclude_edges_in_adj_set(&edge_list, link_eh_pack->fix_out_adj_set);
    el = edge_list;
    while (el != NULL) {
      q = (t_adj_set_list *)Malloc(sizeof(t_adj_set_list));
      if (q == NULL)
	_OutMem();
      for (v = first_vertex; v <= last_vertex; v++)
	P_setcpy(q->adj_set[v - MIN_VERTEX], empty_set);
      P_addset(P_expset(q->adj_set[el->w - MIN_VERTEX], 0L), el->v);
	  /* empty_set + */
      P_addset(P_expset(q->adj_set[el->v - MIN_VERTEX], 0L), el->w);
	  /* empty_set + */
      q->pointer = d_a_plus;
      d_a_plus = q;
      el = el->pointer;
    }
    dispose_edge_list(&edge_list);
    p = p->pointer;
  }
  while (p != NULL && !interrupt_2) {
    d_a_plus_x = NULL;
    normal_to_minus(&p->g_c, g, &edge_list);
    if (link_eh_pack->fix_out)
      exclude_edges_in_adj_set(&edge_list, link_eh_pack->fix_out_adj_set);
    while (d_a_plus != NULL && !interrupt_3) {
      el = edge_list;
      not_there = true;
      while (el != NULL) {
	if (!P_inset(el->v, d_a_plus->adj_set[el->w - MIN_VERTEX])) {
	  for (v = first_vertex; v <= last_vertex; v++)
	    P_setcpy(tmp_model[v - MIN_VERTEX],
		     d_a_plus->adj_set[v - MIN_VERTEX]);
	  P_addset(tmp_model[el->w - MIN_VERTEX], el->v);
	  P_addset(tmp_model[el->v - MIN_VERTEX], el->w);
	  insert_minimal_adj_set(tmp_model, &d_a_plus_x);
	} else if (not_there) {
	  not_there = false;
	  insert_minimal_adj_set(d_a_plus->adj_set, &d_a_plus_x);
	}
	el = el->pointer;
      }
      q = d_a_plus;
      d_a_plus = d_a_plus->pointer;
      _Free(q);
    }
    if (interrupt_3)
      dispose_adj_set_list(&d_a_plus_x);
    dispose_edge_list(&edge_list);
    d_a_plus = d_a_plus_x;
    p = p->pointer;
  }
  *d_a = NULL;
  while (d_a_plus != NULL) {
    r = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (r == NULL)
      _OutMem();
    r->pointer = *d_a;
    *d_a = r;
    find_cliques(d_a_plus->adj_set, g, &(*d_a)->g_c);
    q = d_a_plus;
    d_a_plus = d_a_plus->pointer;
    _Free(q);
  }
}  /* find_d_a_graphical */


/*@+"findh.p"*/


Static Void find_d_r_hierarchical(s, g, d_r)
t_g_c_list **s;
long *g;
t_g_c_list **d_r;
{
  t_g_c_list *p, *q;
  t_g_c_list *d_r_dual = NULL;
  t_g_c_list *d_r_dual_x;
  t_set_list *g_c_0, *g_c, *g_c_x;
  boolean not_there;
  _PROCEDURE TEMP;

  if (*s != NULL) {
    p = *s;
    if (link_eh_pack->fix_out) {
      d_r_dual = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
      if (d_r_dual == NULL)
	_OutMem();
      d_r_dual->pointer = NULL;
      copy_set_list(link_eh_pack->fix_out_gc, &d_r_dual->g_c);
    } else {
      if (link_eh_pack->fix_in) {
	copy_set_list(p->g_c, &g_c_0);

	TEMP.proc = (Anyptr)subset_of_an_edge;
	TEMP.link = (Anyptr)NULL;

	/*$ifdef On-DOS
	exclude_sub_vertex_sets_in_list(g_c_0, link_eh_pack^.fix_in_gc)
	 $endif On-DOS*/
	exclude_vertex_sets_in_list(&g_c_0, TEMP, &link_eh_pack->fix_in_gc);
      } else
	g_c_0 = p->g_c;
      g_c = g_c_0;
      while (g_c != NULL) {
	if (cardinality(g_c->vertex_set) > 1) {
	  q = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
	  if (q == NULL)
	    _OutMem();
	  q->g_c = (t_set_list *)Malloc(sizeof(t_set_list));
	  if (q->g_c == NULL)
	    _OutMem();
	  P_setcpy(q->g_c->vertex_set, g_c->vertex_set);
	  q->g_c->pointer = NULL;
	  q->pointer = d_r_dual;
	  d_r_dual = q;
	}
	g_c = g_c->pointer;
      }
      if (link_eh_pack->fix_in)
	dispose_set_list(&g_c_0);
      p = p->pointer;
    }
    while (p != NULL && !interrupt_2) {
      d_r_dual_x = NULL;
      if (link_eh_pack->fix_in) {
	copy_set_list(p->g_c, &g_c_0);

	TEMP.proc = (Anyptr)subset_of_an_edge;
	TEMP.link = (Anyptr)NULL;

	/*$ifdef On-DOS
	exclude_sub_vertex_sets_in_list(g_c_0, link_eh_pack^.fix_in_gc)
	 $endif On-DOS*/
	exclude_vertex_sets_in_list(&g_c_0, TEMP, &link_eh_pack->fix_in_gc);
      } else
	g_c_0 = p->g_c;
      while (d_r_dual != NULL && !interrupt_3) {
	g_c = g_c_0;
	not_there = true;
	while (g_c != NULL) {
	  if (cardinality(g_c->vertex_set) > 1) {
	    if (!contains_an_edge(g_c->vertex_set, &d_r_dual->g_c)) {
	      copy_set_list(d_r_dual->g_c, &g_c_x);
	      insert_set_minimal(g_c->vertex_set, &g_c_x);
	      insert_maximal_dual(&g_c_x, &d_r_dual_x);
	    } else if (not_there) {
	      not_there = false;
	      copy_set_list(d_r_dual->g_c, &g_c_x);
	      insert_maximal_dual(&g_c_x, &d_r_dual_x);
	    }
	  }
	  g_c = g_c->pointer;
	}
	dispose_set_list(&d_r_dual->g_c);
	q = d_r_dual;
	d_r_dual = d_r_dual->pointer;
	_Free(q);
      }
      if (interrupt_3)
	dispose_g_c_list(&d_r_dual_x);
      if (link_eh_pack->fix_in)
	dispose_set_list(&g_c_0);
      d_r_dual = d_r_dual_x;
      p = p->pointer;
    }
  }
  *d_r = NULL;
  while (d_r_dual != NULL) {
    q = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (q == NULL)
      _OutMem();
    q->pointer = *d_r;
    *d_r = q;
    dual_to_normal(d_r_dual->g_c, g, &(*d_r)->g_c);
    dispose_set_list(&d_r_dual->g_c);
    q = d_r_dual;
    d_r_dual = d_r_dual->pointer;
    _Free(q);
  }
}  /* find_d_r_hierarchical */


Static Void find_d_a_hierarchical(s, g, d_a)
t_g_c_list **s;
long *g;
t_g_c_list **d_a;
{
  t_g_c_list *p, *q, *d_a_x;
  t_set_list *dual_g_c, *g_c, *g_c_x;
  t_vertex v;
  t_vertex_set a, d;
  boolean not_there;
  _PROCEDURE TEMP;

  *d_a = NULL;
  if (*s != NULL) {
    p = *s;
    if (link_eh_pack->fix_in) {
      *d_a = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
      if (*d_a == NULL)
	_OutMem();
      (*d_a)->pointer = NULL;
      copy_set_list(link_eh_pack->fix_in_gc, &(*d_a)->g_c);
    } else {
      normal_to_dual(p->g_c, g, &dual_g_c);
      if (link_eh_pack->fix_out) {
	if (!is_empty_g_c(&link_eh_pack->fix_out_gc)) {
	  TEMP.proc = (Anyptr)contains_an_edge;
	  TEMP.link = (Anyptr)NULL;
	  exclude_vertex_sets_in_list(&dual_g_c, TEMP,
				      &link_eh_pack->fix_out_gc);
	}

      }

      /*$ifdef On-DOS
      exclude_super_vertex_sets_in_list(dual_g_c,
                                        link_eh_pack^.fix_out_gc);
       $endif On-DOS*/
      g_c = dual_g_c;
      while (g_c != NULL) {
	q = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
	if (q == NULL)
	  _OutMem();
	q->g_c = (t_set_list *)Malloc(sizeof(t_set_list));
	if (q->g_c == NULL)
	  _OutMem();
	P_setcpy(q->g_c->vertex_set, g_c->vertex_set);
	q->g_c->pointer = NULL;
	q->pointer = *d_a;
	*d_a = q;
	g_c = g_c->pointer;
      }
      dispose_set_list(&dual_g_c);
      p = p->pointer;
    }
    while (p != NULL && !interrupt_2) {
      normal_to_dual(p->g_c, g, &dual_g_c);
      if (link_eh_pack->fix_out) {
	if (!is_empty_g_c(&link_eh_pack->fix_out_gc)) {
	  TEMP.proc = (Anyptr)contains_an_edge;
	  TEMP.link = (Anyptr)NULL;
	  exclude_vertex_sets_in_list(&dual_g_c, TEMP,
				      &link_eh_pack->fix_out_gc);
	}

      }

      /*$ifdef On-DOS
      exclude_super_vertex_sets_in_list(dual_g_c,
                                        link_eh_pack^.fix_out_gc);
       $endif On-DOS*/
      d_a_x = NULL;
      while (*d_a != NULL && !interrupt_3) {
	g_c = dual_g_c;
	not_there = true;
	while (g_c != NULL) {
	  if (!subset_of_an_edge(g_c->vertex_set, &(*d_a)->g_c)) {
	    copy_set_list((*d_a)->g_c, &g_c_x);
	    insert_clique(g_c->vertex_set, &g_c_x);
	    insert_minimal(&g_c_x, &d_a_x);
	  } else if (not_there) {
	    not_there = false;
	    copy_set_list((*d_a)->g_c, &g_c_x);
	    insert_minimal(&g_c_x, &d_a_x);
	  }
	  g_c = g_c->pointer;
	}
	dispose_set_list(&(*d_a)->g_c);
	q = *d_a;
	*d_a = (*d_a)->pointer;
	_Free(q);
      }
      if (interrupt_3)
	dispose_g_c_list(&d_a_x);
      *d_a = d_a_x;
      dispose_set_list(&dual_g_c);
      p = p->pointer;
    }
  }
  q = *d_a;
  while (q != NULL) {
    g_c = q->g_c;
    P_setcpy(a, empty_set);
    while (g_c != NULL) {
      P_setunion(a, a, g_c->vertex_set);
      g_c = g_c->pointer;
    }
    P_setdiff(d, g, a);
    if (!P_setequal(d, empty_set)) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, d)) {
	  g_c = (t_set_list *)Malloc(sizeof(t_set_list));
	  if (g_c == NULL)
	    _OutMem();
	  P_addset(P_expset(g_c->vertex_set, 0L), v);   /* empty_set + */
	  g_c->pointer = q->g_c;
	  q->g_c = g_c;
	}
      }
    }
    q = q->pointer;
  }
}  /* find_d_a_hierarchical */


/*@+"ehsizes.p"*/


Static t_long_real log_a_dual(g, fit_gra, p)
long *g;
boolean *fit_gra;
t_g_c_list *p;
{
  t_long_integer dim, n_edges;
  t_long_real log_d_a_size;
  t_set_list *alt_rep;
  t_vertex v;
  t_v_arr_of_v_sets adj_set;

  if (*fit_gra) {
    log_d_a_size = 0.0;
    dim = cardinality(g);
    while (p != NULL) {
      hypergraph_sets_to_graph_sets(p->g_c, g, adj_set);
      n_edges = 0;
      for (v = first_vertex; v <= last_vertex; v++)
	n_edges += dim - cardinality(adj_set[v - MIN_VERTEX]) - 1;
      if (n_edges != 0)
	log_d_a_size += log_10(n_edges / 2.0);
      p = p->pointer;
    }
    return log_d_a_size;
  }
  log_d_a_size = 0.0;
  while (p != NULL) {
    normal_to_dual(p->g_c, g, &alt_rep);
    n_edges = g_c_size(alt_rep);
    dispose_set_list(&alt_rep);
    if (n_edges != 0)
      log_d_a_size += log_10((double)n_edges);
    p = p->pointer;
  }
  return log_d_a_size;
}  /* log_a_dual */


Static t_long_real log_r_dual(g, fit_gra, p)
long *g;
boolean *fit_gra;
t_g_c_list *p;
{
  t_long_integer n_edges;
  t_long_real log_d_r_size;
  t_vertex v;
  t_v_arr_of_v_sets adj_set;

  if (*fit_gra) {
    log_d_r_size = 0.0;
    while (p != NULL) {
      hypergraph_sets_to_graph_sets(p->g_c, g, adj_set);
      n_edges = 0;
      for (v = first_vertex; v <= last_vertex; v++)
	n_edges += cardinality(adj_set[v - MIN_VERTEX]);
      if (n_edges != 0)
	log_d_r_size += log_10(n_edges / 2.0);
      p = p->pointer;
    }
    return log_d_r_size;
  }
  log_d_r_size = 0.0;
  while (p != NULL) {
    n_edges = g_c_size(p->g_c);
    if (n_edges != 0)
      log_d_r_size += log_10((double)n_edges);
    p = p->pointer;
  }
  return log_d_r_size;
}  /* log_r_dual */


/*@+"find.p"*/


Static Void update_d_r(fit_gra, g_c, g, d_r)
boolean *fit_gra;
t_set_list **g_c;
long *g;
t_g_c_list **d_r;
{
  if (*fit_gra)
    update_d_r_graphical(g_c, g, d_r);
  else
    update_d_r_hierarchical(g_c, g, d_r);
  write_pch_20_text(report_file, " DualRej.:  ", 12L);
  write_integer_text(report_file, class_size(*d_r), 7L);
  write_space_text(report_file, 3L);
}  /* update_d_r */


Static Void update_d_a(fit_gra, g_c, g, d_a)
boolean *fit_gra;
t_set_list **g_c;
long *g;
t_g_c_list **d_a;
{
  if (*fit_gra)
    update_d_a_graphical(g_c, g, d_a);
  else
    update_d_a_hierarchical(g_c, g, d_a);
  write_pch_20_text(report_file, " DualAcc.:  @@@@@@@ ", 12L);
  write_integer_text(report_file, class_size(*d_a), 7L);
  write_space_text(report_file, 3L);
}  /* update_d_a */


Static Void find_a_dual(g, fit_gra, p, d_a)
long *g;
boolean *fit_gra;
t_g_c_list *p, **d_a;
{
  t_long_real start_clock;

  if (*fit_gra)
    write_pch_30_text(report_file, " -- Find A-Dual Graphical    ", 29L);
  else
    write_pch_30_text(report_file, " -- Find A-Dual Hierarchical ", 29L);
  write_line_text(report_file);
  start_clock = my_clock()/1;
  write_pch_20_text(report_file, " -- RoughADual:", 15L);
  write_real_text(report_file, log_a_dual(g, fit_gra, p), 10L, 2L);
  write_pch_20_text(report_file, " RoughDualTime: ", 16L);
  write_time_text(report_file, "", 0L, (double)my_clock()/1, start_clock,
		  8L, 3L);
  write_line_text(report_file);
  fflush(report_file);
  P_ioresult = 0;
  dispose_g_c_list(d_a);
  if (link_eh_pack->search_opt == 3) {
    start_clock = my_clock()/1;
    if (*fit_gra)
      find_d_a_graphical(&p, g, d_a);
    else
      find_d_a_hierarchical(&p, g, d_a);
    write_pch_20_text(report_file, " -- DualAcc.:  ", 15L);
    write_integer_text(report_file, class_size(*d_a), 7L);
    write_space_text(report_file, 3L);
    write_pch_20_text(report_file, " TimeFindDual:  ", 16L);
    write_time_text(report_file, "", 0L, (double)my_clock()/1,
		    start_clock, 8L, 3L);
    write_line_text(report_file);
  } else {
    while (p != NULL && !interrupt_2) {
      start_clock = my_clock()/1;
      write_pch_10_text(report_file, " //", 3L);
      update_d_a(fit_gra, &p->g_c, g, d_a);
      write_pch_20_text(report_file, " TimeUpDate: ", 13L);
      write_time_text(report_file, "", 0L, (double)my_clock()/1,
		      start_clock, 8L, 3L);
      write_line_text(report_file);
      fflush(report_file);
      P_ioresult = 0;
      p = p->pointer;
    }
  }
  fflush(report_file);
  P_ioresult = 0;
}  /* find_a_dual */


Static Void find_r_dual(g, fit_gra, p, d_r)
long *g;
boolean *fit_gra;
t_g_c_list *p, **d_r;
{
  t_long_real start_clock;

  start_clock = my_clock()/1;
  if (*fit_gra)
    write_pch_30_text(report_file, " -- Find R-Dual Graphical    ", 29L);
  else
    write_pch_30_text(report_file, " -- Find R-Dual Hierarchical ", 29L);
  write_line_text(report_file);
  write_pch_20_text(report_file, " -- RoughRDual:", 15L);
  write_real_text(report_file, log_r_dual(g, fit_gra, p), 10L, 2L);
  write_pch_20_text(report_file, " RoughDualTime: ", 16L);
  write_time_text(report_file, "", 0L, (double)my_clock()/1, start_clock,
		  8L, 3L);
  write_line_text(report_file);
  fflush(report_file);
  P_ioresult = 0;
  dispose_g_c_list(d_r);
  if (link_eh_pack->search_opt == 3) {
    start_clock = my_clock()/1;
    if (*fit_gra)
      find_d_r_graphical(&p, g, d_r);
    else
      find_d_r_hierarchical(&p, g, d_r);
    write_pch_20_text(report_file, " -- DualRej.:  ", 15L);
    write_integer_text(report_file, class_size(*d_r), 7L);
    write_space_text(report_file, 3L);
    write_pch_20_text(report_file, " TimeFindDual:  ", 16L);
    write_time_text(report_file, "", 0L, (double)my_clock()/1,
		    start_clock, 8L, 3L);
    write_line_text(report_file);
  } else {
    while (p != NULL && !interrupt_2) {
      start_clock = my_clock()/1;
      write_pch_10_text(report_file, " //", 3L);
      update_d_r(fit_gra, &p->g_c, g, d_r);
      write_pch_20_text(report_file, " TimeUpDate: ", 13L);
      write_time_text(report_file, "", 0L, (double)my_clock()/1,
		      start_clock, 8L, 3L);
      write_line_text(report_file);
      fflush(report_file);
      P_ioresult = 0;
      p = p->pointer;
    }
  }
  fflush(report_file);
  P_ioresult = 0;
}  /* find_r_dual */


/*@+"ehtest.p"*/


/*


2108:    +++  ++
2109:    +++  ++
2110:    ---  -- p/ehtest.p          5      23     340 p/ehtest.p
2111: |    4:    procedure write_model_out_of_space_eh
2112: |   19:    procedure eh_test_against_saturated
2113: |   45:    procedure eh_test_against_base_without_partitioning
2114: |   66:    procedure eh_test_against_base
2115: |  149:    procedure eh_test
2116:    +++  ++
2117:    +++  ++

*/


Static Void write_model_out_of_space_eh(model, g_c, c)
t_model **model;
t_set_list *g_c;
Char *c;
{
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_true();
  local_test_labels = new_test_labels_empty();
  write_model_out_of_space(*model, g_c, c, &local_write_options,
			   &local_test_labels, 0L);
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* write_model_out_of_space_eh */


Static Void eh_test_against_saturated(model, g, test)
t_model **model;
long *g;
t_test *test;
{
  note_mixed(stdout, " EhTestAgainstSatur.", 20L);
  test->test_ifail = -4;
  test->ok = ok_model_fit_values(model);
  if (test->ok)
    compute_full_x_deviance_and_x_pearson(model, g, &test->x_deviance,
					  &test->x_pearson, &test->x_power);
  else {
    test->ok = ok_model_to_test(model) & ok_model_to_test(&link_full->model);
    if (test->ok)
      compute_x_deviance_and_x_pearson(model, &link_full->model, g,
	&test->x_deviance, &test->x_pearson, &test->x_power);
  }
  if (test->ok && test->df < _INFINITY)
    find_adjusted_df(model, &link_full->model, &test->adj);
  else
    test->adj = _INFINITY;
  dispose_marginals_cond();
  if (!test->ok)
    write_model_out_of_space_eh(model, NULL, "SATURATED ");
}  /* eh_test_against_saturated */


Static Void eh_test_against_base_without_partitioning(model, base_model, g, test)
t_model **model, **base_model;
long *g;
t_test *test;
{
  note_mixed(stdout, " EhTestAgainstBaseW.", 20L);
  test->ok = ok_model_to_test(model);
  if (test->ok)
    compute_x_deviance_and_x_pearson(model, base_model, g, &test->x_deviance,
				     &test->x_pearson, &test->x_power);
  if (test->ok && test->df < _INFINITY)
    find_adjusted_df(model, base_model, &test->adj);
  else
    test->adj = _INFINITY;
  dispose_marginals_cond();
  if (!test->ok)
    write_model_out_of_space_eh(model, NULL, "BASE      ");
}  /* eh_test_against_base_without_partitioning */


Static Void eh_test_against_base(model, base_model, g, test)
t_model **model, **base_model;
long *g;
t_test *test;
{
  t_long_integer dummy;
  t_sort_list *link_sort_list;
  t_set_list *g_c_model, *g_c_base;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;
  boolean homogeneous;

  local_write_options = new_test_write_options_true();
  local_write_options->write_models = !global_write_options->line_form;
  local_test_labels = new_test_labels_empty();
  note_mixed(stdout, " EhTestAgainstBase", 18L);
  if (c_partitioning || mixed_data) {
    test->test_ifail = -5;
    if (local_write_options->line_form && local_write_options->write_test)
      write_space(stdout, 7L);
    dummy = 0;
    dispose_part_list(&link_part_list);
    g_c_model = return_g_c_copy_for_mixed_model(model);
    g_c_base = return_g_c_copy_for_mixed_model(base_model);
    if ((*model)->id->model_type == mixed)
      homogeneous = (*model)->id->UU.U1.homogeneous;
    else
      homogeneous = false;
    partitioning_hierarchical(&g_c_model, &g_c_base,
      &(*model)->id->causal_structure, &homogeneous, &local_write_options,
      &local_test_labels, &dummy);
    dispose_g_c_copy_for_mixed_model(model, &g_c_model);
    dispose_g_c_copy_for_mixed_model(base_model, &g_c_base);
    if (link_part_list != NULL) {
      if (link_part_list->pointer != NULL && local_write_options->write_test) {
	if (local_write_options->line_form)
	  write_pch(stdout, "   =   ", 7L);
	else {
	  write_pch(stdout, " Total ", 7L);
	  write_line(stdout);
	}
      }
      sum_up_partitioning(&link_sort_list, 0L, &c_partitioning,
			  &local_write_options, &local_test_labels,
			  exclude_missing);
      test->test_ifail = link_sort_list->link_test_list->test.test_ifail;
      test->x_pearson = link_sort_list->link_test_list->test.x_pearson;
      test->x_power = link_sort_list->link_test_list->test.x_power;
      test->x_deviance = link_sort_list->link_test_list->test.x_deviance;
      test->n_count = link_sort_list->link_test_list->test.n_count;
      test->f_test_df = link_sort_list->link_test_list->test.f_test_df;
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2114L, 1L)) {
	write_line(stdout);
	write_pch(stdout, " Df(F TEST): ", 13L);
	write_integer(stdout, test->n_count - test->f_test_df, 3L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      test->df = link_sort_list->link_test_list->test.df;
      test->x_f_test = deviance_to_f_value(test->df, n[0], test->f_test_df,
					   test->x_deviance);
      test->adj = link_sort_list->link_test_list->test.adj;
      test->ok = link_sort_list->link_test_list->test.ok;
      dispose_sort_list(&link_sort_list);
    } else {
      test->x_pearson = 0.0;
      test->x_power = 0.0;
      test->x_deviance = 0.0;
      test->n_count = 0;
      /* f_test_df := 0; */
      test->df = 0;
      test->adj = 0;
      test->ok = true;
      if (local_write_options->line_form && local_write_options->write_test)
	write_line(stdout);
    }
  } else
    eh_test_against_base_without_partitioning(model, base_model, g, test);
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* eh_test_against_base */


Static Void eh_test(g_c, arg_base, graphical, decomposable, g, test)
t_set_list **g_c;
t_model_list **arg_base;
boolean *graphical, *decomposable;
long *g;
t_test *test;
{
  boolean keep_just, reuse;
  t_model *model;
  t_test_list *link_test;
  t_long_real start_clock;
  t_model *base__model;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_true();
  local_write_options->write_models = !global_write_options->line_form;
  local_write_options->write_test = false;
  local_test_labels = new_test_labels_empty();
  note_mixed(stdout, " EhTest", 7L);
  clear_test(test);
  if (*arg_base != NULL)
    base__model = (*arg_base)->model;
  else
    base__model = link_full->model;
  reuse = return_test_g_c_model(g_c, &base__model, &link_test, test);
  new_model(&model);   /* HomMode */
  sub_insert_g_c_in_model(g_c, g, &base__model->id->causal_structure, false,
			  base__model->id->UU.U1.homogeneous, false, &model);
  identify_model(&model);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2115L, 1L)) {
    write_line(stdout);
    write_pch(stdout, " Model:   ", 10L);
    describe_model(&model, false, true);
    write_line(stdout);
    write_pch(stdout, " Against: ", 10L);
    describe_model(&base__model, false, true);
    write_line(stdout);
  }
  /*$endif TRACE*/
  *graphical = model->graphical;
  *decomposable = model->decomposable;
  if (!reuse) {
    test->test_ifail = -6;
    /* ToDo: Identification !!! */
    /* test.g_c_1 := g_c; */
    if ((model->dim < _INFINITY) & (marginal_dimension(g) < _INFINITY))
      test->df = marginal_dimension(g) - model->dim - 1;
    else
      test->df = _INFINITY;
    start_clock = my_clock()/1;
    if (model->decomposable && model->graphical && exact_test &&
	exact_test_for_test_models && !mixed_data &&
	!(*arg_base != NULL && c_partitioning)) {
      dispose_marginals_cond();
      local_write_options->write_test = false;
      factorization_one_edge_exact(&model, &base__model, &link_test,
				   &local_write_options, &local_test_labels);
      local_write_options->write_test = true;
      *test = link_test->test;
      dispose_marginals_cond();
      write_pch_20_text(report_file, " TimeExact:     ", 16L);
      write_real_text(report_file, (my_clock()/1 - start_clock) / 1000, 8L, 3L);
      write_pch_10_text(report_file, "s.        ", 2L);
    } else {
      if (!decomposable_mode || *graphical && *decomposable) {
	if (mixed_data) {
	  /* write_pch(output, ' [ @@@@@@@', 3); */
	  keep_just = global_write_options->write_test;
	  /* To avoid double printing of test (without `just'): */
	  global_write_options->write_test = false;
	  test->test_ifail = -7;
	  eh_test_against_base(&model, &base__model, g, test);
	  /* write_pch(output, ' ] @@@@@@@', 3); */
	  global_write_options->write_test = keep_just;
	} else if (*arg_base != NULL)
	  eh_test_against_base(&model, &(*arg_base)->model, g, test);
	else
	  eh_test_against_saturated(&model, g, test);
      }
      if (re_use_test) {
	copy_gc_and_model_to_test(g_c, &base__model, test);
	insert_test(&link_test, test);
      }
      write_pch_20_text(report_file, " TimeTest:      ", 16L);
      write_real_text(report_file, (my_clock()/1 - start_clock) / 1000, 8L, 3L);
      write_pch_10_text(report_file, "s.        ", 2L);
    }
  }
  dispose_model_but_gc(&model);
  dispose_model_link(&model);
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* eh_test */


/*@+"ehfit.p"*/


Static Void fit(alfa_, g, fit_gra, find_duals, s, a, r, d_a, d_r, fit_a_dual,
		fit_r_dual, acc, rej)
t_long_real *alfa_;
long *g;
boolean *fit_gra, find_duals;
t_g_c_list **s, **a, **r, **d_a, **d_r;
boolean fit_a_dual, fit_r_dual;
t_long_integer *acc, *rej;
{
  t_long_real start_clock, test_clock, p_value;
  boolean p_value_ok, gra, dec;
  t_g_c_list *p;
  t_set_list *m;
  t_test test;
  t_long_integer decision;
  FILE *TEMP;

  if (*fit_gra)
    write_pch_20_text(report_file, " Graphical Fit ", 15L);
  else
    write_pch_20_text(report_file, " Hierarchical Fit ", 18L);
  write_line_text(report_file);
  page(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
  flush_file(&diary_file);
  write_line(stdout);
  write_space(stdout, 2L);
  if (link_eh_pack->link_base != NULL && c_partitioning)
    write_space(stdout, 5L);
  sub_write_test_head(stdout, global_write_options, global_test_labels);
      /* true !!! */
  write_space(stdout, 7L);
  write_pch(stdout, " Model ", 7L);
  write_line(stdout);
  write_line(stdout);
  *acc = 0;
  *rej = 0;
  p = *s;
  test_clock = my_clock()/1;
  while (p != NULL && !interrupt_2) {
    eh_test(&p->g_c, &link_eh_pack->link_base, &gra, &dec, g, &test);
    p_value = sub_select_p_value(&test);
    if (ic)
      p_value_ok = !is_invalid_real(test.x_deviance);
    else
      p_value_ok = test.ok;
    if (p_value < 0 && !ic)
      p_value = 1.0;
    copy_set_list(p->g_c, &m);
    start_clock = my_clock()/1;
    decision = 3;
    if (p_value_ok) {
      if (p_value < *alfa_) {
	decision = 2;
	(*rej)++;
	insert_maximal(&m, r);
	write_pch_10_text(report_file, " Rej.: ", 7L);
	write_integer_text(report_file, class_size(*r), 5L);
	write_space_text(report_file, 2L);
	if (link_eh_pack->search_opt == 1)
	  update_d_a(fit_gra, &p->g_c, g, d_a);
      } else {
	decision = 1;
	(*acc)++;
	insert_minimal(&m, a);
	write_pch_10_text(report_file, " Acc.: ", 7L);
	write_integer_text(report_file, class_size(*a), 5L);
	write_space_text(report_file, 2L);
	if (link_eh_pack->search_opt == 1)
	  update_d_r(fit_gra, &p->g_c, g, d_r);
      }
    } else
      dispose_set_list(&m);
    write_pch_20_text(report_file, " TimeUpDate: ", 13L);
    write_real_text(report_file, (my_clock()/1 - start_clock) / 1000, 8L, 3L);
    write_pch_10_text(report_file, "s.", 2L);
    write_line_text(report_file);
    fflush(report_file);
    P_ioresult = 0;
    write_space(stdout, 2L);
    search_write_test(&test, &gra, &dec, &decision);
    p = p->pointer;
    TEMP = stdout;
    flush_file(&TEMP);
    flush_file(&diary_file);
  }
  if (interrupt_2) {
    interrupt_1 = false;
    interrupt_2 = false;
  }
  write_pch_20_text(report_file, " TotalTestTime: ", 16L);
  write_real_text(report_file, (my_clock()/1 - test_clock) / 1000, 8L, 3L);
  write_pch_10_text(report_file, "s.", 2L);
  write_pch_10_text(report_file, "  Acc.: ", 8L);
  write_integer_text(report_file, *acc, 5L);
  write_char_text(report_file, ' ');
  write_pch_10_text(report_file, "  Rej.: ", 8L);
  write_integer_text(report_file, *rej, 5L);
  write_line_text(report_file);
  fflush(report_file);
  P_ioresult = 0;
  write_line(stdout);
  write_pch(stdout, "    Accepted:", 13L);
  write_integer(stdout, *acc, 5L);
  write_line(stdout);
  write_pch(stdout, "    Rejected:", 13L);
  write_integer(stdout, *rej, 5L);
  write_line(stdout);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
  flush_file(&diary_file);
  if (link_eh_pack->search_opt != 1) {
    if (*acc != 0 && !(*rej == 0 && fit_a_dual)) {
      if (find_duals)
	find_r_dual(g, fit_gra, *a, d_r);
      else
	dispose_g_c_list(d_r);
    }
    if (*rej != 0 && !(*acc == 0 && fit_r_dual)) {
      if (find_duals)
	find_a_dual(g, fit_gra, *r, d_a);
      else
	dispose_g_c_list(d_a);
    }
  }
  write_pch_10_text(report_file, " Fit End ", 9L);
  write_line_text(report_file);
}  /* fit */


Static Void find_d_r_a_com_r(a, b, c)
t_g_c_list *a, *b, **c;
{
  t_g_c_list *p;
  boolean ok;

  *c = NULL;
  while (a != NULL) {
    ok = false;
    p = b;
    while (!ok && p != NULL) {
      if (test_sub_g_c(a->g_c, p->g_c))
	ok = true;
      else
	p = p->pointer;
    }
    if (p == NULL) {
      p = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
      if (p == NULL)
	_OutMem();
      p->pointer = *c;
      *c = p;
      copy_set_list(a->g_c, &(*c)->g_c);
    }
    a = a->pointer;
  }
}  /* find_d_r_a_com_r */


Static Void find_d_a_r_com_a(a, b, c)
t_g_c_list *a, *b, **c;
{
  t_g_c_list *p;
  boolean ok;

  *c = NULL;
  while (a != NULL) {
    ok = false;
    p = b;
    while (!ok && p != NULL) {
      if (test_sub_g_c(p->g_c, a->g_c))
	ok = true;
      else
	p = p->pointer;
    }
    if (p == NULL) {
      p = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
      if (p == NULL)
	_OutMem();
      p->pointer = *c;
      *c = p;
      copy_set_list(a->g_c, &(*c)->g_c);
    }
    a = a->pointer;
  }
}  /* find_d_a_r_com_a */


/*@+"ehprint.p"*/


Static Void print_base_fix_out_fix_in()
{
  write_line_diary();
  if (link_eh_pack->link_base != NULL) {
    write_pch(stdout, " Base Model:  ", 14L);
    print_model_g_c(&link_eh_pack->link_base->model, 14L);
    write_line(stdout);
  }
  if (link_eh_pack->fix_out) {
    write_pch(stdout, " Fix Out:     ", 14L);
    print_g_c(link_eh_pack->fix_out_gc, 14L, line_length);
    write_line(stdout);
  }
  if (!link_eh_pack->fix_in)
    return;
  write_pch(stdout, " Fix In:      ", 14L);
  print_g_c(link_eh_pack->fix_in_gc, 14L, line_length);
  write_line(stdout);
}  /* print_base_fix_out_fix_in */


Static Void print_models(heading)
boolean heading;
{
  FILE *TEMP;

  page(stdout);
  if (heading) {
    if (link_eh_pack->graphical_search)
      write_pch(stdout, " Inital sets for graphical search:   ", 37L);
    else
      write_pch(stdout, " Inital sets for hierarchical search:", 37L);
    write_line(stdout);
    write_line(stdout);
  }
  write_pch(stdout, " Accepted:", 10L);
  write_line(stdout);
  print_g_c_list(link_eh_pack->a);
  write_pch(stdout, " Rejected:", 10L);
  write_line(stdout);
  print_g_c_list(link_eh_pack->r);
  write_line(stdout);
  TEMP = stdout;
  flush_file(&TEMP);
  flush_file(&diary_file);
}  /* print_models */


Static Void report_sizes(g, fit_gra, a, r, d_a, d_r, d_a_of_r_com_a,
			 d_r_of_a_com_r)
long *g;
boolean *fit_gra;
t_g_c_list *a, *r, *d_a, *d_r, *d_a_of_r_com_a, *d_r_of_a_com_r;
{
  t_long_real t_r_, t_a, start_clock, log_d_a_size, log_d_r_size;
  t_long_integer a_size, r_size, d_a_size, d_r_size, d_a_com_size,
		 d_r_com_size;

  if (*fit_gra)
    write_pch_20_text(report_file, " Graphical Report", 17L);
  else
    write_pch_20_text(report_file, " Hierarchical Report", 20L);
  write_line_text(report_file);
  start_clock = my_clock()/1;
  a_size = class_size(a);
  d_r_size = class_size(d_r);
  d_r_com_size = class_size(d_r_of_a_com_r);
  t_r_ = my_clock()/1;
  log_d_r_size = log_r_dual(g, fit_gra, a);
  t_r_ = my_clock()/1 - t_r_;
  r_size = class_size(r);
  d_a_size = class_size(d_a);
  d_a_com_size = class_size(d_a_of_r_com_a);
  t_a = my_clock()/1;
  log_d_a_size = log_a_dual(g, fit_gra, r);
  t_a = my_clock()/1 - t_a;
  write_pch_20_text(report_file, " == Acc.:        ", 17L);
  write_integer_text(report_file, a_size, 10L);
  write_line_text(report_file);
  write_pch_20_text(report_file, " == DualRej.:    ", 17L);
  if (d_r_size != 0) {
    write_integer_text(report_file, d_r_size, 10L);
    if (a_size != 0)
      write_real_text(report_file, (double)d_r_size / a_size, 10L, 2L);
    else
      write_space_text(report_file, 10L);
  }
  write_line_text(report_file);
  write_pch_20_text(report_file, " == DualRej.\\R:  ", 17L);
  if (d_r_size != 0) {
    write_integer_text(report_file, d_r_com_size, 10L);
    if (a_size != 0)
      write_real_text(report_file, (double)d_r_com_size / a_size, 10L, 2L);
    else
      write_space_text(report_file, 10L);
    if (true)
      write_real_text(report_file, (double)d_r_com_size / d_r_size, 10L, 2L);
    else
      write_space_text(report_file, 10L);
  }
  write_line_text(report_file);
  write_pch_20_text(report_file, " == Log DualRej.:", 17L);
  write_real_text(report_file, log_d_r_size, 10L, 2L);
  if (a_size > 0)
    write_real_text(report_file, log_d_r_size - log_10((double)a_size), 10L,
		    2L);
  else
    write_space_text(report_file, 10L);
  if (d_r_size > 0)
    write_real_text(report_file, log_d_r_size - log_10((double)d_r_size), 10L,
		    2L);
  else
    write_space_text(report_file, 10L);
  if (d_r_com_size > 0)
    write_real_text(report_file, log_d_r_size - log_10((double)d_r_com_size),
		    10L, 2L);
  else
    write_space_text(report_file, 10L);
  write_pch_10_text(report_file, " Time: ", 7L);
  write_real_text(report_file, t_r_ / 1000, 8L, 3L);
  write_pch_10_text(report_file, "s.", 2L);
  write_line_text(report_file);
  write_pch_20_text(report_file, " == Rej.:        ", 17L);
  write_integer_text(report_file, r_size, 10L);
  write_line_text(report_file);
  write_pch_20_text(report_file, " == DualAcc.:    ", 17L);
  if (d_a_size != 0) {
    write_integer_text(report_file, d_a_size, 10L);
    if (r_size != 0)
      write_real_text(report_file, (double)d_a_size / r_size, 10L, 2L);
    else
      write_space_text(report_file, 10L);
  }
  write_line_text(report_file);
  write_pch_20_text(report_file, " == DualAcc.\\A:  ", 17L);
  if (d_a_size != 0) {
    write_integer_text(report_file, d_a_com_size, 10L);
    if (r_size != 0)
      write_real_text(report_file, (double)d_a_com_size / r_size, 10L, 2L);
    else
      write_space_text(report_file, 10L);
    if (true)
      write_real_text(report_file, (double)d_a_com_size / d_a_size, 10L, 2L);
    else
      write_space_text(report_file, 10L);
  }
  write_line_text(report_file);
  write_pch_20_text(report_file, " == Log DualAcc.:", 17L);
  write_real_text(report_file, log_d_a_size, 10L, 2L);
  if (r_size > 0)
    write_real_text(report_file, log_d_a_size - log_10((double)r_size), 10L,
		    2L);
  else
    write_space_text(report_file, 10L);
  if (d_a_size > 0)
    write_real_text(report_file, log_d_a_size - log_10((double)d_a_size), 10L,
		    2L);
  else
    write_space_text(report_file, 10L);
  if (d_a_com_size > 0)
    write_real_text(report_file, log_d_a_size - log_10((double)d_a_com_size),
		    10L, 2L);
  else
    write_space_text(report_file, 10L);
  write_pch_10_text(report_file, " Time: ", 7L);
  write_real_text(report_file, t_a / 1000, 8L, 3L);
  write_pch_10_text(report_file, "s.", 2L);
  write_line_text(report_file);
  if (d_r_com_size == d_a_com_size)
    write_pch_40_text(report_file,
		      " == Size D<R>(A)\\R = D<A>(R)\\A  ", 32L);
  else if (d_r_com_size < d_a_com_size)
    write_pch_30_text(report_file, " == D<R>(A)\\R Smallest  ", 24L);
  else
    write_pch_30_text(report_file, " == D<A>(R)\\A Smallest  ", 24L);
  if ((d_r_com_size <= d_a_com_size) == (log_d_r_size <= log_d_a_size))
    write_pch_20_text(report_file, " Equal Rough ", 13L);
  else if (d_r_com_size != 0 && d_a_com_size != 0 &&
	   d_r_com_size != d_a_com_size)
    write_pch_30_text(report_file, " ***** Diff. Rough ***** ", 25L);
  write_line_text(report_file);
  write_pch_20_text(report_file, " == ReportTime: ", 16L);
  write_line_text(report_file);
  write_real_text(report_file, (my_clock()/1 - start_clock) / 1000, 8L, 3L);
  write_pch_10_text(report_file, "s.", 2L);
}  /* report_sizes */


Static Void print_duals(complete, heading, fit_gra, g, a, r, d_a, d_r,
			d_a_of_r_com_a, d_r_of_a_com_r)
boolean complete, heading, *fit_gra;
long *g;
t_g_c_list *a, *r, *d_a, *d_r, *d_a_of_r_com_a, *d_r_of_a_com_r;
{
  FILE *TEMP;

  report_sizes(g, fit_gra, a, r, d_a, d_r, d_a_of_r_com_a, d_r_of_a_com_r);
  if (report) {
    page(stdout);
    write_pch(stdout, " D<A>(R): ", 10L);
    write_line(stdout);
    if (d_a == NULL) {
      write_line(stdout);
      write_pch(stdout, " Not found/updated. ", 20L);
      write_line(stdout);
      write_line(stdout);
    } else
      print_g_c_list(d_a);
    write_pch(stdout, " D<R>(A): ", 10L);
    write_line(stdout);
    if (d_r == NULL) {
      write_line(stdout);
      write_pch(stdout, " Not found/updated. ", 20L);
      write_line(stdout);
      write_line(stdout);
    } else
      print_g_c_list(d_r);
    write_line(stdout);
  }
  if (complete) {
    if (!report)
      page(stdout);
    if (heading) {
      write_pch(stdout, " CHOOSE BETWEEN ", 16L);
      write_line(stdout);
      write_line(stdout);
    }
    write_pch(stdout, " 1)  D<A>(R)\\A: ", 16L);
    write_line(stdout);
    print_g_c_list(d_a_of_r_com_a);
    write_pch(stdout, " 2)  D<R>(A)\\R: ", 16L);
    write_line(stdout);
    print_g_c_list(d_r_of_a_com_r);
    write_line(stdout);
  }
  TEMP = stdout;
  flush_file(&TEMP);
  flush_file(&diary_file);
}  /* print_duals */


/*@+"ehinit.p"*/

/*

2135:    +++  ++
2136:    +++  ++
2137:    ---  -- p/ehinit.p         38     130    1951 p/ehinit.p
2138: |    4:    procedure dispose_duals
2139: |   10:    procedure dispose_classes
2140: |   16:    procedure dispose_duals_and_models
2141: |   24:    procedure read_main_effects_arguments
2142: |   31:    procedure proc_set_main_effects
2143: |   49:    procedure init_graphical_search
2144: |   71:    procedure find_duals
2145: |   83:    procedure insert_base_model
2146: |  145:    procedure search_base
2147: |  157:    function to_update_fix_in_or_out
2148: |  189:    procedure do_fix_out
2149: |  220:    procedure do_fix_in
2150: |  260:    procedure fix_out_argument
2151: |  271:    procedure proc_set_fix_out
2152: |  291:    procedure redo_fix_out
2153: |  299:    procedure add_fix_out_argument
2154: |  314:    procedure proc_add_fix_out
2155: |  334:    procedure fix_in_argument
2156: |  345:    procedure proc_set_fix_in
2157: |  365:    procedure redo_fix_in
2158: |  373:    procedure add_fix_in_argument
2159: |  388:    procedure proc_add_fix_in
2160: |  408:    procedure add_models_to_accepted
2161: |  433:    procedure add_models_to_rejected
2162: |  458:    procedure add_a_dual_to_accepted
2163: |  468:    procedure add_r_dual_to_rejected
2164: |  478:    procedure proc_set_accepted_models
2165: |  505:    procedure proc_set_rejected_models
2166: |  532:    procedure proc_set_start_models
2167: |  564:    procedure set_search_class
2168: |  576:    procedure end_search
2169: |  606:    procedure start_search
2170: |  651:    procedure proc_extract_models
2171: |  682:    procedure enter_accepted_models
2172: |  692:    procedure enter_rejected_models
2173: |  702:    procedure enter_start_models
2174: |  717:    procedure proc_export_one
2175: |  742:    procedure proc_export_interval
2176:    +++  ++
2177:    +++  ++

*/

Static Void dispose_duals()
{
  dispose_g_c_list(&link_eh_pack->d_r);
  dispose_g_c_list(&link_eh_pack->d_a);
}  /* dispose_duals */


Static Void dispose_classes()
{
  dispose_g_c_list(&link_eh_pack->a);
  dispose_g_c_list(&link_eh_pack->r);
}  /* dispose_classes */


Static Void dispose_duals_and_models()
{
  dispose_g_c_list(&link_eh_pack->d_r);
  dispose_g_c_list(&link_eh_pack->d_a);
  dispose_g_c_list(&link_eh_pack->a);
  dispose_g_c_list(&link_eh_pack->r);
}  /* dispose_duals_and_models */


Static Void read_main_effects_arguments(a)
long *a;
{
  dispose_duals_and_models();
  P_setcpy(link_eh_pack->g, a);
  short_print_do_exclude(link_eh_pack->g);
}  /* read_main_effects_arguments */


Static Void proc_set_main_effects(command_file, as_argument, ifail, sub_code,
				  arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex_set a;
  t_long_integer i = PCH_START;

  P_setcpy(a, link_eh_pack->g);
  if (get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		     sub_code, arg_pos, nargs, arg_char, " SET->", 6L, a,
		     a) && *sub_code != -1)
    read_main_effects_arguments(a);
}  /* proc_set_main_effects */


Static Void init_graphical_search()
{
  t_set_list *m = NULL;
  t_vertex v;
  t_vertex_set b;

  note_mixed(stdout, " InitGraphicalSearch", 20L);
  dispose_duals_and_models();
  link_eh_pack->graphical_search = true;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, link_eh_pack->g)) {
      P_addset(P_expset(b, 0L), v);   /* empty_set + */
      insert_set_in_set_list(b, &m);
    }
  }
  insert_maximal(&m, &link_eh_pack->r);
  m = NULL;
  insert_set_in_set_list(link_eh_pack->g, &m);
  insert_minimal(&m, &link_eh_pack->a);
}  /* init_graphical_search */


Static Void find_duals()
{
  write_line(stdout);
  print_models(true);
  if (link_eh_pack->d_a == NULL)
    find_a_dual(link_eh_pack->g, &link_eh_pack->graphical_search,
		link_eh_pack->r, &link_eh_pack->d_a);
  if (link_eh_pack->d_r == NULL)
    find_r_dual(link_eh_pack->g, &link_eh_pack->graphical_search,
		link_eh_pack->a, &link_eh_pack->d_r);
}  /* find_duals */


Static Void insert_base_model(g_c, causal__structure, hm)
t_set_list **g_c, **causal__structure;
boolean *hm;
{
  t_vertex_set g_local;
  t_set_list *tmp_p;
  boolean dummy_ok;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " InsertBaseModel", sizeof(pch20));
  ntr(tzt, 13L, 2145L, 1L, -1L, 1L);
  /*$endif TRACE*/
  if (mixed_data)
    note_mixed(stdout, tzt, 16L);
  if (link_eh_pack->link_base != NULL)
    dispose_model(&link_eh_pack->link_base->model);
  else {
    link_eh_pack->link_base = (t_model_list *)Malloc(sizeof(t_model_list));
    if (link_eh_pack->link_base == NULL)
      _OutMem();
    new_model(&link_eh_pack->link_base->model);
    link_eh_pack->link_base->pointer = NULL;
  }

  WITH = link_eh_pack->link_base->model;

  P_setcpy(g_local, empty_set);
  add_union_of_gc(*g_c, g_local);   /* HomMode */
  sub_insert_g_c_in_model(g_c, g_local, causal__structure, false, *hm, false,
			  &link_eh_pack->link_base->model);

  /*$ifdef TRACE*/
  ntr(tzt, 13L, 2145L, 2L, -1L, 3L);
  /*$endif TRACE*/
  identify_model(&link_eh_pack->link_base->model);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 2145L, 3L, -1L, 4L);
  /*$endif TRACE*/
  dummy_ok = ok_model_to_test(&link_eh_pack->link_base->model);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 2145L, 4L, -1L, 5L);
  /*$endif TRACE*/
  link_eh_pack->fix_out = true;
  P_setcpy(link_eh_pack->g, WITH->id->vertices);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 2145L, 5L, -1L, 14L);
  /*$endif TRACE*/
  short_print_do_exclude(link_eh_pack->g);
  dispose_set_list(&link_eh_pack->fix_out_gc);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 2145L, 5L, -1L, 15L);
  /*$endif TRACE*/
  normal_to_dual(*g_c, link_eh_pack->g, &link_eh_pack->fix_out_gc);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 2145L, 5L, -1L, 16L);
  /*$endif TRACE*/
  if (link_eh_pack->fix_in) {
    if (!test_sub_g_c(link_eh_pack->fix_in_gc, *g_c)) {
      /*$ifdef TRACE*/
      ntr(tzt, 13L, 2145L, 6L, 2L, 1L);
      /*$endif TRACE*/
      write_pch(stdout, " FixIn not sub GC of BaseModel.", 31L);
      write_line(stdout);
      find_g_c_intersection_maximal(link_eh_pack->fix_in_gc, g_c, &tmp_p);
      dispose_set_list(&link_eh_pack->fix_in_gc);
      link_eh_pack->fix_in_gc = tmp_p;
      hypergraph_sets_to_graph_sets(link_eh_pack->fix_in_gc, g_local,
				    link_eh_pack->fix_in_adj_set);
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 2145L, 7L, -1L, 17L);
  /*$endif TRACE*/
  first_order_to_graph_sets(link_eh_pack->fix_out_gc,
			    link_eh_pack->fix_out_adj_set);
  /*$ifdef TRACE*/
  ntr(tzt, 13L, 2145L, 8L, -1L, 18L);
  /*$endif TRACE*/
  print_base_fix_out_fix_in();
  write_pch(stdout, " Base model read", 16L);
  dispose_g_c_copy_for_mixed_model(&link_eh_pack->link_base->model, g_c);
}  /* insert_base_model */


Static Void search_base()
{
  t_set_list *g_c;

  if (!current())
    return;
  g_c = return_g_c_copy_for_mixed_model(&link_current->model);
  if (g_c != NULL)
    insert_base_model(&g_c, &link_current->model->id->causal_structure,
		      &link_current->model->id->UU.U1.homogeneous);
  dispose_g_c_copy_for_mixed_model(&link_current->model, &g_c);
}  /* search_base */


Static boolean to_update_fix_in_or_out()
{
  t_set_list *p, *q;
  boolean to_update = false;

  p = link_eh_pack->fix_out_gc;
  while (p != NULL) {
    q = link_eh_pack->fix_in_gc;
    while (q != NULL) {
      if (P_subset(p->vertex_set, q->vertex_set)) {
	if (!to_update) {
	  write_line_diary();
	  write_pch(stdout, " FixOut Edges subset of FixIn edges.", 36L);
	  write_line(stdout);
	}
	to_update = true;
	write_pch(stdout, " FixIn:   ", 10L);
	print_vertex_set_table(q->vertex_set);
	write_line(stdout);
	write_pch(stdout, " FixOut:  ", 10L);
	print_vertex_set_table(p->vertex_set);
	write_line(stdout);
      }
      q = q->pointer;
    }
    p = p->pointer;
  }
  return to_update;
}  /* to_update_fix_in_or_out */


Static Void do_fix_out()
{
  t_set_list *alt_rep, *tmp_p, *g_c;

  link_eh_pack->fix_out = true;
  if (link_eh_pack->link_base != NULL) {
    dual_to_normal(link_eh_pack->fix_out_gc, link_eh_pack->g, &alt_rep);
    g_c = return_g_c_copy_for_mixed_model(&link_eh_pack->link_base->model);
    find_g_c_intersection_maximal(g_c, &alt_rep, &tmp_p);
    dispose_g_c_copy_for_mixed_model(&link_eh_pack->link_base->model, &g_c);
    dispose_set_list(&alt_rep);
    dispose_set_list(&link_eh_pack->fix_out_gc);
    normal_to_dual(tmp_p, link_eh_pack->g, &link_eh_pack->fix_out_gc);
    dispose_set_list(&tmp_p);
  }
  if (link_eh_pack->fix_in) {
    if (!is_empty_g_c(&link_eh_pack->fix_out_gc)) {
      if (to_update_fix_in_or_out()) {
	dual_to_normal(link_eh_pack->fix_out_gc, link_eh_pack->g, &alt_rep);
	find_g_c_intersection_maximal(link_eh_pack->fix_in_gc, &alt_rep,
				      &tmp_p);
	dispose_set_list(&alt_rep);
	dispose_set_list(&link_eh_pack->fix_in_gc);
	link_eh_pack->fix_in_gc = tmp_p;
      }
    }
  }
  first_order_to_graph_sets(link_eh_pack->fix_out_gc,
			    link_eh_pack->fix_out_adj_set);
}  /* do_fix_out */


Static Void do_fix_in()
{
  t_set_list *alt_rep, *tmp_p;
  t_vertex_set g_local;
  t_set_list *g_c;

  if (link_eh_pack->fix_out) {
    if (!is_empty_g_c(&link_eh_pack->fix_out_gc)) {
      if (to_update_fix_in_or_out()) {
	dual_to_normal(link_eh_pack->fix_out_gc, link_eh_pack->g, &alt_rep);
	add_set_list_maximal(link_eh_pack->fix_in_gc, &alt_rep);
	dispose_set_list(&link_eh_pack->fix_out_gc);
	normal_to_dual(alt_rep, link_eh_pack->g, &link_eh_pack->fix_out_gc);
	dispose_set_list(&alt_rep);
      }
    }
  }
  if (link_eh_pack->link_base != NULL) {
    g_c = return_g_c_copy_for_mixed_model(&link_eh_pack->link_base->model);
    if (!test_sub_g_c(link_eh_pack->fix_in_gc, g_c)) {
      write_pch(stdout, " FixIn not sub GC of BaseModel.", 31L);
      write_line(stdout);
      find_g_c_intersection_maximal(link_eh_pack->fix_in_gc, &g_c, &tmp_p);
      copy_set_list(g_c, &alt_rep);
      add_set_list_maximal(link_eh_pack->fix_in_gc, &alt_rep);
      write_pch(stdout, " Alternative BaseModel:", 23L);
      print_g_c(alt_rep, 1L, line_length);
      write_line(stdout);
      dispose_set_list(&alt_rep);
      dispose_set_list(&link_eh_pack->fix_in_gc);
      link_eh_pack->fix_in_gc = tmp_p;
    }
    dispose_g_c_copy_for_mixed_model(&link_eh_pack->link_base->model, &g_c);
  }
  hypergraph_sets_to_graph_sets(link_eh_pack->fix_in_gc, g_local,
				link_eh_pack->fix_in_adj_set);
}  /* do_fix_in */


Static Void fix_out_argument(p)
t_set_list **p;
{
  link_eh_pack->fix_out = true;
  dispose_set_list(&link_eh_pack->fix_out_gc);
  dispose_set_list(&link_eh_pack->fix_out_gc_x);
  link_eh_pack->fix_out_gc = *p;
  copy_set_list(link_eh_pack->fix_out_gc, &link_eh_pack->fix_out_gc_x);
  do_fix_out();
  print_base_fix_out_fix_in();
}  /* fix_out_argument */


Static Void proc_set_fix_out(command_file, as_argument, ifail, sub_code,
			     arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_set_list *p = NULL;
  t_long_integer i = PCH_START;

  if (get_gc(command_file, true, true, false, as_argument, &i, ifail,
	     sub_code, arg_pos, nargs, arg_char, &link_eh_pack->fix_out_gc,
	     &p) && *sub_code != -1)
	/* ' GC->@@@@@', 5, */
	  fix_out_argument(&p);
  else if (*sub_code != -1)
    print_base_fix_out_fix_in();
}  /* proc_set_fix_out */


Static Void redo_fix_out()
{
  dispose_set_list(&link_eh_pack->fix_out_gc);
  copy_set_list(link_eh_pack->fix_out_gc_x, &link_eh_pack->fix_out_gc);
  do_fix_out();
  print_base_fix_out_fix_in();
}  /* redo_fix_out */


Static Void add_fix_out_argument(p)
t_set_list **p;
{
  t_set_list *q;

  q = *p;
  while (q != NULL) {
    insert_set_minimal((*p)->vertex_set, &link_eh_pack->fix_out_gc);
    insert_set_minimal((*p)->vertex_set, &link_eh_pack->fix_out_gc_x);
    q = q->pointer;
  }
  dispose_set_list(p);
  do_fix_out();
  print_base_fix_out_fix_in();
}  /* add_fix_out_argument */


Static Void proc_add_fix_out(command_file, as_argument, ifail, sub_code,
			     arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_set_list *p = NULL;
  t_long_integer i = PCH_START;

  if (get_gc(command_file, true, true, false, as_argument, &i, ifail,
	     sub_code, arg_pos, nargs, arg_char, &link_eh_pack->fix_out_gc_x,
	     &p) && *sub_code != -1)
	/* ' GC->@@@@@', 5, */
	  add_fix_out_argument(&p);
  else if (*sub_code != -1)
    print_base_fix_out_fix_in();
}  /* proc_add_fix_out */


Static Void fix_in_argument(p)
t_set_list **p;
{
  link_eh_pack->fix_in = true;
  dispose_set_list(&link_eh_pack->fix_in_gc);
  dispose_set_list(&link_eh_pack->fix_in_gc_x);
  link_eh_pack->fix_in_gc = *p;
  copy_set_list(link_eh_pack->fix_in_gc, &link_eh_pack->fix_in_gc_x);
  do_fix_in();
  print_base_fix_out_fix_in();
}  /* fix_in_argument */


Static Void proc_set_fix_in(command_file, as_argument, ifail, sub_code,
			    arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_set_list *p = NULL;
  t_long_integer i = PCH_START;

  if (get_gc(command_file, true, true, false, as_argument, &i, ifail,
	     sub_code, arg_pos, nargs, arg_char, &link_eh_pack->fix_in_gc,
	     &p) && *sub_code != -1)
	/* ' GC->@@@@@', 5, */
	  fix_in_argument(&p);
  else if (*sub_code != -1)
    print_base_fix_out_fix_in();
}  /* proc_set_fix_in */


Static Void redo_fix_in()
{
  dispose_set_list(&link_eh_pack->fix_in_gc);
  copy_set_list(link_eh_pack->fix_in_gc_x, &link_eh_pack->fix_in_gc);
  do_fix_in();
  print_base_fix_out_fix_in();
}  /* redo_fix_in */


Static Void add_fix_in_argument(p)
t_set_list **p;
{
  t_set_list *q;

  q = *p;
  while (q != NULL) {
    insert_clique((*p)->vertex_set, &link_eh_pack->fix_in_gc);
    insert_clique((*p)->vertex_set, &link_eh_pack->fix_in_gc_x);
    q = q->pointer;
  }
  dispose_set_list(p);
  do_fix_in();
  print_base_fix_out_fix_in();
}  /* add_fix_in_argument */


Static Void proc_add_fix_in(command_file, as_argument, ifail, sub_code,
			    arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_set_list *p = NULL;
  t_long_integer i = PCH_START;

  if (get_gc(command_file, true, true, false, as_argument, &i, ifail,
	     sub_code, arg_pos, nargs, arg_char, &link_eh_pack->fix_in_gc_x,
	     &p) && *sub_code != -1)
	/* ' GC->@@@@@', 5, */
	  add_fix_in_argument(&p);
  else if (*sub_code != -1)
    print_base_fix_out_fix_in();
}  /* proc_add_fix_in */


Static Void add_models_to_accepted(s, copy, a, d_r)
t_g_c_list *s;
boolean copy;
t_g_c_list **a, **d_r;
{
  t_g_c_list *p;
  t_set_list *g_c;

  while (s != NULL) {
    if (!is_empty_g_c(&s->g_c)) {
      if (copy) {
	copy_set_list(s->g_c, &g_c);
	insert_minimal(&g_c, a);
      } else {
	insert_minimal(&s->g_c, a);
	s->g_c = NULL;
      }
    }
    p = s;
    s = s->pointer;
    if (!copy)
      _Free(p);
  }
  find_r_dual(link_eh_pack->g, &link_eh_pack->graphical_search, *a, d_r);
}  /* add_models_to_accepted */


Static Void add_models_to_rejected(s, copy, r, d_a)
t_g_c_list *s;
boolean copy;
t_g_c_list **r, **d_a;
{
  t_g_c_list *p;
  t_set_list *g_c;

  while (s != NULL) {
    if (!is_empty_g_c(&s->g_c)) {
      if (copy) {
	copy_set_list(s->g_c, &g_c);
	insert_maximal(&g_c, r);
      } else {
	insert_maximal(&s->g_c, r);
	s->g_c = NULL;
      }
    }
    p = s;
    s = s->pointer;
    if (!copy)
      _Free(p);
  }
  find_a_dual(link_eh_pack->g, &link_eh_pack->graphical_search, *r, d_a);
}  /* add_models_to_rejected */


Static Void add_a_dual_to_accepted(a, d_r)
t_g_c_list **a, **d_r;
{
  t_g_c_list *s = NULL;

  find_a_dual(link_eh_pack->g, &link_eh_pack->graphical_search, *a, &s);
  add_models_to_accepted(s, false, a, d_r);
}  /* add_a_dual_to_accepted */


Static Void add_r_dual_to_rejected(r, d_a)
t_g_c_list **r, **d_a;
{
  t_g_c_list *s = NULL;

  find_r_dual(link_eh_pack->g, &link_eh_pack->graphical_search, *r, &s);
  add_models_to_rejected(s, false, r, d_a);
}  /* add_r_dual_to_rejected */


Static Void proc_set_accepted_models(command_file, as_argument, ifail,
				     sub_code, arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_g_c_list *s = NULL;
  t_long_integer i = PCH_START;

  if (!(get_gc_list(command_file, true, true, false, as_argument, &i, ifail,
		    sub_code, arg_pos, nargs, arg_char, &link_eh_pack->a,
		    &s) && *sub_code != -1))
	/* ' Models->@', 9, */
	  return;
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " Read models: ", 14L);
  write_line(stdout);
  print_g_c_list(s);
  write_line(stdout);
  add_models_to_accepted(s, false, &link_eh_pack->a, &link_eh_pack->d_r);
  print_models(true);
}  /* proc_set_accepted_models */


Static Void proc_set_rejected_models(command_file, as_argument, ifail,
				     sub_code, arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_g_c_list *s = NULL;
  t_long_integer i = PCH_START;

  if (!(get_gc_list(command_file, true, true, false, as_argument, &i, ifail,
		    sub_code, arg_pos, nargs, arg_char, &link_eh_pack->r,
		    &s) && *sub_code != -1))
	/* ' Models->@', 9, */
	  return;
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " Read models: ", 14L);
  write_line(stdout);
  print_g_c_list(s);
  write_line(stdout);
  add_models_to_rejected(s, false, &link_eh_pack->r, &link_eh_pack->d_a);
  print_models(true);
}  /* proc_set_rejected_models */


Static Void proc_set_start_models(command_file, as_argument, ifail, sub_code,
				  arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_g_c_list *s = NULL;
  t_long_integer i = PCH_START, acc = 0, rej = 0;

  if (!get_gc_list(command_file, true, true, false, as_argument, &i, ifail,
		   sub_code, arg_pos, nargs, arg_char, &s, &s))
	/* ' Models->@', 9, */
	  return;
  write_line(stdout);
  page(stdout);
  write_pch(stdout, " Initial set: ", 14L);
  write_line(stdout);
  print_g_c_list(s);
  write_line(stdout);
  fit(&alfa_, link_eh_pack->g, &link_eh_pack->graphical_search, false, &s,
      &link_eh_pack->a, &link_eh_pack->r, &link_eh_pack->d_a,
      &link_eh_pack->d_r, false, false, &acc, &rej);
  dispose_g_c_list(&s);
  print_models(true);
}  /* proc_set_start_models */


Static Void set_search_class(code)
t_integer *code;
{
  if (*code <= 9)
    return;
  decomposable_mode = (*code / 10 == 1);
  if (link_eh_pack->graphical_search == (*code / 10 != 3))
    return;
  link_eh_pack->graphical_search = (*code / 10 != 3);
  dispose_duals();
  find_duals();
}  /* set_search_class */


Static Void end_search(link_eh_pack)
t_eh_pack **link_eh_pack;
{
  t_eh_pack *WITH;

  if (*link_eh_pack == NULL)
    return;
  WITH = *link_eh_pack;
  if (timer) {
    write_pch(stdout, " Search ", 8L);
    write_pch(stdout, " TIME: ", 7L);
    write_real(stdout, WITH->search_time / 1000, 10L, 3L);
    write_pch(stdout, "secs.", 5L);
    write_line(stdout);
  }
  dispose_duals_and_models();
  dispose_set_list(&WITH->fix_in_gc);
  dispose_set_list(&WITH->fix_out_gc);
  dispose_set_list(&WITH->fix_in_gc_x);
  dispose_set_list(&WITH->fix_out_gc_x);
  dispose_model(&link_full->model);
  _Free(link_full);
  link_full = NULL;
  if (WITH->link_base != NULL) {
    dispose_model(&WITH->link_base->model);
    _Free((*link_eh_pack)->link_base);
    (*link_eh_pack)->link_base = NULL;
  }
  _Free(*link_eh_pack);
  *link_eh_pack = NULL;
  write_pch(stdout, " Search ended", 13L);
  write_line(stdout);
}  /* end_search */


Static Void start_search(link_eh_pack)
t_eh_pack **link_eh_pack;
{
  boolean homogeneous = true;
  boolean dummy_ok;
  t_set_list *cs = NULL, *g_c = NULL;
  t_eh_pack *WITH;

  if (link_base != NULL) {
    cs = link_base->model->id->causal_structure;
    homogeneous = link_base->model->id->UU.U1.homogeneous;
  }
  *link_eh_pack = (t_eh_pack *)Malloc(sizeof(t_eh_pack));
  if (*link_eh_pack == NULL)
    _OutMem();
  WITH = *link_eh_pack;
  WITH->fix_in_gc_x = NULL;
  WITH->fix_out_gc_x = NULL;
  WITH->fix_out_gc = NULL;
  WITH->fix_in_gc = NULL;
  WITH->fix_out = false;
  WITH->fix_in = false;
  WITH->link_base = NULL;
  link_full = (t_model_list *)Malloc(sizeof(t_model_list));
  if (link_full == NULL)
    _OutMem();
  new_model(&link_full->model);
  link_full->pointer = NULL;

  note_mixed(stdout, " StartSearch - 1", 16L);
  if (mixed_data)
    P_setcpy(WITH->g, delta_gamma);
  else
    P_setcpy(WITH->g, delta);
  insert_set_in_set_list(WITH->g, &g_c);   /* HomMode */
  insert_g_c_in_model(&g_c, WITH->g, &cs, false, homogeneous,
		      &link_full->model);

  note_mixed(stdout, " StartSearch - 2", 16L);
  identify_model(&link_full->model);
  note_mixed(stdout, " StartSearch - 3", 16L);
  dummy_ok = ok_model_to_test(&link_full->model);
  note_mixed(stdout, " StartSearch - 4", 16L);
  WITH->a = NULL;
  WITH->r = NULL;
  WITH->d_a = NULL;
  WITH->d_r = NULL;
  WITH->search_opt = 3;
  WITH->search_time = 0.0;
  WITH->graphical_search = true;
  WITH->search_strategy = 1;
}  /* start_search */


Static Void proc_extract_models(code)
t_integer code;
{
  t_g_c_list *p;
  t_set_list *gc, *cs;
  boolean hm;

  switch (code % 10) {

  case 1:
    p = link_eh_pack->a;
    break;

  case 2:
    p = link_eh_pack->r;
    break;

  case 3:
    p = link_eh_pack->d_a;
    break;

  case 4:
    p = link_eh_pack->d_r;
    break;
  }
  while (p != NULL) {
    new_model_in_list(&link_model_list, &first_model_available);
    if (link_eh_pack->link_base != NULL) {
      cs = link_eh_pack->link_base->model->id->causal_structure;
      hm = link_eh_pack->link_base->model->id->UU.U1.homogeneous;
    } else {
      cs = link_full->model->id->causal_structure;
      hm = link_full->model->id->UU.U1.homogeneous;
    }
    copy_set_list(p->g_c, &gc);
    P_setcpy(link_model_list->model->id->vertices, empty_set);
    add_union_of_gc(p->g_c, link_model_list->model->id->vertices);
    insert_g_c_in_model(&gc, link_model_list->model->id->vertices, &cs, false,
			hm, &link_model_list->model);
    p = p->pointer;
  }
}  /* proc_extract_models */


Static Void enter_accepted_models(s)
t_g_c_list **s;
{
  write_pch(stdout, " Initial set: ", 14L);
  write_line(stdout);
  print_g_c_list(*s);
  write_line(stdout);
  add_models_to_accepted(*s, false, &link_eh_pack->a, &link_eh_pack->d_r);
  print_models(true);
}  /* enter_accepted_models */


Static Void enter_rejected_models(s)
t_g_c_list **s;
{
  write_pch(stdout, " Initial set: ", 14L);
  write_line(stdout);
  print_g_c_list(*s);
  write_line(stdout);
  add_models_to_rejected(*s, false, &link_eh_pack->r, &link_eh_pack->d_a);
  print_models(true);
}  /* enter_rejected_models */


Static Void enter_start_models(s)
t_g_c_list **s;
{
  t_long_integer acc, rej;

  write_pch(stdout, " Initial set: ", 14L);
  write_line(stdout);
  print_g_c_list(*s);
  write_line(stdout);
  fit(&alfa_, link_eh_pack->g, &link_eh_pack->graphical_search, false, s,
      &link_eh_pack->a, &link_eh_pack->r, &link_eh_pack->d_a,
      &link_eh_pack->d_r, false, false, &acc, &rej);
  dispose_g_c_list(s);
  print_models(true);
}  /* enter_start_models */


Static Void proc_export_one(base, current, code)
boolean base, current;
t_integer code;
{
  t_model_list *link_model;
  t_g_c_list *s;

  if (current)
    link_model = link_current;
  else if (base)
    link_model = link_base;
  else
    link_model = link_model_list;
  if (link_model == NULL)
    return;
  s = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
  if (s == NULL)
    _OutMem();
  s->pointer = NULL;
  s->g_c = return_g_c_copy(&link_model->model);
  if (code == 0) {
    enter_start_models(&s);
    return;
  }
  if (code == 1)
    enter_accepted_models(&s);
  else
    enter_rejected_models(&s);
}  /* proc_export_one */


Static Void proc_export_interval(command_file, all_, one, code, as_argument,
				 ifail, sub_code, arg_pos, nargs, arg_int)
FILE *command_file;
boolean all_, one;
t_integer code;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_model_list *link_model;
  t_g_c_list *s = NULL;
  t_g_c_list *t;
  t_integer nr1, nr2, i;

  if (!all_) {
    i = 0;
    nr1 = 0;
    nr2 = 0;
    get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		     nargs, arg_int, " Number->", 9L, &nr1);
    if (one)
      nr2 = nr1;
    else
      get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		       arg_pos, nargs, arg_int, " Number->", 9L, &nr2);
  }
  link_model = link_model_list;
  while (link_model != NULL) {
    if ((nr1 <= link_model->model->model_number &&
	 link_model->model->model_number <= nr2) || all_) {
      t = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
      if (t == NULL)
	_OutMem();
      t->pointer = s;
      t->g_c = return_g_c_copy(&link_model->model);
      s = t;
    }
    link_model = link_model->pointer;
  }
  if (s == NULL)
    return;
  if (code == 0) {
    enter_start_models(&s);
    return;
  }
  if (code == 1)
    enter_accepted_models(&s);
  else
    enter_rejected_models(&s);
}  /* proc_export_interval */


/*@+"maineh.p"*/


Static Void search_directed(command_file, alfa_, g, fit_gra, a, r, d_a, d_r)
FILE *command_file;
t_long_real *alfa_;
long *g;
boolean *fit_gra;
t_g_c_list **a, **r, **d_a, **d_r;
{
  t_g_c_list *s, *d_a_of_r_com_a, *d_r_of_a_com_r;
  t_long_integer rej, acc, choice;
  boolean stop = false;

  if (*d_a == NULL)
    find_a_dual(g, fit_gra, *r, d_a);
  if (*d_r == NULL)
    find_r_dual(g, fit_gra, *a, d_r);
  while (!stop) {
    find_d_r_a_com_r(*d_r, *r, &d_r_of_a_com_r);
    find_d_a_r_com_a(*d_a, *a, &d_a_of_r_com_a);
    print_duals(true, true, fit_gra, g, *a, *r, *d_a, *d_r, d_a_of_r_com_a,
		d_r_of_a_com_r);
    read_integer(command_file, " 1/2/3->  ", 8L, &choice);
    if ((unsigned long)choice >= 32 || ((1L << choice) & 0x6) == 0)
      break;
    if (choice == 2)
      s = d_r_of_a_com_r;
    else
      s = d_a_of_r_com_a;
    fit(alfa_, g, fit_gra, true, &s, a, r, d_a, d_r, choice == 1, choice == 2,
	&acc, &rej);
    dispose_g_c_list(&d_r_of_a_com_r);
    dispose_g_c_list(&d_a_of_r_com_a);
    print_models(false);
    stop = (choice == 1 && rej == 0 || choice == 2 && acc == 0);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  }
}  /* search_directed */


Static Void search_auto(alfa_, g, fit_gra, a, r, d_a, d_r)
t_long_real *alfa_;
long *g;
boolean *fit_gra;
t_g_c_list **a, **r, **d_a, **d_r;
{
  t_g_c_list *s, *d_a_of_r_com_a, *d_r_of_a_com_r, *p;
  t_long_integer rej, acc, choice;
  boolean stop = false;
  boolean r_dual;

  if (*d_a == NULL)
    find_a_dual(g, fit_gra, *r, d_a);
  if (*d_r == NULL)
    find_r_dual(g, fit_gra, *a, d_r);
  while (!stop) {
    find_d_r_a_com_r(*d_r, *r, &d_r_of_a_com_r);
    find_d_a_r_com_a(*d_a, *a, &d_a_of_r_com_a);
    choice = 0;
    p = d_r_of_a_com_r;
    while (p != NULL) {
      choice++;
      p = p->pointer;
    }
    p = d_a_of_r_com_a;
    while (p != NULL) {
      choice--;
      p = p->pointer;
    }
    print_duals(true, false, fit_gra, g, *a, *r, *d_a, *d_r, d_a_of_r_com_a,
		d_r_of_a_com_r);
    r_dual = (choice <= 0);
    if (r_dual)
      s = d_r_of_a_com_r;
    else
      s = d_a_of_r_com_a;
    fit(alfa_, g, fit_gra, true, &s, a, r, d_a, d_r, !r_dual, r_dual, &acc,
	&rej);
    dispose_g_c_list(&d_r_of_a_com_r);
    dispose_g_c_list(&d_a_of_r_com_a);
    print_models(false);
    stop = (!r_dual && rej == 0 || r_dual && acc == 0 || interrupt_3);
  }
}  /* search_auto */


Static Void alter_search_auto(alfa_, g, fit_gra, a, r, d_a, d_r)
t_long_real *alfa_;
long *g;
boolean *fit_gra;
t_g_c_list **a, **r, **d_a, **d_r;
{
  t_g_c_list *s, *d_a_of_r_com_a, *d_r_of_a_com_r;
  t_long_integer rej, acc;
  boolean stop = false, a_dual = false;

  while (!stop) {
    if (a_dual) {
      d_r_of_a_com_r = NULL;
      if (*d_a == NULL)
	find_a_dual(g, fit_gra, *r, d_a);
      find_d_a_r_com_a(*d_a, *a, &d_a_of_r_com_a);
      s = d_a_of_r_com_a;
    } else {
      d_a_of_r_com_a = NULL;
      if (*d_r == NULL)
	find_r_dual(g, fit_gra, *a, d_r);
      find_d_r_a_com_r(*d_r, *r, &d_r_of_a_com_r);
      s = d_r_of_a_com_r;
    }
    print_duals(false, false, fit_gra, g, *a, *r, *d_a, *d_r, d_a_of_r_com_a,
		d_r_of_a_com_r);
    fit(alfa_, g, fit_gra, false, &s, a, r, d_a, d_r, a_dual, !a_dual, &acc,
	&rej);
    dispose_g_c_list(&d_r_of_a_com_r);
    dispose_g_c_list(&d_a_of_r_com_a);
    print_models(false);
    stop = (a_dual && rej == 0 || !a_dual && acc == 0 || interrupt_3);
    a_dual = !a_dual;
  }
}  /* alter_search_auto */


Static Void rough_search_auto(alfa_, g, fit_gra, a, r, d_a, d_r)
t_long_real *alfa_;
long *g;
boolean *fit_gra;
t_g_c_list **a, **r, **d_a, **d_r;
{
  t_g_c_list *s, *d_a_of_r_com_a, *d_r_of_a_com_r;
  t_long_integer rej, acc;
  boolean stop = false;
  boolean a_dual;

  while (!stop) {
    a_dual = (log_a_dual(g, fit_gra, *r) < log_r_dual(g, fit_gra, *a));
    if (a_dual) {
      d_r_of_a_com_r = NULL;
      if (*d_a == NULL)
	find_a_dual(g, fit_gra, *r, d_a);
      find_d_a_r_com_a(*d_a, *a, &d_a_of_r_com_a);
      s = d_a_of_r_com_a;
    } else {
      d_a_of_r_com_a = NULL;
      if (*d_r == NULL)
	find_r_dual(g, fit_gra, *a, d_r);
      find_d_r_a_com_r(*d_r, *r, &d_r_of_a_com_r);
      s = d_r_of_a_com_r;
    }
    print_duals(false, false, fit_gra, g, *a, *r, *d_a, *d_r, d_a_of_r_com_a,
		d_r_of_a_com_r);
    fit(alfa_, g, fit_gra, false, &s, a, r, d_a, d_r, a_dual, !a_dual, &acc,
	&rej);
    dispose_g_c_list(&d_r_of_a_com_r);
    dispose_g_c_list(&d_a_of_r_com_a);
    print_models(false);
    stop = (a_dual && rej == 0 || !a_dual && acc == 0 || interrupt_3);
  }
}  /* rough_search_auto */


Static Void proc_search(code)
t_long_integer *code;
{
  t_eh_pack *WITH;

  set_search_class(code);
  if (*code % 10 != 5)
    link_eh_pack->search_strategy = *code % 10;
  WITH = link_eh_pack;
  switch (WITH->search_strategy) {

  case 1:
    search_auto(&alfa_, WITH->g, &WITH->graphical_search, &WITH->a, &WITH->r,
		&WITH->d_a, &WITH->d_r);
    break;

  case 2:
    alter_search_auto(&alfa_, WITH->g, &WITH->graphical_search, &WITH->a,
		      &WITH->r, &WITH->d_a, &WITH->d_r);
    break;

  case 3:
    rough_search_auto(&alfa_, WITH->g, &WITH->graphical_search, &WITH->a,
		      &WITH->r, &WITH->d_a, &WITH->d_r);
    break;
  }
}  /* proc_search */


Static Void fit_size(smallest, alfa_, g, fit_gra, a, r, d_a, d_r)
boolean smallest;
t_long_real *alfa_;
long *g;
boolean *fit_gra;
t_g_c_list **a, **r, **d_a, **d_r;
{
  t_g_c_list *s, *d_a_of_r_com_a, *d_r_of_a_com_r, *p;
  t_long_integer rej, acc;
  t_long_integer choice = 0;
  boolean r_dual;

  if (*d_a == NULL)
    find_a_dual(g, fit_gra, *r, d_a);
  if (*d_r == NULL)
    find_r_dual(g, fit_gra, *a, d_r);
  find_d_r_a_com_r(*d_r, *r, &d_r_of_a_com_r);
  find_d_a_r_com_a(*d_a, *a, &d_a_of_r_com_a);
  p = d_r_of_a_com_r;
  while (p != NULL) {
    choice++;
    p = p->pointer;
  }
  p = d_a_of_r_com_a;
  while (p != NULL) {
    choice--;
    p = p->pointer;
  }
  print_duals(true, false, fit_gra, g, *a, *r, *d_a, *d_r, d_a_of_r_com_a,
	      d_r_of_a_com_r);
  r_dual = (choice <= 0 && smallest || choice >= 0 && !smallest);
  if (r_dual)
    s = d_r_of_a_com_r;
  else
    s = d_a_of_r_com_a;
  fit(alfa_, g, fit_gra, false, &s, a, r, d_a, d_r, !r_dual, r_dual, &acc,
      &rej);
  dispose_g_c_list(&d_r_of_a_com_r);
  dispose_g_c_list(&d_a_of_r_com_a);
  print_models(false);
}  /* fit_size */


Static Void fit_a_dual(alfa_, g, fit_gra, a, r, d_a, d_r)
t_long_real *alfa_;
long *g;
boolean *fit_gra;
t_g_c_list **a, **r, **d_a, **d_r;
{
  t_g_c_list *d_a_of_r_com_a;
  t_long_integer rej, acc;

  if (*d_a == NULL)
    find_a_dual(g, fit_gra, *r, d_a);
  find_d_a_r_com_a(*d_a, *a, &d_a_of_r_com_a);
  fit(alfa_, g, fit_gra, false, &d_a_of_r_com_a, a, r, d_a, d_r, true, false,
      &acc, &rej);
  dispose_g_c_list(&d_a_of_r_com_a);
  print_models(false);
}  /* fit_a_dual */


Static Void fit_r_dual(alfa_, g, fit_gra, a, r, d_a, d_r)
t_long_real *alfa_;
long *g;
boolean *fit_gra;
t_g_c_list **a, **r, **d_a, **d_r;
{
  t_g_c_list *d_r_of_a_com_r;
  t_long_integer rej, acc;

  if (*d_r == NULL)
    find_r_dual(g, fit_gra, *a, d_r);
  find_d_r_a_com_r(*d_r, *r, &d_r_of_a_com_r);
  fit(alfa_, g, fit_gra, false, &d_r_of_a_com_r, a, r, d_a, d_r, false, true,
      &acc, &rej);
  dispose_g_c_list(&d_r_of_a_com_r);
  print_models(false);
}  /* fit_r_dual */


Static Void fit_both(alfa_, g, fit_gra, a, r, d_a, d_r)
t_long_real *alfa_;
long *g;
boolean *fit_gra;
t_g_c_list **a, **r, **d_a, **d_r;
{
  t_g_c_list *d_a_of_r_com_a, *d_r_of_a_com_r;
  t_long_integer rej, acc;

  if (*d_a == NULL)
    find_a_dual(g, fit_gra, *r, d_a);
  find_d_a_r_com_a(*d_a, *a, &d_a_of_r_com_a);
  if (*d_r == NULL)
    find_r_dual(g, fit_gra, *a, d_r);
  find_d_r_a_com_r(*d_r, *r, &d_r_of_a_com_r);
  fit(alfa_, g, fit_gra, false, &d_a_of_r_com_a, a, r, d_a, d_r, true, false,
      &acc, &rej);
  fit(alfa_, g, fit_gra, false, &d_r_of_a_com_r, a, r, d_a, d_r, false, true,
      &acc, &rej);
  dispose_g_c_list(&d_a_of_r_com_a);
  dispose_g_c_list(&d_r_of_a_com_r);
  print_models(false);
}  /* fit_both */


/*@-"describe.c"*/
/*@+"findghk.p"*/


/*

2192:    +++  ++
2193:    +++  ++
2194:    ---  -- p/findghk.p         10      51     599 p/findghk.p
2195: |    3:    procedure new_ghk_workspace
2196: |   19:    procedure add_hk
2197: |  174:    procedure sub_sub_do_add_hk
2198: |  202:    procedure sub_do_add_hk
2199: |  240:    procedure do_add_hk
2200: |  253:    function find_homogene_ssd_inverse
2201: |  338:    function sub_sub_do_find_ssd
2202: |  411:    function sub_do_find_ssd
2203: |  450:    function do_find_ssd
2204: |  458:    function find_ghk_for_model
2205:    +++  ++
2206:    +++  ++

*/

Static Void new_ghk_workspace(m_ips_leaf)
t_mips_element **m_ips_leaf;
{
  t_find_ghk_element *p;

  p = (t_find_ghk_element *)Malloc(sizeof(t_find_ghk_element));
  if (p == NULL)
    _OutMem();
  p->r_upper_offset = -1;
  p->r_upper = NULL;
  p->r_lower_offset = -1;
  p->r_lower = NULL;
  p->k_upper_offset = -1;
  p->k_upper = NULL;
  p->k_lower_offset = -1;
  p->k_lower = NULL;
  (*m_ips_leaf)->ghk_work = p;
}  /* new_ghk_workspace */


Static Void add_hk(a, d, c, homogeneous, r_total, r_total_offset, r_marginal,
		   r_marginal_offset, ssd_inverse, ssd_inverse_offset, r_p,
		   r_p_offset, m, m1, m2, factor)
long *a, *d, *c;
boolean homogeneous;
t_t_r **r_total;
t_t_offset *r_total_offset;
t_t_r **r_marginal;
t_t_offset *r_marginal_offset;
t_t_r **ssd_inverse;
t_t_offset *ssd_inverse_offset;
t_t_r **r_p;
t_t_offset *r_p_offset;
t_integer *m, *m1, *m2, factor;
{
  boolean ok;
  t_integer m_i = 0;
  t_integer m1_, m2_, i, j, k, l, index, m_index, t_index, t_index_, n_index;
  t_vertex v, w;
  t_offset n_a_offset, n_offset;
  t_fast_next_offset_pack d_in_a;
  t_cell cell;
  t_vertex_set a_continuous, a_discrete, b;
  /*$ifdef TRACE*/
  pch20 tzt;
  long FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " AddHK              ", sizeof(pch20));
  ntr_3_sets(tzt, 20L, 2196L, 1L, 1L, 1L, a, d, c);
  /*$endif TRACE*/
  P_setint(a_discrete, a, delta);
  if (em)
    write_warning_em(stdout, 2196L, " AddHK              ");
  n_a_offset = return_offset(a_discrete, &ok);
  P_setint(a_continuous, a, gamma_);
  return_ghk_size(c, &m1_, &m2_);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2196L, 1L)) {
    write_line(stdout);
    write_char(stdout, ':');
    print_vertex_set(a);
    print_vertex_set(a_discrete);
    print_vertex_set(c);
    print_vertex_set(d);
    write_integer(stdout, *m1, 3L);
    write_integer(stdout, *m2, 3L);
    write_integer(stdout, m1_, 3L);
    write_integer(stdout, m2_, 3L);
    write_integer(stdout, *r_total_offset, 5L);
    write_integer(stdout, *r_marginal_offset, 5L);
    write_integer(stdout, *ssd_inverse_offset, 5L);
    write_integer(stdout, *r_p_offset, 5L);
    write_integer(stdout, factor, 5L);
    write_line(stdout);
    write_headed_ssd_t(" Old table@@@@@@@@@@                    ", 10L, a,
		       n_a_offset, *r_total_offset, r_total, *m1, *m2, NULL,
		       false, 2L, false);
    P_setunion(b, c, d);
    write_char(stdout, ' ');
    print_vertex_set(b);
    write_line(stdout);
    write_headed_ssd_t(" Marginal table@@@@@                    ", 15L, b,
		       -1L, *r_marginal_offset, r_marginal, m1_, m2_, NULL,
		       false, 2L, false);
    if (homogeneous)
      write_headed_ssd_t(" Ssd inverse   @@@@@                    ", 15L, b,
			 -1L, *ssd_inverse_offset, ssd_inverse, m1_, m2_,
			 NULL, false, 2L, false);
  }
  /*$endif TRACE*/
  fast_find_products(a_discrete, d, &d_in_a);
  n_offset = return_offset(d, &ok);
  memcpy(cell, first_cell, sizeof(t_cell));
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2196L, 1L))
    write_line(stdout);
  FORLIM = *m;
  /*$endif TRACE*/
  for (index = 0; index < FORLIM; index++) {
    n_index = *r_p_offset + index;
    /*$ifdef TRACE-ARRAY*/
    if (factor > 0)   /* ntr */
      ntr_t_upd(r_p, r_p_offset, n_index, (double)n[n_offset + m_i], 3L,
		" AddHK              ", 20L, 2106L, 1L);
    else
      ntr_t_upd(r_p, r_p_offset, n_index, (double)n[n_offset + m_i], -3L,
		" AddHK              ", 20L, 2106L, 1L);
    /* ntr */
    /*$endif TRACE-ARRAY*/
    if (factor > 0)
      (*r_p)->z[n_index] *= n[n_offset + m_i];
    else
      (*r_p)->z[n_index] /= n[n_offset + m_i];
    k = 0;
    l = 0;
    t_index = *r_total_offset + *m2 * index;
    if (homogeneous)
      m_index = *r_marginal_offset + m1_ * m_i;
    else
      m_index = *r_marginal_offset + m2_ * m_i;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 2196L, 1L)) {
      write_pch(stdout, " Add hK:  ", 10L);
      write_integer(stdout, index, 3L);
      write_integer(stdout, m_i, 3L);
      write_integer(stdout, t_index, 3L);
      write_integer(stdout, m_index, 3L);
    }
    /*$endif TRACE*/
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, a_continuous)) {
	if (P_inset(v, c)) {
	  i = k;
	  j = l;
	  for (w = v; w <= last_vertex; w++) {
	    if (P_inset(w, a_continuous)) {
	      if (P_inset(w, c)) {
		t_index_ = t_index + *m1 + sm_index(i, k, *m1);
		if (homogeneous) {   /* ntr */
		  ntr_t_ref(ssd_inverse, ssd_inverse_offset,
			    *ssd_inverse_offset + sm_index(j, l, m1_),
			    " AddHK              ", 20L, 2106L, 1L);
		      /* ntr */
		  /* ntr */
		  /* ntr */
		  ntr_t_upd(r_total,
			    r_total_offset, t_index, factor * (*ssd_inverse)->
				z[*ssd_inverse_offset + sm_index(j, l, m1_)],
			    1L, " AddHK              ", 20L, 2106L, 1L);
		      /* ntr */
		  /*$endif TRACE-ARRAY*/
		  (*r_total)->z[t_index_] += factor *
		      (*ssd_inverse)->z[*ssd_inverse_offset + sm_index(j, l, m1_)];
		}
		/*$ifdef TRACE-ARRAY*/
		else {   /* ntr */
		  ntr_t_ref(r_marginal, r_marginal_offset,
			    m_index + m1_ + sm_index(j, l, m1_),
			    " AddHK              ", 20L, 2106L, 1L);
		      /* ntr */
		  /* ntr */
		  /* ntr */
		  ntr_t_upd(r_total, r_total_offset, t_index,
		    factor * (*r_marginal)->z[m_index + m1_ + sm_index(j, l, m1_)],
		    1L, " AddHK              ", 20L, 2106L, 1L);
		  /*$endif TRACE-ARRAY*/
		  (*r_total)->z[t_index_] += factor *
		      (*r_marginal)->z[m_index + m1_ + sm_index(j, l, m1_)];
		}
		/*$ifdef TRACE-ARRAY*/
		/* ntr */
		/*$ifdef TRACE*/
		if (trace_flag_set(20L, 2196L, 1L)) {
		  if (homogeneous)
		    write_pch(stdout, " (2): ", 6L);
		  else
		    write_pch(stdout, " (3): ", 6L);
		  write_integer(stdout, t_index_, 3L);
		  write_integer(stdout, m_index + m1_ + sm_index(j, l, m1_),
				3L);
		}
		/*$endif TRACE*/
		j++;
	      }
	      i++;
	    }
	  }
	  if (true) {
	    /*$ifdef TRACE-ARRAY*/
	    ntr_t_ref(r_marginal, r_marginal_offset, m_index + l,
		      " AddHK              ", 20L, 2106L, 1L);
		/* ntr */
	    /* ntr */
	    ntr_t_upd(r_total, r_total_offset, t_index + k,
		      factor * (*r_marginal)->z[m_index + l], 1L,
		      " AddHK              ", 20L, 2106L, 1L);
		/* ntr */
	    /*$endif TRACE-ARRAY*/
	    (*r_total)->z[t_index + k] += factor * (*r_marginal)->z[m_index + l];
	  }
	  /*$ifdef TRACE*/
	  if (trace_flag_set(20L, 2196L, 1L)) {
	    write_pch(stdout, " (1): ", 6L);
	    write_integer(stdout, t_index + k, 3L);
	    write_integer(stdout, m_index + l, 3L);
	  }
	  /*$endif TRACE*/
	  l++;
	}
	k++;
      }
    }
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 2196L, 1L))
      write_line(stdout);
    /*$endif TRACE*/
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 2196L, 1L)) {
      write_pch(stdout, " New table (AddHK-1)", 20L);
      print_ssd_t(a, n_a_offset, *r_total_offset, *r_total, *m1, *m2, NULL,
		  3L, false, false, 2L, false);
      write_line(stdout);
    }
    /*$endif TRACE*/
    fast_next_offset(&d_in_a, &m_i, cell);
  }
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 2196L, 1L))
    return;
  /*$endif TRACE*/
  write_pch(stdout, " New table (AddHK-2)", 20L);
  print_ssd_t(a, n_a_offset, *r_total_offset, *r_total, *m1, *m2, NULL, 3L,
	      false, false, 2L, false);
  write_line(stdout);
}  /* add_hk */


Static Void sub_sub_do_add_hk(p, homogeneous, outer_set, ms, separator,
			      r_total, r_total_offset, r_p, r_p_offset, m, m1,
			      m2)
t_mips_element **p;
boolean *homogeneous;
long *outer_set, *ms, *separator;
t_t_r **r_total;
t_t_offset *r_total_offset;
t_t_r **r_p;
t_t_offset *r_p_offset;
t_integer *m, *m1, *m2;
{
  t_vertex_set c1, d1;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubSubDoAddHK      ", sizeof(pch20));
  ntr_4(tzt, 20L, 2197L, 1L, 1L, *m, *m1, *m2);
  ntr_set(tzt, 20L, 2197L, 1L, 1L, 0L, outer_set);
  ntr_set(tzt, 20L, 2197L, 1L, 1L, 1L, ms);
  ntr_set(tzt, 20L, 2197L, 1L, 1L, 2L, separator);
  /*$endif TRACE*/
  P_setint(d1, ms, delta);
  P_setint(c1, ms, gamma_);
  add_hk(outer_set, d1, c1, *homogeneous && (*p)->complete, r_total,
	 r_total_offset, &(*p)->ghk_work->r_upper,
	 &(*p)->ghk_work->r_upper_offset, &(*p)->ghk_work->k_upper,
	 &(*p)->ghk_work->k_upper_offset, r_p, r_p_offset, m, m1, m2, 1L);
  P_setint(d1, separator, delta);
  P_setint(c1, separator, gamma_);   /* true */
  /*$ifdef TRACE*/
  add_hk(outer_set, d1, c1, *homogeneous, r_total, r_total_offset,
	 &(*p)->ghk_work->r_lower, &(*p)->ghk_work->r_lower_offset,
	 &(*p)->ghk_work->k_lower, &(*p)->ghk_work->k_lower_offset, r_p,
	 r_p_offset, m, m1, m2, -1L);
  ntr(tzt, 20L, 2197L, 1L, 9L, 9L);
  /*$endif TRACE*/
}  /* sub_sub_do_add_hk */


Static Void sub_do_add_hk(model, outer_set, c, r_total, r_total_offset, r_p,
			  r_p_offset, m, m1, m2)
t_model **model;
long *outer_set, *c;
t_t_r **r_total;
t_t_offset *r_total_offset;
t_t_r **r_p;
t_t_offset *r_p_offset;
t_integer *m, *m1, *m2;
{
  /* n_offset : t_offset;
     g_c_d, g_c_l, g_c_q : t_link_set_list;
     m_ips_leaf : t_link_mips_element; */
  t_decomposition_element *decomposition_element;
  t_formula_node *formula, *separator;
  t_vertex_set c_left, c_right;
  boolean homogeneous;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubDoAddHK         ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 2198L, 1L, -1L, -1L, model);
  ntr_4(tzt, 20L, 2198L, 1L, 1L, *m, *m1, *m2);
  ntr_set(tzt, 20L, 2198L, 1L, 1L, 0L, outer_set);
  ntr_set(tzt, 20L, 2198L, 1L, 1L, 1L, (*model)->id->vertices);
  ntr_set(tzt, 20L, 2198L, 1L, 1L, 2L, c);
  /*$endif TRACE*/
  formula = (*model)->formula_node;
  if (formula != NULL) {
    if (formula->node_type == decomposition_node) {
      decomposition_element = formula->UU.decomposition_node_;
      separator = decomposition_element->separator;
      /*$ifdef TRACE*/
      ntr_set(tzt, 20L, 2198L, 1L, 2L, 1L, separator->UU.m_complete_leaf->a);
      /*$endif TRACE*/
      if (P_subset(c, decomposition_element->right_model->id->vertices)) {
	P_setcpy(c_left, separator->UU.m_complete_leaf->a);
	P_setcpy(c_right, c);
      } else {
	P_setcpy(c_left, c);
	P_setcpy(c_right, separator->UU.m_complete_leaf->a);
      }
      /*$ifdef TRACE*/
      ntr_set(tzt, 20L, 2198L, 1L, 3L, 1L, c_left);
      ntr_set(tzt, 20L, 2198L, 1L, 3L, 2L, c_right);
      /*$endif TRACE*/
      sub_do_add_hk(&decomposition_element->left_model, outer_set, c_left,
		    r_total, r_total_offset, r_p, r_p_offset, m, m1, m2);
      sub_do_add_hk(&decomposition_element->right_model, outer_set, c_right,
		    r_total, r_total_offset, r_p, r_p_offset, m, m1, m2);
    } else {
      homogeneous = false;
      if ((*model)->id->model_type == mixed)
	homogeneous = (*model)->id->UU.U1.homogeneous;
      switch (formula->node_type) {

      case decomposition_node:
	write_warning(stdout, " ?: Error in SubDoAddHK:   Decomposition", 40L);
	break;

      case null_node:
	write_warning(stdout, " ?: Error in SubDoAddHK:   NullNode.", 36L);
	break;

      case d_complete_node:
	/* write_warning(output,
	                ' ?: Error in SubDoAddHK:   D-complete.@@', 38); */
	sub_sub_do_add_hk(&formula->tmp_m_ips_leaf, &homogeneous, outer_set,
			  (*model)->id->vertices, c, r_total, r_total_offset,
			  r_p, r_p_offset, m, m1, m2);
	break;

      case c_complete_node:
	/*$ifdef TRACE*/
	ntr_4(tzt, 20L, 2198L, 1L, 2L, -1L, *m1, *m2);
	/*$endif TRACE*/
	return_ghk_size(outer_set, m1, m2);
	/*$ifdef TRACE*/
	ntr_4(tzt, 20L, 2198L, 1L, 2L, -2L, *m1, *m2);
	/*$endif TRACE*/
	sub_sub_do_add_hk(&formula->tmp_m_ips_leaf, &homogeneous, outer_set,
			  (*model)->id->vertices, c, r_total, r_total_offset,
			  r_p, r_p_offset, m, m1, m2);
	break;

      case m_complete_node:
	write_warning(stdout, " ?: Error in SubDoAddHK:   M-complete.", 38L);
	break;

      case d_ips_node:
	/* write_warning(output,
	                ' ?: Error in SubDoAddHK:   D-ips.@@@@@@@', 33); */
	sub_sub_do_add_hk(&formula->tmp_m_ips_leaf, &homogeneous, outer_set,
			  (*model)->id->vertices, c, r_total, r_total_offset,
			  r_p, r_p_offset, m, m1, m2);
	break;

      case r_ips_node:
	write_warning(stdout, " ?: Error in SubDoAddHK:   Radim-part.", 38L);
	break;

      case c_ips_node:
	sub_sub_do_add_hk(&formula->tmp_m_ips_leaf, &homogeneous, outer_set,
			  (*model)->id->vertices, c, r_total, r_total_offset,
			  r_p, r_p_offset, m, m1, m2);
	break;

      case m_ips_node:
	sub_sub_do_add_hk(&formula->UU.m_ips_leaf, &homogeneous, outer_set,
			  (*model)->id->vertices, c, r_total, r_total_offset,
			  r_p, r_p_offset, m, m1, m2);
	break;
      }
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2198L, 1L, 9L, 9L);
  /*$endif TRACE*/
}  /* sub_do_add_hk */


Static Void do_add_hk(model, outer_set, r_total, r_total_offset, r_p,
		      r_p_offset, m, m1, m2)
t_model **model;
long *outer_set;
t_t_r **r_total;
t_t_offset *r_total_offset;
t_t_r **r_p;
t_t_offset *r_p_offset;
t_integer *m, *m1, *m2;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DoAddHK            ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 2199L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  sub_do_add_hk(model, outer_set, empty_set, r_total, r_total_offset, r_p,
		r_p_offset, m, m1, m2);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2199L, 1L, 9L, 9L);
  /*$endif TRACE*/
}  /* do_add_hk */


Static boolean find_homogene_ssd_inverse(a, m1, m2, n_offset, h_offset, h,
					 k_offset, k)
long *a;
t_integer *m1, *m2;
t_offset *n_offset;
t_t_offset *h_offset;
t_t_r **h;
t_t_offset *k_offset;
t_t_r **k;
{
  t_integer m_b, i, j, size, count;
  t_vertex_set b;
  boolean ok;
  t_s_offset s_offset, s_index, x_offset, l_offset;
  t_s_r *s, *x, *l;   /* T_S, find_ssd/return_tmp_s_space/x */
  t_t_offset m_offset, h_index;
  t_t_r *m;   /* T_T, return_tmp_t_space */
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindHomogeneSsdInv ", sizeof(pch20));
  ntr_4(tzt, 20L, 2200L, 1L, 1L, 1L, *m1, *m2);
  ntr_set(tzt, 20L, 2200L, 1L, 1L, 2L, a);
  /*$endif TRACE*/
  P_setint(b, a, delta);
  m_b = marginal_dimension(b);
  ok = find_ssd(a, m1, m2, n_offset, &s_offset, &s);
  if (ok) {
    size = m_b * *m1;
    if (ok)
      ok = return_t_space(size, h, h_offset);
    size = *m1 * (*m1 + 1) / 2;
    if (ok)
      ok = return_t_space(size, k, k_offset);
    if (ok)
      ok = return_tmp_s_space(size * 2, &x, &x_offset);
    if (ok)
      ok = return_tmp_t_space(size, &m, &m_offset);
  } else {
    if (note_warnings) {
      write_pch(stdout, " Note-1 (FindHomognSsdInverse): FindSsd.", 40L);
      write_line(stdout);
    }
  }
  if (ok) {
    for (j = 0; j <= size; j++) {
      /*$ifdef TRACE-ARRAY*/
      ntr_s_ass(&x, &x_offset, x_offset + j, 0.0, " FindHomogeneSsdInv ", 20L,
		2200L, 1L);
	  /* ntr */
      /*$endif TRACE-ARRAY*/
      x->z[x_offset + j] = 0.0;
    }
    s_index = s_offset + *m1;
    for (i = 0; i < m_b; i++) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2200L, 1L)) {
	trace_1(" FindHomogeneSSD-1: ", 20L, i, -1L, s_index, -1L, *m1, *m2,
		-1.0, -1.0, -1.0);
	write_headed_matrix_s(" TERm:                                  ", 10L,
			      &s, &s_index, m1);
      }
      /*$endif TRACE*/
      for (j = FIRST_INDEX; j <= FIRST_INDEX + size; j++) {
	/*$ifdef TRACE-ARRAY*/
	ntr_s_ref(&s, &s_offset, s_index + j, " FindHomogeneSsdInv ", 20L,
		  2200L, 1L);
	    /* ntr */
	ntr_s_upd(&x, &x_offset, x_offset + j, s->z[s_index + j], 1L,
		  " FindHomogeneSsdInv ", 20L, 2200L, 1L);
	    /* ntr */
	/*$endif TRACE-ARRAY*/
	x->z[x_offset + j] += s->z[s_index + j];
      }
      s_index += *m2;
    }
    l_offset = x_offset + size;
    l = x;
    count = n[0];
    find_one_k_s_t(&count, &x, k, &l, &m, &x_offset, k_offset, &l_offset,
		   &m_offset, m1, &ok);
  } else {
    if (note_warnings) {
      write_pch(stdout, " Note-2 (FindHomognSsdInverse): TmpSSpc.", 40L);
      write_line(stdout);
    }
  }
  if (ok) {
    s_index = s_offset;
    h_index = *h_offset;
    for (i = 0; i < m_b; i++) {
      count = n[*n_offset + i];
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2200L, 1L)) {
	trace_1(" FindHomogeneSSD-1: ", 20L, i, count, s_index, h_index, *m1,
		*m2, -2.0, -1.0, -1.0);
	write_headed_matrix_s(" TERM:                                  ", 10L,
			      &s, &s_index, m1);
      }
      /*$endif TRACE*/
      mult_symmetric_matrix_and_vector_s_t_t(&s, k, h, &s_index, k_offset,
					     &h_index, m1);
      if (boolean_option[118] && count > 0) {
	for (j = FIRST_INDEX; j < FIRST_INDEX + *m1; j++) {
	  /*$ifdef TRACE-ARRAY*/
	  ntr_t_upd(h, h_offset, h_index + j, (double)count, -3L,
		    " FindHomogeneSsdInv ", 20L, 2200L, 1L);
	      /* ntr */
	  /*$endif TRACE-ARRAY*/
	  (*h)->z[h_index + j] /= count;   /* Wrong !! */
	}
      }
      h_index += *m1;
      s_index += *m2;
    }
  } else {
    if (note_warnings) {
      write_pch(stdout, " Note-3 (FindHomognSsdInverse): FindOneK", 40L);
      write_line(stdout);
    }
  }
  free_tmp_s_space();   /* 2 * size, x, x_offset */
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  free_tmp_t_space();   /* size, m, m_offset */
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2200L, 1L, 9L, 9L);
  /*$endif TRACE*/
  return ok;
}  /* find_homogene_ssd_inverse */


Static boolean sub_sub_do_find_ssd(p, full_specified, homogeneous, outer_set,
				   separator, n_offset, m, m1, m2, ifail)
t_mips_element **p;
boolean *full_specified, *homogeneous;
long *outer_set, *separator;
t_offset *n_offset;
t_integer *m, *m1, *m2, *ifail;
{
  boolean Result, ok;
  /*$ifdef TRACE*/
  t_set_list *mips_g_c;
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubSubDoFindSsd    ", sizeof(pch20));
  ntr_4(tzt, 20L, 2201L, 1L, 1L, *ifail, *m1, *m2);
  ntr_set(tzt, 20L, 2201L, 1L, 1L, 2L, outer_set);
  ntr_set(tzt, 20L, 2201L, 1L, 1L, 3L, separator);
  /*$endif TRACE*/
  *m1 = -1;
  *m2 = -1;
  if ((*p)->ghk_work == NULL)
    new_ghk_workspace(p);
  if ((*p)->complete) {
    if (*homogeneous) {
      ok = find_homogene_ssd_inverse(outer_set, m1, m2, n_offset,
	  &(*p)->ghk_work->r_upper_offset, &(*p)->ghk_work->r_upper,
	  &(*p)->ghk_work->k_upper_offset, &(*p)->ghk_work->k_upper);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 2201L, 1L, 2L, 2L, ok);
      /*$endif TRACE*/
    } else {
      ok = find_ghk_(outer_set, false, false, true, m1, m2, n_offset,
		     &(*p)->ghk_work->r_upper_offset,
		     &(*p)->ghk_work->r_upper);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 2201L, 1L, 3L, 2L, ok);
      /*$endif TRACE*/
    }
  } else {
    ok = true;
    if (!(*p)->fund_ghk) {
      /*$ifdef TRACE*/
      mips_g_c = NULL;
      ntr_mixed_item(tzt, 20L, 2201L, 1L, -1L, -1L, *p, &mips_g_c);
	  /* true, */
      /*$endif TRACE*/
      /*$ifdef TRACE*/
      mips(p, full_specified, homogeneous, outer_set, n, mips_epsilon,
	   &mips_max_it, &ok);
      ntr_boolean(tzt, 20L, 2201L, 1L, 4L, 2L, ok);
      /*$endif TRACE*/
    } else {
      if ((*p)->ifail > 0)
	ok = false;
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 2201L, 1L, 5L, 3L, ok);
      /*$endif TRACE*/
    }
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2201L, 1L, 3L, 2L, ok);
    /*$endif TRACE*/
    if (ok) {
      (*p)->ghk_work->r_upper_offset = (*p)->r_offset;
      (*p)->ghk_work->r_upper = (*p)->r;
    } else
      *ifail = (*p)->ifail;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2201L, 1L))
    trace_1(" FindGhKforModel", 16L, *m1, *m2, *ifail, -999L, -999L,
	    (*p)->ghk_work->r_upper_offset, -1.0, -1.0, -1.0);
  /*$endif TRACE*/
  if (ok) {
    if (*homogeneous) {
      ok = find_homogene_ssd_inverse(separator, m1, m2, n_offset,
	  &(*p)->ghk_work->r_lower_offset, &(*p)->ghk_work->r_lower,
	  &(*p)->ghk_work->k_lower_offset, &(*p)->ghk_work->k_lower);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 2201L, 1L, 6L, 2L, ok);
      /*$endif TRACE*/
    } else {
      ok = find_ghk_(separator, false, false, true, m1, m2, n_offset,
		     &(*p)->ghk_work->r_lower_offset,
		     &(*p)->ghk_work->r_lower);
      /*$ifdef TRACE*/
      ntr_boolean(tzt, 20L, 2201L, 1L, 7L, 2L, ok);
      /*$endif TRACE*/
    }
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2201L, 1L))
    trace_1(" FindGhKforModel", 16L, *m1, *m2, -1L, -1L, -1L,
	    (*p)->ghk_work->r_lower_offset, -1.0, -1.0, -1.0);
  /*$endif TRACE*/
  Result = ok;
  /*$ifdef TRACE*/
  ntr_4(tzt, 20L, 2201L, 1L, 9L, 9L, *m1, *m2);
  /*$endif TRACE*/
  return Result;
}  /* sub_sub_do_find_ssd */


Static boolean sub_do_find_ssd(model, c, n_offset, m, m1, m2, ifail)
t_model **model;
long *c;
t_offset *n_offset;
t_integer *m, *m1, *m2, *ifail;
{
  boolean Result;
  t_set_list *g_c_d = NULL, *g_c_l = NULL, *g_c_q = NULL;
  t_cips_set_list *p;
  t_ips_set_list *p_ips;
  t_decomposition_element *decomposition_element;
  t_formula_node *formula, *separator;
  t_vertex_set a, c_left, c_right;
  boolean complete, full_specified, homogeneous;
  boolean ok = false;
  /*$ifdef TRACE*/
  pch20 tzt;
  boolean TEMP, TEMP1, TEMP2;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubDoFindSsd       ", sizeof(pch20));
  ntr_4(tzt, 20L, 2202L, 1L, 1L, 1L, *m1, *m2);
  ntr_set(tzt, 20L, 2202L, 1L, 1L, 1L, c);
  ntr_model_g_c(tzt, 20L, 2202L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  formula = (*model)->formula_node;
  if (formula != NULL) {
    if (formula->node_type == decomposition_node) {
      decomposition_element = formula->UU.decomposition_node_;
      separator = decomposition_element->separator;
      if (P_subset(c, decomposition_element->right_model->id->vertices)) {
	P_setcpy(c_left, separator->UU.m_complete_leaf->a);
	P_setcpy(c_right, c);
      } else {
	P_setcpy(c_left, c);
	P_setcpy(c_right, separator->UU.m_complete_leaf->a);
      }
      /*$ifdef TRACE*/
      ntr_4(tzt, 20L, 2202L, 1L, 4L, 4L, *m1, *m2);
      /*$endif TRACE*/
      ok = sub_do_find_ssd(&decomposition_element->left_model, c_left,
			   n_offset, m, m1, m2, ifail);
      if (ok)
	ok = sub_do_find_ssd(&decomposition_element->right_model, c_right,
			     n_offset, m, m1, m2, ifail);
    } else {
      homogeneous = false;
      if ((*model)->id->model_type == mixed)
	homogeneous = (*model)->id->UU.U1.homogeneous;
      full_specified = false;
      if ((*model)->id->model_type == mixed)
	full_specified = (*model)->id->UU.U1.full_specified;
      /*$ifdef TRACE*/
      ntr_4(tzt, 20L, 2202L, 1L, 5L, 5L, *m1, *m2);
      /*$endif TRACE*/
      switch (formula->node_type) {

      case decomposition_node:
	/* blank case */
	break;

      case null_node:
	/* blank case */
	break;

      case d_complete_node:
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2202L, 1L, 6L, 1L);
	/*$endif TRACE*/
	homogeneous = true;
	insert_clique(formula->UU.d_complete_leaf->a, &g_c_d);
	TEMP = true;
	TEMP1 = false;
	TEMP2 = true;
	new_m_ips_leaf(&(*model)->formula_node->tmp_m_ips_leaf, &TEMP,
		       formula->UU.d_complete_leaf->a, empty_set, true,
		       &TEMP1, homogeneous, &TEMP2, &g_c_d, &g_c_l, &g_c_q);
	TEMP = false;
	ok = sub_sub_do_find_ssd(&(*model)->formula_node->tmp_m_ips_leaf,
				 &TEMP, &homogeneous, (*model)->id->vertices,
				 c, n_offset, m, m1, m2, ifail);
	/*$ifdef TRACE*/
	ntr_4(tzt, 20L, 2198L, 1L, 2L, -1L, *m1, *m2);
	/*$endif TRACE*/
	break;

      case c_complete_node:
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2202L, 1L, 6L, 2L);
	/*$endif TRACE*/
	homogeneous = true;
	insert_clique(formula->UU.c_complete_leaf->a, &g_c_q);
	TEMP = true;
	TEMP1 = false;
	TEMP2 = true;
	new_m_ips_leaf(&(*model)->formula_node->tmp_m_ips_leaf, &TEMP,
		       formula->UU.c_complete_leaf->a, empty_set, true,
		       &TEMP1, homogeneous, &TEMP2, &g_c_d, &g_c_l, &g_c_q);
	TEMP = false;
	ok = sub_sub_do_find_ssd(&(*model)->formula_node->tmp_m_ips_leaf,
				 &TEMP, &homogeneous, (*model)->id->vertices,
				 c, n_offset, m, m1, m2, ifail);
	/*$ifdef TRACE*/
	ntr_4(tzt, 20L, 2198L, 1L, 2L, -1L, *m1, *m2);
	/*$endif TRACE*/
	break;

      case m_complete_node:
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2202L, 1L, 6L, 3L);
	/*$endif TRACE*/
	break;

      case d_ips_node:
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2202L, 1L, 6L, 10L);
	/*$endif TRACE*/
	homogeneous = true;
	p_ips = formula->UU.d_ips_leaf->gen_class;
	while (p_ips != NULL) {
	  insert_clique(p_ips->vertex_set, &g_c_d);
	  p_ips = p_ips->pointer;
	}
	insert_clique(p_ips->vertex_set, &g_c_l);
	TEMP = true;
	TEMP1 = false;
	TEMP2 = true;
	new_m_ips_leaf(&(*model)->formula_node->tmp_m_ips_leaf, &TEMP,
		       formula->UU.d_ips_leaf->a, empty_set, true, &TEMP1,
		       homogeneous, &TEMP2, &g_c_d, &g_c_l, &g_c_q);
	TEMP = false;
	ok = sub_sub_do_find_ssd(&(*model)->formula_node->tmp_m_ips_leaf,
				 &TEMP, &homogeneous, (*model)->id->vertices,
				 c, n_offset, m, m1, m2, ifail);
	/*$ifdef TRACE*/
	ntr_4(tzt, 20L, 2198L, 1L, 2L, -1L, *m1, *m2);
	/*$endif TRACE*/
	break;

      case r_ips_node:
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2202L, 1L, 6L, 11L);
	/*$endif TRACE*/
	break;

      case c_ips_node:
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2202L, 1L, 6L, 12L);
	/*$endif TRACE*/
	/* if model^.formula_node^.tmp_m_ips_leaf <> nil then begin */
	p = formula->UU.c_ips_leaf->generators;
	P_setcpy(a, empty_set);
	while (p != NULL) {
	  insert_clique(p->vertex_set, &g_c_q);
	  P_setunion(a, a, p->vertex_set);
	  p = p->pointer;
	}
	insert_clique(a, &g_c_d);
	unfold_linear(&g_c_d, &g_c_l, &ok, tzt, 20L, false);
	if (ok)
	  dispose_set_list(&g_c_d);
	else
	  g_c_l = g_c_d;
	g_c_d = NULL;
	complete = false;
	if (g_c_q->pointer == NULL)
	  complete = true;
	/*$ifdef TRACE*/
	ntr_triple_g_c(tzt, 20L, 2202L, 1L, 6L, 13L, &g_c_d, &g_c_l, &g_c_q);
	TEMP = true;
	TEMP1 = true;
	/*$endif TRACE*/
	/* graphical: */
	/* upper: */
	/* lower: */
	/* homogeneous: */
	/* node_homogeneous: */
	new_m_ips_leaf(&(*model)->formula_node->tmp_m_ips_leaf, &TEMP, a,
		       empty_set, complete, &full_specified, true, &TEMP1,
		       &g_c_d, &g_c_l, &g_c_q);
	/* end; */
	ok = sub_sub_do_find_ssd(&(*model)->formula_node->tmp_m_ips_leaf,
	    &full_specified, &homogeneous, (*model)->id->vertices, c,
	    n_offset, m, m1, m2, ifail);
	break;

      case m_ips_node:
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2202L, 1L, 6L, 13L);
	/*$endif TRACE*/
	ok = sub_sub_do_find_ssd(&(*model)->formula_node->UU.m_ips_leaf,
	    &full_specified, &homogeneous, (*model)->id->vertices, c,
	    n_offset, m, m1, m2, ifail);
	break;
      }
    }
  } else {
    /*$ifdef TRACE*/
    ntr_4(tzt, 20L, 2202L, 1L, 8L, 8L, *m1, *m2);
    /*$endif TRACE*/
  }
  Result = ok;
  /*$ifdef TRACE*/
  ntr_4(tzt, 20L, 2202L, 1L, 9L, 9L, *m1, *m2);
  /*$endif TRACE*/
  return Result;
}  /* sub_do_find_ssd */


Static boolean do_find_ssd(model, n_offset, m, m1, m2)
t_model **model;
t_offset *n_offset;
t_integer *m, *m1, *m2;
{
  /*$ifdef TRACE*/
  boolean Result;
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DoFindSsd          ", sizeof(pch20));
  ntr_4(tzt, 20L, 2203L, 1L, 1L, 1L, *m1, *m2);
  ntr_model_g_c(tzt, 20L, 2203L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  Result = sub_do_find_ssd(model, empty_set, n_offset, m, m1, m2,
			   &(*model)->model_ifail);
  /*$ifdef TRACE*/
  ntr_4(tzt, 20L, 2203L, 1L, 9L, 9L, *m1, *m2);
  /*$endif TRACE*/
  return Result;
}  /* do_find_ssd */


Static boolean find_ghk_for_model(model, m1, m2, n_offset, r_total,
				  r_total_offset)
t_model **model;
t_integer *m1, *m2;
t_offset *n_offset;
t_t_r **r_total;
t_t_offset *r_total_offset;
{
  /* T_T, return_t_space */
  t_integer i, m, size;
  boolean ok = true;
  t_vertex_set d;
  t_t_offset r_size, tmp_offset, r_workspace_offset, r_p_offset,
	     r_determinants_offset, r_products_offset;
  t_long_real gamma_constant;
  t_t_r *r_workspace = NULL, *r_p = NULL, *r_determinants = NULL,
	*r_products = NULL;
      /* T_T, return_tmp_t_space/3*malloc_workspace */
  pch20 txt;
  t_model *WITH;

  memcpy(txt, " FindGhkForModel    ", sizeof(pch20));
  /*$ifdef TRACE*/
  ntr_4(txt, 20L, 2204L, 1L, 1L, 1L, *m1, *m2);
  ntr_model_g_c(txt, 20L, 2204L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  if (em)
    write_warning_em(stdout, 2204L, txt);
  *r_total = NULL;
  WITH = *model;
  ok = do_find_ssd(model, n_offset, &m, m1, m2);
  /*$ifdef TRACE*/
  ntr_boolean(txt, 20L, 2204L, 1L, 1L, 2L, ok);
  /*$endif TRACE*/
  P_setint(d, WITH->id->vertices, delta);
  return_ghk_size(WITH->id->vertices, m1, m2);
  m = last_index(d) - FIRST_INDEX + 1;
  r_size = *m2 * m;
  size = r_size;
  if (ok)
    ok = return_t_space(size, r_total, r_total_offset);
  /*$ifdef TRACE*/
  ntr_boolean(txt, 20L, 2204L, 1L, 1L, 3L, ok);
  /*$endif TRACE*/
  if (!ok)
    return ok;
  clear_t_array(r_total, r_total_offset, &r_size);
  size = m * 3 + *m2 * 2;
  if (ok)
    ok = return_tmp_t_space(size, &r_workspace, &r_workspace_offset);
  /*$ifdef TRACE*/
  ntr_boolean(txt, 20L, 2204L, 1L, 1L, 4L, ok);
  /*$endif TRACE*/
  if (!ok)
    return ok;
  tmp_offset = r_workspace_offset;
  malloc_workspace(&r_workspace, &tmp_offset, &r_p, &r_p_offset, m);
  malloc_workspace(&r_workspace, &tmp_offset, &r_determinants,
		   &r_determinants_offset, m);
  malloc_workspace(&r_workspace, &tmp_offset, &r_products, &r_products_offset,
		   m);
  for (i = 0; i < m; i++) {
    /*$ifdef TRACE-ARRAY*/
    ntr_t_ass(&r_p, &r_p_offset, r_p_offset + i, 1.0, txt, 20L, 2204L, 1L);
	/* ntr */
    /*$endif TRACE-ARRAY*/
    r_p->z[r_p_offset + i] = 1.0;
  }
  do_add_hk(model, WITH->id->vertices, r_total, r_total_offset, &r_p,
	    &r_p_offset, &m, m1, m2);
  P_setint(d, WITH->id->vertices, delta);
  *n_offset = return_offset(d, &ok);
  /*$ifdef TRACE*/
  ntr_boolean(txt, 20L, 2204L, 1L, 1L, 5L, ok);
  /*$endif TRACE*/
  find_determinants_and_products(&m, m1, m2, n_offset, r_total,
    r_total_offset, &r_workspace, tmp_offset, &r_determinants,
    &r_determinants_offset, &r_products, &r_products_offset, false, &ok);
  /*$ifdef TRACE*/
  ntr_boolean(txt, 20L, 2204L, 1L, 1L, 6L, ok);
  /*$endif TRACE*/
  if (ok) {
    gamma_constant = *m1 * LN_2_PI_HALF;   /* m1, */
    p_to_gs(1.0, &gamma_constant, &m, m2, n_offset, r_total, r_total_offset,
	    &r_p, &r_p_offset, &r_determinants, &r_determinants_offset,
	    &r_products, &r_products_offset);
  }
  /* ?!?!? */
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2204L, 1L)) {
    write_pch(stdout, " New table (FindGhK)", 20L);
    print_ssd_t(WITH->id->vertices, *n_offset, *r_total_offset, *r_total, *m1,
		*m2, NULL, 3L, false, false, 2L, false);
    write_line(stdout);
  }
  /*$endif TRACE*/
  free_tmp_t_space();   /* size, r_workspace, r_workspace_offset */
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  return ok;
}  /* find_ghk_for_model */


/*@+"ssd.p"*/


/*

2207:    +++  ++
2208:    +++  ++
2209:    ---  -- p/ssd.p          2      10     129 p/ssd.p
2210: |    4:    procedure print_or_return_ssd
2211: |   37:    procedure find_and_print_covariance
2212:    +++  ++
2213:    +++  ++

*/

Static Void print_or_return_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a,
  output_type, return_, table, permuted, ssd_type, sigma, ifail,
  arg_pos_double, nargs, arg_double)
long *a;
t_offset n_offset;
t_s_offset s_offset;
t_s_r *s;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean return_, table, permuted;
t_integer ssd_type;
boolean sigma;
t_integer *ifail, arg_pos_double;
long **nargs;
double **arg_double;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PrintOrReturnSsd", sizeof(pch20));
  ntr(tzt, 17L, 2210L, 1L, m1, m2);
  /*$endif TRACE*/
  if (s == NULL) {
    write_empty_ssd(a, n_offset, s_offset, &s, m1, m2, p_a, output_type,
		    table, permuted, ssd_type, sigma);
    return;
  }
  if (return_) {
    /*$ifdef TRACE*/
    ntr(tzt, 17L, 2210L, 2L, -1L, 1L);
    /*$endif TRACE*/
    /* output_type, */
    /* ssd_type, */
    /*$ifdef TRACE*/
    return_ssd(a, n_offset, s_offset, s, m1, m2, p_a, permuted, sigma, ifail,
	       arg_pos_double, nargs, arg_double);
    ntr(tzt, 17L, 2210L, 2L, -1L, 2L);
    /*$endif TRACE*/
    return;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 17L, 2210L, 3L, -1L, 1L);
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  print_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a, output_type, table,
	      permuted, ssd_type, sigma);
  ntr(tzt, 17L, 2210L, 3L, -1L, 2L);
  /*$endif TRACE*/
}  /* print_or_return_ssd_s */


Static Void print_or_return_ssd_r(a, n_offset, r_offset, r, m1, m2, p_a,
  output_type, return_, table, permuted, ssd_type, sigma, ifail,
  arg_pos_double, nargs, arg_double)
long *a;
t_offset n_offset;
t_r_offset r_offset;
t_r_r **r;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean return_, table, permuted;
t_integer ssd_type;
boolean sigma;
t_integer *ifail, arg_pos_double;
long **nargs;
double **arg_double;
{
  t_s_offset s_offset = r_offset;
  t_s_r *s = NULL;

  if (*r == NULL) {
    write_empty_ssd(a, n_offset, s_offset, &s, m1, m2, p_a, output_type,
		    table, permuted, ssd_type, sigma);
    return;
  }
  s = (t_s_r *)Malloc(sizeof(t_s_r));
  if (s == NULL)
    _OutMem();
  /*$ifdef CAST*/
  s->z = (*r)->z;   /* Cast of T_R to T_S. */
  /*$endif CAST*/
  print_or_return_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a, output_type,
			return_, table, permuted, ssd_type, sigma, ifail,
			arg_pos_double, nargs, arg_double);
  _Free(s);
}  /* print_or_return_ssd_r */


Static Void print_or_return_ssd_ss(a, n_offset, ss_offset, ss, m1, m2, p_a,
  output_type, return_, table, permuted, ssd_type, sigma, ifail,
  arg_pos_double, nargs, arg_double)
long *a;
t_offset n_offset;
t_ss_offset ss_offset;
t_ss_r **ss;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean return_, table, permuted;
t_integer ssd_type;
boolean sigma;
t_integer *ifail, arg_pos_double;
long **nargs;
double **arg_double;
{
  t_s_offset s_offset = ss_offset;
  t_s_r *s = NULL;

  if (*ss == NULL) {
    write_empty_ssd(a, n_offset, s_offset, &s, m1, m2, p_a, output_type,
		    table, permuted, ssd_type, sigma);
    return;
  }
  s = (t_s_r *)Malloc(sizeof(t_s_r));
  if (s == NULL)
    _OutMem();
  /*$ifdef CAST*/
  s->z = (*ss)->z;   /* Cast of T_SS to T_S. */
  /*$endif CAST*/
  print_or_return_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a, output_type,
			return_, table, permuted, ssd_type, sigma, ifail,
			arg_pos_double, nargs, arg_double);
  _Free(s);
}  /* print_or_return_ssd_ss */


Static Void print_or_return_ssd_t(a, n_offset, t_offset_, t, m1, m2, p_a,
  output_type, return_, table, permuted, ssd_type, sigma, ifail,
  arg_pos_double, nargs, arg_double)
long *a;
t_offset n_offset;
t_t_offset t_offset_;
t_t_r **t;
t_integer m1, m2;
t_vertex_list *p_a;
t_integer output_type;
boolean return_, table, permuted;
t_integer ssd_type;
boolean sigma;
t_integer *ifail, arg_pos_double;
long **nargs;
double **arg_double;
{
  t_s_offset s_offset = t_offset_;
  t_s_r *s = NULL;

  if (*t == NULL) {
    write_empty_ssd(a, n_offset, s_offset, &s, m1, m2, p_a, output_type,
		    table, permuted, ssd_type, sigma);
    return;
  }
  s = (t_s_r *)Malloc(sizeof(t_s_r));
  if (s == NULL)
    _OutMem();
  /*$ifdef CAST*/
  s->z = (*t)->z;   /* Cast of T_T to T_S. */
  /*$endif CAST*/
  print_or_return_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a, output_type,
			return_, table, permuted, ssd_type, sigma, ifail,
			arg_pos_double, nargs, arg_double);
  _Free(s);
}  /* print_or_return_ssd_t */


Static Void find_and_print_covariance(model, value_type, a, p_a, return_,
  matrix, table, permuted, ifail, arg_pos_double, nargs, arg_double)
t_model_list **model;
t_integer *value_type;
long *a;
t_vertex_list *p_a;
boolean return_, matrix, table, permuted;
t_integer *ifail, arg_pos_double;
long **nargs;
double **arg_double;
{
  boolean update_discrete, update_linear;
  t_vertex_list *p_model_set;
  t_offset n_offset, p_offset;
  t_integer output_type, m, m1, m2;
  boolean ok, dummy_ok;
  t_ss_offset ss_offset;
  t_s_offset s_offset;
  t_r_offset r_offset;
  t_ss_r *ss = NULL;   /* T_SS, find_ss */
  t_s_r *s = NULL;   /* T_S, find_ssd/find_determinants */
  t_r_r *r = NULL;   /* T_R, find_gs/find_ghk */
  t_t_r *s_workspace = NULL, *khi = NULL, *sigma = NULL, *E_n = NULL;
      /* T_T, return_tmp_t_space/malloc_workspace/2*= */
  t_t_offset s_workspace_offset, khi_offset, sigma_offset, E_n_offset,
	     tmp_offset, r_total_offset;
  t_t_r *r_total = NULL;   /* T_T, find_ghk_for_model/print_ssd */
  /*$ifdef TRACE*/
  pch20 tzt;
  t_model *WITH;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindAndPrintCovari.", sizeof(pch20));
  if (*model != NULL) {
    ntr_model_g_c(tzt, 20L, 2211L, 1L, -1L, -1L, &(*model)->model);
    /*$endif TRACE*/
  }
  if (matrix)
    output_type = 2;
  else
    output_type = 0;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2211L, 1L, *value_type, output_type);
  ntr_set(tzt, 20L, 2211L, 1L, 1L, 1L, a);
  /*$endif TRACE*/
  if (*model == NULL) {
    switch (*value_type) {

    case 0:
      /* blank case */
      break;

    case 1:  /* ??? */
      find_covariance(a, &n_offset, &p_offset, &m1, &m2, &ok);
      if (ok)
	print_covariance(a, n_offset, p_offset, m1, m2, p_a, output_type,
			 permuted);
      break;

    case 2:  /* Canonical */
      ok = find_ghk(a, true, true, true, &m1, &m2, &n_offset, &r_offset, &r);
      if (ok)   /*0/2*/
	print_or_return_ssd_r(a, n_offset, r_offset, &r, m1, m2, p_a,
			      output_type, return_, table, permuted, 2L,
			      false, ifail, arg_pos_double, nargs,
			      arg_double);
      break;

    case 3:  /* g's*/
      ok = find_gs(a, &m1, &m2, &n_offset, &r_offset, &r);
      if (ok) {
	/* output_type, */
	print_ssd_r(a, n_offset, r_offset, r, m1, m2, p_a, 2L, table,
		    permuted, 2L, false);
      }
      break;

    case 4:  /* h's */
      ok = find_ghk(a, false, false, true, &m1, &m2, &n_offset, &r_offset, &r);
      if (ok) {
	/* output_type, */
	print_ssd_r(a, n_offset, r_offset, r, m1, m2, p_a, 1L, table,
		    permuted, 2L, false);
      }
      break;

    case 5:  /* K's */
      ok = find_ghk(a, false, false, false, &m1, &m2, &n_offset, &r_offset,
		    &r);
      if (ok) {
	/* output_type, */
	print_ssd_r(a, n_offset, r_offset, r, m1, m2, p_a, 3L, table,
		    permuted, 2L, false);
      }
      break;

    case 6:  /* Moments */
      ok = find_ssd(a, &m1, &m2, &n_offset, &s_offset, &s);
      if (ok)   /*0/2*/
	print_or_return_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a,
			      output_type, return_, table, permuted, 1L,
			      false, ifail, arg_pos_double, nargs,
			      arg_double);
      break;

    case 7:  /* Means */
      ok = find_ssd(a, &m1, &m2, &n_offset, &s_offset, &s);
      if (ok) {
	/* output_type*/
	print_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a, 1L, table,
		    permuted, 1L, false);
      }
      break;

    case 8:  /* Covariance */
      ok = find_ssd(a, &m1, &m2, &n_offset, &s_offset, &s);
      if (ok) {
	/* output_type */
	print_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a, 3L, table,
		    permuted, 1L, false);
      }
      break;

    case 9:  /* Raw moments */
      ok = find_ss(a, &m1, &m2, &n_offset, &ss_offset, &ss);
      if (ok)   /*0/2*/
	print_or_return_ssd_ss(a, n_offset, ss_offset, &ss, m1, m2, p_a,
			       output_type, return_, table, permuted, 1L,
			       false, ifail, arg_pos_double, nargs,
			       arg_double);
      break;

    case 10:  /* Totals */
      ok = find_ss(a, &m1, &m2, &n_offset, &ss_offset, &ss);
      if (ok) {
	/* output_type */
	print_ssd_ss(a, n_offset, ss_offset, &ss, m1, m2, p_a, 1L, table,
		     permuted, 1L, false);
      }
      break;

    case 11:  /* SS */
      ok = find_ss(a, &m1, &m2, &n_offset, &ss_offset, &ss);
      if (ok)   /* 3 */
	print_ssd_ss(a, n_offset, ss_offset, &ss, m1, m2, p_a, output_type,
		     table, permuted, 1L, false);
      break;

    case 12:  /* Sigma = SSD */
      ok = find_ssd(a, &m1, &m2, &n_offset, &s_offset, &s);
      if (ok)   /* 3 */
	print_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a, output_type, table,
		    permuted, 1L, true);
      break;

    case 13:  /* Determinants */
      ok = find_determinants(a, &m1, &m2, &n_offset, &s_offset, &s);
      if (ok)
	print_ssd_s(a, n_offset, s_offset, s, m1, m2, p_a, output_type, table,
		    permuted, 1L, false);
      break;
    }
    return;
  }
  switch (*value_type) {

  case 2:
    WITH = (*model)->model;
    /* Canonical for model, MK */
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2211L, 2L, -1L, 1L);
    /*$endif TRACE*/
    /* if r_total = nil then */
    ok = find_ghk_for_model(&(*model)->model, &m1, &m2, &n_offset, &r_total,
			    &r_total_offset);
    /* else begin
       ok := true;
       return_ghk_size(id^.vertices, m1, m2);
       a := id^.vertices * delta;
       n_offset := return_offset(a, ok)
    end */
    p_model_set = NULL;
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 2211L, 1L)) {
      write_pch(stdout, " New table (F-P-Cov)", 20L);
      print_ssd_t((*model)->model->id->vertices, n_offset, r_total_offset,
		  r_total, m1, m2, NULL, 3L, false, false, 2L, false);
      write_line(stdout);
    }
    /*$endif TRACE*/
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2211L, 2L, -1L, 2L, ok);   /*0/2*/
    /*$endif TRACE*/
    /* r_total_offset := 0; */
    /* ??? */
    print_or_return_ssd_t(WITH->id->vertices, n_offset, r_total_offset,
			  &r_total, m1, m2, p_model_set, output_type, return_,
			  table, false, 2L, false, ifail, arg_pos_double,
			  nargs, arg_double);
    /* print_ssd_t(id^.vertices, n_offset, r_total_offset, r_total,
                  m1, m2, p_model_set,
                  output_type, table, false, 2, false) */
    break;

  case 12:
    WITH = (*model)->model;
    /* Sigma for model, MS */
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2211L, 3L, 2L, 1L);
    /*$endif TRACE*/
    /* if r_total = nil then */
    ok = find_ghk_for_model(&(*model)->model, &m1, &m2, &n_offset, &r_total,
			    &r_total_offset);
    /* else begin
       ok := true;
       return_ghk_size(id^.vertices, m1, m2);
       a := id^.vertices * delta;
       n_offset := return_offset(a, ok)
    end*/
    /*$ifdef TRACE*/
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 2211L, 1L)) {
      write_pch(stdout, " New table (F-P-Cov)", 20L);
      print_ssd_t((*model)->model->id->vertices, n_offset, r_total_offset,
		  r_total, m1, m2, NULL, 3L, false, false, 2L, false);
      write_line(stdout);
    }
    /*$endif TRACE*/
    ntr_boolean(tzt, 20L, 2211L, 3L, 2L, 2L, ok);
    /*$endif TRACE*/
    m = marginal_dimension(WITH->id->vertices);
    /*$ifdef TRACE*/
    ntr_4(tzt, 20L, 2211L, 3L, 2L, 3L, m, (m + 2) * m2);
    /*$endif TRACE*/
    if (ok)
      ok = return_tmp_t_space((m + 2) * m2, &s_workspace, &s_workspace_offset);
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2211L, 3L, 2L, 3L, ok);
    /*$endif TRACE*/
    if (ok) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2211L, 1L, 2L, 4L);
      /*$endif TRACE*/
      tmp_offset = s_workspace_offset;
      sigma = s_workspace;
      sigma_offset = tmp_offset + m1;
      E_n = s_workspace;
      E_n_offset = tmp_offset + m2 - 1;
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2211L, 1L, 2L, 5L);
      /*$endif TRACE*/
      malloc_workspace(&s_workspace, &tmp_offset, &khi, &khi_offset, m * m2);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2211L, 1L, 2L, 6L);
      /*$endif TRACE*/
      update_discrete = true;
      update_linear = true;   /* nil !?!? */
      /*
      update_discrete,
      update_linear, */
      find_expected_ns_khis_and_sigmas(&m, &m1, &m2, &n_offset, &r_total,
	&r_total_offset, &s_workspace, tmp_offset, &E_n, &E_n_offset, &khi,
	&khi_offset, &sigma, &sigma_offset, n, &ok);
      p_model_set = NULL;
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2211L, 1L, 2L, 7L);   /*0/2*/
      /*$endif TRACE*/
      print_or_return_ssd_t(WITH->id->vertices, n_offset, s_workspace_offset,
			    &s_workspace, m1, m2, p_model_set, output_type,
			    return_, table, false, 3L, false, ifail,
			    arg_pos_double, nargs, arg_double);
      /* print_ssd_t(id^.vertices, n_offset, s_workspace_offset,
                    s_workspace, m1, m2, p_model_set,
                    output_type, table, false, 3, false); */
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2211L, 1L, 2L, 8L);
      /*$endif TRACE*/
      dummy_ok = free_tmp_t_space();
	  /* (m + 2) * m2, s_workspace, s_workspace_offset */
    }
    break;
  }
}  /* find_and_print_covariance */


/*@+"plot.p"*/


Static Void return_vector(a, p_a, table_type, log_trans, permuted,
			  a_set_offset, n_total, model_set_offset, model,
			  arg_double)
long *a;
t_vertex_list **p_a;
t_long_integer *table_type;
boolean *log_trans, *permuted;
t_offset *a_set_offset;
t_long_real n_total;
t_offset *model_set_offset;
t_model **model;
double **arg_double;
{
  t_long_integer i, ii;
  t_cell cell;
  t_long_real x;
  /*$ifdef TRACE*/
  pch20 tzt;
  long FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnVector       ", sizeof(pch20));
  ntr(tzt, 20L, 2217L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if (mixed_data && *table_type != 0 &&
      (*model)->id->model_type != pure_discrete)
    note_mixed(stdout, " ReturnVector", 13L);
  memcpy(cell, first_cell, sizeof(t_cell));
  ntr(tzt, 20L, 2217L, 2L, -1L, -1L);
  FORLIM = last_index(a);
  for (i = FIRST_INDEX; i <= FORLIM; i++) {
    ntr(tzt, 20L, 2217L, 3L, -1L, i);
    if (*permuted)
      ii = marginal_hash(a, cell);
    else
      ii = i;
    x = return_table_value(a, *table_type, a_set_offset, &n_total, ii, cell,
			   model_set_offset, model);
    if (*permuted)
      next_marginal_cell_list(*p_a, cell);
    else if (*table_type != 0)
      next_marginal_cell(a, cell);
    if (is_infinity_real(x) || x <= 0 && *log_trans)
      (*arg_double)[i - FIRST_INDEX] = my_var_na_float;
    else {
      if (*log_trans)
	x = log_10(x);
      (*arg_double)[i - FIRST_INDEX] = x;
    }
  }
}  /* return_vector */


Static Void print_vector(a, p_a, table_type, log_trans, permuted,
			 a_set_offset, n_total, model_set_offset, model)
long *a;
t_vertex_list **p_a;
t_long_integer *table_type;
boolean *log_trans, *permuted;
t_offset *a_set_offset;
t_long_real n_total;
t_offset *model_set_offset;
t_model **model;
{
  t_long_integer i, ii, m;
  t_cell cell;
  t_long_real x;

  if (mixed_data && (*model)->id->model_type != pure_discrete)
    note_mixed(stdout, " PrintVector", 12L);
  if (!dump)
    write_line(stdout);
  memcpy(cell, first_cell, sizeof(t_cell));
  m = last_index(a);
  for (i = FIRST_INDEX; i <= m; i++) {
    if (*permuted)
      ii = marginal_hash(a, cell);
    else
      ii = i;
    x = return_table_value(a, *table_type, a_set_offset, &n_total, ii, cell,
			   model_set_offset, model);
    if (*permuted)
      next_marginal_cell_list(*p_a, cell);
    else if (*table_type != 0)
      next_marginal_cell(a, cell);
    if (*log_trans) {
      if (is_infinity_real(x) || x <= 0)
	x = _INFINITY_REAL;
      else
	x = log_10(x);
    }
    if (dump) {
      if (is_infinity_real(x)) {
	write_space_text(dump_file, labs(width) - 1);
	write_char_text(dump_file, '-');
      } else
	write_real_text(dump_file, x, labs(width), decdiff);
      if (i == m)
	write_char_text(dump_file, ';');
      else
	write_char_text(dump_file, ',');
    } else if (is_infinity_real(x))
      write_real(stdout, _INFINITY_REAL, width, decdiff);
    else
      write_real(stdout, x, width, decdiff);
    if ((i - FIRST_INDEX) % (line_length / labs(width)) == 0) {  /* fpa */
      if (dump)
	write_line_text(dump_file);
      else
	write_line(stdout);
    }
  }
  if (dump)
    write_line_text(dump_file);
  else
    write_line(stdout);
}  /* print_vector */


Static Void print_list(a, p_a, permuted, a_set_offset, n_total,
		       model_set_offset, model)
long *a;
t_vertex_list **p_a;
boolean *permuted;
t_offset *a_set_offset;
t_long_real n_total;
t_offset *model_set_offset;
t_model **model;
{
  t_long_integer i = FIRST_INDEX;
  t_long_integer ii, j;
  t_cell cell;
  t_long_real x;
  t_vertex v;

  if (mixed_data && (*model)->id->model_type != pure_discrete)
    note_mixed(stdout, " PrintList", 10L);
  page(stdout);
  write_line(stdout);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      if (variable_description[v - MIN_VERTEX]->UU.U0.levels > 9)
	write_char(stdout, ' ');
      write_char(stdout, ' ');
      print_vertex_on_file(stdout, v, 0L);
    }
  }
  write_space(stdout, labs(width) - 9);
  write_pch(stdout, " Observed", 9L);
  write_space(stdout, 1L);
  write_space(stdout, labs(width) - 9);
  write_pch(stdout, " Probabi.", 9L);
  write_space(stdout, labs(width) - 8);
  write_pch(stdout, " Residual", 9L);
  write_space(stdout, labs(width) - 6);
  write_pch(stdout, "  F-res", 7L);
  write_space(stdout, labs(width) - 6);
  write_pch(stdout, "  Res-F", 7L);
  write_space(stdout, labs(width) - 6);
  write_pch(stdout, "  G-res", 7L);
  write_space(stdout, labs(width) - 6);
  write_pch(stdout, "  Res-G", 7L);
  write_line(stdout);
  write_line(stdout);
  memcpy(cell, first_cell, sizeof(t_cell));
  while (i <= last_index(a) && !interrupt_1) {
    if (*permuted)
      ii = marginal_hash(a, cell);
    else
      ii = i;
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, a)) {
	if (variable_description[v - MIN_VERTEX]->UU.U0.levels > 9)
	  write_integer(stdout, cell[v - MIN_VERTEX] - FIRST_LEVEL + 1L, 3L);
	else
	  write_integer(stdout, cell[v - MIN_VERTEX] - FIRST_LEVEL + 1L, 2L);
      }
    }
    if (em)
      write_real(stdout, p[i + *a_set_offset], width, decexpt);
    else
      write_integer(stdout, n[i + *a_set_offset], width);
    if (incomplete_table) {
      if (marginal_zero_cell(a, cell, q_tables_offsets))
	write_char(stdout, '*');
      else
	write_char(stdout, ' ');
    } else
      write_char(stdout, ' ');
    if (em)
      write_real(stdout, compute_m_p_em(a, cell, model), width, decprob);
    else
      write_real(stdout, compute_m_p(a, cell, model), width, decprob);
    for (j = 3; j <= 7; j++) {
      write_char(stdout, ' ');
      x = return_table_value(a, j, a_set_offset, &n_total, ii, cell,
			     model_set_offset, model);
      if (is_infinity_real(x)) {
	write_space(stdout, labs(width) - 1);
	write_char(stdout, '-');
      } else
	write_real(stdout, x, width, print_dec);
    }
    write_line(stdout);
    if (*permuted)
      next_marginal_cell_list(*p_a, cell);
    else
      next_marginal_cell(a, cell);
    i++;
  }
  write_line(stdout);
  write_line(stdout);
  write_line(stdout);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      if (variable_description[v - MIN_VERTEX]->UU.U0.levels > 9)
	write_char(stdout, ' ');
      write_char(stdout, ' ');
      print_vertex_on_file(stdout, v, 0L);
    }
  }
  write_space(stdout, labs(width) - 9);
  write_pch(stdout, " Expected", 9L);
  write_space(stdout, labs(width) - 8);
  write_pch(stdout, " Adjusted", 9L);
  write_space(stdout, labs(width) - 8);
  write_pch(stdout, " Standard", 9L);
  write_space(stdout, labs(width) - 8);
  write_pch(stdout, " -2Log(q)", 9L);
  write_space(stdout, labs(width) - 7);
  write_pch(stdout, " Freeman", 8L);
  write_space(stdout, labs(width) - 8);
  write_pch(stdout, " 2(/n-/m)", 9L);
  write_space(stdout, labs(width) - 8);
  write_pch(stdout, "    Power", 9L);
  write_line(stdout);
  write_line(stdout);
  memcpy(cell, first_cell, sizeof(t_cell));
  i = FIRST_INDEX;
  while (i <= last_index(a) && !interrupt_1) {
    if (*permuted)
      ii = marginal_hash(a, cell);
    else
      ii = i;
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, a)) {
	if (variable_description[v - MIN_VERTEX]->UU.U0.levels > 9)
	  write_integer(stdout, cell[v - MIN_VERTEX] - FIRST_LEVEL + 1L, 3L);
	else
	  write_integer(stdout, cell[v - MIN_VERTEX] - FIRST_LEVEL + 1L, 2L);
      }
    }
    if (em)
      write_real(stdout, n_total * compute_m_p_em(a, cell, model), width,
		 decexpt);
    else
      write_real(stdout, n_total * compute_m_p(a, cell, model), width,
		 decexpt);
    for (j = 8; j <= 13; j++) {
      write_char(stdout, ' ');
      x = return_table_value(a, j, a_set_offset, &n_total, ii, cell,
			     model_set_offset, model);
      if (is_infinity_real(x)) {
	write_space(stdout, labs(width) - 1);
	write_char(stdout, '-');
      } else
	write_real(stdout, x, width, print_dec);
    }
    write_line(stdout);
    if (*permuted)
      next_marginal_cell_list(*p_a, cell);
    else
      next_marginal_cell(a, cell);
    i++;
  }
  write_line(stdout);
  write_line(stdout);
}  /* print_list */


Static Void plot(a, x_type, y_type, log_x, log_y, x_set_offset, y_set_offset,
		 n_total, x_model_set_offset, x_model, y_model_set_offset,
		 y_model)
long *a;
t_long_integer *x_type, *y_type;
boolean *log_x, *log_y;
t_offset *x_set_offset, *y_set_offset;
t_long_real n_total;
t_offset *x_model_set_offset;
t_model **x_model;
t_offset *y_model_set_offset;
t_model **y_model;
{
  t_long_integer x_length, y_length;
  t_long_integer count_invalid = 0;
  t_long_integer i, j, x_i, y_i;
  t_cell cell;
  char plot[129][65];
  t_long_real x_start, x_stop, y_start, y_stop, x, y, x_delta, y_delta,
	      x_min = LONG_MAX;
  t_long_real x_max, y_min = LONG_MAX;
  t_long_real y_max;
  long FORLIM;

  if (mixed_data && ((*x_model)->id->model_type != pure_discrete ||
		     (*y_model)->id->model_type != pure_discrete))
    note_mixed(stdout, " Plot", 5L);
  memcpy(cell, first_cell, sizeof(t_cell));
  x_max = -x_min;
  y_max = -y_min;
  FORLIM = last_index(a);
  for (i = FIRST_INDEX; i <= FORLIM; i++) {
    x = return_table_value(a, *x_type, x_set_offset, &n_total, i, cell,
			   x_model_set_offset, x_model);
    y = return_table_value(a, *y_type, y_set_offset, &n_total, i, cell,
			   y_model_set_offset, y_model);
    if ((is_infinity_real(x) | is_infinity_real(y)) || x <= 0 && *log_x ||
	y <= 0 && *log_y)
      count_invalid++;
    else {
      if (*log_x)
	x = log_10(x);
      if (*log_y)
	y = log_10(y);
      if (x < x_min)
	x_min = x;
      if (x > x_max)
	x_max = x;
      if (y < y_min)
	y_min = y;
      if (y > y_max)
	y_max = y;
    }
    next_marginal_cell(a, cell);
  }
  if (x_min != x_max && y_min != y_max) {
    x_length = line_length - labs(print_width) - 4;
    y_length = page_length - 12;
    if (x_length >= 128)
      x_length = 128;
    if (y_length >= 64)
      y_length = 64;
    scale(x_min, x_max, x_length, &x_start, &x_stop, &x_delta, &x_length);
    scale(y_min, y_max, y_length, &y_start, &y_stop, &y_delta, &y_length);
    for (i = 0; i <= y_length; i++) {
      for (j = 0; j <= x_length; j++)
	plot[j][i] = 0;
    }
    memcpy(cell, first_cell, sizeof(t_cell));
    FORLIM = last_index(a);
    for (i = FIRST_INDEX; i <= FORLIM; i++) {
      x = return_table_value(a, *x_type, x_set_offset, &n_total, i, cell,
			     x_model_set_offset, x_model);
      y = return_table_value(a, *y_type, y_set_offset, &n_total, i, cell,
			     y_model_set_offset, y_model);
      if (!(((is_infinity_real(x) || x <= 0 && *log_x) | is_infinity_real(y)) ||
	    y <= 0 && *log_y)) {
	if (*log_x)
	  x = log_10(x);
	if (*log_y)
	  y = log_10(y);
	x_i = (long)floor((x - x_start) / x_delta + 0.5);
	y_i = (long)floor((y - y_start) / y_delta + 0.5);
	if (plot[x_i][y_i] < 127)
	  plot[x_i][y_i]++;
      }
      next_marginal_cell(a, cell);
    }
    page(stdout);
    write_line(stdout);
    write_pch(stdout, "  PLOT OF:  ", 12L);
    print_table_type(*y_type, *log_y);
    write_pch(stdout, " BY ", 4L);
    print_table_type(*x_type, *log_x);
    write_line(stdout);
    write_pch(stdout, "  PLOT", 6L);
    write_line(stdout);
    write_line(stdout);
    write_pch(stdout, " Unit horizontal:", 17L);
    write_pch(stdout, " - = ", 5L);
    write_real(stdout, x_delta, print_width, print_dec);
    write_line(stdout);
    write_pch(stdout, " Unit vertical:  ", 17L);
    write_pch(stdout, " ! = ", 5L);
    write_real(stdout, y_delta, print_width, print_dec);
    write_line(stdout);
    write_line(stdout);
    write_line(stdout);
    print_table_type(*y_type, *log_y);
    write_line(stdout);
    write_space(stdout, labs(print_width) + 2);
    write_char(stdout, '!');
    for (j = 0; j <= x_length; j++)
      write_char(stdout, '-');
    write_char(stdout, '!');
    write_line(stdout);
    for (i = y_length; i >= 0; i--) {
      write_space(stdout, 1L);
      write_real(stdout, delta_round(y_start + i * y_delta, i * y_delta),
		 print_width, print_dec);
      write_space(stdout, 1L);
      write_char(stdout, '!');
      for (j = 0; j <= x_length; j++) {
	if (plot[j][i] == 0)
	  write_char(stdout, ' ');
	else if (plot[j][i] == 1)
	  write_char(stdout, '*');
	else if (plot[j][i] < 10)
	  write_char(stdout, plot[j][i] - 1 + '1');
	else if (plot[j][i] < 35)
	  write_char(stdout, plot[j][i] - 10 + 'a');
	else if (plot[j][i] < 60)
	  write_char(stdout, plot[j][i] - 35 + 'A');
	else
	  write_char(stdout, '^');
      }
      write_char(stdout, '!');
      write_line(stdout);
    }
    write_space(stdout, labs(print_width) + 2);
    write_char(stdout, '!');
    for (j = 0; j <= x_length; j++) {
      if (j % labs(print_width) == 0)
	write_char(stdout, '+');
      else
	write_char(stdout, '-');
    }
    write_char(stdout, '!');
    write_line(stdout);
    write_space(stdout, print_dec + 4);
    FORLIM = (x_length + 1) / labs(print_width);
    for (j = 0; j <= FORLIM; j++) {
      if (char_count + labs(print_width) <= line_length)
	write_real(stdout,
		   delta_round(x_start + j * labs(print_width) * x_delta,
			       j * labs(print_width) * x_delta), print_width,
		   print_dec);
    }
    write_line(stdout);
    write_space(stdout, x_length);
    print_table_type(*x_type, *log_x);
    write_line(stdout);
    write_line(stdout);
    write_space(stdout, labs(print_width) + 2);
    write_pch(stdout, " EXCLUDED:", 10L);
    write_integer(stdout, count_invalid, print_width);
    write_line(stdout);
    write_line(stdout);
    return;
  }
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " One value constant ", 20L);
  write_line(stdout);
  write_line(stdout);
}  /* plot */


Local t_long_integer findpivot_(i, j)
t_long_integer *i, *j;
{
  long Result = -1;
  t_long_real firstkey;
  t_long_integer k;

  firstkey = p[*i];
  k = *i;
  while (k <= *j) {
    if (firstkey < p[k]) {
      Result = k;
      k = *j;
    } else if (p[k] < firstkey) {
      Result = *i;
      k = *j;
    }
    k++;
  }
  return Result;
}  /* findpivot */

Local Void swap_(x, y)
t_real *x, *y;
{
  t_real z;

  z = *x;
  *x = *y;
  *y = z;
}  /* swap */

Local t_long_integer partition_(l, r, pivot)
t_long_integer l, r;
t_long_real *pivot;
{
  do {
    swap_(&p[l], &p[r]);
    while (p[l] < *pivot)
      l++;
    while (p[r] >= *pivot)
      r--;
  } while (l <= r);
  return l;
}  /* partition */

Local Void quicksort_(i, j)
t_long_integer i, j;
{
  t_long_real pivot;
  t_long_integer pivotindex, k;

  pivotindex = findpivot_(&i, &j);
  if (pivotindex == -1)
    return;
  pivot = p[pivotindex];
  k = partition_(i, j, &pivot);
  quicksort_(i, k - 1);
  quicksort_(k, j);
}  /* quicksort */


/*@+"describe.p"*/


Static Void sort_p_array(min, max)
t_long_integer min, max;
{
  quicksort_(min, max);
}  /* sort_p_array */


/* Local variables for describe_table: */
struct LOC_describe_table {
  long *table_type;
  boolean *log_trans;
  FILE *x_file;
  boolean on_file;
} ;

/* Local variables for merge_: */
struct LOC_merge_ {
  FILE *f1, *f2;
  t_long_integer used[2];
  boolean finf[2];
  t_long_real current[2];
} ;

Local Void getrecord_(k, i, LINK)
t_long_integer *k, i;
struct LOC_merge_ *LINK;
{
  if ((LINK->used[i-1] == *k) | ((i == 1) & eof_real_file(LINK->f1)) |
      ((i == 2) & eof_real_file(LINK->f2)))
    LINK->finf[i-1] = true;
  else if (i == 1)
    read_real_file(LINK->f1, &LINK->current[i-1]);
  else
    read_real_file(LINK->f2, &LINK->current[1]);
  LINK->used[i-1]++;
}  /* getrecord */

Local Void merge_(k, f1_, f2_, g1, g2)
t_long_integer *k;
FILE *f1_, *f2_, *g1, *g2;
{
  struct LOC_merge_ Local_Var;
  boolean outswitch = true;
  t_long_integer winner;

  Local_Var.f1 = f1_;
  Local_Var.f2 = f2_;
  rewrite_real_file(g1);
  rewrite_real_file(g2);
  reset_real_file(Local_Var.f1);
  reset_real_file(Local_Var.f2);
  while ((!eof_real_file(Local_Var.f1)) | (!eof_real_file(Local_Var.f2))) {
    Local_Var.used[0] = 0;
    Local_Var.used[1] = 0;
    Local_Var.finf[0] = false;
    Local_Var.finf[1] = false;
    getrecord_(k, 1L, &Local_Var);
    getrecord_(k, 2L, &Local_Var);
    while (!Local_Var.finf[0] || !Local_Var.finf[1]) {
      if (Local_Var.finf[0])
	winner = 2;
      else if (Local_Var.finf[1])
	winner = 1;
      else if (Local_Var.current[0] < Local_Var.current[1])
	winner = 1;
      else
	winner = 2;
      if (outswitch)
	write_real_file(g1, Local_Var.current[winner-1]);
      else
	write_real_file(g2, Local_Var.current[winner-1]);
      getrecord_(k, winner, &Local_Var);
    }
    outswitch = !outswitch;
  }
}  /* merge */

Local Void init_(k, count, f, g1, g2)
t_long_integer k, count;
FILE *f, *g1, *g2;
{
  boolean outswitch = true;
  t_long_real x;
  t_long_integer i, j, min_index;
  long FORLIM;

  rewrite_real_file(g1);
  rewrite_real_file(g2);
  reset_real_file(f);
  if (k == 1) {
    FORLIM = count - count / 2;
    for (i = 1; i <= FORLIM; i++) {
      read_real_file(f, &x);
      write_real_file(g1, x);
    }
    for (i = 1; i <= count / 2; i++) {
      read_real_file(f, &x);
      write_real_file(g2, x);
    }
    return;
  }
  min_index = fpa - 1;
  while (!eof_real_file(f)) {
    i = 0;
    while (!eof_real_file(f) && i < k) {
      i++;
      read_real_file(f, &x);
      p[min_index + i] = x;
    }
    sort_p_array(min_index + 1, min_index + i);
    if (outswitch) {
      for (j = min_index + 1; j <= min_index + i; j++) {
	x = p[j];
	write_real_file(g1, x);
      }
    } else {
      for (j = min_index + 1; j <= min_index + i; j++) {
	x = p[j];
	write_real_file(g2, x);
      }
    }
    outswitch = !outswitch;
  }
}  /* init */

Local Void sort_x_file(x_file, a, b, LINK)
FILE *x_file;
t_long_integer *a, *b;
struct LOC_describe_table *LINK;
{
  pch_long file_name_f1, file_name_f2, file_name_g1, file_name_g2;
  FILE *f1 = NULL, *f2 = NULL, *g1 = NULL, *g2 = NULL;
  t_long_integer k;
  t_long_real x;
  boolean out_f = true;

  default_to_file_name(DEFAULT_TMP, file_name_f1);
  assign_real_file_write(&f1, file_name_f1, &tmp_count);
  default_to_file_name(DEFAULT_TMP, file_name_f2);
  assign_real_file_write(&f2, file_name_f2, &tmp_count);
  default_to_file_name(DEFAULT_TMP, file_name_g1);
  assign_real_file_write(&g1, file_name_g1, &tmp_count);
  default_to_file_name(DEFAULT_TMP, file_name_g2);
  assign_real_file_write(&g2, file_name_g2, &tmp_count);
  tmp_count -= 4;
  if (8 < max_p_cell_number - fpa)
    k = max_p_cell_number - fpa;
  else
    k = 1;
  init_(k, *b - *a + 1, x_file, f1, f2);
  while (k <= *b - *a) {
    out_f = !out_f;
    if (out_f) {
      reassign_real_file_write(&f1, file_name_f1);
      reassign_real_file_write(&f2, file_name_f2);
      merge_(&k, g1, g2, f1, f2);
    } else {
      reassign_real_file_write(&g1, file_name_g1);
      reassign_real_file_write(&g2, file_name_g2);
      merge_(&k, f1, f2, g1, g2);
    }
    k *= 2;
  }
  rewrite_real_file(x_file);
  if (out_f) {
    reset_real_file(f1);
    while (!eof_real_file(f1)) {
      read_real_file(f1, &x);
      write_real_file(x_file, x);
    }
  } else {
    reset_real_file(g1);
    while (!eof_real_file(g1)) {
      read_real_file(g1, &x);
      write_real_file(x_file, x);
    }
  }
  unlink_real_file(&f1, file_name_f1);
  unlink_real_file(&f2, file_name_f2);
  unlink_real_file(&g1, file_name_g1);
  unlink_real_file(&g2, file_name_g2);
  if (f1 != NULL)
    fclose(f1);
  if (f2 != NULL)
    fclose(f2);
  if (g1 != NULL)
    fclose(g1);
  if (g2 != NULL)
    fclose(g2);
}  /* sort_x_file */

Local Void plot_uniform(a, b, y_type, min, max, x_mean, x_variance, LINK)
t_long_integer *a, *b, y_type;
t_long_real *min, *max, *x_mean, *x_variance;
struct LOC_describe_table *LINK;
{
  char plot[129][65];
  t_long_integer count, x_length, y_length, i, j, x_i, y_i;
  t_long_real y_min, y_start, y_stop, y_delta, x, x_start, x_stop, delta;
  long FORLIM;

  count = *b - *a + 1;
  x_length = line_length - labs(print_width) - 4;
  y_length = page_length - 12;
  if (x_length >= 128)
    x_length = 128;
  if (y_length >= 64)
    y_length = 64;
  scale(*min, *max, x_length, &x_start, &x_stop, &delta, &x_length);
  if (y_type != 1) {
    if (y_type == 3)
      y_min = normal_percent_point_approx(0.5 / count);
    else
      y_min = normal_percent_point_approx(2.0 / (count * 3 + 1));
    if ((y_length & 1) != 0)
      y_length--;
    scale(0.0, -2 * y_min, y_length, &y_start, &y_stop, &y_delta, &y_length);
    if ((y_length & 1) != 0) {
      y_length++;
      y_start = y_length / -2.0 * y_delta;
      y_stop = y_length / 2.0 * y_delta;
    } else {
      y_start = -0.5 * y_stop;
      y_stop = 0.5 * y_stop;
    }
  }
  for (i = 0; i <= y_length; i++) {
    for (j = 0; j <= x_length; j++)
      plot[j][i] = 0;
  }
  if (LINK->on_file) {
    reset_real_file(LINK->x_file);
    for (i = *a; i <= *b; i++) {
      read_real_file(LINK->x_file, &x);
      x_i = (long)floor((x - x_start) / delta + 0.5);
      switch (y_type) {

      case 1:
	y_i = (long)floor(y_length * (i - *a + 1.0) / count + 0.5);
	break;

      case 2:
	y_i = (long)floor(
		y_length / (y_stop - y_start) * (normal_percent_point_approx(
		    ((i - *a + 1.0) * 3 - 1) / (count * 3 + 1)) - y_start) + 0.5);
	break;

      case 3:
	y_i = (long)floor(
		y_length / (y_stop - y_start) * (normal_percent_point_approx(
		    (i - *a + 0.5) / (*b - *a + 1)) - y_start) + 0.5);
	break;
      }
      if (plot[x_i][y_i] < 127)
	plot[x_i][y_i]++;
    }
  } else {
    for (i = *a; i <= *b; i++) {
      x_i = (long)floor((p[i] - x_start) / delta + 0.5);
      switch (y_type) {

      case 1:
	y_i = (long)floor(y_length * (i - *a + 1.0) / count + 0.5);
	break;

      case 2:
	y_i = (long)floor(
		y_length / (y_stop - y_start) * (normal_percent_point_approx(
		    ((i - *a + 1.0) * 3 - 1) / (count * 3 + 1)) - y_start) + 0.5);
	break;

      case 3:
	y_i = (long)floor(
		y_length / (y_stop - y_start) * (normal_percent_point_approx(
		    (i - *a + 0.5) / (*b - *a + 1)) - y_start) + 0.5);
	break;
      }
      if (plot[x_i][y_i] < 127)
	plot[x_i][y_i]++;
    }
  }
  page(stdout);
  write_line(stdout);
  switch (y_type) {

  case 1:
    write_pch(stdout, " Uniform plot", 13L);
    break;

  case 2:
    write_pch(stdout, " Rankit plot", 12L);
    break;

  case 3:
    write_pch(stdout, " Probit plot", 12L);
    break;
  }
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " Unit horizontal:", 17L);
  write_pch(stdout, " - = ", 5L);
  write_real(stdout, delta, print_width, print_dec);
  write_line(stdout);
  if (y_type > 1) {
    write_pch(stdout, " Unit vertical:  ", 17L);
    write_pch(stdout, " ! = ", 5L);
    write_real(stdout, y_delta, print_width, print_dec);
    write_line(stdout);
  }
  write_line(stdout);
  write_line(stdout);
  write_line(stdout);
  write_space(stdout, labs(print_width));
  write_char(stdout, '!');
  for (j = 0; j <= x_length; j++)
    write_char(stdout, '-');
  write_char(stdout, '!');
  write_line(stdout);
  for (i = y_length; i >= 0; i--) {
    write_space(stdout, 1L);
    if (y_type == 1)
      write_real(stdout, (double)i / y_length, print_width - 2,
		 print_width - 5);
    else
      write_real(stdout, delta_round(i * y_delta + y_start, i * y_delta),
		 labs(print_width) - 2, labs(print_width) - 5);
    write_space(stdout, 1L);
    write_char(stdout, '!');
    for (j = 0; j <= x_length; j++) {
      if (plot[j][i] == 0) {
	if (y_type != 1) {
	  if ((long)floor(((x_start + j * delta - *x_mean) / sqrt(*x_variance) -
			   y_start) / y_delta + 0.5) == i)
	    write_char(stdout, '+');
	  else
	    write_char(stdout, ' ');
	} else if ((long)floor((x_start - *min + j * delta) / (*max - *min) *
			       y_length + 0.5) == i)
	  write_char(stdout, '+');
	else
	  write_char(stdout, ' ');
      } else if (plot[j][i] == 1)
	write_char(stdout, '*');
      else if (plot[j][i] < 10)
	write_char(stdout, plot[j][i] - 1 + '1');
      else if (plot[j][i] < 35)
	write_char(stdout, plot[j][i] - 10 + 'a');
      else if (plot[j][i] < 60)
	write_char(stdout, plot[j][i] - 35 + 'A');
      else
	write_char(stdout, '^');
    }
    write_char(stdout, '!');
    write_line(stdout);
  }
  write_space(stdout, labs(print_width));
  write_char(stdout, '!');
  for (j = 0; j <= x_length; j++) {
    if (j % labs(print_width) == 0)
      write_char(stdout, '+');
    else
      write_char(stdout, '-');
  }
  write_char(stdout, '!');
  write_line(stdout);
  write_space(stdout, print_dec + 2);
  FORLIM = (x_length + 1) / labs(print_width);
  for (j = 0; j <= FORLIM; j++) {
    if (char_count + labs(print_width) <= line_length)
      write_real(stdout, delta_round(x_start + j * labs(print_width) * delta,
				     j * labs(print_width) * delta),
		 print_width, print_dec);
  }
  write_line(stdout);
  write_space(stdout, x_length + 3);
  print_table_type(*LINK->table_type, *LINK->log_trans);
  write_line(stdout);
  write_line(stdout);
}  /* plot_uniform */

Local Void plot_histogram(a, b, min, max, LINK)
t_long_integer *a, *b;
t_long_real *min, *max;
struct LOC_describe_table *LINK;
{
  t_integer cell[101];
  t_long_integer cell_factor;
  t_long_integer max_cell = 0;
  t_long_integer count, x_length, i, j, x_i;
  t_long_real x, x_start, x_stop, delta;
  long FORLIM1;

  count = *b - *a + 1;
  x_length = (long)floor(2 * sqrt((double)count) + 0.5);
  if (x_length > page_length - 12)
    x_length = page_length - 12;
  scale(*min, *max, x_length, &x_start, &x_stop, &delta, &x_length);
  for (i = 0; i <= x_length; i++)
    cell[i] = 0;
  if (LINK->on_file) {
    reset_real_file(LINK->x_file);
    for (i = *a; i <= *b; i++) {
      read_real_file(LINK->x_file, &x);
      x_i = (long)floor((x - x_start) / delta + 0.5);
      cell[x_i]++;
    }
  } else {
    for (i = *a; i <= *b; i++) {
      x_i = (long)floor((p[i] - x_start) / delta + 0.5);
      cell[x_i]++;
    }
  }
  while (cell[x_length] == 0)
    x_length--;
  for (i = 0; i <= x_length; i++) {
    if (cell[i] > max_cell)
      max_cell = cell[i];
  }
  page(stdout);
  write_line(stdout);
  write_pch(stdout, " Histogram", 10L);
  write_line(stdout);
  write_line(stdout);
  cell_factor = max_cell / (line_length - 20) + 1;
  write_pch(stdout, " Unit horizontal: ", 18L);
  write_pch(stdout, "* = ", 4L);
  write_integer(stdout, cell_factor, print_width);
  write_line(stdout);
  write_pch(stdout, " Unit vertical:   ", 18L);
  write_pch(stdout, "! = ", 4L);
  write_real(stdout, delta, print_width, print_dec);
  write_line(stdout);
  write_line(stdout);
  for (i = 0; i <= x_length; i++) {
    write_real(stdout, delta_round(x_start + i * delta, i * delta),
	       print_width, print_dec);
    write_pch(stdout, " ->  !  ", 8L);
    FORLIM1 = ceil_x((double)cell[i] / cell_factor);
    for (j = 1; j <= FORLIM1; j++)
      write_char(stdout, '*');
    write_line(stdout);
  }
  write_real(stdout, x_start + (x_length + 1) * delta, print_width, print_dec);
  write_line(stdout);
  write_line(stdout);
}  /* plot_histogram */

/* Local variables for describe_observations: */
struct LOC_describe_observations {
  struct LOC_describe_table *LINK;
} ;

Local t_long_real return_x(i, max, j, x_j, LINK)
t_long_integer i, max, *j;
t_long_real *x_j;
struct LOC_describe_observations *LINK;
{
  if (LINK->LINK->on_file) {
    if (i == *j)
      return (*x_j);
    else if (i == *j + 1) {
      (*j)++;
      if (eof_real_file(LINK->LINK->x_file))
	*x_j = _INVALID;
      else
	read_real_file(LINK->LINK->x_file, x_j);
      return (*x_j);
    } else
      _Escape(0);
  } else if (i <= max)
    return (p[i]);
  else if (i == max + 1)
    return _INVALID;
  else
    _Escape(0);
}  /* return_x */

Local Void describe_observations(a, b, LINK)
t_long_integer *a, *b;
struct LOC_describe_table *LINK;
{
  struct LOC_describe_observations Local_Var;
  t_long_integer i = 0;
  t_long_integer j, count, j_i, k, i1, i2;
  t_long_real x_k;

  Local_Var.LINK = LINK;
  page(stdout);
  write_line(stdout);
  write_pch(stdout, " Counts", 7L);
  write_line(stdout);
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "Cell      ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "Number of ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "Cumm.     ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "% of total", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "Cumm. %   ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_line(stdout);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "count     ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "cells with", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "number of ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "number of ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "          ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_line(stdout);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "          ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "count     ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "cells     ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "cells     ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "          ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_line(stdout);
  write_pch(stdout, " !", 2L);
  for (i1 = 1; i1 <= 5; i1++)
    write_pch(stdout, "------------!", 13L);
  write_line(stdout);
  count = *b - *a + 1;
  j = *a;
  k = j;
  if (LINK->on_file) {
    reset_real_file(LINK->x_file);
    read_real_file(LINK->x_file, &x_k);
  }
  while ((i <= 10 || (double)(j - *a) / count <= 0.40 || *b - 10 <= j ||
	  0.90 <= (double)(j - *a) / count) && j <= *b) {
    j_i = j;
    while ((long)floor(return_x(j, *b, &k, &x_k, &Local_Var) + 0.5) == i &&
	   j <= *b)
      j++;
    if (j - j_i != 0) {
      write_pch(stdout, " ! ", 3L);
      write_integer(stdout, i, 10L);
      write_pch(stdout, " ! ", 3L);
      write_integer(stdout, j - j_i, 10L);
      write_pch(stdout, " ! ", 3L);
      write_integer(stdout, j - *a, 10L);
      write_pch(stdout, " ! ", 3L);
      write_real(stdout, (double)(j - j_i) / count, 10L, print_dec);
      write_pch(stdout, " ! ", 3L);
      write_real(stdout, (double)(j - *a) / count, 10L, print_dec);
      write_pch(stdout, " ! ", 3L);
      write_line(stdout);
    }
    i++;
  }
  if ((double)(j - *a) / count < 0.90 && j < *b - 10) {
    for (i1 = 1; i1 <= 3; i1++) {
      for (i2 = 1; i2 <= 5; i2++) {
	write_pch(stdout, " ! ", 3L);
	write_space(stdout, 9L);
	write_pch(stdout, ".", 1L);
      }
      write_pch(stdout, " ! ", 3L);
      write_line(stdout);
    }
    j = *b - 10;
    if (LINK->on_file) {
      for (i = k + 1; i <= j; i++)
	read_real_file(LINK->x_file, &x_k);
      k = j;
    }
    i = (long)floor(return_x(j, *b, &k, &x_k, &Local_Var) + 0.5);
    while ((long)floor(return_x(j, *b, &k, &x_k, &Local_Var) + 0.5) == i)
      j++;
    i = (long)floor(return_x(j, *b, &k, &x_k, &Local_Var) + 0.5);
    while (j <= *b) {
      j_i = j;
      while ((long)floor(return_x(j, *b, &k, &x_k, &Local_Var) + 0.5) == i &&
	     j <= *b)
	j++;
      write_pch(stdout, " ! ", 3L);
      write_integer(stdout, i, 10L);
      write_pch(stdout, " ! ", 3L);
      write_integer(stdout, j - j_i, 10L);
      write_pch(stdout, " ! ", 3L);
      write_integer(stdout, j - *a, 10L);
      write_pch(stdout, " ! ", 3L);
      write_real(stdout, (double)(j - j_i) / count, 10L, print_dec);
      write_pch(stdout, " ! ", 3L);
      write_real(stdout, (double)(j - *a) / count, 10L, print_dec);
      write_pch(stdout, " ! ", 3L);
      write_line(stdout);
      if (j <= *b)
	i = (long)floor(return_x(j, *b, &k, &x_k, &Local_Var) + 0.5);
    }
  }
  write_pch(stdout, " !", 2L);
  for (i1 = 1; i1 <= 5; i1++)
    write_pch(stdout, "------------!", 13L);
  write_line(stdout);
  write_line(stdout);
  write_line(stdout);
}  /* describe_observations */

Local Void describe_statistics(a, b, min, max, mean, variance, LINK)
t_long_integer *a, *b;
t_long_real *min, *max, *mean, *variance;
struct LOC_describe_table *LINK;
{
  boolean harm = true;
  t_long_integer run = 1, max_run = 1, count_zero = 0;
  t_long_integer i, count, k1, k2, k3;
  t_long_real xk1a, xk1b, xk2a, xk2b, xk3a, xk3b, x_i, x;
  t_long_real x1 = 0.0, x2 = 0.0, x3 = 0.0, x4 = 0.0, xp = 1.0, xr = 0.0,
	      pred_p = -_INFINITY_REAL;
  t_long_real mode, skewness, kurtosis, geometric_, harmonic_, range;
  t_long_real sum = 0.0;
  long FORLIM;

  count = *b - *a + 1;
  k1 = (count + 2) / 4;
  k2 = (count + 1) / 2;
  k3 = (count + 1) * 3 / 4;
  range = *max - *min;
  if (LINK->on_file) {
    reset_real_file(LINK->x_file);
    for (i = *a; i <= *b; i++) {
      read_real_file(LINK->x_file, &x_i);
      sum += x_i - *min;
    }
  } else {
    for (i = *a; i <= *b; i++)
      sum += p[i] - *min;
  }
  *mean = *min + sum / count;
  if (LINK->on_file) {
    reset_real_file(LINK->x_file);
    FORLIM = *b - *a + 1;
    for (i = 1; i <= FORLIM; i++) {
      read_real_file(LINK->x_file, &x_i);
      if (fabs(x_i) <= ips_epsilon)
	count_zero++;
      if (x_i == pred_p) {
	run++;
	if (run > max_run) {
	  max_run = run;
	  mode = x_i;
	}
      } else
	run = 1;
      pred_p = x_i;
      if (i == k1)
	xk1a = x_i;
      else if (i == k1 + 1)
	xk1b = x_i;
      else if (i == k2)
	xk2a = x_i;
      else if (i == k2 + 1)
	xk2b = x_i;
      else if (i == k3)
	xk3a = x_i;
      else if (i == k3 + 1)
	xk3b = x_i;
      x = x_i - *mean;
      x1 += x;
      x2 += x * x;
      x3 += x * x * x;
      x4 += x * x * x * x;
      if (fabs(x_i) < 1 / _INFINITY_REAL)
	xp = 0.0;
      else if (fabs(xp) < _INFINITY_REAL / (fabs(x_i) + 1))
	xp *= x_i;
      else
	xp = 0.0;
      if (fabs(x_i) > 1 / _INFINITY_REAL)
	xr += 1 / x_i;
      else
	harm = false;
    }
  } else {
    xk1a = p[*a + k1 - 1];
    xk1b = p[*a + k1];
    xk2a = p[*a + k2 - 1];
    xk2b = p[*a + k2];
    xk3a = p[*a + k3 - 1];
    xk3b = p[*a + k3];
    for (i = *a; i <= *b; i++) {
      if (fabs(p[i]) <= ips_epsilon)
	count_zero++;
      if (p[i] == pred_p) {
	run++;
	if (run > max_run) {
	  max_run = run;
	  mode = p[i];
	}
      } else
	run = 1;
      pred_p = p[i];
      x = p[i] - *mean;
      x1 += x;
      x2 += x * x;
      x3 += x * x * x;
      x4 += x * x * x * x;
      if (fabs(p[i]) < 1 / _INFINITY_REAL)
	xp = 0.0;
      else if (fabs(xp) < _INFINITY_REAL / (fabs(p[i]) + 1))
	xp *= p[i];
      else
	xp = 0.0;
      if (fabs(p[i]) > 1 / _INFINITY_REAL)
	xr += 1 / p[i];
      else
	harm = false;
    }
  }
  *variance = x2 / count;
  skewness = x3 / count / exp(3.0 / 2 * log(x2 / count));
  kurtosis = x4 / count / exp(2 * log(x2 / count));
  if (xp != 0)
    geometric_ = exp(log(fabs(xp)) / count) * fabs(xp) / xp;
  else
    geometric_ = 0.0;
  if (harm)
    harmonic_ = count / xr;
  else
    harmonic_ = 0.0;
  write_line(stdout);
  write_pch(stdout, " Statistics", 11L);
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " Number of values:", 18L);
  write_integer(stdout, count, 5L);
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " 25%:  ", 7L);
  write_pch(stdout, " Rank: ", 7L);
  write_integer(stdout, k1, 5L);
  write_pch(stdout, " VALUE: ", 8L);
  write_real(stdout, xk1a, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Rank: ", 7L);
  write_integer(stdout, k1 + 1, 5L);
  write_pch(stdout, " VALUE: ", 8L);
  write_real(stdout, xk1b, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " 50%:  ", 7L);
  write_pch(stdout, " Rank: ", 7L);
  write_integer(stdout, k2, 5L);
  write_pch(stdout, " VALUE: ", 8L);
  write_real(stdout, xk2a, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Rank: ", 7L);
  write_integer(stdout, k2 + 1, 5L);
  write_pch(stdout, " VALUE: ", 8L);
  write_real(stdout, xk2b, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " 75%:  ", 7L);
  write_pch(stdout, " Rank: ", 7L);
  write_integer(stdout, k3, 5L);
  write_pch(stdout, " VALUE: ", 8L);
  write_real(stdout, xk3a, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Rank: ", 7L);
  write_integer(stdout, k3 + 1, 5L);
  write_pch(stdout, " VALUE: ", 8L);
  write_real(stdout, xk3b, print_width, print_dec);
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " Minimum: ", 10L);
  write_real(stdout, *min, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Maximum: ", 10L);
  write_real(stdout, *max, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Range:   ", 10L);
  write_real(stdout, range, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " Max RUN: ", 10L);
  write_integer(stdout, max_run, print_width);
  write_space(stdout, 3L);
  write_pch(stdout, " Mode:    ", 10L);
  if (max_run > 1)
    write_real(stdout, mode, print_width, print_dec);
  else {
    write_space(stdout, labs(print_width) - 1);
    write_char(stdout, '-');
  }
  write_space(stdout, 3L);
  write_pch(stdout, " # < Eps.:", 10L);
  write_integer(stdout, count_zero, print_width);
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " Sum  (X)   :       ", 20L);
  write_real(stdout, sum + count * *min, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Mean:              ", 20L);
  write_real(stdout, *mean, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " Sum  (1/X) :       ", 20L);
  if (harm)
    write_real(stdout, xr, print_width, print_dec);
  else {
    write_space(stdout, labs(print_width) - 1);
    write_char(stdout, '-');
  }
  write_space(stdout, 3L);
  write_pch(stdout, " Harmonic Mean:     ", 20L);
  if (harm)
    write_real(stdout, harmonic_, print_width, print_dec);
  else {
    write_space(stdout, labs(print_width) - 1);
    write_char(stdout, '-');
  }
  write_line(stdout);
  write_pch(stdout, " Prod (X)   :       ", 20L);
  write_real(stdout, xp, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Geometric Mean:    ", 20L);
  write_real(stdout, geometric_, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " Sum (X-Mean)^2 :   ", 20L);
  write_real(stdout, x2, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Variance:          ", 20L);
  write_real(stdout, *variance, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " Sum (X-Mean)^3 :   ", 20L);
  write_real(stdout, x3, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Skewness:          ", 20L);
  write_real(stdout, skewness, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " Sum (X-Mean)^4 :   ", 20L);
  write_real(stdout, x4, print_width, print_dec);
  write_space(stdout, 3L);
  write_pch(stdout, " Kurtosis:          ", 20L);
  write_real(stdout, kurtosis, print_width, print_dec);
  write_line(stdout);
  write_line(stdout);
}  /* describe_statistics */


Static Void describe_table(a, table_type_, uniform, rankit, probit,
			   log_trans_, a_set_offset, n_total,
			   model_set_offset, model)
long *a;
t_long_integer *table_type_;
boolean *uniform, *rankit, *probit, *log_trans_;
t_offset *a_set_offset;
t_long_real n_total;
t_offset *model_set_offset;
t_model **model;
{
  struct LOC_describe_table Local_Var;
  t_long_integer i, min_index, max_index;
  t_cell cell;
  t_long_real x, min, max, mean, variance;
  pch_long file_name;
  long FORLIM;

  Local_Var.table_type = table_type_;
  Local_Var.log_trans = log_trans_;
  Local_Var.x_file = NULL;
  if (mixed_data && *Local_Var.table_type != 0) {
    if ((*model)->id->model_type != pure_discrete)
      note_mixed(stdout, " DescribeTable", 14L);
  }
  memcpy(cell, first_cell, sizeof(t_cell));
  if (last_index(a) >= max_p_cell_number - fpa) {
    write_pch(stdout, " (On file)", 10L);
    write_line(stdout);
    min_index = 1;
    max_index = 0;
    Local_Var.on_file = true;
#ifndef NO_REAL_FILE
    default_to_file_name(DEFAULT_TMP, file_name);
    assign_real_file_write(&Local_Var.x_file, file_name, &tmp_count);
    rewrite_real_file(Local_Var.x_file);
    min = _INFINITY_REAL;
    max = -min;
    FORLIM = last_index(a);
    for (i = FIRST_INDEX; i <= FORLIM; i++) {
      x = return_table_value(a, *Local_Var.table_type, a_set_offset, &n_total,
			     i, cell, model_set_offset, model);
      if (!is_infinity_real(x)) {
	if (*Local_Var.log_trans) {
	  if (x > 0) {
	    x = log_10(x);
	    if (x < min)
	      min = x;
	    if (x > max)
	      max = x;
	    max_index++;
	    write_real_file(Local_Var.x_file, x);
	  }
	} else {
	  if (x < min)
	    min = x;
	  if (x > max)
	    max = x;
	  max_index++;
	  write_real_file(Local_Var.x_file, x);
	}
      }
      if (*Local_Var.table_type != 0)
	next_marginal_cell(a, cell);
    }
    sort_x_file(Local_Var.x_file, &min_index, &max_index, &Local_Var);
#endif /*  NO_REAL_FILE */
  } else {
    Local_Var.on_file = false;
    min_index = fpa;
    max_index = min_index - 1;
    FORLIM = last_index(a);
    for (i = FIRST_INDEX; i <= FORLIM; i++) {
      x = return_table_value(a, *Local_Var.table_type, a_set_offset, &n_total,
			     i, cell, model_set_offset, model);
      if (!is_infinity_real(x)) {
	if (*Local_Var.log_trans) {
	  if (x > 0) {
	    max_index++;
	    p[max_index] = log_10(x);
	  }
	} else {
	  max_index++;
	  p[max_index] = x;
	}
      }
      if (*Local_Var.table_type != 0)
	next_marginal_cell(a, cell);
    }
    sort_p_array(min_index, max_index);
    min = p[min_index];
    max = p[max_index];
  }
  page(stdout);
  write_line(stdout);
  write_pch(stdout, " Describe table:         ", 25L);
  print_table_type(*Local_Var.table_type, *Local_Var.log_trans);
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " Number of cells in table:    ", 30L);
  write_integer(stdout, marginal_dimension(a), print_width);
  write_line(stdout);
  write_pch(stdout, " Number of invalid cells:     ", 30L);
  write_integer(stdout, marginal_dimension(a) - max_index + min_index - 1,
		print_width);
  write_line(stdout);
  write_pch(stdout, " Number of cells to describe: ", 30L);
  write_integer(stdout, max_index - min_index + 1, print_width);
  write_line(stdout);
  if ((max_index - min_index + 1) / (line_length / labs(print_width)) /
      page_length < 2) {
    write_line(stdout);
    write_line(stdout);
    write_pch(stdout, " Sorted list", 12L);
    write_line(stdout);
    write_line(stdout);
    if (Local_Var.on_file) {
#ifndef NO_REAL_FILE
      reset_real_file(Local_Var.x_file);
      for (i = min_index + 1; i <= max_index + 1; i++) {
	read_real_file(Local_Var.x_file, &x);
	write_real(stdout, x, print_width, print_dec);
	if ((i - min_index) % (line_length / labs(print_width)) == 0)
	  write_line(stdout);
      }
#endif /* NO_REAL_FILE */
    } else {
      for (i = min_index; i <= max_index; i++) {
	write_real(stdout, p[i], print_width, print_dec);
	if ((i - min_index + 1) % (line_length / labs(print_width)) == 0)
	  write_line(stdout);
      }
    }
    write_line(stdout);
  }
  write_line(stdout);
  if (max > min && max_index >= min_index) {
    describe_statistics(&min_index, &max_index, &min, &max, &mean, &variance,
			&Local_Var);
    if (*uniform)
      plot_uniform(&min_index, &max_index, 1L, &min, &max, &mean, &variance,
		   &Local_Var);
    if (*rankit)
      plot_uniform(&min_index, &max_index, 2L, &min, &max, &mean, &variance,
		   &Local_Var);
    if (*probit)
      plot_uniform(&min_index, &max_index, 3L, &min, &max, &mean, &variance,
		   &Local_Var);
    plot_histogram(&min_index, &max_index, &min, &max, &Local_Var);
  }
  if (*Local_Var.table_type == 0 && !*Local_Var.log_trans)
    describe_observations(&min_index, &max_index, &Local_Var);
#ifndef NO_REAL_FILE
  if (Local_Var.on_file)
    unlink_real_file(&Local_Var.x_file, file_name);
  if (Local_Var.x_file != NULL)
    fclose(Local_Var.x_file);
#endif /* NO_REAL_FILE */
}  /* describe_table */


/*@-"readdata.c"*/
/*@+"readsel.p"*/


/*

2243:    +++  ++
2244:    +++  ++
2245:    ---  -- p/readsel.p         15      54     802 p/readsel.p
2246: |    4:    procedure insert_name_in_name_list
2247: |   15:    procedure insert_vertex_and_name_in_name_list
2248: |   30:    procedure note_select
2249: |   58:    procedure revers_vertex_name_list
2250: |   72:    procedure dispose_vertex_name_list
2251: |   83:    procedure test_long_vertex_names
2252: |  112:    procedure select_datastructure
2253: |  300:    procedure set_read_subset_argument
2254: |  460:    procedure set_read_all
2255: |  465:    procedure proc_set_read_subset
2256: |  488:    procedure get_cell_list
2257: |  531:    procedure proc_select_reject
2258: |  563:    procedure read_cutpoint
2259: |  611:    procedure proc_enter_cutpoints
2260: |  681:    procedure skip_missing
2261:    +++  ++
2262:    +++  ++

*/


Static Void insert_name_in_name_list(v, name_list)
t_vertex *v;
t_vertex_name_list **name_list;
{
  t_vertex_name_list *p;

  p = (t_vertex_name_list *)Malloc(sizeof(t_vertex_name_list));
  if (p == NULL)
    _OutMem();
  p->vertex = *v;
  p->pointer = *name_list;
  *name_list = p;
}  /* insert_name_in_name_list */


Static Void insert_vertex_and_name_in_name_list(v, length, name, name_list)
t_vertex *v;
t_integer length;
Char *name;
t_vertex_name_list **name_list;
{
  t_vertex_name_list *p;

  p = (t_vertex_name_list *)Malloc(sizeof(t_vertex_name_list));
  if (p == NULL)
    _OutMem();
  p->vertex = *v;
  p->length = length;
  memcpy(p->name, name, sizeof(pch_long));
  p->pointer = *name_list;
  *name_list = p;
}  /* insert_vertex_and_name_in_name_list */


Static Void note_select(p1, p2)
t_long_real p1, p2;
{
  if (datastructure == list_file && p1 * 3 <= max_cell_number) {
    write_pch(stdout, " Choos datastructure or CoCo", 28L);
    write_pch(stdout, " will use computer-time", 23L);
    write_line(stdout);
    write_pch(stdout, " to do it when reading observations.", 36L);
    write_line(stdout);
    write_pch(stdout, " (if more than", 14L);
    write_integer(stdout, (long)floor(p1 / N_LIMIT_T / dimension + 0.5), 8L);
    write_pch(stdout, " cases then use SET DATASTRUCTURE NECESSARY",
		43L);
    write_line(stdout);
    write_pch(stdout, " between READ SPECIFICATION and READ OBSERVATIONS)",
		50L);
    write_line(stdout);
  }
  if (datastructure == all || p2 > max_cell_number)
    return;
  write_pch(stdout, " If model-search is going to be performed then use",
	      50L);
  write_line(stdout);
  write_pch(stdout, " SET DATASTRUCTURE ALL before READ OBSERVATIONS.",
	      48L);
  write_line(stdout);
}  /* note_select */


Static Void revers_vertex_name_list(p)
t_vertex_name_list **p;
{
  t_vertex_name_list *hp1 = NULL;
  t_vertex_name_list *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_vertex_name_list */


Static Void dispose_vertex_name_list(p)
t_vertex_name_list **p;
{
  t_vertex_name_list *q;

  while (*p != NULL) {
    q = (*p)->pointer;
    _Free(*p);
    *p = q;
  }
}  /* dispose_vertex_name_list */


Static Void test_long_vertex_names()
{
  t_vertex_name_list *p_name_list, *q_name_list;
  t_integer i, count;

  q_name_list = full_name_list;
  while (q_name_list != NULL) {
    p_name_list = full_name_list;
    count = 0;
    while (p_name_list != NULL) {
      i = 1;
      while (q_name_list->name[i - PCH_START] ==
	     p_name_list->name[i - PCH_START] && i < p_name_list->length &&
	     i < q_name_list->length)
	i++;
      if (i == p_name_list->length && i == q_name_list->length &&
	  q_name_list->name[i - PCH_START] == p_name_list->name[i - PCH_START])
	count++;
      p_name_list = p_name_list->pointer;
    }
    if (count > 1) {
      write_pch(stdout, " Not unique factor name: `", 26L);
      write_pch(stdout, q_name_list->name, q_name_list->length);
      write_char(stdout, '\'');
      write_line(stdout);
    }
    q_name_list = q_name_list->pointer;
  }
}  /* test_long_vertex_names */


Static Void select_datastructure(init_select)
boolean init_select;
{
  t_vertex v;
  t_continuous_vertex w;
  t_discrete_vertex u;
  t_long_real p1 = 1.0, p2 = 1.0, p3 = 1.0, p4 = 1.0;
  t_vertex_name name;
  t_vertex_name_list *q_name_list;
  short TEMP;

  dispose_all_models();
  fna = N_START - FIRST_INDEX;
  fpa = P_START - FIRST_INDEX;
  /* first_vertex := min_vertex; */
  P_setcpy(full_names, empty_name_set);
  for (TEMP = MIN_NAME; TEMP <= MAX_NAME; TEMP++) {
    name = TEMP;
    full_name_to_vertex[name - MIN_NAME] = MAX_VERTEX;
    name_to_vertex[name - MIN_NAME] = MAX_VERTEX;
  }
  if (long_names) {
    if (mixed_data)
      note_mixed(stdout, " LongNames          ", 10L);
    test_long_vertex_names();

    dispose_vertex_name_list(&name_list);
    q_name_list = full_name_list;
    while (q_name_list != NULL) {
      insert_vertex_and_name_in_name_list(&q_name_list->vertex,
	q_name_list->length, q_name_list->name, &name_list);
      q_name_list = q_name_list->pointer;
    }
    revers_vertex_name_list(&name_list);

    dispose_vertex_name_list(&discrete_name_list);
    q_name_list = full_name_list;
    v = first_vertex;
    while (q_name_list != NULL) {
      if (full_variable_description[q_name_list->vertex - MIN_VERTEX]->
	  variable_type == discrete) {
	insert_vertex_and_name_in_name_list(&v, q_name_list->length,
	  q_name_list->name, &discrete_name_list);
	v++;
      }
      q_name_list = q_name_list->pointer;
    }
    revers_vertex_name_list(&discrete_name_list);

    dispose_vertex_name_list(&continuous_name_list);
    q_name_list = full_name_list;
    v = first_vertex;
    while (q_name_list != NULL) {
      if (full_variable_description[q_name_list->vertex - MIN_VERTEX]->
	  variable_type == continuous) {
	insert_vertex_and_name_in_name_list(&v, q_name_list->length,
	  q_name_list->name, &continuous_name_list);
	v++;
      }
      q_name_list = q_name_list->pointer;
    }

    revers_vertex_name_list(&continuous_name_list);
  }
  P_setcpy(full_delta, empty_set);
  P_setcpy(full_gamma, empty_set);
  full_last_discrete_vertex = first_discrete_vertex;
  full_last_continuous_vertex = first_continuous_vertex;
  for (v = first_vertex; v <= full_last_vertex; v++) {
    full_variable_description[v - MIN_VERTEX]->stratum = 0;
    if (full_variable_description[v - MIN_VERTEX]->variable_type == continuous) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2252L, 1L)) {
	write_pch(stdout, " Defined to continuous: ", 24L);
	print_full_vertex_on_file(stdout, v, 0L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      P_addset(full_gamma, v);
      variable_description[v - MIN_VERTEX] =
	full_variable_description[v - MIN_VERTEX];
      w = full_last_continuous_vertex;
      full_last_continuous_vertex++;
      full_to_continuous[v - MIN_VERTEX] = w;
      to_continuous[v - MIN_VERTEX] = w;
      full_to_discrete[v - MIN_VERTEX] = first_vertex;
      to_discrete[v - MIN_VERTEX] = first_vertex;
      full_continuous_variable_description[w - MIN_VERTEX] =
	full_variable_description[v - MIN_VERTEX];
      continuous_variable_description[w - MIN_VERTEX] =
	full_continuous_variable_description[w - MIN_VERTEX];
    } else {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2252L, 1L)) {
	write_pch(stdout, " Defined to discrete: ", 22L);
	print_full_vertex_on_file(stdout, v, 0L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      P_addset(full_delta, v);
      if (init_select)
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels +=
	  full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing;
      full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total =
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels;
      full_variable_description[v - MIN_VERTEX]->UU.U0.ordinal = false;
      variable_description[v - MIN_VERTEX] =
	full_variable_description[v - MIN_VERTEX];
      u = full_last_discrete_vertex;
      full_last_discrete_vertex++;
      full_to_continuous[v - MIN_VERTEX] = first_vertex;
      to_continuous[v - MIN_VERTEX] = first_vertex;
      full_to_discrete[v - MIN_VERTEX] = u;
      to_discrete[v - MIN_VERTEX] = u;
      full_discrete_variable_description[u - MIN_VERTEX] =
	full_variable_description[v - MIN_VERTEX];
      discrete_variable_description[u - MIN_VERTEX] =
	full_discrete_variable_description[u - MIN_VERTEX];
      /* full_last_cell[u] := (first_level - 1 +
                              full_discrete_variable_description[u]^.levels); */
      last_cell[u - MIN_VERTEX] = FIRST_LEVEL +
	  full_discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels - 1;
      first_cell[u - MIN_VERTEX] = FIRST_LEVEL;
      p1 *= discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels;
      p2 *= discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels + 1;
      p3 *= discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels -
	  discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels_missing;
      p4 *= discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels -
	    discrete_variable_description[u - MIN_VERTEX]->
	    UU.U0.levels_missing + 1;
    }
    if (P_inset(full_variable_description[v - MIN_VERTEX]->name, full_names) &&
	!long_names) {
      write_pch(stdout, " Warning: Duplicated name: ", 27L);
      write_char(stdout, full_variable_description[v - MIN_VERTEX]->name);
      write_line(stdout);
    }
    P_addset(full_names, full_variable_description[v - MIN_VERTEX]->name);
    full_name_to_vertex[full_variable_description[v - MIN_VERTEX]->name -
			MIN_NAME] = v;
    name_to_vertex[full_variable_description[v - MIN_VERTEX]->name - MIN_NAME] = v;
  }
  full_last_discrete_vertex--;
  full_last_continuous_vertex--;
  hash_overflow = (p1 > max_cell_number);
  last_vertex = full_last_vertex;
  last_discrete_vertex = full_last_discrete_vertex;
  last_continuous_vertex = full_last_continuous_vertex;
  P_setcpy(delta, full_delta);
  P_setcpy(gamma_, full_gamma);
  P_setunion(delta_gamma, delta, gamma_);
  P_setcpy(full_delta_gamma, delta_gamma);
  P_setunion(subset, delta, gamma_);
  P_addsetr(P_expset(discrete_subset, 0L), first_vertex, last_discrete_vertex);
  P_addsetr(P_expset(continuous_subset, 0L), first_vertex,
	    last_continuous_vertex);
  P_setcpy(names, full_names);
  full_dimension = full_last_vertex - first_vertex + 1;
  dimension = full_dimension;
  init_half_sqr_array((long)dimension);
  /* explanatory := empty_set;
     full_explanatory := empty_set;
     response := empty_set;
     full_response := empty_set; */
  link_select = NULL;
  link_reject = NULL;
  reject_missing = false;
  read_subset = false;
  if (p2 <= max_cell_number && dimension <= MAX_FIND_ALL)
    datastructure = all;
  else if (p1 * 3 <= max_cell_number && p1 <= N_LIMIT * N_LIMIT_T * dimension)
    datastructure = necessary;
  else
    datastructure = list_file;
#ifdef CoCo_Cygwin
#ifdef NO_LEVEL_FILE
  if (datastructure == list_file || datastructure == both) {
    datastructure = necessary; /* !?!?!? */
  }
#endif
#endif /* CoCo_Cygwin */
#ifdef CoCo_Cygwin
#ifdef NO_LEVEL_FILE
  if (datastructure == list_file || datastructure == both) {
    datastructure = necessary; /* !?!?!? */
  }
#endif
#endif /* CoCo_Cygwin */
  if (term && diary)
    write_line_diary();
  note_select(p1, p2);
}  /* select_datastructure */


Static Void set_read_subset_argument(a)
long *a;
{
  t_vertex v, x;
  t_continuous_vertex w, y;
  t_discrete_vertex u, z;
  t_long_real p1 = 1.0, p2 = 1.0, p3 = 1.0, p4 = 1.0;
  t_vertex_name_list *q_name_list;

  P_setcpy(ordinal_factors, empty_set);
  ordinal_tests = false;
  P_setcpy(subset, a);
  dispose_all_models();
  dispose_set_list(&g_c_q_tables);
  dispose_offset_list(&q_tables_offsets);
  g_c_q_tables = NULL;
  q_tables_offsets = NULL;
  incomplete_table = false;
  fqa = Q_START - FIRST_INDEX;
  read_obs = false;
  note_command_end_line(stdout);
  fna = N_START - FIRST_INDEX;
  fpa = P_START - FIRST_INDEX;
  P_setcpy(names, empty_name_set);
  if (long_names) {
    if (mixed_data)
      note_mixed(stdout, " LongNames          ", 10L);

    v = first_vertex;
    dispose_vertex_name_list(&name_list);
    q_name_list = full_name_list;
    while (q_name_list != NULL) {
      if (P_inset(q_name_list->vertex, subset)) {
	insert_vertex_and_name_in_name_list(&v, q_name_list->length,
					    q_name_list->name, &name_list);
	v++;
      }
      q_name_list = q_name_list->pointer;
    }
    revers_vertex_name_list(&name_list);

    v = first_vertex;
    dispose_vertex_name_list(&discrete_name_list);
    q_name_list = full_name_list;
    while (q_name_list != NULL) {
      if (P_inset(q_name_list->vertex, subset)) {
	if (full_variable_description[q_name_list->vertex - MIN_VERTEX]->
	    variable_type == discrete) {
	  insert_vertex_and_name_in_name_list(&v, q_name_list->length,
	    q_name_list->name, &discrete_name_list);
	  v++;
	}
      }
      q_name_list = q_name_list->pointer;
    }
    revers_vertex_name_list(&discrete_name_list);

    v = first_vertex;
    dispose_vertex_name_list(&continuous_name_list);
    q_name_list = full_name_list;
    while (q_name_list != NULL) {
      if (P_inset(q_name_list->vertex, subset)) {
	if (full_variable_description[q_name_list->vertex - MIN_VERTEX]->
	    variable_type == continuous) {
	  insert_vertex_and_name_in_name_list(&v, q_name_list->length,
	    q_name_list->name, &continuous_name_list);
	  v++;
	}
      }
      q_name_list = q_name_list->pointer;
    }

    revers_vertex_name_list(&continuous_name_list);
  }
  x = first_vertex;
  y = first_vertex;
  z = first_vertex;
  last_discrete_vertex = first_vertex;
  last_continuous_vertex = first_vertex;
  P_setcpy(delta, empty_set);
  P_setcpy(gamma_, empty_set);
  P_setcpy(discrete_subset, empty_set);
  P_setcpy(continuous_subset, empty_set);
  for (v = first_vertex; v <= full_last_vertex; v++) {
    if (P_inset(v, subset)) {
      variable_description[x - MIN_VERTEX] =
	full_variable_description[v - MIN_VERTEX];
      if (full_variable_description[v - MIN_VERTEX]->variable_type ==
	  continuous) {
	P_addset(gamma_, x);
	w = last_continuous_vertex;
	last_continuous_vertex++;
	to_continuous[x - MIN_VERTEX] = w;
	to_discrete[x - MIN_VERTEX] = first_vertex;
	continuous_variable_description[w - MIN_VERTEX] =
	  full_variable_description[v - MIN_VERTEX];
	P_addset(continuous_subset, y);
      } else {
	P_addset(delta, x);
	u = last_discrete_vertex;
	last_discrete_vertex++;
	to_continuous[x - MIN_VERTEX] = first_vertex;
	to_discrete[x - MIN_VERTEX] = u;
	discrete_variable_description[u - MIN_VERTEX] =
	  full_variable_description[v - MIN_VERTEX];
	last_cell[u - MIN_VERTEX] = FIRST_LEVEL +
	    discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels - 1;
	first_cell[u - MIN_VERTEX] = FIRST_LEVEL;
	P_addset(discrete_subset, z);
	p1 *= discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels;
	p2 *= discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels + 1;
	p3 *= discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels -
	      discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels_missing;
	p4 *= discrete_variable_description[u - MIN_VERTEX]->UU.U0.levels -
	      discrete_variable_description[u - MIN_VERTEX]->
	      UU.U0.levels_missing + 1;
      }
      if (P_inset(variable_description[v - MIN_VERTEX]->name, names) &&
	  !long_names) {
	write_pch(stdout, " Warning: Duplicated name: ", 27L);
	write_char(stdout, variable_description[v - MIN_VERTEX]->name);
	write_line(stdout);
      }
      P_addset(names, variable_description[x - MIN_VERTEX]->name);
      name_to_vertex[variable_description[x - MIN_VERTEX]->name - MIN_NAME] = x;
      x++;
    }
    if (P_inset(v, full_gamma))
      y++;
    if (P_inset(v, full_delta))
      z++;
  }
  last_vertex = x - 1;
  last_discrete_vertex--;
  last_continuous_vertex--;
  hash_overflow = (p1 > max_cell_number);
  P_setunion(delta_gamma, delta, gamma_);
  dimension = last_vertex - first_vertex + 1;
  link_select = NULL;
  link_reject = NULL;
  reject_missing = false;
  read_subset = true;
  if (p2 <= max_cell_number && dimension <= MAX_FIND_ALL)
    datastructure = all;
  else if (p1 * 3 <= max_cell_number && p1 <= N_LIMIT * N_LIMIT_T * dimension)
    datastructure = necessary;
  else
    datastructure = list_file;
  if (term && diary)
    write_line_diary();
  note_select(p1, p2);
}  /* set_read_subset_argument */


Static Void set_read_all()
{
  select_datastructure(false);
}  /* set_read_all */


Static Void proc_set_read_subset(command_file, as_argument, ifail, sub_code,
				 arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex_set a;
  t_integer i = PCH_START;

  if (*sub_code == 1) {
    select_datastructure(false);
    return;
  }
  P_setcpy(a, empty_set);
  if (get_vertex_set(command_file, true, true, true, as_argument, &i, ifail,
		     sub_code, arg_pos, nargs, arg_char, " SET->", 6L,
		     subset, a))
    set_read_subset_argument(a);
}  /* proc_set_read_subset */


Static Void get_cell_list(command_file, as_argument, ifail, sub_code,
			  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int,
			  do_dispose, cell_list)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
boolean do_dispose;
t_cell_list **cell_list;
{
  t_cell_list *r;
  t_vertex_list *p;
  t_integer x, i = PCH_START;
  Char c;
  boolean dummy_ok;
  t_cell_list *WITH;

  if (do_dispose)
    dispose_cell_list(cell_list);
  r = (t_cell_list *)Malloc(sizeof(t_cell_list));
  if (r == NULL)
    _OutMem();
  r->pointer = *cell_list;
  *cell_list = r;
  WITH = *cell_list;
  WITH->vertex_list = NULL;
  dummy_ok = get_vertex_list(command_file, true, true, true, as_argument, &i,
			     ifail, sub_code, arg_pos_char, nargs, arg_char,
			     " Set->", 6L, &WITH->vertex_list,
			     &WITH->vertex_list);
  if (WITH->vertex_list == NULL)
    return;
  revers_vertex_list(&WITH->vertex_list);
  p = WITH->vertex_list;
  i = 0;
  while (p != NULL && *ifail == 0) {
    get_next_level(command_file, stdout, true, true, true, as_argument, &i,
		   ifail, sub_code, arg_pos_int, nargs, arg_int, " Level->",
		   8L, &x, &c, MAX_LEVEL, p->vertex);
    WITH->cell[p->vertex - MIN_VERTEX] = FIRST_LEVEL + x - 1;
    p = p->pointer;
  }
}  /* get_cell_list */


Static Void proc_select_reject(command_file, as_argument, ifail, sub_code,
			       arg_pos_char, arg_pos_int, nargs, arg_char,
			       arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  switch (*sub_code) {

  case 96:
    get_cell_list(command_file, as_argument, ifail, sub_code, arg_pos_char,
		  arg_pos_int, nargs, arg_char, arg_int, true, &link_select);
    break;

  case 97:
    get_cell_list(command_file, as_argument, ifail, sub_code, arg_pos_char,
		  arg_pos_int, nargs, arg_char, arg_int, false, &link_select);
    break;

  case 98:
    get_cell_list(command_file, as_argument, ifail, sub_code, arg_pos_char,
		  arg_pos_int, nargs, arg_char, arg_int, true, &link_reject);
    break;

  case 99:
    get_cell_list(command_file, as_argument, ifail, sub_code, arg_pos_char,
		  arg_pos_int, nargs, arg_char, arg_int, false, &link_reject);
    break;
  }
  if (link_reject != NULL) {
    if (link_reject->pointer == NULL && link_reject->vertex_list == NULL)
      dispose_cell_list(&link_reject);
  }
}  /* proc_select_reject */


Static Void read_cutpoint(fil, c, ok)
FILE *fil;
Char *c;
boolean *ok;
{
  t_vertex v;
  t_integer i;
  t_long_real x;
  boolean do_read_cutpoints;

  read_vertex(fil, false, false, true, &v);
  if (full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total == 0)
    i = 0;
  else if (full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total == 1)
    i = 1;
  else
    i = 2;
  *c = ' ';
  *ok = true;
  if (cutpoints[v - MIN_VERTEX] != NULL) {
    do_read_cutpoints = false;
    write_pch(stdout, " Ignoring cutpoint for factor `", 31L);
    print_full_vertex_on_file(stdout, v, 0L);
    write_pch(stdout, "' on datafile", 13L);
    write_line(stdout);
  } else
    do_read_cutpoints = true;
  while (i <= full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total &&
	 *ok) {
    read_real_separator(fil, false, false, "1234567890", 0L, &x, c);
    if (x != _INVALID && x != MISSING && x != _UNDEF) {
      if (do_read_cutpoints)
	insert_real_in_real_list(x, &cutpoints[v - MIN_VERTEX]);
      i++;
      continue;
    }
    *ok = false;
    if (*c == 'C' || *c == 'c')
      write_pch(stdout, " To few cutpoints for factor `", 30L);
    else
      write_pch(stdout, " Invalid cutpoint for factor `", 30L);
    print_full_vertex_on_file(stdout, v, 0L);
    write_pch(stdout, "' on datafile", 13L);
    write_line(stdout);
  }
  /* if do_read_cutpoints and ok then
       discrete_cutpoints[full_to_discrete[v]] := cutpoints[v] */
}  /* read_cutpoint */


Static Void proc_enter_cutpoints(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_double, nargs, arg_char, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_double;
long **nargs;
Char **arg_char;
double **arg_double;
{
  boolean eod = false;
  t_vertex v;
  t_integer i = PCH_START;
  t_integer j;
  t_long_real x;
  t_real_list *p;
  long FORLIM;

  v = first_vertex;
  if (*sub_code == -1) {
    *sub_code = 1;
    if (!get_vertex(command_file, true, true, true, as_argument, &i, ifail,
		    sub_code, arg_pos_char, nargs, arg_char, " Factor->", 9L,
		    &v, &v)) {
      set_ifail(ifail, 80L);
      return;
    }
    if (cutpoints[v - MIN_VERTEX] == NULL) {
      set_ifail(ifail, 81L);
      return;
    }
    *sub_code = -1;
    j = 0;
    p = cutpoints[v - MIN_VERTEX];
    FORLIM = full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total;
    for (i = 1; i < FORLIM; i++) {
      get_next_long_real(command_file, as_argument, &j, ifail, sub_code,
			 arg_pos_double, nargs, arg_double, "", 0L,
			 &p->x);
      p = p->pointer;
    }
    return;
  }
  if (!get_vertex(command_file, true, true, true, as_argument, &i, ifail,
		  sub_code, arg_pos_char, nargs, arg_char, " Factor->", 9L,
		  &v, &v))
    return;
  if (cutpoints[v - MIN_VERTEX] != NULL)
    dispose_real_list(&cutpoints[v - MIN_VERTEX]);
  j = 0;
  FORLIM = full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total;
  for (i = 1; i < FORLIM; i++) {
    do {
      write_pch(stdout, " Cutpoint(", 10L);
      print_full_vertex_on_file(stdout, v, 0L);
      write_char(stdout, ',');
      write_integer(stdout, i, 3L);
      write_pch(stdout, ")-> ", 4L);
      x = _INVALID;
      get_next_long_real(command_file, as_argument, &j, ifail, sub_code,
			 arg_pos_double, nargs, arg_double, " Point.->", 9L,
			 &x);
      if (is_invalid_real(x))
	write_pch(stdout, " Invalid  ", 10L);
      else
	write_real(stdout, x, 10L, 3L);
      write_line(stdout);
      if (!as_argument)
	eod = eof_command(command_file);
    } while (is_invalid_real(x) && *ifail == 0 && !eod);
    insert_real_in_real_list(x, &cutpoints[v - MIN_VERTEX]);
  }
  /* discrete_cutpoints[full_to_discrete[v]] := cutpoints[v] */
}  /* proc_enter_cutpoints */


Static Void skip_missing()
{
  t_vertex v;

  reject_missing = true;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, delta)) {
      variable_description[v - MIN_VERTEX]->UU.U0.levels =
	variable_description[v - MIN_VERTEX]->UU.U0.levels_total -
	variable_description[v - MIN_VERTEX]->UU.U0.levels_missing;
      last_cell[v - MIN_VERTEX] =
	FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1;
    }
  }
}  /* skip_missing */


/*@+"readini.p"*/


/*

2263:    +++  ++
2264:    +++  ++
2265:    ---  -- p/readini.p         15      58     662 p/readini.p
2266: |    4:    function hash
2267: |   18:    procedure init_datastructure
2268: |   73:    procedure close_datastructure
2269: |  138:    function cell_equal
2270: |  161:    function include
2271: |  195:    function include_mixed
2272: |  202:    function space_for_saturated_q_table
2273: |  224:    procedure insert_structural_zero_cell
2274: |  246:    procedure clear_structural_zero_cell
2275: |  264:    procedure insert_cases
2276: |  325:    procedure new_item
2277: |  343:    procedure insert_mixed_cases
2278: |  375:    procedure test_zero_data
2279: |  383:    procedure note
2280: |  433:    procedure clean_data
2281:    +++  ++
2282:    +++  ++

*/


Static t_cell_index hash(i)
t_level *i;
{
  t_cell_index sum = FIRST_INDEX, product = 1;
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    sum += (i[v - MIN_VERTEX] - FIRST_LEVEL) * product;
    product *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
  }
  return sum;
}  /* hash */


Static Void init_datastructure()
{
  t_long_integer i;
  t_vertex v;
  t_long_real p1;
  long FORLIM;

  if (exclude_missing)
    do_exclude(empty_set);
#ifdef CoCo_Cygwin
#ifdef NO_LEVEL_FILE
  if (datastructure == list_file || datastructure == both) {
    datastructure = necessary; /* !?!?!? */
  }
#endif
#endif /* CoCo_Cygwin */
  if (mixed_data) {
    n[0] = 0;
    if (!datastructure_selected)
      datastructure = list_file;
    else
      note_mixed(stdout, " InitDatastructure", 18L);
  } else {
    if (!datastructure_selected && datastructure != all) {
      p1 = 1.0;
      for (v = first_vertex; v <= last_vertex; v++)
	p1 *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
      if (p1 * 3 <= max_cell_number)
	datastructure = both;
    }
    n[0] = 0;
    if (datastructure == list_file || datastructure == both) {
      number_of_cells = 0;
      if (file_read_set) {
	reassign_tmp_level_file_write(&file_read, file_name_read);
	rewrite_level_file(file_read);
      } else {
	default_to_file_name(DEFAULT_TMP, file_name_read);
	assign_tmp_level_write(&file_read, file_name_read, &tmp_count);
	default_to_file_name(DEFAULT_TMP, file_name_excluded);
	assign_tmp_level_write(&file_excluded, file_name_excluded, &tmp_count);
	file_read_set = true;
      }
    }
    if (datastructure == all || datastructure == necessary ||
	datastructure == both) {
      number_of_cells = marginal_dimension(delta);
      fna = N_START - FIRST_INDEX + number_of_cells;
      if (number_of_cells < max_cell_number) {
	FORLIM = FIRST_INDEX + number_of_cells;
	for (i = FIRST_INDEX; i <= FORLIM; i++)
	  n[i] = 0;
      }
      if (dimension <= MAX_OFFSET_DIM)
	offset[(int)((long)floor(exp(log(2.0) * dimension) + 0.5)) - 1] =
	  N_START - FIRST_INDEX;
      offset[0] = -FIRST_INDEX;
    }
  }
  dispose_all_expressions();
  dispose_tests();
  dispose_marginals();
}  /* init_datastructure */


Static Void close_datastructure()
{
  boolean dummy_ok;
  t_long_integer dummy;
  t_vertex v;
  t_long_real p1, t1, t2, t3, t4;
  t_vertex_set dummy_set;

  if (mixed_data) {
    datastructure = list_file;
    dispose_marginals();
    item_list = item_list_read;
  } else {
    if (datastructure == both) {
      p1 = 1.0;
      for (v = first_vertex; v <= last_vertex; v++)
	p1 *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
      if (p1 <= n[0] * N_LIMIT_T * dimension / 1000)
	datastructure = necessary;
      else if (p1 >= n[0] * N_LIMIT_T * dimension * 1000)
	datastructure = list_file;
      else {
	t1 = my_clock()/1;
	datastructure = necessary;
	dispose_marginals();
	P_addset(P_expset(dummy_set, 0L), first_vertex);   /* empty_set + */
	dummy = find_marginal(dummy_set, &dummy_ok);
	t2 = my_clock()/1;
	write_line(stdout);
	write_pch(stdout, " Time(NECESSARY):   ", 20L);
	write_real(stdout, (t2 - t1) / 1000, 10L, 3L);
	write_pch(stdout, "secs.", 5L);
	t3 = my_clock()/1;
	datastructure = list_file;
	dispose_marginals();
	fna = N_START - FIRST_INDEX + number_of_cells;
	dummy = find_marginal(dummy_set, &dummy_ok);
	t4 = my_clock()/1;
	write_line(stdout);
	write_pch(stdout, " Time(FILE):        ", 20L);
	write_real(stdout, (t4 - t3) / 1000, 10L, 3L);
	write_pch(stdout, "secs.", 5L);
	if (t2 - t1 < t4 - t3)
	  datastructure = necessary;
      }
      if (datastructure == necessary) {
	reassign_tmp_level_file_write(&file_read, file_name_read);
	rewrite_level_file(file_read);
      } else
	number_of_cells = 0;
      dispose_marginals();
    }
    space_for_case_list = (n[0] < max_cases_in_list_var);
    if (space_for_case_list && datastructure == list_file) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2268L, 1L)) {
	write_pch(stdout, " Making CASE-LIST   ", 20L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      make_case_list();
    }
  }
  if (!mixed_data)
    return;
  exclude_missing = true;
  if (n[0] == 1)
    do_exclude(delta_gamma);
  else
    new_print_do_exclude(delta_gamma, &global_write_options->line_form);
}  /* close_datastructure */


Static boolean cell_equal(i, link)
t_level *i;
t_cell_list **link;
{
  boolean ok = true;
  t_vertex_list *link_vertex;
  t_vertex v;
  t_cell_list *WITH;

  WITH = *link;
  link_vertex = WITH->vertex_list;
  while (ok && link_vertex != NULL) {
    v = link_vertex->vertex;
    ok = (i[v - MIN_VERTEX] == WITH->cell[v - MIN_VERTEX] ||
	  (i[v - MIN_VERTEX] >
	   FIRST_LEVEL + full_variable_description[v - MIN_VERTEX]->
	     UU.U0.levels_total - full_variable_description[v - MIN_VERTEX]->
				  UU.U0.levels_missing - 1 &&
	   WITH->cell[v - MIN_VERTEX] == MISSING_LEVEL));
    link_vertex = link_vertex->pointer;
  }
  return ok;
}  /* cell_equal */


Static boolean include(i)
t_level *i;
{
  boolean ok;
  t_vertex v;
  t_cell_list *link;

  if (link_select != NULL) {
    ok = false;
    link = link_select;
    while (!ok && link != NULL) {
      ok = cell_equal(i, &link);
      link = link->pointer;
    }
  } else
    ok = true;
  link = link_reject;
  while (ok && link != NULL) {
    ok = !cell_equal(i, &link);
    link = link->pointer;
  }
  if (!reject_missing)
    return ok;
  for (v = first_vertex; v <= full_last_vertex; v++) {
    if (P_inset(v, subset)) {
      if (P_inset(v, full_delta))
	ok = (ok &&
	    i[v - MIN_VERTEX] <=
	    FIRST_LEVEL + full_variable_description[v - MIN_VERTEX]->
	      UU.U0.levels_total - full_variable_description[v - MIN_VERTEX]->
				   UU.U0.levels_missing - 1);
      else
	ok = (ok && i[v - MIN_VERTEX] != MISSING_LEVEL);
    }
  }
  return ok;
}  /* include */


Static boolean include_mixed(i)
t_level *i;
{
  /* ;
                         var j : t_integer_vector;
                         var x : t_real_vector */
  return (include(i));
}  /* include_mixed */


Static boolean space_for_saturated_q_table(q)
t_offset_list **q;
{
  t_q_cell_index index;
  boolean ok = true;
  t_q_cell_index FORLIM;

  if (!TURBO_PC)
    ok = space_in_q_array(marginal_dimension(delta), fqa);
  if (last_index(delta) > max_q_cell_number - fqa)
    return false;
  incomplete_table = true;
  insert_set_minimal(delta, &g_c_q_tables);
  insert_offset(delta, fqa, &q_tables_offsets);
  *q = q_tables_offsets;
  fqa += marginal_dimension(delta);
  FORLIM = (*q)->offset + last_index(delta);
  for (index = (*q)->offset; index <= FORLIM; index++) {
    q_array[index] = 1;
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  }
  return ok;
}  /* space_for_saturated_q_table */


Static Void insert_structural_zero_cell(i)
t_level *i;
{
  t_offset_list *q;
  boolean ok = true;

  if (incomplete_table) {
    q = q_tables_offsets;
    while (q->pointer != NULL && !P_setequal(q->vertex_set, delta))
      q = q->pointer;
    if (!P_setequal(q->vertex_set, delta))
      ok = space_for_saturated_q_table(&q);
  } else
    ok = space_for_saturated_q_table(&q);
  if (ok)
    q_array[q->offset + hash(i)] = 0;
  else {
    write_pch(stdout, " Structural table to large. ", 28L);
    write_line(stdout);
  }
}  /* insert_structural_zero_cell */


Static Void clear_structural_zero_cell(i)
t_level *i;
{
  t_offset_list *q;

  q = q_tables_offsets;
  while (q->pointer != NULL && !P_setequal(q->vertex_set, delta))
    q = q->pointer;
  if (P_setequal(q->vertex_set, delta)) {
    q_array[q->offset + hash(i)] = 1;
    return;
  }
  if (space_for_saturated_q_table(&q))
    q_array[q->offset + hash(i)] = 1;
  else {
    write_pch(stdout, " Structural table to large. ", 28L);
    write_line(stdout);
  }
}  /* clear_structural_zero_cell */


Static Void insert_cases_(i, count)
t_level *i;
t_cell_count count;
{
  t_cell_count j;
  t_vertex v, w;
  t_cell ii;

  /* writeln('InsertCases'); */
  if (!include(i))
    return;
  /* else writeln('% Include'); */
  if (datastructure == all || datastructure == necessary ||
      datastructure == both) {
    if (read_subset) {
      w = first_vertex;
      for (v = first_vertex; v <= full_last_vertex; v++) {
	if (P_inset(v, subset)) {
	  ii[w - MIN_VERTEX] = i[v - MIN_VERTEX];
	  w++;
	}
      }
      if (count != STRUCT_ZERO_COUNT) {
	if (incomplete_table) {
	  if (n[N_START - FIRST_INDEX + hash(ii)] == 0)
	    clear_structural_zero_cell(ii);
	}
	n[N_START - FIRST_INDEX + hash(ii)] += count;
      } else if (n[N_START - FIRST_INDEX + hash(ii)] == 0)
	insert_structural_zero_cell(ii);
    } else if (count != STRUCT_ZERO_COUNT)
      n[N_START - FIRST_INDEX + hash(i)] += count;
    else
      insert_structural_zero_cell(i);
  }
  if (datastructure == list_file || datastructure == both) {
    for (j = 1; j <= count; j++) {
      for (v = first_vertex; v <= full_last_vertex; v++) {
	if (P_inset(v, subset))
	  write_level_file(file_read, i[v - MIN_VERTEX]);
      }
    }
  }
  /*
  if (datastructure = list_file) or (datastructure = both) then begin
     if (count = struct_zero_count) and (datastructure = list_file) then
        if read_subset then begin
           w := first_vertex;
           for v := first_vertex to full_last_vertex  do
              if v in subset then begin
                 ii[w] := i[v];
                 w := succ(w)
              end;
        end
        else
           insert_structural_zero_cell(i)
        else
           for j := 1 to count do
              for v := first_vertex to full_last_vertex  do
                 if v in subset then
                    write_level_file(file_read, i[v])
  end; */
  if (count != STRUCT_ZERO_COUNT)
    n[0] += count;
}  /* insert_cases */


Static Void new_item(i, x, link_item)
t_level *i;
float *x;
t_item_list **link_item;
{
  t_item_list *p;
  t_vertex v;

  p = (t_item_list *)Malloc(sizeof(t_item_list));
  if (p == NULL)
    _OutMem();
  p->pointer = *link_item;
  *link_item = p;
  (*link_item)->item.integer_vector = (t_level *)Malloc(sizeof(t_integer_vector));
  if ((*link_item)->item.integer_vector == NULL)
    _OutMem();
  for (v = first_vertex; v <= last_discrete_vertex; v++)
    (*link_item)->item.integer_vector[v - MIN_VERTEX] = i[v - MIN_VERTEX];
  (*link_item)->item.real_vector = (float *)Malloc(sizeof(t_real_vector));
  if ((*link_item)->item.real_vector == NULL)
    _OutMem();
  for (v = first_vertex; v <= last_continuous_vertex; v++)
    (*link_item)->item.real_vector[v - MIN_VERTEX] = x[v - MIN_VERTEX];
}  /* new_item */


Static Void insert_mixed_cases(i, j, x, count)
t_level *i;
t_level *j;
float *x;
t_cell_count count;
{
  t_vertex v, w;
  t_integer_vector j_;
  t_real_vector x_;

  if (!include_mixed(i))   /* , j, x */
    return;
  if (read_subset) {
    w = first_vertex;
    for (v = first_vertex; v <= full_last_discrete_vertex; v++) {
      if (P_inset(v, discrete_subset)) {
	j_[w - MIN_VERTEX] = j[v - MIN_VERTEX];
	w++;
      }
    }
    w = first_vertex;
    for (v = first_vertex; v <= full_last_continuous_vertex; v++) {
      if (P_inset(v, continuous_subset)) {
	x_[w - MIN_VERTEX] = x[v - MIN_VERTEX];
	w++;
      }
    }
    new_item(j_, x_, &item_list_read);
  } else
    new_item(j, x, &item_list_read);
  if (count != STRUCT_ZERO_COUNT)
    n[0] += count;
}  /* insert_mixed_cases */


/* Local variables for test_zero_data: */
struct LOC_test_zero_data {
  boolean noted;
} ;

Local Void note(LINK)
struct LOC_test_zero_data *LINK;
{
  if (LINK->noted)
    return;
  LINK->noted = true;
  write_pch(stdout, " *** WARNING *** Obs. in ZeroCells.  Use", 40L);
  write_pch(stdout, " `clean data' *** WARNING *** ", 30L);
  write_line(stdout);
}  /* note */


Static Void test_zero_data()
{
  struct LOC_test_zero_data Local_Var;
  t_long_integer index, case_number;
  t_cell i;
  t_vertex v;
  t_case_list *p_case_list;
  long FORLIM;

  if (mixed_data)
    note_mixed(stdout, " TestZeroData", 13L);
  Local_Var.noted = false;
  if (case_list != NULL) {
    p_case_list = case_list;
    for (index = 1; index <= n[0]; index++) {
      if (zero_cell(p_case_list->cell, q_tables_offsets))
	note(&Local_Var);
      p_case_list = p_case_list->pointer;
    }
    return;
  }
  if (datastructure == list_file && !exclude_missing) {
    reset_level_file(file_read);
    for (case_number = 1; case_number <= n[0]; case_number++) {
      for (v = first_vertex; v <= last_vertex; v++)
	read_level_file(file_read, &i[v - MIN_VERTEX]);
      if (zero_cell(i, q_tables_offsets))
	note(&Local_Var);
    }
    return;
  }
  if (datastructure == list_file && exclude_missing) {
    reset_level_file(file_excluded);
    for (case_number = 1; case_number <= n[0]; case_number++) {
      for (v = first_vertex; v <= last_vertex; v++) {
	if (P_inset(v, delta_missing_excluded))
	  read_level_file(file_excluded, &i[v - MIN_VERTEX]);
      }
      if (zero_cell(i, q_tables_offsets))
	note(&Local_Var);
    }
    return;
  }
  memcpy(i, first_cell, sizeof(t_cell));
  FORLIM = last_index(delta);
  for (index = FIRST_INDEX; index <= FORLIM; index++) {
    if (zero_cell(i, q_tables_offsets) && n[N_START + index] != 0)
      note(&Local_Var);
    next_cell(i);
  }
}  /* test_zero_data */


Static Void clean_data()
{
  pch_long file_name;
  t_long_integer index, case_number;
  FILE *x_file = NULL;
  t_vertex v;
  t_cell i;
  boolean ok;
  t_case_list *p_case_list, *q_case_list;
  long FORLIM;

  if (mixed_data)
    note_mixed(stdout, " CleanData", 10L);
  if (!mixed_data) {
    dispose_all_expressions();
    dispose_tests();
    default_to_file_name(DEFAULT_TMP, file_name);
    assign_tmp_level_write(&x_file, file_name, &tmp_count);
    if (datastructure == list_file && !exclude_missing) {
      dispose_case_list(&case_list_read);
      case_list = NULL;
      reset_level_file(file_read);
      rewrite_level_file(x_file);
      for (case_number = 1; case_number <= n[0]; case_number++) {
	for (v = first_vertex; v <= last_vertex; v++)
	  read_level_file(file_read, &i[v - MIN_VERTEX]);
	if (zero_cell(i, q_tables_offsets))
	  n[0]--;
	else {
	  for (v = first_vertex; v <= last_vertex; v++)
	    write_level_file(x_file, i[v - MIN_VERTEX]);
	}
      }
      reassign_tmp_level_file_write(&file_read, file_name_read);
      rewrite_level_file(file_read);
      reset_level_file(x_file);
      for (case_number = 1; case_number <= n[0]; case_number++) {
	for (v = first_vertex; v <= last_vertex; v++) {
	  read_level_file(x_file, &i[v - MIN_VERTEX]);
	  write_level_file(file_read, i[v - MIN_VERTEX]);
	}
      }
      if (space_for_case_list) {
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 2280L, 1L)) {
	  write_pch(stdout, " Making CASE-LIST   ", 20L);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	make_case_list();
      }
    } else if (datastructure == list_file && exclude_missing &&
	       case_list_excluded != NULL) {
      q_case_list = case_list_excluded;
      case_list = NULL;
      while (q_case_list != NULL) {
	if (zero_cell(q_case_list->cell, q_tables_offsets))
	  n[0]--;
	else {
	  p_case_list = (t_case_list *)Malloc(sizeof(t_case_list));
	  if (p_case_list == NULL)
	    _OutMem();
	  p_case_list->pointer = case_list;
	  memcpy(p_case_list->cell, q_case_list->cell, sizeof(t_cell));
	  case_list = p_case_list;
	}
	q_case_list = q_case_list->pointer;
      }
      dispose_case_list(&case_list_excluded);
      case_list_excluded = case_list;
    } else if (datastructure == list_file && exclude_missing) {
      reset_level_file(file_excluded);
      rewrite_level_file(x_file);
      for (case_number = 1; case_number <= n[0]; case_number++) {
	for (v = first_vertex; v <= last_vertex; v++) {
	  if (P_inset(v, delta_missing_excluded))
	    read_level_file(file_excluded, &i[v - MIN_VERTEX]);
	}
	if (zero_cell(i, q_tables_offsets))
	  n[0]--;
	else {
	  for (v = first_vertex; v <= last_vertex; v++)
	    write_level_file(x_file, i[v - MIN_VERTEX]);
	}
      }
      reassign_tmp_level_file_write(&file_excluded, file_name_excluded);
      rewrite_level_file(file_excluded);
      reset_level_file(x_file);
      for (case_number = 1; case_number <= n[0]; case_number++) {
	for (v = first_vertex; v <= last_vertex; v++) {
	  if (P_inset(v, delta_missing_excluded)) {
	    read_level_file(x_file, &i[v - MIN_VERTEX]);
	    write_level_file(file_excluded, i[v - MIN_VERTEX]);
	  }
	}
      }
    } else {
      memcpy(i, first_cell, sizeof(t_cell));
      FORLIM = last_index(delta);
      for (index = FIRST_INDEX; index <= FORLIM; index++) {
	if (zero_cell(i, q_tables_offsets)) {
	  n[0] -= n[N_START + index];
	  n[N_START + index] = 0;
	}
	next_cell(i);
      }
    }
    if (datastructure == all) {
      if (TURBO_PC)
	write_pch(stdout, " WAIT !! -", 10L);
      write_pch(stdout, " Finding all marginals.  ", 25L);
      if (exclude_missing)
	fna = N_START - FIRST_INDEX + number_of_cells +
	      marginal_dimension(delta_missing_excluded);
      else
	fna = N_START - FIRST_INDEX + number_of_cells;
      find_all_marginals(&ok);
    } else
      dispose_marginals();
  } else
    note_mixed(stdout, " CleanDATA", 10L);
  if (x_file != NULL)
    fclose(x_file);
}  /* clean_data */


/*@+"readspe.p"*/


/*

2283:    +++  ++
2284:    +++  ++
2285:    ---  -- p/readspe.p          4      18     212 p/readspe.p
2286: |    4:    procedure read_factors
2287: |  127:    procedure enter_names
2288: |  308:    procedure read_names
2289: |  445:    procedure proc_redefine_factor
2290:    +++  ++
2291:    +++  ++

*/


Static Void read_factors(f)
FILE *f;
{
  t_vertex v;
  Char c;
  /* i_: t_integer; */
  t_level i;

  for (v = first_vertex; v <= last_vertex; v++)
    dispose_real_list(&cutpoints[v - MIN_VERTEX]);
  read_spec = true;
  read_obs = false;
  em = false;
  exclude_missing = false;
  term = (terminal || !strncmp(command_name, spec_name, sizeof(pch_long)));
  v = first_vertex;
  long_names = false;
  dispose_vertex_name_list(&full_name_list);
  do {
    seek_non_blank_data(f, false, false, &c);
    if (c == ':') {
      if (!long_names && v != first_vertex) {
	write_pch(stdout, " First factor name must start with `:', ", 40L);
	write_pch(stdout, "if long names are to be used.", 29L);
	write_line(stdout);
      } else
	long_names = true;
    }
    if (c != '/' && c != ';') {
      full_variable_description[v - MIN_VERTEX] =
	(t_variable_description_node *)Malloc(sizeof(t_variable_description_node));
      if (full_variable_description[v - MIN_VERTEX] == NULL)
	_OutMem();
      full_variable_description[v - MIN_VERTEX]->long_name = NULL;
      if (long_names) {
	if (c == ':')
	  read_char_data(f, &c);
	insert_name_in_name_list(&v, &full_name_list);
	i = 1;
	full_name_list->name[i - PCH_START] = c;
	full_variable_description[v - MIN_VERTEX]->name = c;
	while ((c != ' ' && c != ':' && c != '/' && c != ';') &
	       (!eolnorf_data(f))) {
	  read_char_data(f, &c);
	  i++;
	  full_name_list->name[i - PCH_START] = c;
	}
	if (eolnorf_data(f) && c != ' ' && c != ':' && c != '/' && c != ';')
	  full_name_list->length = i;
	else
	  full_name_list->length = i - 1;
	while (eolnnotf_data(f))
	  read_line_data_plus(f);
      } else
	full_variable_description[v - MIN_VERTEX]->name = c;
      read_level(f, &i, &c);
      if (i == MISSING_LEVEL) {
	full_variable_description[v - MIN_VERTEX]->variable_type = continuous;
	full_variable_description[v - MIN_VERTEX]->UU.missing_values = false;
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 2286L, 1L)) {
	  write_pch(stdout, " Defined to continuous: ", 24L);
	  print_full_vertex_on_file(stdout, v, 0L);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	mixed_data = true;
      } else {
	full_variable_description[v - MIN_VERTEX]->variable_type = discrete;
	if (i == _UNDEF_LEVEL || i == _INVALID_LEVEL) {
	  write_pch(stdout, " Invalid number of levels at ", 29L);
	  print_full_vertex_on_file(stdout, v, 0L);
	  full_variable_description[v - MIN_VERTEX]->UU.U0.levels = 0;
	  write_line(stdout);
	} else
	  full_variable_description[v - MIN_VERTEX]->UU.U0.levels = i;
      }
      if (c != '/' && c != ';') {
	if ((c == '*' &&
	     full_variable_description[v - MIN_VERTEX]->variable_type !=
	     continuous) || c == '.')
	  i = 1;
	else {
	  read_level(f, &i, &c);
	  if (i == _UNDEF_LEVEL)
	    i = 0;
	  else if (i == _INVALID_LEVEL) {
	    write_pch(stdout, " Invalid missing count at ", 26L);
	    print_full_vertex_on_file(stdout, v, 0L);
	    write_line(stdout);
	    i = 0;
	  } else if (i == MISSING_LEVEL)
	    i = 1;
	}
	if (full_variable_description[v - MIN_VERTEX]->variable_type ==
	    continuous)
	  full_variable_description[v - MIN_VERTEX]->UU.missing_values = (i != 0);
	else
	  full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing = i;
	while (c != '/' && c != ';') {
	  if (eolnnotf_data(f))
	    read_line_data_plus(f);
	  else if (eof_data(f))
	    c = '/';
	  else
	    read_char_data(f, &c);
	}
      } else
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing = 0;
      c = ' ';
      v++;
    }
  } while (c != '/' && c != ';' && v <= MAX_VERTEX);
  full_last_vertex = v - 1;
  revers_vertex_name_list(&full_name_list);
  if (c == '/' || c == ';')
    select_datastructure(true);
  else
    write_pch(stdout, " Too many factors", 17L);
}  /* read_factors */


Static Void enter_names(arg_pos_char, arg_pos_int, nargs, arg_char, arg_int,
			ifail)
t_integer arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
t_integer *ifail;
{
  t_vertex v;
  t_integer i = PCH_START;
  t_integer j, length_names, n_levels, n_missing;
  t_level levels;
  Char c;

  if (!(ok_char_arg(ifail, arg_pos_char, 0L, nargs, arg_char) &
	ok_int_arg(ifail, arg_pos_int, 3L, nargs, arg_int)))
    return;
  length_names = (*arg_int)[0];
  n_levels = (*arg_int)[1];
  n_missing = (*arg_int)[2];
  for (v = first_vertex; v <= last_vertex; v++)
    dispose_real_list(&cutpoints[v - MIN_VERTEX]);
  read_spec = true;
  read_obs = false;
  em = false;
  exclude_missing = false;
  v = first_vertex;
  long_names = false;
  dispose_vertex_name_list(&full_name_list);
  while (i <= length_names && (*arg_char)[i - PCH_START] != '\0' &&
	 (*arg_char)[i - PCH_START] != ';' && v <= MAX_VERTEX) {
    /*$ifdef TRACE*/
    ntr_char(" Enter    ", 10L, 2287L, 1L, 0L, i,
	     (*arg_char)[i - PCH_START]);
    /*$endif TRACE*/
    if ((*arg_char)[i - PCH_START] == ':') {
      if (!long_names && v != first_vertex) {
	write_pch(stdout, " First factor name must start with `:', ", 40L);
	write_pch(stdout, "if long names are to be used.", 29L);
	write_line(stdout);
      } else
	long_names = true;
    }
    full_variable_description[v - MIN_VERTEX] =
      (t_variable_description_node *)Malloc(sizeof(t_variable_description_node));
    if (full_variable_description[v - MIN_VERTEX] == NULL)
      _OutMem();
    full_variable_description[v - MIN_VERTEX]->long_name = NULL;
    if (long_names) {
      /*$ifdef TRACE*/
      ntr_char(" Long     ", 10L, 2287L, 1L, 0L, i,
	       (*arg_char)[i - PCH_START]);
      /*$endif TRACE*/
      if ((*arg_char)[i - PCH_START] == ':')
	i++;
      insert_name_in_name_list(&v, &full_name_list);
      full_variable_description[v - MIN_VERTEX]->name = (*arg_char)[i - PCH_START];
      j = 1;
      /*$ifdef TRACE*/
      ntr_char(" Before   ", 10L, 2287L, 1L, 0L, i,
	       (*arg_char)[i - PCH_START]);
      /*$endif TRACE*/
      while ((*arg_char)[i - PCH_START] == ' ' && i <= length_names)
	i++;
      c = (*arg_char)[i - PCH_START];
      while (c != ' ' && c != ':' && c != ',' && c != '\0' &&
	     i <= length_names) {
	if (c == ',' || c == '.' || c == '[' || c == ']' || c == '/' ||
	    c == ';' || c == '<' || c == '>' || c == '|' || c == '*' ||
	    c == '+' || c == '-' || c == '(' || c == ')' || c == '{' ||
	    c == '}' || c == '&' || c == '^' || c == '=')
	  full_name_list->name[j - PCH_START] = '_';
	else
	  full_name_list->name[j - PCH_START] = c;
	j++;
	i++;
	while ((*arg_char)[i - PCH_START] == ' ' && i <= length_names)
	  i++;
	c = (*arg_char)[i - PCH_START];
	/*$ifdef TRACE*/
	ntr_char(" In       ", 10L, 2287L, 1L, 0L, i, c);
	/*$endif TRACE*/
      }
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2287L, 1L))
	write_line_text(stdout);
      /*$endif TRACE*/
      /*$ifdef TRACE*/
      ntr_char(" After    ", 10L, 2287L, 1L, 0L, i, c);
      /*$endif TRACE*/
      if (i <= length_names && c != '\0')
	i++;
      /*$ifdef TRACE*/
      ntr_char(" End      ", 10L, 2287L, 1L, 0L, i,
	       (*arg_char)[i - PCH_START]);
      /*$endif TRACE*/
      full_name_list->length = j - 1;
    } else {
      full_variable_description[v - MIN_VERTEX]->name = (*arg_char)[i - PCH_START];
      i++;
    }
    v++;
  }
  revers_vertex_name_list(&full_name_list);
  full_last_vertex = v;
  v = first_vertex;
  for (i = 3; i <= n_levels + 2; i++) {
    levels = (*arg_int)[i];
    if (levels == MISSING_LEVEL || levels == 0) {
      full_variable_description[v - MIN_VERTEX]->variable_type = continuous;
      full_variable_description[v - MIN_VERTEX]->UU.missing_values = false;
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2287L, 1L)) {
	write_pch(stdout, " Defined to continuous: ", 24L);
	print_full_vertex_on_file(stdout, v, 0L);
	write_line(stdout);
      }
      /*$endif TRACE*/
      mixed_data = true;
    } else {
      full_variable_description[v - MIN_VERTEX]->variable_type = discrete;
      full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing = 0;
      if (levels >= _INVALID_LEVEL || levels == _UNDEF_LEVEL ||
	  levels == _INVALID_LEVEL) {
	*ifail = 11;
	write_pch(stdout, " Invalid number of levels at ", 29L);
	print_full_vertex_on_file(stdout, v, 0L);
	write_line(stdout);
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels = 0;
	write_pch(stdout, " Invalid number of levels at ", 29L);
	print_full_vertex_on_file(stdout, v, 0L);
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels = 0;
	write_line(stdout);
      } else
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels = levels;
    }
    v++;
  }
  if (v == full_last_vertex) {
    v = first_vertex;
    for (i = 3; i <= n_missing + 2; i++) {
      levels = (*arg_int)[n_levels + i];
      if (levels == MISSING_LEVEL)
	levels = 1;
      else if (levels == _UNDEF_LEVEL)
	levels = 0;
      else if (levels >= _INVALID_LEVEL) {   /* Always false: */
	/* or
	   (levels < 0) */
	*ifail = 12;
	write_pch(stdout, " Invalid missing count at ", 26L);
	print_full_vertex_on_file(stdout, v, 0L);
	write_line(stdout);
	levels = 0;
      }
      if (full_variable_description[v - MIN_VERTEX]->variable_type == continuous)
	full_variable_description[v - MIN_VERTEX]->UU.missing_values = (levels != 0);
      else
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing = levels;
      v++;
    }
    full_last_vertex--;
    select_datastructure(true);
    return;
  }
  *ifail = 13;
  full_last_vertex = v - 1;
  write_pch(stdout, " Number of names and levels differs     ", 40L);
  write_line(stdout);
}  /* enter_names */


Static Void read_names(f)
FILE *f;
{
  t_vertex v;
  Char c;
  /* i_: t_integer; */
  t_level i;

  for (v = first_vertex; v <= last_vertex; v++)
    dispose_real_list(&cutpoints[v - MIN_VERTEX]);
  read_spec = true;
  read_obs = false;
  em = false;
  exclude_missing = false;
  term = (terminal || !strncmp(command_name, spec_name, sizeof(pch_long)));
  long_names = false;
  dispose_vertex_name_list(&full_name_list);
  v = first_vertex;
  do {
    seek_non_blank_data(f, false, false, &c);
    if (c == ':') {
      if (!long_names && v != first_vertex) {
	write_pch(stdout, " First factor name must start with `:', ", 40L);
	write_pch(stdout, "if long names are to be used.", 29L);
	write_line(stdout);
      } else
	long_names = true;
    }
    if (c != '/' && c != ';') {
      full_variable_description[v - MIN_VERTEX] = (t_variable_description_node *)
	  Malloc(sizeof(t_variable_description_node));
      if (full_variable_description[v - MIN_VERTEX] == NULL)
	_OutMem();
      full_variable_description[v - MIN_VERTEX]->long_name = NULL;
      if (long_names) {
	if (c == ':')
	  read_char_data(f, &c);
	insert_name_in_name_list(&v, &full_name_list);
	i = 1;
	full_name_list->name[i - PCH_START] = c;
	full_variable_description[v - MIN_VERTEX]->name = c;
	while ((c != ' ' && c != ':' && c != '/' && c != ';') &
	       (!eolnorf_data(f))) {
	  read_char_data(f, &c);
	  i++;
	  full_name_list->name[i - PCH_START] = c;
	}
	if (eolnorf_data(f) && c != ' ' && c != ':' && c != '/' && c != ';')
	  full_name_list->length = i;
	else
	  full_name_list->length = i - 1;
	while (eolnnotf_data(f))
	  read_line_data_plus(f);
      } else
	full_variable_description[v - MIN_VERTEX]->name = c;
      v++;
    }
  } while (c != '/' && c != ';' && v <= MAX_VERTEX);
  revers_vertex_name_list(&full_name_list);
  full_last_vertex = v;
  if (c != '/' && c != ';') {
    full_last_vertex--;
    write_pch(stdout, " Too many factors", 17L);
    return;
  }
  v = first_vertex;
  do {
    read_level(f, &i, &c);
    if (i == _UNDEF_LEVEL || i == _INVALID_LEVEL) {
      write_pch(stdout, " Invalid number of levels at ", 29L);
      print_full_vertex_on_file(stdout, v, 0L);
      write_line(stdout);
      full_variable_description[v - MIN_VERTEX]->UU.U0.levels = 0;
      c = '/';
    } else {
      if (i == MISSING_LEVEL) {
	full_variable_description[v - MIN_VERTEX]->variable_type = continuous;
	full_variable_description[v - MIN_VERTEX]->UU.missing_values = false;
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 2288L, 1L)) {
	  write_pch(stdout, " Defined to continuous: ", 24L);
	  print_full_vertex_on_file(stdout, v, 0L);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	mixed_data = true;
      } else {
	full_variable_description[v - MIN_VERTEX]->variable_type = discrete;
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels = i;
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing = 0;
      }
      v++;
    }
  } while (c != '/' && c != ';' && v != full_last_vertex);
  if (v == full_last_vertex) {
    while (c != '/' && c != ';') {
      if (eoln_data(f))
	read_line_data_plus(f);
      else if (eof_data(f))
	c = ';';
      else
	read_char_data(f, &c);
    }
    v = first_vertex;
    do {
      read_level(f, &i, &c);
      if (i == MISSING_LEVEL)
	i = 1;
      else if (i == _UNDEF_LEVEL) {
	i = 0;
	c = '/';
      } else if (i == _INVALID_LEVEL) {
	write_pch(stdout, " Invalid missing count at ", 26L);
	print_full_vertex_on_file(stdout, v, 0L);
	write_line(stdout);
	i = 0;
	c = '/';
      }
      if (full_variable_description[v - MIN_VERTEX]->variable_type == continuous)
	full_variable_description[v - MIN_VERTEX]->UU.missing_values = (i != 0);
      else
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing = i;
      v++;
    } while (c != '/' && c != ';' && v != full_last_vertex);
    full_last_vertex--;
    select_datastructure(true);
    return;
  }
  if (v > first_vertex)
    full_last_vertex = v - 1;
  write_pch(stdout, " More names than levels defined", 31L);
}  /* read_names */


Static Void proc_redefine_factor(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_vertex v;
  t_level levels, levels_missing;
  Char c = '@';
  t_integer i = PCH_START;
  t_integer x;

  v = first_vertex;
  if (!get_vertex(command_file, true, true, true, as_argument, &i, ifail,
		  sub_code, arg_pos_char, nargs, arg_char, " Factor->", 9L,
		  &v, &v))
    return;
  read_obs = false;
  i = 0;
  get_next_level(command_file, stdout, true, true, true, as_argument, &i,
		 ifail, sub_code, arg_pos_int, nargs, arg_int, " Levels->",
		 9L, &x, &c, MAX_LEVEL, v);
  if (x == _INVALID_LEVEL || x == MISSING_LEVEL || x == _UNDEF_LEVEL) {
    write_pch(stdout, " Invalid number of levels at ", 29L);
    print_full_vertex_on_file(stdout, v, 0L);
    levels = 0;
    write_line(stdout);
  } else
    levels = x;
  if (c != '/' && c != ';') {
    if (c == '.' || c == '*')
      levels_missing = 1;
    else {
      get_next_level(command_file, stdout, true, true, true, as_argument, &i,
		     ifail, sub_code, arg_pos_int, nargs, arg_int,
		     " Missing->", 10L, &x, &c, MAX_LEVEL, v);
      if (x == _UNDEF_LEVEL || *ifail != 0)
	levels_missing = 0;
      else if (x == _INVALID_LEVEL) {
	write_pch(stdout, " Invalid missing count at ", 26L);
	print_full_vertex_on_file(stdout, v, 0L);
	levels_missing = 0;
      } else if (x == MISSING_LEVEL)
	levels_missing = 1;
      else
	levels_missing = x;
    }
  } else
    levels_missing = 0;
  if (levels == 0)
    return;
  full_variable_description[v - MIN_VERTEX]->UU.U0.levels = levels + levels_missing;
  full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing = levels_missing;
  select_datastructure(false);   /* Cutpoints ?? */
  if (!P_subset(delta, subset))   /* => delta == subset */
    set_read_subset_argument(subset);
}  /* proc_redefine_factor */


/*@+"readobs.p"*/
/*@-"readlst.p"*/


/*

2292:    +++  ++
2293:    +++  ++
2294:    ---  -- p/readtab.p         17      73     875 p/readtab.p
2295: |    4:    procedure read_count
2296: |   24:    procedure x_to_cutpoint_level
2297: |   48:    procedure read_cutpoint_level
2298: |   59:    procedure full_next_cell
2299: |   78:    procedure note_last_read_data_line
2300: |  108:    procedure note_skip_case
2301: |  146:    procedure note_case
2302: |  178:    procedure note_skip_mixed_case
2303: |  245:    procedure note_mixed_case
2304: |  306:    function end_of_data
2305: |  316:    function is_case_ok
2306: |  331:    procedure enter_table
2307: |  494:    procedure read_table
2308: |  506:    procedure full_next_marginal_cell_list
2309: |  525:    function full_cardinality
2310: |  537:    function init_q_table
2311: |  635:    procedure enter_q_table
2312:    +++  ++
2313:    +++  ++

*/


Static Void read_count(f, count)
FILE *f;
t_cell_count *count;
{
  t_long_integer i;

  read_integer_data(f, false, false, &i);
  if (i == MISSING) {
    *count = _INVALID_COUNT;
    return;
  }
  if (i == _INVALID) {
    *count = _INVALID_COUNT;
    return;
  }
  if (i == _UNDEF) {
    *count = _UNDEF_COUNT;
    return;
  }
  if (i == STRUCT_ZERO || i == MISSING) {
    *count = STRUCT_ZERO_COUNT;
    return;
  }
  if ((unsigned long)i <= MAX_COUNT_NUMBER)
    *count = i;
  else
    *count = _INVALID_COUNT;
}  /* read_count */


Static Void x_to_cutpoint_level(x, level, v)
t_long_real x;
t_level *level;
t_vertex *v;
{
  t_real_list *p;

  if (x == MISSING || x == -1) {
    *level = MISSING_LEVEL;
    return;
  }
  if (x == _UNDEF) {
    *level = _UNDEF_LEVEL;
    return;
  }
  *level = FIRST_LEVEL + full_variable_description[*v - MIN_VERTEX]->
			 UU.U0.levels_total - 1;
  p = cutpoints[*v - MIN_VERTEX];
  while (p != NULL) {
    if (p->x < x)
      p = NULL;
    else {
      (*level)--;
      p = p->pointer;
    }
  }
}  /* x_to_cutpoint_level */


Static Void read_cutpoint_level(f, level, c, v)
FILE *f;
t_level *level;
Char *c;
t_vertex *v;
{
  t_long_real x;

  read_real_separator(f, false, false, "1234567890", 0L, &x, c);
  x_to_cutpoint_level(x, level, v);
}  /* read_cutpoint_level */


Static Void full_next_cell(i)
t_level *i;
{
  t_vertex v;

  v = first_vertex;
  while (i[v - MIN_VERTEX] ==
	 FIRST_LEVEL + full_variable_description[v - MIN_VERTEX]->
		       UU.U0.levels_total - 1 && v < full_last_vertex) {
    i[v - MIN_VERTEX] = FIRST_LEVEL;
    v++;
  }
  if (v == full_last_vertex &&
      i[v - MIN_VERTEX] ==
      FIRST_LEVEL + full_variable_description[v - MIN_VERTEX]->
		    UU.U0.levels_total - 1)
    i[v - MIN_VERTEX] = FIRST_LEVEL;
  else
    i[v - MIN_VERTEX]++;
}  /* full_next_cell */


Static Void note_last_read_data_line(data_file)
FILE *data_file;
{
  Char c;

  write_pch(stdout, " Total number of lines read on datafiles:",
	      41L);
  write_integer(stdout, data_line_number, 6L);
  write_line(stdout);
  write_pch(stdout, " Total number of observation lines read: ",
	      41L);
  write_integer(stdout, data_line_number - observation_line_number, 6L);
  write_line(stdout);
  write_pch(stdout, " Last read line on data file:", 29L);
  write_line(stdout);
  write_pch(stdout, " >", 2L);
  write_pch(stdout, last_data_line, data_line_position);
  write_line(stdout);
  if (eoln_data(data_file) || term)
    return;
  write_pch(stdout, " Skipping to EndOfLine on data file:  > ", 40L);
  while (!eolnorf_data(data_file)) {
    read_text_char(data_file, &c);
    if (log_on && log_data_on)
      write_char_text(log_file, c);
    write_char(stdout, c);
  }
  write_line(stdout);
}  /* note_last_read_data_line */


Static Void note_skip_case(i, term, as_argument, case_number, data_file)
t_level *i;
boolean *term, as_argument;
t_long_integer *case_number;
FILE *data_file;
{
  t_vertex v;

  if (*term && diary && !as_argument)
    write_line_diary();
  write_pch(stdout, " Case number ", 13L);
  write_integer(stdout, *case_number, 10L);
  write_pch(stdout, " skipped.", 9L);
  write_line(stdout);
  for (v = first_vertex; v <= full_last_vertex; v++) {
    if (i[v - MIN_VERTEX] == MISSING_LEVEL &&
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing == 0)
      write_pch(stdout, "  .", 3L);
    else if (i[v - MIN_VERTEX] == _INVALID_LEVEL)
      write_pch(stdout, "  ?", 3L);
    else
      write_integer(stdout, i[v - MIN_VERTEX] - FIRST_LEVEL + 1L, 3L);
    /* Always false: */
    /* (i[v] < first_level) or */
    if (FIRST_LEVEL + full_variable_description[v - MIN_VERTEX]->
		      UU.U0.levels_total - 1 < i[v - MIN_VERTEX])
      write_char(stdout, '%');
    else
      write_char(stdout, ' ');
  }
  write_line(stdout);
  if (as_argument)
    return;
  note_last_read_data_line(data_file);
  if (*term && diary)
    write_pch_10_text(diary_file, " DATA->", 7L);
}  /* note_skip_case */


Static Void note_case(i, term, as_argument, case_number)
t_level *i;
boolean *term, as_argument;
t_long_integer *case_number;
{
  t_vertex v;

  if (*term && diary && !as_argument)
    write_line_diary();
  write_pch(stdout, " Case number ", 13L);
  write_integer(stdout, *case_number, 10L);
  write_pch(stdout, " read.", 6L);
  write_line(stdout);
  for (v = first_vertex; v <= full_last_vertex; v++) {
    if (i[v - MIN_VERTEX] == MISSING_LEVEL &&
	full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing == 0)
      write_pch(stdout, "  .", 3L);
    else if (i[v - MIN_VERTEX] == _INVALID_LEVEL)
      write_pch(stdout, "  ?", 3L);
    else
      write_integer(stdout, i[v - MIN_VERTEX] - FIRST_LEVEL + 1L, 3L);
    /* Always false: */
    /* (i[v] < first_level) or */
    if (FIRST_LEVEL + full_variable_description[v - MIN_VERTEX]->
		      UU.U0.levels_total - 1 < i[v - MIN_VERTEX])
      write_char(stdout, '%');
    else
      write_char(stdout, ' ');
  }
  write_line(stdout);
}  /* note_case */


Static Void note_skip_mixed_case(i, j, x, term, as_argument, case_number,
				 data_file)
t_level *i;
t_level *j;
float *x;
boolean *term, as_argument;
t_long_integer *case_number;
FILE *data_file;
{
  t_discrete_vertex v;
  t_continuous_vertex w;
  t_vertex U;
  t_integer width;

  if (*term && diary && !as_argument)
    write_line_diary();
  write_pch(stdout, " Case number ", 13L);
  write_integer(stdout, *case_number, 10L);
  write_pch(stdout, " skipped.", 9L);
  write_line(stdout);
  for (U = first_vertex; U <= full_last_vertex; U++) {
    if (P_inset(U, full_delta)) {
      v = full_to_discrete[U - MIN_VERTEX];
      if (full_variable_description[U - MIN_VERTEX]->UU.U0.levels_total > 99)
	width = 4;
      else if (full_variable_description[U - MIN_VERTEX]->UU.U0.levels_total > 9)
	width = 3;
      else
	width = 2;
      write_char(stdout, ' ');
      write_char(stdout, '(');
      write_integer(stdout, j[v - MIN_VERTEX] - FIRST_LEVEL + 1L, width);
      write_char(stdout, ')');
      if (i[U - MIN_VERTEX] == MISSING_LEVEL &&
	  full_variable_description[U - MIN_VERTEX]->UU.U0.levels_missing == 0)
	write_pch(stdout, " . ", width);
      else if (i[U - MIN_VERTEX] == MISSING_LEVEL)
	write_pch(stdout, " * ", width);
      else if (i[U - MIN_VERTEX] == MAX_LEVEL)
	write_pch(stdout, " ~ ", width);
      else if (i[U - MIN_VERTEX] == _INVALID_LEVEL)
	write_pch(stdout, " ? ", width);
      else if (i[U - MIN_VERTEX] == _UNDEF_LEVEL)
	write_pch(stdout, " @ ", width);
      else
	write_integer(stdout, i[U - MIN_VERTEX] - FIRST_LEVEL + 1L, width);
      /* Always false: */
      /* (i[U] < first_level) or */
      if (FIRST_LEVEL + full_variable_description[U - MIN_VERTEX]->
			UU.U0.levels_total - 1 < i[U - MIN_VERTEX])
	write_char(stdout, '%');
      else
	write_char(stdout, ' ');
    } else {
      w = full_to_continuous[U - MIN_VERTEX];
      write_char(stdout, ' ');
      write_real(stdout, x[w - MIN_VERTEX], 5L, 2L);
    }
  }
  write_line(stdout);
  if (as_argument)
    return;
  note_last_read_data_line(data_file);
  if (*term && diary)
    write_pch_10_text(diary_file, " DATA->", 7L);
}  /* note_skip_mixed_case */


Static Void note_mixed_case(i, j, x, term, as_argument, case_number)
t_level *i;
t_level *j;
float *x;
boolean *term, as_argument;
t_long_integer *case_number;
{
  t_discrete_vertex v;
  t_continuous_vertex w;
  t_vertex U;
  t_integer width;

  if (*term && diary && !as_argument)
    write_line_diary();
  write_pch(stdout, " Case number ", 13L);
  write_integer(stdout, *case_number, 10L);
  write_pch(stdout, " read.", 6L);
  write_line(stdout);
  for (U = first_vertex; U <= full_last_vertex; U++) {
    if (P_inset(U, full_delta)) {
      v = full_to_discrete[U - MIN_VERTEX];
      if (full_variable_description[U - MIN_VERTEX]->UU.U0.levels_total > 99)
	width = 4;
      else if (full_variable_description[U - MIN_VERTEX]->UU.U0.levels_total > 9)
	width = 3;
      else
	width = 2;
      write_char(stdout, ' ');
      write_char(stdout, '(');
      write_integer(stdout, j[v - MIN_VERTEX] - FIRST_LEVEL + 1L, width);
      write_char(stdout, ')');
      if (i[U - MIN_VERTEX] == MISSING_LEVEL &&
	  full_variable_description[U - MIN_VERTEX]->UU.U0.levels_missing == 0)
	write_pch(stdout, " . ", width);
      else if (i[U - MIN_VERTEX] == MISSING_LEVEL)
	write_pch(stdout, " * ", width);
      else if (i[U - MIN_VERTEX] == MAX_LEVEL)
	write_pch(stdout, " ~ ", width);
      else if (i[U - MIN_VERTEX] == _INVALID_LEVEL)
	write_pch(stdout, " ? ", width);
      else if (i[U - MIN_VERTEX] == _UNDEF_LEVEL)
	write_pch(stdout, " @ ", width);
      else
	write_integer(stdout, i[U - MIN_VERTEX] - FIRST_LEVEL + 1L, width);
      /* Always false: */
      /* (i[U] < first_level) or */
      if (FIRST_LEVEL + full_variable_description[U - MIN_VERTEX]->
			UU.U0.levels_total - 1 < i[U - MIN_VERTEX])
	write_char(stdout, '%');
      else
	write_char(stdout, ' ');
    } else {
      w = full_to_continuous[U - MIN_VERTEX];
      write_char(stdout, ' ');
      write_real(stdout, x[w - MIN_VERTEX], 5L, 2L);
    }
  }
  write_line(stdout);
}  /* note_mixed_case */


Static boolean end_of_data(as_argument, j, k, max_j, max_k, f)
boolean as_argument;
t_long_integer *j, *k, *max_j, *max_k;
FILE *f;
{
  if (as_argument)
    return (*j >= *max_j || *k >= *max_k);
  else
    return (eof_data(f));
}  /* end_of_data */


Static boolean is_case_ok(i, a)
t_level *i;
long *a;
{
  t_vertex v;
  boolean ok = true;

  for (v = first_vertex; v <= full_last_vertex; v++) {
    if (P_inset(v, a)) {
      if (FIRST_LEVEL + full_variable_description[v - MIN_VERTEX]->
			UU.U0.levels_total - 1 < i[v - MIN_VERTEX])
	ok = false;
    }
  }
  return ok;
}


Static Void enter_table(arg_pos_int, nargs, arg_int, ifail, as_argument,
			note_data, data_file)
t_integer arg_pos_int;
long **nargs, **arg_int;
t_integer *ifail;
boolean as_argument, note_data;
FILE *data_file;
{
  t_cell_count count;
  t_long_integer number_of_cells_expected;
  t_long_integer index = 0;
  t_long_integer max_index;
  t_cell i;
  Char c;
  boolean ok = true;

  if (mixed_data)
    note_mixed(stdout, " EnterTable", 11L);
  if (as_argument) {
    if (ok_int_arg(ifail, arg_pos_int, 2L, nargs, arg_int))
      max_index = (*nargs)[arg_pos_int];
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2306L, 1L)) {
    if (as_argument) {
      write_pch_20_text(report_file, " Max_index: ", 12L);
      write_integer_text(report_file, max_index, 3L);
    }
  }
  /*$endif TRACE*/
  /* dispose_all_expressions;
     dispose_tests;
     dispose_marginals; */
  init_datastructure();
  read_obs = true;
  term = (terminal || !strncmp(command_name, data_name, sizeof(pch_long)) ||
	  as_argument);
  memcpy(i, first_cell, sizeof(t_cell));
  number_of_cells_expected = marginal_dimension_tf(full_delta, true, true);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2306L, 1L)) {
    if (as_argument)
      write_pch_20_text(report_file, "  Before WHILE ", 15L);
  }
  /*$endif TRACE*/
  while ((ok && index < number_of_cells_expected) & (!end_of_data(as_argument,
	     &index, &index, &max_index, &max_index, data_file))) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 2306L, 1L)) {
      if (as_argument)
	write_pch_20_text(report_file, "  In WHILE     ", 15L);
    }
    /*$endif TRACE*/
    if (as_argument) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2306L, 1L)) {
	write_pch_20_text(report_file, " Index:     ", 12L);
	write_integer_text(report_file, index, 3L);
      }
      /*$endif TRACE*/
      count = (*arg_int)[index];
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2306L, 1L)) {
	write_pch_20_text(report_file, " Count:     ", 12L);
	write_integer_text(report_file, count, 3L);
      }
      /*$endif TRACE*/
    } else
      read_count(data_file, &count);
    if ((count != _INVALID_COUNT && count != _UNDEF_COUNT &&
	 count < MAX_COUNT_NUMBER - n[0]) || count == STRUCT_ZERO_COUNT)
      insert_cases_(i, count);
    else
      ok = false;
    index++;
    full_next_cell(i);
  }
  if (term && diary && !as_argument)
    write_line_diary();
  if (!as_argument || note_data) {
    write_integer(stdout, index, 4L);
    write_pch(stdout, " cells with ", 12L);
    write_integer(stdout, n[0], 5L);
    write_pch(stdout, " cases read.", 12L);
    write_line(stdout);
  }
  if ((index < number_of_cells_expected) & end_of_data(as_argument, &index,
	&index, &max_index, &max_index, data_file)) {
    set_ifail(ifail, 16L);
    if (datastructure == all) {
      datastructure = necessary;
      dispose_marginals();
    }
    write_integer(stdout, number_of_cells_expected, 4L);
    write_pch(stdout, " cells expected.", 16L);
  } else {
    if (ok) {
      if (datastructure == all && !mixed_data) {
	if (TURBO_PC)
	  write_pch(stdout, " WAIT !! -", 10L);
	if (!as_argument || note_data)
	  write_pch(stdout, " Finding all marginals.", 23L);
	find_all_marginals(&ok);
      }
    } else {
      if (datastructure == all) {
	datastructure = necessary;
	dispose_marginals();
      }
      if (count == _INVALID_COUNT || count == _UNDEF_COUNT) {
	set_ifail(ifail, 17L);
	write_pch(stdout, " Invalid count in last read cell.", 33L);
      } else {
	set_ifail(ifail, 18L);
	write_pch(stdout, " Too many observations.", 23L);
      }
    }
    if (!as_argument) {
      while ((eolnnotf(data_file) & (!eof_data(data_file))) && !term)
	read_line_data(data_file);
    }
    if (!end_of_data(as_argument, &index, &index, &max_index, &max_index,
		     data_file) && !term) {
      write_line(stdout);
      write_pch(stdout, " Cells skipped:  ", 17L);
      write_line(stdout);
      write_line(stdout);
      if (as_argument) {
	while (index < max_index) {
	  /*$ifdef TRACE*/
	  if (trace_flag_set(20L, 2306L, 1L)) {
	    write_pch_10_text(stdout, " Index: ", 8L);
	    write_integer_text(stdout, index, 3L);
	    write_pch_10_text(stdout, " Count: ", 8L);
	    write_integer_text(stdout, (*arg_int)[index], 3L);
	    write_line_text(stdout);
	  }
	  /*$endif TRACE*/
	  write_integer(stdout, (*arg_int)[index], 5L);
	  write_line(stdout);
	  index++;
	}
      } else {
	while (!eof_data(data_file)) {
	  if (eoln_data(data_file)) {
	    read_text_ln(data_file);
	    if (log_on && log_data_on)
	      write_line_text(log_file);
	    write_line(stdout);
	  } else {
	    read_text_char(data_file, &c);
	    if (log_on && log_data_on)
	      write_char_text(log_file, c);
	    write_char(stdout, c);
	  }
	}
      }
    }
  }
  close_datastructure();
  if (incomplete_table) {
    write_line(stdout);
    test_zero_data();
  }
  if (as_argument && note_data)
    write_line(stdout);
}  /* enter_table */


Static Void read_table(data_file)
FILE *data_file;
{
  t_integer ifail = 0;
  long *nargs = NULL, *arg_int = NULL;

  enter_table(0L, &nargs, &arg_int, &ifail, false, false, data_file);
}  /* read_table */


Static Void full_next_marginal_cell_list(p, i)
t_vertex_list *p;
t_level *i;
{
  if (p == NULL)
    return;
  while (i[p->vertex - MIN_VERTEX] ==
	 FIRST_LEVEL + full_variable_description[p->vertex - MIN_VERTEX]->
		       UU.U0.levels - 1 && p->pointer != NULL) {
    i[p->vertex - MIN_VERTEX] = FIRST_LEVEL;
    p = p->pointer;
  }
  if (p->pointer == NULL &&
      i[p->vertex - MIN_VERTEX] ==
      FIRST_LEVEL + full_variable_description[p->vertex - MIN_VERTEX]->
		    UU.U0.levels - 1)
    i[p->vertex - MIN_VERTEX] = FIRST_LEVEL;
  else
    i[p->vertex - MIN_VERTEX]++;
}  /* full_next_marginal_cell_list */


Static boolean init_q_table(a, table, b, q, as_argument, data_file)
long *a;
boolean table;
long *b;
t_offset_list **q;
boolean as_argument;
FILE *data_file;
{
  Char c;
  boolean subset_of_existing, contains_existing, ok;
  t_q_cell_index index;
  t_vertex v, w;
  t_q_cell_index FORLIM;

  dispose_all_expressions();
  dispose_tests();
  dispose_marginals();
  P_setcpy(b, empty_set);
  w = first_vertex;
  for (v = first_vertex; v <= full_last_vertex; v++) {
    if (P_inset(v, subset)) {
      if (P_inset(v, a))
	P_addset(b, w);
      w++;
    }
  }
  subset_of_existing = subset_of_an_edge(b, &g_c_q_tables);
  contains_existing = contains_an_edge(b, &g_c_q_tables);
  if (subset_of_existing && contains_existing) {
    *q = q_tables_offsets;
    while (!P_setequal((*q)->vertex_set, b))
      *q = (*q)->pointer;
    ok = true;
    if (term && diary)
      write_line_diary();
    if (table)
      write_pch(stdout, " Warning - Over-writing existing Q-table", 40L);
    else
      write_pch(stdout,
		  " Warning - Adding ZeroCells to an existing Q-table", 50L);
    write_line(stdout);
  } else {
    if (subset_of_existing) {
      if (term && diary)
	write_line_diary();
      write_pch(stdout, " Warning - Subset of an existing Q-table", 40L);
      write_line(stdout);
    }
    if (contains_existing) {
      if (term && diary)
	write_line_diary();
      write_pch(stdout, " Warning - Contains an existing Q-table", 39L);
      write_line(stdout);
    }
    if (!TURBO_PC) {
      space_in_q_array(marginal_dimension(b), fqa);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    }
    ok = (last_index(b) <= max_q_cell_number - fqa);
    if (ok) {
      if (table) {
	FORLIM = fqa + last_index(b);
	for (index = fqa; index <= FORLIM; index++)
	  q_array[index] = 0;
      } else {
	FORLIM = fqa + last_index(b);
	for (index = fqa; index <= FORLIM; index++)
	  q_array[index] = 1;
      }
      insert_offset(b, fqa, &q_tables_offsets);
      *q = q_tables_offsets;
      fqa += marginal_dimension(b);
      insert_set_in_set_list(b, &g_c_q_tables);
    }
  }
  if (ok)
    return true;
  write_pch(stdout, " Structural table to large.", 27L);
  write_line(stdout);
  if (as_argument)
    return false;
  note_last_read_data_line(data_file);
  while (eolnnotf_data(data_file) && !term)
    read_line_data(data_file);
  if (!eof_data(data_file) && !term) {
    write_line(stdout);
    write_pch(stdout, " Cases skipped:  ", 17L);
    write_line(stdout);
    write_line(stdout);
    c = ' ';
    while (!eof_data(data_file) && c != ';' && c != '/') {
      if (eoln_data(data_file)) {
	read_text_ln(data_file);
	write_line(stdout);
      } else {
	read_text_char(data_file, &c);
	write_char(stdout, c);
      }
    }
  }
  write_line(stdout);
  return false;
}  /* init_q_table */


Static Void enter_q_table(a, p, arg_int, max_index, as_argument, data_file)
long *a;
t_vertex_list *p;
long *arg_int;
t_long_integer max_index;
boolean as_argument;
FILE *data_file;
{
  t_cell_count index, count;
  t_cell i;
  Char c;
  boolean ok;
  t_offset_list *q;
  t_vertex_set b;
  t_vertex v, w;
  t_cell ii;
  t_long_integer j, expected_number_off_cells;

  term = (terminal || !strncmp(command_name, data_name, sizeof(pch_long)) ||
	  as_argument);
  if (init_q_table(a, true, b, &q, as_argument, data_file)) {
    ok = true;
    index = 1;
    j = 0;
    memcpy(i, first_cell, sizeof(t_cell));
    incomplete_table = true;
    expected_number_off_cells = marginal_dimension_tf(a, false, true);
    while ((ok && index <= expected_number_off_cells) &
	   (!end_of_data(as_argument, &j, &j, &max_index, &max_index,
			 data_file))) {
      if (as_argument) {
	count = arg_int[j];
	j++;
      } else
	read_count(data_file, &count);
      if (count != _INVALID_COUNT && count != _UNDEF_COUNT ||
	  count == STRUCT_ZERO_COUNT) {
	if (count != STRUCT_ZERO_COUNT && count != 0) {
	  if (read_subset) {
	    w = first_vertex;
	    for (v = first_vertex; v <= full_last_vertex; v++) {
	      if (P_inset(v, subset)) {
		ii[w - MIN_VERTEX] = i[v - MIN_VERTEX];
		w++;
	      }
	    }
	    q_array[q->offset + marginal_hash(b, ii)] += count;
	  } else
	    q_array[q->offset + marginal_hash(b, i)] = count;
	  if (count != 1)
	    initial_values_for_ips = true;
	}
      } else
	ok = false;
      index++;
      full_next_marginal_cell_list(p, i);
    }
    if (term && diary)
      write_line_diary();
    write_integer(stdout, index - 1, 4L);
    write_pch(stdout, " Q-cells read.", 14L);
    write_line(stdout);
    if (index < marginal_dimension_tf(full_delta, true, true)) {
      write_integer(stdout, expected_number_off_cells, 4L);
      write_pch(stdout, " cells expected.", 16L);
      write_line(stdout);
    }
    if (!ok) {
      write_pch(stdout, " Invalid count in last read cell.", 33L);
      write_line(stdout);
      if (!as_argument) {
	note_last_read_data_line(data_file);
	while (eolnnotf_data(data_file) && !term)
	  read_line_data(data_file);
	if (!eof_data(data_file) && !term) {
	  write_line(stdout);
	  write_pch(stdout, " Cells skipped:  ", 17L);
	  write_line(stdout);
	  write_line(stdout);
	  c = ' ';
	  while (!eof_data(data_file) && c != ';' && c != '/') {
	    if (eoln_data(data_file)) {
	      read_text_ln(data_file);
	      write_line(stdout);
	    } else {
	      read_text_char(data_file, &c);
	      write_char(stdout, c);
	    }
	  }
	  write_line(stdout);
	}
      }
    }
  }
  if (initial_values_for_ips) {
    write_pch(stdout, " Initial values for IPS used.", 29L);
    write_line(stdout);
  }
  if (read_obs)
    test_zero_data();
}  /* enter_q_table */


/*@-"readlst.p"*/


/*

2314:    +++  ++
2315:    +++  ++
2316:    ---  -- p/readlst.p         17      79     951 p/readlst.p
2317: |    2:    procedure sub_read_level
2318: |   32:    procedure sub_get_level
2319: |   70:    procedure get_case_q
2320: |   98:    procedure read_case_q
2321: |  122:    procedure enter_q_list
2322: |  193:    procedure read_q_table_data
2323: |  206:    procedure proc_enter_q_table
2324: |  249:    procedure read_q_list_data
2325: |  262:    procedure proc_enter_q_list
2326: |  304:    procedure get_case
2327: |  329:    procedure sub_get_mixed_case
2328: |  382:    procedure get_mixed_case
2329: |  417:    procedure read_case
2330: |  439:    procedure sub_read_mixed_case
2331: |  480:    procedure read_mixed_case
2332: |  512:    procedure enter_list
2333: |  646:    procedure read_list
2334:    +++  ++
2335:    +++  ++

*/


Static Void sub_read_level(data_file, i, c, v, start_vertex, end_of_file)
FILE *data_file;
t_level *i;
Char *c;
t_vertex *v, *start_vertex;
boolean *end_of_file;
{
  t_level level;

  if (cutpoints[*v - MIN_VERTEX] == NULL)
    read_list_level(data_file,
      full_variable_description[*v - MIN_VERTEX]->UU.U0.levels_total < 10,
      &level, c);
  else
    read_cutpoint_level(data_file, &level, c, v);
  if (level == _UNDEF_LEVEL) {
    if (*v != *start_vertex) {
      write_pch(stdout, " Eof at ", 8L);
      print_vertex(*v);
      write_line(stdout);
    }
    *end_of_file = true;
  } else {
    if (level == MISSING_LEVEL) {
      if (full_variable_description[*v - MIN_VERTEX]->UU.U0.levels_missing > 0)
	level = FIRST_LEVEL +
	    full_variable_description[*v - MIN_VERTEX]->UU.U0.levels_total -
	    full_variable_description[*v - MIN_VERTEX]->UU.U0.levels_missing;
    }
  }
  i[*v - MIN_VERTEX] = level;
}  /* sub_read_level */


Static Void sub_get_level(arg_int, arg_double, in_int, j, max_index, u, level,
			  u_0, level_0, eol)
long **arg_int;
double **arg_double;
boolean *in_int;
t_integer *j, *max_index;
t_vertex *u;
t_level *level;
t_vertex *u_0;
t_level *level_0;
boolean *eol;
{
  t_integer int_;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubGetLevel        ", sizeof(pch20));
  ntr(tzt, 20L, 2318L, 1L, *j, *max_index);
  /*$endif TRACE*/
  if (*j < *max_index) {
    if (*in_int)
      int_ = (*arg_int)[*j];
    else
      int_ = (long)floor((*arg_double)[*j] + 0.5);
    if (cutpoints[*u - MIN_VERTEX] == NULL) {
      if (int_ > MAX_LEVEL)
	*level = _INVALID_LEVEL;
      else if (int_ == -1)
	*level = MISSING_LEVEL;
      else
	*level = FIRST_LEVEL + int_ - 1;
    } else
      x_to_cutpoint_level((double)int_, level, u);
    if (*level == _UNDEF_LEVEL) {
      if (*u != first_vertex) {
	if (*u_0 == first_vertex && *level_0 == 0) {
	  write_pch(stdout, " // ", 4L);
	  /* write_pch(output, ' EndMark!@', 9); */
	  write_line(stdout);
	} else {
	  write_pch(stdout, " Eol at ", 8L);
	  print_vertex(*u);
	  write_line(stdout);
	}
      }
      *eol = true;
    } else if (*level == MISSING_LEVEL) {
      if (full_variable_description[*u - MIN_VERTEX]->UU.U0.levels_missing > 0)
	*level = FIRST_LEVEL +
	    full_variable_description[*u - MIN_VERTEX]->UU.U0.levels_total -
	    full_variable_description[*u - MIN_VERTEX]->UU.U0.levels_missing;
      else
	*level = MISSING_LEVEL;
    }
  } else
    *eol = true;
  *level_0 = *level;
  *u_0 = *u;
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2318L, 1L, 1L, *j, *eol);
  /*$endif TRACE*/
  (*j)++;
}  /* sub_get_level */


Static Void sub_get_continuous(arg_double, k, max_double, u, w_0,
			       start_vertex, level, dummy_x, x_0, eod)
double **arg_double;
t_integer *k, *max_double;
t_vertex *u, *w_0, *start_vertex;
t_level *level;
t_real *dummy_x, *x_0;
boolean *eod;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubGetContinuous   ", sizeof(pch20));
  ntr(tzt, 20L, 2318L, 1L, *k, *max_double);
  /*$endif TRACE*/
  if (*k < *max_double)
    *dummy_x = (*arg_double)[*k];
  else
    *eod = true;
  if (is_invalid_short_real_imported(*dummy_x))   /* _invalid_short_real */
    *dummy_x = _INFINITY_SHORT_REAL;
  if ((*eod) | ((*dummy_x < 0) & is_invalid_short_real(*dummy_x))) {
    if (*u != *start_vertex) {
      if (*w_0 == *start_vertex && *x_0 == 0) {
	write_pch(stdout, " EndMark!", 9L);
	write_line(stdout);
      } else {
	write_pch(stdout, " Eol at ", 8L);
	print_vertex(*u);
	write_line(stdout);
      }
    }
    *level = _UNDEF_LEVEL;
    *eod = true;
  } else {
    if (is_invalid_short_real(*dummy_x))
      *level = MISSING_LEVEL;
    else
      *level = (long)floor(*dummy_x + 0.5) % (MAX_LEVEL / 2);
  }
  *x_0 = *dummy_x;
  *w_0 = *u;
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2318L, 1L, 2L, *k, *eod);
  /*$endif TRACE*/
  (*k)++;
}  /* sub_get_continuous */


/* Local variables for get_case_q: */
struct LOC_get_case_q {
  boolean in_int;
} ;


Static Void get_case_q(arg_int, arg_double, in_int_, j, max_index, i, a, p,
		       ok_case, eol)
long **arg_int;
double **arg_double;
boolean in_int_;
t_integer *j, *max_index;
t_level *i;
long *a;
t_vertex_list *p;
boolean *ok_case, *eol;
{
  struct LOC_get_case_q Local_Var;
  t_vertex v, v_0;
  t_level level_0 = MAX_LEVEL;

  Local_Var.in_int = in_int_;
  v = p->vertex;
  p = p->pointer;
  v_0 = last_vertex;
  sub_get_level(arg_int, arg_double, &Local_Var.in_int, j, max_index, &v,
		&i[v - MIN_VERTEX], &v_0, &level_0, eol);
  while (*j < *max_index && !*eol && p != NULL) {
    v = p->vertex;
    p = p->pointer;
    sub_get_level(arg_int, arg_double, &Local_Var.in_int, j, max_index, &v,
		  &i[v - MIN_VERTEX], &v_0, &level_0, eol);
  }
  if (p == NULL)
    *ok_case = is_case_ok(i, a);
  else
    *ok_case = false;
}  /* get_case_q */


Static Void read_case_q(data_file, i, c, a, p, ok_case, end_file)
FILE *data_file;
t_level *i;
Char *c;
long *a;
t_vertex_list *p;
boolean *ok_case, *end_file;
{
  t_vertex v, start_vertex;

  v = p->vertex;
  start_vertex = v;
  p = p->pointer;
  sub_read_level(data_file, i, c, &v, &start_vertex, end_file);
  while (!eof_data(data_file) && !*end_file && p != NULL) {
    v = p->vertex;
    p = p->pointer;
    sub_read_level(data_file, i, c, &v, &start_vertex, end_file);
  }
  if (p == NULL)
    *ok_case = is_case_ok(i, a);
  else
    *ok_case = false;
}  /* read_case_q */


Static Void enter_q_list(a, p, arg_int, arg_double, max_index, max_double,
			 as_argument, data_file)
long *a;
t_vertex_list **p;
long *arg_int;
double *arg_double;
t_integer max_index, max_double;
boolean as_argument;
FILE *data_file;
{
  Char c;
  t_cell i, ii;
  t_offset_list *q;
  t_vertex v, w;
  t_vertex_set b;
  t_long_integer case_number;
  boolean ok_case, end_file, in_int;
  t_integer j;

  term = (terminal || !strncmp(command_name, data_name, sizeof(pch_long)) ||
	  as_argument);
  if (init_q_table(a, false, b, &q, as_argument, data_file)) {
    memcpy(i, first_cell, sizeof(t_cell));
    incomplete_table = true;
    end_file = false;
    case_number = 1;
    j = 0;
    in_int = (max_index > 0);
    if (!in_int)
      max_index = max_double;
    if (as_argument)
      get_case_q(&arg_int, &arg_double, in_int, &j, &max_index, i, a, *p,
		 &ok_case, &end_file);
    else
      read_case_q(data_file, i, &c, a, *p, &ok_case, &end_file);
    while (!end_file) {
      if (ok_case) {
	if (read_subset) {
	  w = first_vertex;
	  for (v = first_vertex; v <= full_last_vertex; v++) {
	    if (P_inset(v, subset)) {
	      ii[w - MIN_VERTEX] = i[v - MIN_VERTEX];
	      w++;
	    }
	  }
	  q_array[q->offset + marginal_hash(b, ii)] = 0;
	} else
	  q_array[q->offset + marginal_hash(b, i)] = 0;
      } else
	note_skip_case(i, &term, as_argument, &case_number, data_file);
      case_number++;
      if ((c == ';') | end_of_data(as_argument, &j, &j, &max_index,
				   &max_index, data_file)) {
	end_file = true;
	break;
      }
      if (as_argument)
	get_case_q(&arg_int, &arg_double, in_int, &j, &max_index, i, a, *p,
		   &ok_case, &end_file);
      else
	read_case_q(data_file, i, &c, a, *p, &ok_case, &end_file);
    }
    if (term && diary)
      write_line_diary();
    if (end_file | end_of_data(as_argument, &j, &j, &max_index, &max_index,
			       data_file)) {
      write_integer(stdout, case_number - 1, 5L);
      write_pch(stdout, " cases read.", 12L);
      write_line(stdout);
    }
  }
  if (read_obs)
    test_zero_data();
}  /* enter_q_list */


Static Void read_q_table_data(fil)
FILE *fil;
{
  t_vertex_list *p = NULL;
  t_vertex_set a;

  read_vertex_list(fil, false, false, true, &p);
  list_of_vertices_to_set(p, a);
  revers_vertex_list(&p);
  enter_q_table(a, p, NULL, 0L, false, fil);
  dispose_vertex_list(&p);
}  /* read_q_table_data */


Static Void proc_enter_q_table(command_file, as_argument, ifail, sub_code,
			       arg_pos_char, arg_pos_int, nargs, arg_char,
			       arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  Char sep = ' ';
  boolean tmp;
  t_vertex_set a;
  t_vertex_list *p = NULL;
  t_integer i = PCH_START;

  P_setcpy(a, empty_set);
  if (!get_vertex_list_sep(command_file, true, true, true, as_argument, &sep,
			   &i, ifail, sub_code, arg_pos_char, nargs, arg_char,
			   &p, &p))
    return;
  /* ' Set->@@@@', 6, */
  list_of_vertices_to_set(p, a);
  revers_vertex_list(&p);
  if (as_argument && *sub_code != 0)
    enter_q_table(a, p, *arg_int, (*nargs)[arg_pos_int], true, command_file);
  else {
    if (as_argument)
      read_line_data(command_file);
    note_command_end_line(stdout);
    tmp = terminal;
    terminal = true;
    term = true;
    if (as_argument)
      read_line_data(command_file);
    enter_q_table(a, p, NULL, 0L, false, command_file);
    terminal = tmp;
  }
  dispose_vertex_list(&p);
}  /* proc_enter_q_table */


Static Void read_q_list_data(fil)
FILE *fil;
{
  t_vertex_list *p = NULL;
  t_vertex_set a;

  read_vertex_list(fil, false, false, true, &p);
  list_of_vertices_to_set(p, a);
  revers_vertex_list(&p);
  enter_q_list(a, &p, NULL, NULL, 0L, 0L, false, fil);
  dispose_vertex_list(&p);
}  /* read_q_list_data */


Static Void proc_enter_q_list(command_file, as_argument, ifail, sub_code,
			      arg_pos_char, arg_pos_int, arg_pos_double,
			      nargs, arg_char, arg_int, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int, arg_pos_double;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
{
  Char sep = ' ';
  boolean tmp;
  t_vertex_set a;
  t_vertex_list *p = NULL;
  t_integer i = PCH_START;

  P_setcpy(a, empty_set);
  if (!get_vertex_list_sep(command_file, true, true, true, as_argument, &sep,
			   &i, ifail, sub_code, arg_pos_char, nargs, arg_char,
			   &p, &p))
    return;
  /* ' Set->@@@@', 6, */
  list_of_vertices_to_set(p, a);
  revers_vertex_list(&p);
  if (as_argument && *sub_code != 0)
    enter_q_list(a, &p, *arg_int, *arg_double, (*nargs)[arg_pos_int],
		 (*nargs)[arg_pos_double], true, command_file);
  else {
    note_command_end_line(stdout);
    tmp = terminal;
    terminal = true;
    term = true;
    if (as_argument)
      read_line_data(command_file);
    enter_q_list(a, &p, NULL, NULL, 0L, 0L, false, command_file);
    terminal = tmp;
  }
  dispose_vertex_list(&p);
}  /* proc_enter_q_list */


/* Local variables for get_case: */
struct LOC_get_case {
  boolean in_int;
} ;


Static Void get_case(arg_int, arg_double, in_int_, max_index, j, i, ok_case,
		     eol)
long **arg_int;
double **arg_double;
boolean in_int_;
t_integer *max_index, *j;
t_level *i;
boolean *ok_case, *eol;
{
  /* var max_double: t_integer; */
  struct LOC_get_case Local_Var;
  t_vertex v, v_0;
  t_level level_0 = MAX_LEVEL;

  Local_Var.in_int = in_int_;
  v = first_vertex;
  v_0 = last_vertex;
  sub_get_level(arg_int, arg_double, &Local_Var.in_int, j, max_index, &v,
		&i[v - MIN_VERTEX], &v_0, &level_0, eol);
      /* (j < max_index) and */
  while (!*eol && v < full_last_vertex)
  {   /* Straps (not working: look a head)! */
    v++;
    sub_get_level(arg_int, arg_double, &Local_Var.in_int, j, max_index, &v,
		  &i[v - MIN_VERTEX], &v_0, &level_0, eol);
  }
  /* if j >= max_index then
     eol := true; */
  if (v == full_last_vertex)
    *ok_case = is_case_ok(i, full_delta);
  else
    *ok_case = false;
}  /* get_case */


/* Local variables for sub_get_mixed_case: */
struct LOC_sub_get_mixed_case {
  boolean in_int;
} ;


Static Void sub_get_mixed_case(arg_int, arg_double, in_int_, max_index,
			       max_double, u, start_vertex, j, k, i, i_, x,
			       v_0, level_0, w_0, x_0, end_of_int,
			       end_of_double)
long **arg_int;
double **arg_double;
boolean in_int_;
t_long_integer *max_index, *max_double;
t_vertex *u, *start_vertex;
t_long_integer *j, *k;
t_level *i;
t_level *i_;
float *x;
t_vertex *v_0;
t_level *level_0;
t_vertex *w_0;
t_real *x_0;
boolean *end_of_int, *end_of_double;
{
  struct LOC_sub_get_mixed_case Local_Var;
  t_discrete_vertex v;
  t_continuous_vertex w;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.in_int = in_int_;
  /*$ifdef TRACE*/
  memcpy(tzt, " SubGetMixedCase    ", sizeof(pch20));
  ntr(tzt, 20L, 2327L, 1L, *j, *k);
  /*$endif TRACE*/
  if (P_inset(*u, full_delta)) {
    if (!*end_of_int) {
      v = full_to_discrete[*u - MIN_VERTEX];
      i[*u - MIN_VERTEX] = _UNDEF_LEVEL;
      if (Local_Var.in_int)
	sub_get_level(arg_int, arg_double, &Local_Var.in_int, j, max_index, u,
		      &i[*u - MIN_VERTEX], v_0, level_0, end_of_int);
      else
	sub_get_level(arg_int, arg_double, &Local_Var.in_int, k, max_double,
		      u, &i[*u - MIN_VERTEX], v_0, level_0, end_of_double);
      i_[v - MIN_VERTEX] = i[*u - MIN_VERTEX];
    }
  } else {
    if (!*end_of_double) {
      w = full_to_continuous[*u - MIN_VERTEX];
      sub_get_continuous(arg_double, k, max_double, u, w_0, start_vertex,
			 &i[*u - MIN_VERTEX], &x[w - MIN_VERTEX], x_0,
			 end_of_double);
    }
    /*$ifdef TRACE*/
  }
  ntr_boolean(tzt, 20L, 2327L, 1L, -1L, 1L, *end_of_int);
  ntr_boolean(tzt, 20L, 2327L, 1L, -1L, 2L, *end_of_double);
  /*$endif TRACE*/
}  /* sub_get_mixed_case */


Static Void get_mixed_case(arg_int, arg_double, in_int, max_index, max_double,
			   j, k, i, i_, x, ok_case, eol)
long **arg_int;
double **arg_double;
boolean in_int;
t_long_integer *max_index, *max_double, *j, *k;
t_level *i;
t_level *i_;
float *x;
boolean *ok_case, *eol;
{
  t_vertex v, start_vertex;
  boolean eoi = false, eod = false;
  t_vertex v_0, w_0;
  t_level level_0 = MAX_LEVEL;
  t_real x_0 = -1.0;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GetMixedCase       ", sizeof(pch20));
  ntr(tzt, 20L, 2328L, 1L, *j, *k);
  /*$endif TRACE*/
  v_0 = last_vertex;
  w_0 = last_vertex;
  v = first_vertex;
  start_vertex = v;
  sub_get_mixed_case(arg_int, arg_double, in_int, max_index, max_double, &v,
		     &start_vertex, j, k, i, i_, x, &v_0, &level_0, &w_0,
		     &x_0, &eoi, &eod);
  *eol = (eoi || eod);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2328L, 1L, -1L, 1L, *eol);
      /* (j < max_index) and (k < max_double) and */
  /*$endif TRACE*/
  while (!*eol && v < full_last_vertex)
  {   /* Straps (not working: look a head)! */
    v++;
    sub_get_mixed_case(arg_int, arg_double, in_int, max_index, max_double, &v,
		       &start_vertex, j, k, i, i_, x, &v_0, &level_0, &w_0,
		       &x_0, &eoi, &eod);
    *eol = (eoi || eod);
  }
  /* if j >= max_index then
     eoi := true; */
  /* if k >= max_double then
     eod := true; */
  /* Straps (not working: look a head)! */
  *eol = (eoi || eod);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2328L, 1L, -1L, 2L, *eol);
  /*$endif TRACE*/
  if (v == full_last_vertex)
    *ok_case = is_case_ok(i, full_delta);
  else
    *ok_case = false;
}  /* get_mixed_case */


Static Void read_case(data_file, i, c, ok_case, end_of_file)
FILE *data_file;
t_level *i;
Char *c;
boolean *ok_case, *end_of_file;
{
  t_vertex v, start_vertex;

  /* writeln('ReadCase'); */
  v = first_vertex;
  start_vertex = v;
  sub_read_level(data_file, i, c, &v, &start_vertex, end_of_file);
  while (!eof_data(data_file) && !*end_of_file && v < full_last_vertex) {
    v++;
    sub_read_level(data_file, i, c, &v, &start_vertex, end_of_file);
  }
  if (v == full_last_vertex)
    *ok_case = is_case_ok(i, full_delta);
  else
    *ok_case = false;
}  /* read_case */


Static Void sub_read_mixed_case(data_file, i, i_, x, u, start_vertex, c,
				end_of_file)
FILE *data_file;
t_level *i;
t_level *i_;
float *x;
t_vertex *u, *start_vertex;
Char *c;
boolean *end_of_file;
{
  /* ok_case, */
  t_discrete_vertex v;
  t_continuous_vertex w;
  t_long_real dummy_x;

  if (P_inset(*u, full_delta)) {
    sub_read_level(data_file, i, c, u, start_vertex, end_of_file);
    v = full_to_discrete[*u - MIN_VERTEX];
    i_[v - MIN_VERTEX] = i[*u - MIN_VERTEX];
    return;
  }
  *c = '@';
  read_real_separator(data_file, false, false, "1234567890", 0L, &dummy_x, c);
  if (eof_data(data_file) | ((dummy_x < 0) & is_invalid_real(dummy_x))) {
    if (*u != *start_vertex) {
      write_pch(stdout, " Eof at ", 8L);
      print_vertex(*u);
      write_real(stdout, dummy_x, 10L, 5L);
      write_line(stdout);
    }
    *end_of_file = true;
    i[*u - MIN_VERTEX] = _UNDEF_LEVEL;
    return;
  }
  w = full_to_continuous[*u - MIN_VERTEX];
  x[w - MIN_VERTEX] = dummy_x;
  if (is_invalid_real(dummy_x))
    i[*u - MIN_VERTEX] = MISSING_LEVEL;
  else
    i[*u - MIN_VERTEX] = (long)floor(dummy_x + 0.5) % (MAX_LEVEL / 2);
}  /* sub_read_mixed_case */


Static Void read_mixed_case(data_file, i, i_, x, c, ok_case, end_of_file)
FILE *data_file;
t_level *i;
t_level *i_;
float *x;
Char *c;
boolean *ok_case, *end_of_file;
{
  t_vertex v, start_vertex;

  v = first_vertex;
  start_vertex = v;
  while (!eof_data(data_file) && !*end_of_file && v <= full_last_vertex) {
    /* ok_case, */
    sub_read_mixed_case(data_file, i, i_, x, &v, &start_vertex, c,
			end_of_file);
    if (i[v - MIN_VERTEX] != _UNDEF_LEVEL) {
      v++;
      continue;
    }
    if (v != first_vertex) {
      write_pch(stdout, " EOF at ", 8L);
      print_vertex(v);
      write_line(stdout);
    }
    *end_of_file = true;
  }
  v--;
  if (v == full_last_vertex)
    *ok_case = is_case_ok(i, full_delta);
  else
    *ok_case = false;
}  /* read_mixed_case */


Static Void enter_list(accumulated, arg_pos_int, arg_pos_double, nargs,
		       arg_int, arg_double, ifail, as_argument, data_file)
boolean accumulated;
t_integer arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
t_integer *ifail;
boolean as_argument;
FILE *data_file;
{
  boolean ok_case;
  boolean local_end_of_data = false;
  boolean in_int;
  t_cell i;
  t_integer_vector i_;
  t_real_vector x;
  Char c;
  t_long_integer case_number = 1, n_of_cases = 1, j = 0, k = 0;
  t_long_integer max_index, max_double;
  boolean dummy_ok;

  if (as_argument) {
    if (ok_int_arg(ifail, arg_pos_int, 0L, nargs, arg_int))
      max_index = (*nargs)[arg_pos_int];
    in_int = (max_index > 0);
    if (!in_int || mixed_data) {
      if (ok_double_arg(ifail, arg_pos_double, 0L, nargs, arg_double))
	max_double = (*nargs)[arg_pos_double];
      if (!in_int)
	max_index = max_double;
    } else
      max_double = 1;
  }
  /*$ifdef TRACE*/
  ntr(" NewEnterList       ", 20L, 2332L, 1L, max_index, max_double);
  /*$endif TRACE*/
  /* dispose_all_expressions;
     dispose_tests;
     dispose_marginals; */
  init_datastructure();
  read_obs = true;
  term = (terminal || !strncmp(command_name, data_name, sizeof(pch_long)));
  if (as_argument) {
    if (accumulated) {
      n_of_cases = (*arg_int)[j];
      j++;
    }
    if (mixed_data)
      get_mixed_case(arg_int, arg_double, in_int, &max_index, &max_double, &j,
		     &k, i, i_, x, &ok_case, &local_end_of_data);
    else
      get_case(arg_int, arg_double, in_int, &max_index, &j, i, &ok_case,
	       &local_end_of_data);
  } else {
    /* max_double, */
    if (accumulated)
      read_integer_data(data_file, false, false, &n_of_cases);
    if (mixed_data)
      read_mixed_case(data_file, i, i_, x, &c, &ok_case, &local_end_of_data);
    else
      read_case(data_file, i, &c, &ok_case, &local_end_of_data);
  }
  while (!local_end_of_data && n[0] < MAX_COUNT_NUMBER) {
    /*$ifdef TRACE*/
    ntr(" NewEnterList", 13L, 2332L, 1L, j, k);
    if (boolean_option[20]) {
      if (mixed_data)
	note_mixed_case(i, i_, x, &term, as_argument, &case_number);
      else
	note_case(i, &term, as_argument, &case_number);
    }
    /*$endif TRACE*/
    if (ok_case) {
      if (mixed_data)
	insert_mixed_cases(i, i_, x, n_of_cases);
      else
	insert_cases_(i, n_of_cases);
    } else if (mixed_data)
      note_skip_mixed_case(i, i_, x, &term, as_argument, &case_number,
			   data_file);
    else
      note_skip_case(i, &term, as_argument, &case_number, data_file);
    if (as_argument) {
      if (c == ';' || j >= max_index || k >= max_double) {
	local_end_of_data = true;
	break;
      }
      case_number++;
      if (accumulated) {
	n_of_cases = (*arg_int)[j];
	j++;
      }
      if (mixed_data)
	get_mixed_case(arg_int, arg_double, in_int, &max_index, &max_double,
		       &j, &k, i, i_, x, &ok_case, &local_end_of_data);
      else {
	get_case(arg_int, arg_double, in_int, &max_index, &j, i, &ok_case,
		 &local_end_of_data);
	/* max_double, */
      }
      continue;
    }
    if ((c == ';') | eof_data(data_file)) {
      local_end_of_data = true;
      break;
/* p2c: coco_d_p2c.p: Note: Deleting unreachable code [255] */
    }
    case_number++;
    if (accumulated)
      read_integer_data(data_file, false, false, &n_of_cases);
    if (mixed_data)
      read_mixed_case(data_file, i, i_, x, &c, &ok_case, &local_end_of_data);
    else
      read_case(data_file, i, &c, &ok_case, &local_end_of_data);
  }
  if (term && diary && !as_argument)
    write_line_diary();
  if (datastructure == all && !mixed_data) {
    if (TURBO_PC)
      write_pch(stdout, " WAIT !! -", 10L);
    write_pch(stdout, " Finding all marginals.", 23L);
    write_line(stdout);
    find_all_marginals(&dummy_ok);
  }
  if (local_end_of_data | end_of_data(as_argument, &j, &k, &max_index,
				      &max_double, data_file)) {
    if (n[0] == 1) {
      if (!as_argument) {
	write_pch(stdout, " 1 case read.", 13L);
	write_line(stdout);
      }
    } else {
      write_integer(stdout, n[0], 5L);
      write_pch(stdout, " cases read.", 12L);
      write_line(stdout);
    }
  } else {
    write_pch(stdout, " Too many observations.", 23L);
    write_line(stdout);
    if (n[0] == 1)
      write_pch(stdout, " 1 case read.", 13L);
    else {
      write_integer(stdout, n[0], 5L);
      write_pch(stdout, " cases read.", 12L);
    }
    note_last_read_data_line(data_file);
  }
  close_datastructure();
  if (incomplete_table) {
    write_line(stdout);
    test_zero_data();
  }
}  /* enter_list */


Static Void read_list(data_file, accumulated)
FILE *data_file;
boolean accumulated;
{
  t_integer ifail = 0;
  long *nargs = NULL, *arg_int = NULL;
  double *arg_double;

  enter_list(accumulated, 0L, 0L, &nargs, &arg_int, &arg_double, &ifail,
	     false, data_file);
}  /* read_list */


Local Void read_specifikations(spec_file)
FILE *spec_file;
{
  Char c = ' ';
  t_long_integer skip_count = 0;
  boolean noted = false;

  term = (terminal || !strncmp(command_name, spec_name, sizeof(pch_long)));
  do {
    do {
      if (eolnnotf_data(spec_file))
	read_line_data(spec_file);
      else if (eof_data(spec_file))
	c = ';';
      else
	read_char_data(spec_file, &c);
    } while (c == ' ' || c == '\t');
    if (c == '#' || c == '%') {
      c = '@';
      while (!(eolnnotf_data(spec_file) || c == ';'))
	read_char_data(spec_file, &c);
      c = ' ';
    } else if (c == 'F' || c == 'f') {
      seek_word(spec_file, false, false, "Factors", 2L, 7L,
		skip_count, true);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    } else if (c == 'N' || c == 'n') {
      seek_word(spec_file, false, false, "Names", 2L, 5L,
		skip_count, true);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    } else if (c == ';')
      skip_word(spec_file, c, &skip_count, true);
    else {
      if (!noted) {
	write_pch(stdout, " Keyword `Names' or `Factors' expected", 38L);
	write_line(stdout);
	noted = true;
      }
      skip_word(spec_file, c, &skip_count, true);
      c = ' ';
    }
  } while (c != 'F' && c != 'f' && c != 'N' && c != 'n' && c != '@' &&
	   c != ';' && c != '/' && skip_count <= 10);
  if (skip_count > 10) {
    write_pch(stdout, " Given up skipping unrecognized keywords", 40L);
    write_line(stdout);
  }
  if (c == 'F' || c == 'f') {
    read_factors(spec_file);
    return;
  }
  if (c == 'N' || c == 'n') {
    read_names(spec_file);
    return;
  }
  write_pch(stdout, " NO FACTORS OR NAMES FOUND.", 27L);
  if (term && diary)
    write_line_diary();
}  /* read_specifikations */

Local Void read_data_file(data_file)
FILE *data_file;
{
  Char c = ' ';
  Char q_type;
  t_long_integer skip_count = 0;
  boolean spec_end = true, noted = false;
  boolean ok;

  term = (terminal || !strncmp(command_name, data_name, sizeof(pch_long)));
  do {
    do {
      if (spec_end && (c == ';' || c == '/')) {
	c = ' ';
	spec_end = false;
      }
      if (eolnnotf_data(data_file))
	read_line_data(data_file);
      else if (eof_data(data_file))
	c = '@';
      else
	read_char_data(data_file, &c);
    } while (spec_end && (c == ';' || c == '/') || c == ' ' || c == '\t');
    spec_end = false;
    if (c == 'C' || c == 'c') {
      do {
	ok = seek_word(data_file, false, false, "Cutpoint", 2L,
		       8L, skip_count, true);
	read_cutpoint(data_file, &c, &ok);
      } while (c == 'C' || c == 'c');
      if (c != 'T' && c != 't' && c != 'L' && c != 'l' && c != 'A' &&
	  c != 'a' && c != 'Q' && c != 'q' && c != '#' && c != '%' &&
	  c != '@')
	c = ':';
    }
    if (c != ';' && c != '/' && c != '@' && c != ':') {
      if (c == '#' || c == '%') {
	c = '@';
	while (!(eolnnotf_data(data_file) || c == ';'))
	  read_char_data(data_file, &c);
	c = ' ';
      } else if (c == 'Q' || c == 'q') {
	q_type = ' ';
	do {
	  do {
	    if (eolnnotf_data(data_file))
	      read_line_data(data_file);
	    else if (eof_data(data_file))
	      q_type = '@';
	    else
	      read_char_data(data_file, &q_type);
	  } while (q_type == ' ' || q_type == '\t');
	  if (q_type != '-' && q_type != '_') {
	    if (q_type == 'T' || q_type == 't')
	      ok = seek_word(data_file, false, false, "Q-Table",
			     4L, 7L, skip_count, true);
	    else if (q_type == 'L' || q_type == 'l')
	      ok = seek_word(data_file, false, false, "Q-List",
			     4L, 6L, skip_count, true);
	    else if (q_type == '@')
	      skip_word(data_file, q_type, &skip_count, true);
	    else {
	      if (!noted) {
		write_pch(stdout,
			    " Keyword `Q-Table' or `Q-List' expected", 39L);
		write_line(stdout);
		noted = true;
	      }
	      skip_word(data_file, q_type, &skip_count, true);
	      q_type = ' ';
	    }
	  }
	} while (q_type != 'L' && q_type != 'l' && q_type != 'T' &&
		 q_type != 't' && q_type != '@' && q_type != ';');
	if (q_type == 'L' || q_type == 'l')
	  read_q_list_data(data_file);
	else
	  read_q_table_data(data_file);
	spec_end = true;
	c = ' ';
	noted = false;
      } else if (c == 'T' || c == 't')
	ok = seek_word(data_file, false, false, "Table", 2L,
		       5L, skip_count, true);
      else if (c == 'L' || c == 'l')
	ok = seek_word(data_file, false, false, "List", 2L,
		       4L, skip_count, true);
      else if (c == 'A' || c == 'a')
	ok = seek_word(data_file, false, false, "Accumulated-list", 2L,
		       16L, skip_count, true);
      else {
	if (!noted) {
	  write_pch(stdout,
		      " Keyword `Table', `List', `Accumulated-list',",
		      45L);
	  write_line(stdout);
	  write_pch(stdout,
		      " `Q-Table', `Q-List' or `Cutpoints' expected",
		      44L);
	  write_line(stdout);
	  noted = true;
	}
	skip_word(data_file, c, &skip_count, true);
	c = ' ';
      }
    }
  } while (c != 'T' && c != 't' && c != 'L' && c != 'l' && c != 'A' &&
	   c != 'a' && c != '@' && c != ';' && c != '/' && skip_count <= 10);
  if (skip_count > 10) {
    write_pch(stdout, " Given up skipping unrecognized keywords", 40L);
    write_line(stdout);
  }
  if (c == 'T' || c == 't') {
    read_table(data_file);
    return;
  }
  if (c == 'L' || c == 'l') {
    read_list(data_file, false);
    return;
  }
  if (c == 'A' || c == 'a')
    read_list(data_file, true);
  else
    write_pch(stdout, " NO DATA FOUND.", 15L);
}  /* read_data_file */


/*@+"read.p"*/

/*

2336:    +++  ++
2337:    +++  ++
2338:    ---  -- p/read.p         11      52     699 p/read.p
2339: |    4:    procedure read_data
2340: |    7:    procedure read_specifikations
2341: |   67:    procedure read_data_file
2342: |  266:    procedure proc_enter_data
2343: |  329:    procedure return_model_set
2344: |  351:    procedure return_model_set_integer
2345: |  377:    procedure return_names
2346: |  398:    procedure return_levels
2347: |  454:    procedure return_marginal_dimension
2348: |  482:    procedure return_dimension
2349: |  504:    procedure return_edges
2350:    +++  ++
2351:    +++  ++

*/

Static Void read_data(command_file, choice)
FILE *command_file;
t_integer *choice;
{
  observation_line_number = data_line_number;
  if (diary &&
      (terminal || !strncmp(command_name, spec_name, sizeof(pch_long))))
    write_char_text(diary_file, ' ');
  if (!terminal &&
      (strncmp(command_name, spec_name, sizeof(pch_long)) ||
       *choice != 2 && *choice != 3 && *choice != 4 && *choice != 1) &&
      (strncmp(command_name, data_name, sizeof(pch_long)) ||
       *choice != 5 && *choice != 6 && *choice != 7) && log_on &&
      log_data_on) {
    write_line_text(log_file);
    write_pch_10_text(log_file, "#Data: ", 7L);
  }
  switch (*choice) {

  case 2:
    if (!strncmp(command_name, spec_name, sizeof(pch_long)) || terminal)
      read_specifikations(command_file);
    else
      read_specifikations(spec_file);
    break;

  case 3:
    if (!strncmp(command_name, spec_name, sizeof(pch_long)) || terminal)
      read_factors(command_file);
    else
      read_factors(spec_file);
    break;

  case 4:
    if (!strncmp(command_name, spec_name, sizeof(pch_long)) || terminal)
      read_names(command_file);
    else
      read_names(spec_file);
    break;

  case 5:
    if (!strncmp(command_name, data_name, sizeof(pch_long)) || terminal)
      read_data_file(command_file);
    else if (!strncmp(data_name, spec_name, sizeof(pch_long)))
      read_data_file(spec_file);
    else
      read_data_file(data_file);
    break;

  case 6:
    if (!strncmp(command_name, data_name, sizeof(pch_long)) || terminal)
      read_table(command_file);
    else if (!strncmp(data_name, spec_name, sizeof(pch_long)))
      read_table(spec_file);
    else
      read_table(data_file);
    break;

  case 7:
    if (!strncmp(command_name, data_name, sizeof(pch_long)) || terminal)
      read_list(command_file, false);
    else if (!strncmp(data_name, spec_name, sizeof(pch_long)))
      read_list(spec_file, false);
    else
      read_list(data_file, false);
    break;

  case 1:
    if (!strncmp(command_name, spec_name, sizeof(pch_long)) || terminal)
      read_specifikations(command_file);
    else
      read_specifikations(spec_file);
    if (!terminal && strncmp(command_name, data_name, sizeof(pch_long)) &&
	log_on && log_data_on) {
      write_line_text(log_file);
      write_pch_10_text(log_file, "#Data: ", 7L);
    }
    observation_line_number = data_line_number;
    if (read_spec) {
      if (!strncmp(command_name, data_name, sizeof(pch_long)) || terminal)
	read_data_file(command_file);
      else if (!strncmp(data_name, spec_name, sizeof(pch_long)))
	read_data_file(spec_file);
      else
	read_data_file(data_file);
    }
    break;
  }
}  /* read_data */


Static Void proc_enter_data(command_file, code, as_argument, ifail, sub_code,
			    arg_pos_char, arg_pos_int, arg_pos_double, nargs,
			    arg_char, arg_int, arg_double)
FILE *command_file;
t_integer code;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int, arg_pos_double;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
{
  boolean ok;

  if (as_argument && *sub_code != 0) {
    switch (code) {

    case 1:
      set_ifail(ifail, 73L);
      break;

    case 2:
      set_ifail(ifail, 73L);
      break;

    case 3:
      set_ifail(ifail, 73L);
      break;

    case 4:
      enter_names(arg_pos_char, arg_pos_int, nargs, arg_char, arg_int, ifail);
      break;

    case 5:
      set_ifail(ifail, 73L);
      break;

    case 6:
      enter_table(arg_pos_int, nargs, arg_int, ifail, *sub_code != 0,
		  *sub_code == 1, command_file);
      break;

    case 7:
      enter_list(*sub_code == 2, arg_pos_int, arg_pos_double, nargs, arg_int,
		 arg_double, ifail, *sub_code != 0, command_file);
      break;
    }
    return;
  }
  if (as_argument) {
    term = true;
    if (terminal || !strncmp(command_name, spec_name, sizeof(pch_long)))
      read_line_data(command_file);
  }
  if (!terminal && code <= 4 && !spec_file_set) {
    default_to_file_name(DEFAULT_SPECIFICATION, spec_name);
    assign_read_cocolib(&spec_file, spec_name, &ok);
    if (code == 1)
      memcpy(data_name, spec_name, sizeof(pch_long));
    if (!ok)
      write_file_not_found(stdout, spec_name);
    else
      spec_file_set = true;
  } else if (!terminal && code >= 5 &&
	     strncmp(data_name, spec_name, sizeof(pch_long)) &&
	     !data_file_set) {
    default_to_file_name(DEFAULT_OBSERVATION, data_name);
    assign_read_cocolib(&data_file, data_name, &ok);
    if (!ok)
      write_file_not_found(stdout, data_name);
    else
      data_file_set = true;
  }
  read_data(command_file, &code);
}  /* proc_enter_data */


Static Void return_model_set(ifail, sub_code, arg_pos_char, nargs, arg_char)
t_integer *ifail, *sub_code, arg_pos_char;
long **nargs;
Char **arg_char;
{
  t_vertex_set a;
  t_integer i = PCH_START;
  t_model_list *p;

  sub_code_to_model(ifail, sub_code, &p);
  if (p == NULL) {
    set_ifail(ifail, 20L);
    return;
  }
  *sub_code = -1;
  P_setcpy(a, empty_set);
  get_vertex_set(stdin, true, true, true, true, &i, ifail, sub_code,
		 arg_pos_char, nargs, arg_char, "", 10L,
		 p->model->id->vertices, a);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
}  /* return_model_set */


Static Void return_model_set_integer(ifail, sub_code, arg_pos_int, nargs,
				     arg_int)
t_integer *ifail, *sub_code, arg_pos_int;
long **nargs, **arg_int;
{
  t_vertex v;
  t_integer i = 0;
  t_integer x;
  t_model_list *p;

  sub_code_to_model(ifail, sub_code, &p);
  if (p == NULL) {
    set_ifail(ifail, 20L);
    return;
  }
  *sub_code = -1;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, p->model->id->vertices))
      x = 1;
    else
      x = 0;
    get_next_integer(stdin, true, &i, ifail, sub_code, arg_pos_int, nargs,
		     arg_int, "", 0L, &x);
  }
  (*nargs)[arg_pos_int] = i;
}  /* return_model_set_integer */


Static Void return_names(ifail, sub_code, arg_pos_char, nargs, arg_char)
t_integer *ifail, *sub_code, arg_pos_char;
long **nargs;
Char **arg_char;
{
  boolean full;
  t_vertex_set a;
  t_integer i = PCH_START;

  full = (*sub_code == 2);
  if (full)
    P_setcpy(a, full_delta_gamma);
  else
    P_setcpy(a, delta_gamma);
  *sub_code = -1;
  get_vertex_set(stdin, true, true, full, true, &i, ifail, sub_code,
		 arg_pos_char, nargs, arg_char, "", 10L, a, a);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
}  /* return_names */


Static Void return_levels(ifail, sub_code, arg_pos_int, nargs, arg_int)
t_integer *ifail, *sub_code, arg_pos_int;
long **nargs, **arg_int;
{
  boolean full, levels, types;
  t_vertex v, u;
  t_integer i = 0;
  t_integer x;

  full = (*sub_code < 4);
  types = (*sub_code == 3 || *sub_code == 6);
  levels = (*sub_code == 1 || *sub_code == 4);
  *sub_code = -1;
  u = first_vertex;
  if (full) {
    for (v = first_vertex; v <= full_last_vertex; v++) {
      if (types) {
	if (P_inset(v, full_gamma))
	  x = 0;
	else {
	  if (P_inset(u, ordinal_factors))
	    x = 2;
	  else
	    x = 1;
	}
      } else {
	if (full_variable_description[v - MIN_VERTEX]->variable_type ==
	    continuous)
	  x = 0;
	else {
	  if (levels)
	    x = full_variable_description[v - MIN_VERTEX]->UU.U0.levels;
	  else
	    x = full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing;
	}
      }
      if (P_inset(v, subset))
	u++;
      get_next_integer(stdin, true, &i, ifail, sub_code, arg_pos_int, nargs,
		       arg_int, "", 0L, &x);
    }
  } else {
    for (v = first_vertex; v <= last_vertex; v++) {
      if (types) {
	if (P_inset(v, gamma_))
	  x = 0;
	else {
	  if (P_inset(v, ordinal_factors))
	    x = 2;
	  else
	    x = 1;
	}
      } else {
	if (variable_description[v - MIN_VERTEX]->variable_type == continuous)
	  x = 0;
	else {
	  if (levels)
	    x = variable_description[v - MIN_VERTEX]->UU.U0.levels;
	  else
	    x = variable_description[v - MIN_VERTEX]->UU.U0.levels_missing;
	}
      }
      get_next_integer(stdin, true, &i, ifail, sub_code, arg_pos_int, nargs,
		       arg_int, "", 0L, &x);
    }
  }
  (*nargs)[arg_pos_int] = i;
}  /* return_levels */


Static Void return_marginal_dimension(ifail, sub_code, arg_pos_char,
				      arg_pos_int, nargs, arg_char, arg_int)
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  boolean full, total;
  t_vertex_set a;
  t_integer i;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnMarginalDimen", sizeof(pch20));
  ntr(tzt, 20L, 2347L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if (ok_int_arg(ifail, arg_pos_int, 1L, nargs, arg_int)) {
    full = (*sub_code == 2 || *sub_code == 4);
    total = (*sub_code > 2);
    i = PCH_START;
    *sub_code = 1;
    P_setcpy(a, empty_set);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 2347L, 1L, -1L, i, a);
    /*$endif TRACE*/
    get_vertex_set(stdin, true, true, full, true, &i, ifail, sub_code,
		   arg_pos_char, nargs, arg_char, "", 10L, a, a);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 2347L, 1L, -2L, i, a);
    /*$endif TRACE*/
    i = marginal_dimension_tf(a, total, full);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 2347L, 1L, -3L, i, a);
    /*$endif TRACE*/
    *sub_code = -1;
    get_one_integer(stdin, true, ifail, sub_code, arg_pos_int, nargs, arg_int,
		    "", 0L, &i);
  } else {
    /*$ifdef TRACE*/
    set_ifail(ifail, 20L);
  }
  /*$endif TRACE*/
  ntr(tzt, 20L, 2347L, 1L, -4L, *ifail);
}  /* return_marginal_dimension */


Static Void return_dimension(ifail, sub_code, arg_pos_int, nargs, arg_int)
t_integer *ifail, *sub_code, arg_pos_int;
long **nargs, **arg_int;
{
  boolean full;
  t_integer i = 0;

  if (!ok_int_arg(ifail, arg_pos_int, 1L, nargs, arg_int)) {
    set_ifail(ifail, 20L);
    return;
  }
  full = (*sub_code == 2);
  if (full)
    i = full_dimension;
  else
    i = dimension;
  *sub_code = -1;
  get_one_integer(stdin, true, ifail, sub_code, arg_pos_int, nargs, arg_int,
		  "", 0L, &i);
}  /* return_dimension */


Static Void return_edges(ifail, sub_code, arg_pos_int, nargs, arg_int)
t_integer *ifail, *sub_code, arg_pos_int;
long **nargs, **arg_int;
{
  t_integer i = 0;
  t_integer edges, fix;
  t_integer x = -1;
  t_vertex_set a, b;
  t_vertex v, w;
  t_model_list *p;
  t_set_list *g_c;

  edges = 0;
  fix = 0;
  sub_code_to_model(ifail, sub_code, &p);
  get_next_integer(stdin, true, &i, ifail, sub_code, arg_pos_int, nargs,
		   arg_int, "", 0L, &edges);
  get_next_integer(stdin, true, &i, ifail, sub_code, arg_pos_int, nargs,
		   arg_int, "", 0L, &fix);
  if (p == NULL || *ifail != 0) {
    set_ifail(ifail, 20L);
    return;
  }
  *sub_code = -1;
  i = 0;
  get_next_integer(stdin, true, &i, ifail, sub_code, arg_pos_int, nargs,
		   arg_int, "", 0L, &x);
  get_next_integer(stdin, true, &i, ifail, sub_code, arg_pos_int, nargs,
		   arg_int, "", 0L, &x);
  i = 0;
  g_c = return_g_c_copy(&p->model);
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    P_addset(P_expset(a, 0L), v);   /* empty_set + */
    for (w = v + 1; w <= last_vertex; w++) {
      P_setcpy(b, a);
      P_addset(b, w);
      if (((((edges == -1) & (!subset_of_an_edge(b, &g_c))) || edges == 0) |
	   ((edges == 1) & subset_of_an_edge(b, &g_c))) &
	  ((((fix == -1) & (!P_inset(w, fix_edges_adj_set[v - MIN_VERTEX]))) ||
	    fix == 0) | ((fix == 1) & P_inset(w,
			   fix_edges_adj_set[v - MIN_VERTEX])))) {
	x = v - first_vertex;
	get_next_integer(stdin, true, &i, ifail, sub_code, arg_pos_int, nargs,
			 arg_int, "", 0L, &x);
	x = w - first_vertex;
	get_next_integer(stdin, true, &i, ifail, sub_code, arg_pos_int, nargs,
			 arg_int, "", 0L, &x);
      }
    }
  }
  dispose_set_list(&g_c);
  (*nargs)[arg_pos_int] = i;
}  /* return_edges */


/*@-"parser.c"*/
/*@+"makepar.p"*/


/*

2352:    +++  ++
2353:    +++  ++
2354:    ---  -- p/makepar.p         18      71     890 p/makepar.p
2355: |    4:    function command_less_than
2356: |   10:    procedure print_productions
2357: |   19:    function find_pos
2358: |   35:    procedure get_next_expected
2359: |  150:    procedure make_parser_table
2360: |  159:    procedure sorter
2361: |  163:    function findpivot
2362: |  185:    function partition
2363: |  189:    procedure swap
2364: |  210:    procedure quicksort
2365: |  231:    procedure get_char
2366: |  242:    procedure seek_1
2367: |  252:    procedure seek_2
2368: |  398:    procedure init_command_parser
2369: |  478:    procedure print_alias
2370: |  501:    function find_word_pos
2371: |  523:    procedure make_alias
2372: |  592:    procedure delete_alias
2373:    +++  ++
2374:    +++  ++

*/


Static boolean command_less_than(a, b)
t_command_des *a, *b;
{
  return (a->current_level < b->current_level ||
	  (a->current_level == b->current_level &&
	   strncmp(a->name, b->name, sizeof(t_command_name)) < 0));
}  /* command_less_than */


/* Local variables for print_productions: */
struct LOC_print_productions {
  FILE *new_help;
  boolean visited[MAX_NUMBER_OF_PRODUCTIONS];
  t_integer pos_i[500];
} ;

Local t_integer find_pos(level, LINK)
t_integer *level;
struct LOC_print_productions *LINK;
{
  t_integer l = 1;
  t_integer r, k;

  r = number_of_productions;
  do {
    k = (l + r) / 2;
    if (command_array[k-1].current_level >= *level)
      r = k - 1;
    if (*level >= command_array[k-1].current_level)
      l = k + 1;
  } while (r >= l);
  return (r + 1);
}  /* find_pos */

Local Void get_next_expected(level, sum_offset, n_words, n_levels_eq,
			     write_label, LINK)
t_integer level, sum_offset, n_words, n_levels_eq;
boolean write_label;
struct LOC_print_productions *LINK;
{
  t_integer i, pos;

  if (false)
    return;
  if (true) {
    write_pch_10_text(LINK->new_help, "+ . ", 4L);
    write_integer_text(LINK->new_help, level, 6L);
    write_pch_10_text(LINK->new_help, "   $", 4L);
    for (i = 0; i <= n_words - 2; i++) {
      write_char_text(LINK->new_help, ' ');
      for (pos = 0; pos < COMMAND_LENGTH; pos++) {
	if (command_array[LINK->pos_i[i] - 1].name[pos] != ' ')
	  write_char_text(LINK->new_help,
			  command_array[LINK->pos_i[i] - 1].name[pos]);
      }
    }
    write_pch_10_text(LINK->new_help, " ...", 4L);
    write_line_stdout();
    write_line_text(LINK->new_help);
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2358L, 1L))
    write_pch(stdout, " Enter:   ", 10L);
  /*$endif TRACE*/
  if (level == 0)
    pos = 1;
  else
    pos = find_pos(&level, LINK);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2358L, 1L)) {
    write_integer(stdout, level, 5L);
    write_integer(stdout, pos, 5L);
  }
  /*$endif TRACE*/
  while (command_array[pos-1].current_level >= level && pos > 1)
    pos--;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2358L, 1L))
    write_integer(stdout, pos, 5L);
  /*$endif TRACE*/
  if (pos <= 0)
    pos = 1;
  while (command_array[pos-1].current_level != level &&
	 pos < number_of_productions)
    pos++;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2358L, 1L)) {
    write_integer(stdout, pos, 5L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  while (command_array[pos-1].current_level == level) {
    LINK->pos_i[n_words-1] = pos;
    if (command_array[pos-1].next_level >= 1 &&
	command_array[pos-1].next_level <= 199) {
      if (!LINK->visited[pos-1] && n_levels_eq < 1) {
	LINK->visited[pos-1] = true;
	if (command_array[pos-1].current_level == command_array[pos-1].next_level)
	  get_next_expected((long)command_array[pos-1].next_level,
			    sum_offset + command_array[pos-1].offset,
			    n_words + 1, n_levels_eq + 1, write_label, LINK);
	else
	  get_next_expected((long)command_array[pos-1].next_level,
			    sum_offset + command_array[pos-1].offset,
			    n_words + 1, n_levels_eq, write_label, LINK);
	LINK->visited[pos-1] = false;
      }
    } else {
      write_integer(stdout, sum_offset + command_array[pos-1].offset, 5L);
      write_integer(stdout, (long)command_array[pos-1].next_level, 5L);
      if (write_label) {
	if (command_array[pos-1].next_level == 255)
	  write_pch(stdout, " Table-value                  ", 30L);
	else if (sum_offset + command_array[pos-1].offset <=
		 MAX_NUMBER_OF_COMMANDS)
	  write_pch(stdout,
		      command_text[sum_offset + command_array[pos-1].offset],
		      30L);
	else
	  write_pch(stdout, " ?: Error in GetNextExpected.", 29L);
      }
      write_space(stdout, 5L);
      for (i = 0; i < n_words; i++) {
	write_command_name(stdout, command_array[LINK->pos_i[i] - 1].name,
			   (long)COMMAND_LENGTH);
	write_space(stdout, 1L);
      }
      write_line(stdout);
    }
    pos++;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2358L, 1L)) {
    write_pch(stdout, " Exit     ", 10L);
    write_line(stdout);
  }
  /*$endif TRACE*/
}  /* get_next_expected */


Static Void print_productions()
{
  struct LOC_print_productions Local_Var;
  pch_long file_name;
  t_integer i;
  boolean ok;

  Local_Var.new_help = NULL;
  for (i = 0; i < MAX_NUMBER_OF_PRODUCTIONS; i++)
    Local_Var.visited[i] = false;
  default_to_file_name(FILE_NAME_NEW_HELP, file_name);
  assign_write(&Local_Var.new_help, file_name, &ok);
  get_next_expected(0L, 0L, 1L, 0L, true, &Local_Var);
  get_next_expected((long)VALUE_OFFSET, 0L, 1L, 0L, false, &Local_Var);
  get_next_expected((long)SWITCH_OFFSET, 0L, 1L, 0L, false, &Local_Var);
  if (Local_Var.new_help != NULL)
    fclose(Local_Var.new_help);
}  /* print_productions */


Local t_integer findpivot__(a, i, j)
t_command_des *a;
t_integer *i, *j;
{
  long Result = 0;
  t_command_des firstkey;
  t_integer k;

  firstkey = a[*i - 1];
  k = *i;
  while (k <= *j) {
    if (command_less_than(&firstkey, &a[k-1])) {
      Result = k;
      k = *j;
    } else if (command_less_than(&a[k-1], &firstkey)) {
      Result = *i;
      k = *j;
    }
    k++;
  }
  return Result;
}  /* findpivot */

Local Void swap__(x, y)
t_command_des *x, *y;
{
  t_command_des z;

  z = *x;
  *x = *y;
  *y = z;
}  /* swap */

Local t_integer partition__(a, l, r, pivot)
t_command_des *a;
t_integer l, r;
t_command_des *pivot;
{
  do {
    swap__(&a[l-1], &a[r-1]);
    while (command_less_than(&a[l-1], pivot))
      l++;
    while (!command_less_than(&a[r-1], pivot))
      r--;
  } while (l <= r);
  return l;
}  /* partition */

Local Void quicksort__(a, i, j)
t_command_des *a;
t_integer i, j;
{
  t_command_des pivot;
  t_integer pivotindex, k;

  pivotindex = findpivot__(a, &i, &j);
  if (pivotindex == 0)
    return;
  pivot = a[pivotindex-1];
  k = partition__(a, i, j, &pivot);
  quicksort__(a, i, k - 1);
  quicksort__(a, k, j);
}  /* quicksort */

Local Void sorter(a, min, max)
t_command_des *a;
t_integer min, max;
{
  quicksort__(a, min, max);
}  /* sorter */

Local Void get_char(fil, a)
FILE *fil;
Char *a;
{
  while (eolnnotf_parser(fil))
    read_text_ln(fil);
  if (!eof_parser(fil))
    read_text_char(fil, a);
  else
    *a = '@';
}  /* get_char */

Local Void seek_1(fil, a)
FILE *fil;
Char a;
{
  Char c;

  get_char(fil, &c);
  while ((c != a) & (!eof_parser(fil)))
    get_char(fil, &c);
}  /* seek */

Local Void seek_2(fil, a, b)
FILE *fil;
Char a, b;
{
  Char c;

  get_char(fil, &c);
  while ((c != a && c != b) & (!eof_parser(fil)))
    get_char(fil, &c);
}  /* seek_2 */


Static Void make_parser_table()
{
  pch_long file_name;
  FILE *parser_table = NULL, *parser_file = NULL;
  t_integer i, j, k;
  pch20 name_read;
  boolean ok;
  Char c;
  long FORLIM;
  t_command_des *WITH;

  default_to_file_name(FILE_NAME_INIT, file_name);
  assign_read(&parser_file, file_name, &ok);
  if (!ok) {
    write_file_not_found(stdout, file_name);
    _Escape(0);
  }
  for (i = 0; i <= MAX_NUMBER_OF_COMMANDS; i++)
    memcpy(command_text[i], "                              ", sizeof(pch30));
  for (i = 0; i <= MAX_NUMBER_OF_COMMANDS; i++) {
    for (k = 0; k < MAX_N_OF_COMMAND_TESTS; k++)
      command_test[i][k] = 0;
  }
  i = 1;
  while (!eof_parser(parser_file)) {
    read_parser_char(parser_file, &c);
    if (c != '#') {
      if (c != ' ') {
	if (c == '*') {
	  WITH = &command_array[i-1];
	  read_parser_char(parser_file, &c);
	  if (c == '=' || c == '+') {
	    seek_1(parser_file, '(');
	    read_parser_level(parser_file, 4L, &WITH->current_level);
	    seek_1(parser_file, '(');
	    read_parser_level(parser_file, 4L, &WITH->next_level);
	    seek_2(parser_file, '[', '{');   /*Killing read*/
	    read_parser_level(parser_file, 4L, &WITH->offset);
	    if (c == '=') {
	      seek_1(parser_file, '=');
	      for (k = 0; k < MAX_N_OF_COMMAND_TESTS; k++) {
		read_parser_integer(parser_file, 2L, &j);
		command_test[WITH->offset][k] = j;
	      }
	    }
	    seek_2(parser_file, '@', '!');
	    for (k = 0; k <= 9; k++) {
	      if (eoln_parser(parser_file))
		name_read[k] = ' ';
	      else
		read_parser_char(parser_file, &name_read[k]);
	    }
	    for (j = 0; j < COMMAND_LENGTH; j++) {
	      if (j + 1 > 1 && (name_read[j] == '@' || name_read[j] == '!'))
		WITH->name[j] = ' ';
	      else
		WITH->name[j] = name_read[j];
	    }
	    if (!eoln_parser(parser_file)) {
	      if (c == '=') {
		seek_1(parser_file, '$');
		for (k = 0; k <= 29; k++) {
		  if (eoln_parser(parser_file))
		    command_text[WITH->offset][k] = ' ';
		  else
		    read_parser_char(parser_file, &command_text[WITH->offset]
				     [k]);
		}
	      }
	    }
	    i++;
	  }
	}
      }
    }
    read_text_ln(parser_file);
    while (eolnnotf_parser(parser_file))
      read_parser_ln(parser_file);
  }
  number_of_productions = i - 1;
  sorter(command_array, 1L, number_of_productions);
  default_to_file_name(FILE_NAME_TABLE, file_name);
  assign_write(&parser_table, file_name, &ok);
  if (!ok) {
    write_pch(stdout, " Unable to write this file", 26L);
    _Escape(0);
  }
  write_integer_text(parser_file, number_of_productions, 5L);
  write_integer_text(parser_file, (long)VERSION_A, 5L);
  write_integer_text(parser_file, (long)VERSION_B, 5L);
  write_line_text(parser_table);
  FORLIM = number_of_productions;
  for (i = 2; i <= FORLIM; i++) {
    if (command_array[i-2].current_level == command_array[i-1].current_level &&
	!strncmp(command_array[i-2].name, command_array[i-1].name,
		 sizeof(t_command_name))) {
      write_pch(stdout, " Error:   ", 10L);
      write_pch(stdout, " Level:   ", 10L);
      write_integer(stdout, (long)command_array[i-1].current_level, 4L);
      write_pch(stdout, " Next:    ", 10L);
      write_integer(stdout, (long)command_array[i-1].next_level, 4L);
      write_pch(stdout, " Offset:  ", 10L);
      write_integer(stdout, (long)command_array[i-1].offset, 4L);
      write_pch(stdout, " Name:    ", 10L);
      for (j = 0; j < COMMAND_LENGTH; j++)
	write_char(stdout, command_array[i-1].name[j]);
      write_line(stdout);
      write_pch(stdout, " Eq:      ", 10L);
      write_pch(stdout, " Level:   ", 10L);
      write_integer(stdout, (long)command_array[i-2].current_level, 4L);
      write_pch(stdout, " Next:    ", 10L);
      write_integer(stdout, (long)command_array[i-2].next_level, 4L);
      write_pch(stdout, " Offset:  ", 10L);
      write_integer(stdout, (long)command_array[i-2].offset, 4L);
      write_pch(stdout, " Name:    ", 10L);
      for (j = 0; j < COMMAND_LENGTH; j++)
	write_char(stdout, command_array[i-2].name[j]);
      write_line(stdout);
    }
  }
  FORLIM = number_of_productions / 4 + 1;
  for (i = 1; i <= FORLIM; i++) {
    for (j = 0; j <= 3; j++) {
      if (i + j * (number_of_productions / 4 + 1) <= number_of_productions) {
	WITH = &command_array[i + j * (number_of_productions / 4 + 1) - 1];
	write_integer_text(parser_file, (long)WITH->current_level, 4L);
	write_integer_text(parser_file, (long)WITH->next_level, 4L);
	write_integer_text(parser_file, (long)WITH->offset, 4L);
	write_space_text(parser_table, 1L);
	for (k = 0; k < COMMAND_LENGTH; k++)
	  write_char_text(parser_table, WITH->name[k]);
	write_char_text(parser_table, ' ');
	write_char_text(parser_table, ' ');
      }
    }
    write_line_text(parser_table);
  }
  for (i = 0; i <= MAX_NUMBER_OF_COMMANDS; i++) {
    write_pch_30_text(parser_table, command_text[i], 30L);
    write_pch_10_text(parser_table, " ;", 2L);
    for (k = 0; k < MAX_N_OF_COMMAND_TESTS; k++)
      write_integer_text(parser_file, (long)command_test[i][k], 2L);
    write_integer_text(parser_file, i, 4L);
    write_line_text(parser_table);
  }
  flush_file(&parser_table);
  if (report)
    print_productions();
  if (parser_table != NULL)
    fclose(parser_table);
  if (parser_file != NULL)
    fclose(parser_file);
}  /* make_parser_table */


Static Void init_command_parser(ifail, local)
t_integer *ifail;
boolean local;
{
  t_integer version_a_i, version_b_i, number_of_productions_i, i, j, k;
  FILE *parser_table = NULL;
  Char name_read[5];
  pch_long parser_name;
  boolean ok;
  long FORLIM;
  t_command_des *WITH;

  P_addsetr(P_expset(command_char, 0L), 'A', 'Z');
  P_addsetr(command_char, 'a', 'z');
  P_addsetr(command_char, '0', '9');
  P_addset(command_char, '!');
  P_addset(command_char, '?');
  P_addset(command_char, '&');
  P_addset(command_char, '-');
  P_addset(command_char, '[');
  P_addset(command_char, '(');
  P_addset(command_char, '{');
  P_addset(command_char, '<');
  P_addset(command_char, ')');
  P_addset(command_char, '/');
  P_addset(command_char, '#');
  /* ^- Kiling read*/

  default_to_file_name(FILE_NAME_TABLE, parser_name);
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("parser_table 1 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
  if (local)
    assign_read(&parser_table, parser_name, &ok);
  else
    assign_read_cocolib(&parser_table, parser_name, &ok);
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("parser_table 2 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
  if (!ok) {
    write_file_not_found(stdout, parser_name);
    if (!local) {
      *ifail = 52;   /* No parser table */
      /* halt */
    }
  } else {
    read_parser_integer(parser_table, 5L, &number_of_productions_i);
    read_parser_integer(parser_table, 5L, &version_a_i);
    read_parser_integer(parser_table, 5L, &version_b_i);
    read_parser_ln(parser_table);
    if (VERSION_A != version_a_i) {
      ok = false;
      write_pch(stdout, " Local Parser-table can not be used", 35L);
      write_line(stdout);
      if (!local)
	_Escape(0);
    }
    if (VERSION_B != version_b_i) {
      write_pch(stdout,
		  " Warning: Local Parser-table not up to date", 43L);
      write_line(stdout);
    }
    if (ok) {
      number_of_productions = number_of_productions_i;
      FORLIM = number_of_productions / 4 + 1;
      for (i = 1; i <= FORLIM; i++) {
	for (j = 0; j <= 3; j++) {
	  if (i + j * (number_of_productions / 4 + 1) <= number_of_productions) {
	    WITH = &command_array[i + j * (number_of_productions / 4 + 1) - 1];
	    read_parser_level(parser_table, 4L, &WITH->current_level);
	    read_parser_level(parser_table, 4L, &WITH->next_level);
	    read_parser_level(parser_table, 4L, &WITH->offset);
	    for (k = 0; k <= 4; k++)
	      read_parser_char(parser_table, &name_read[k]);
	    for (k = 1; k <= 4; k++)
	      WITH->name[k-1] = name_read[k];
	    read_parser_char(parser_table, name_read);
	    read_parser_char(parser_table, name_read);
	  }
	}
	read_parser_ln(parser_table);
      }
      for (i = 0; i <= MAX_NUMBER_OF_COMMANDS; i++) {
	for (k = 0; k <= 29; k++)
	  read_parser_char(parser_table, &command_text[i][k]);
	read_parser_char(parser_table, name_read);
	read_parser_char(parser_table, name_read);
	for (k = 0; k < MAX_N_OF_COMMAND_TESTS; k++) {
	  read_parser_integer(parser_table, 2L, &j);
	  command_test[i][k] = j;
	}
	read_parser_integer(parser_table, 4L, &j);
	read_parser_ln(parser_table);
      }
      close_file(parser_table);
    }
  }
  if (parser_table != NULL)
    fclose(parser_table);
}  /* init_command_parser */


Static Void print_alias(command_nr, level)
t_integer *command_nr, level;
{
  t_integer i = 1;
  t_integer j, current_level, next_level;

  while (command_array[i-1].current_level != level)
    i++;
  write_pch(stdout, "          =", 11L);
  do {
    current_level = command_array[i-1].current_level;
    next_level = command_array[i-1].next_level;
    if (current_level == level && next_level == 0 &&
	command_array[i-1].offset == *command_nr) {
      write_space(stdout, 1L);
      for (j = 0; j < COMMAND_LENGTH; j++)
	write_char(stdout, command_array[i-1].name[j]);
    }
    i++;
  } while (current_level == level);
  write_line(stdout);
}  /* print_alias */


Static boolean find_word_pos(command_, pos)
t_command_des *command_;
t_integer *pos;
{
  t_integer l = 1;
  t_integer r, k;

  r = number_of_productions;
  do {
    k = (l + r) / 2;
    if (!command_less_than(&command_array[k-1], command_))
      r = k - 1;
    if (!command_less_than(command_, &command_array[k-1]))
      l = k + 1;
  } while (r >= l);
  *pos = r + 1;
  if (l - r > 1) {
    *command_ = command_array[k-1];
    return true;
  } else
    return false;
}  /* find_word_pos */


Static Void make_alias(command_nr, kode, name, level)
t_integer *command_nr, *kode;
Char *name;
t_integer level;
{
  boolean ok;
  t_integer i, j, k, pos;
  pch_long file_name;
  FILE *parser_table = NULL;
  t_command_des command_;
  long FORLIM;
  t_command_des *WITH;

  if (number_of_productions <= MAX_NUMBER_OF_PRODUCTIONS) {
    command_.current_level = level;
    memcpy(command_.name, name, sizeof(t_command_name));
    if (find_word_pos(&command_, &pos)) {
      write_pch(stdout, " abbreviation exsists", 21L);
      write_line(stdout);
    } else {
      if (*kode > 0 && *kode != 54)
	command_.next_level = *kode + 200;
      else
	command_.next_level = 0;
      command_.offset = *command_nr;
      number_of_productions++;
      for (i = number_of_productions; i > pos; i--)
	command_array[i-1] = command_array[i-2];
      command_array[pos-1] = command_;
      default_to_file_name(FILE_NAME_TABLE, file_name);
      assign_write(&parser_table, file_name, &ok);
      if (!ok) {
	write_pch(stdout, " Unable to write this file", 26L);
	_Escape(0);
      }
      write_integer_text(parser_table, number_of_productions, 5L);
      write_integer_text(parser_table, (long)VERSION_A, 5L);
      write_integer_text(parser_table, (long)VERSION_B, 5L);
      write_line_text(parser_table);
      FORLIM = number_of_productions / 4 + 1;
      for (i = 1; i <= FORLIM; i++) {
	for (j = 0; j <= 3; j++) {
	  if (i + j * (number_of_productions / 4 + 1) <= number_of_productions) {
	    WITH = &command_array[i + j * (number_of_productions / 4 + 1) - 1];
	    write_integer_text(parser_table, (long)WITH->current_level, 4L);
	    write_integer_text(parser_table, (long)WITH->next_level, 4L);
	    write_integer_text(parser_table, (long)WITH->offset, 4L);
	    write_space_text(parser_table, 1L);
	    for (k = 0; k < COMMAND_LENGTH; k++)
	      write_char_text(parser_table, WITH->name[k]);
	    write_pch_10_text(parser_table, "  @@@@@@@ ", 2L);
	  }
	}
	write_line_text(parser_table);
      }
      for (i = 0; i <= MAX_NUMBER_OF_COMMANDS; i++) {
	write_pch_30_text(parser_table, command_text[i], 30L);
	write_pch_10_text(parser_table, " ;", 2L);
	for (k = 0; k < MAX_N_OF_COMMAND_TESTS; k++)
	  write_integer_text(parser_table, (long)command_test[i][k], 2L);
	write_integer_text(parser_table, i, 4L);
	write_line_text(parser_table);
      }
      flush_file(&parser_table);
    }
  } else {
    write_pch(stdout, " Parser-Table is full", 21L);
    write_line(stdout);
  }
  if (parser_table != NULL)
    fclose(parser_table);
}  /* make_alias */


Static Void delete_alias(name, level)
Char *name;
t_integer level;
{
  boolean ok;
  t_integer i, j, k, pos;
  pch_long file_name;
  FILE *parser_table = NULL;
  t_command_des command_;
  long FORLIM;
  t_command_des *WITH;

  if (number_of_productions <= MAX_NUMBER_OF_PRODUCTIONS) {
    command_.current_level = level;
    memcpy(command_.name, name, sizeof(t_command_name));
    if (!find_word_pos(&command_, &pos)) {
      write_pch(stdout, " abbreviation exsists not", 25L);
      write_line(stdout);
    } else if ((0 < command_array[pos-1].next_level &&
		command_array[pos-1].next_level < 200) ||
	       254 <= command_array[pos-1].next_level) {
      /* and
      (command_array[pos].next_level <= 255) */
      write_pch(stdout, " Do not delete this", 19L);
      write_line(stdout);
    } else {
      FORLIM = number_of_productions;
      for (i = pos; i <= FORLIM; i++)
	command_array[i-1] = command_array[i];
      number_of_productions--;
      default_to_file_name(FILE_NAME_TABLE, file_name);
      assign_write(&parser_table, file_name, &ok);
      if (!ok) {
	write_pch(stdout, " Unable to write this file", 26L);
	_Escape(0);
      }
      write_integer_text(parser_table, number_of_productions, 5L);
      write_integer_text(parser_table, (long)VERSION_A, 5L);
      write_integer_text(parser_table, (long)VERSION_B, 5L);
      write_line_text(parser_table);
      FORLIM = number_of_productions / 4 + 1;
      for (i = 1; i <= FORLIM; i++) {
	for (j = 0; j <= 3; j++) {
	  if (i + j * (number_of_productions / 4 + 1) <= number_of_productions) {
	    WITH = &command_array[i + j * (number_of_productions / 4 + 1) - 1];
	    write_integer_text(parser_table, (long)WITH->current_level, 4L);
	    write_integer_text(parser_table, (long)WITH->next_level, 4L);
	    write_integer_text(parser_table, (long)WITH->offset, 4L);
	    write_space_text(parser_table, 1L);
	    for (k = 0; k < COMMAND_LENGTH; k++)
	      write_char_text(parser_table, WITH->name[k]);
	    write_pch_10_text(parser_table, "  ", 2L);
	  }
	}
	write_line_text(parser_table);
      }
      for (i = 0; i <= MAX_NUMBER_OF_COMMANDS; i++) {
	write_pch_30_text(parser_table, command_text[i], 30L);
	write_pch_10_text(parser_table, " ;", 2L);
	for (k = 0; k < MAX_N_OF_COMMAND_TESTS; k++)
	  write_integer_text(parser_table, (long)command_test[i][k], 2L);
	write_integer_text(parser_table, i, 4L);
	write_line_text(parser_table);
      }
      flush_file(&parser_table);
    }
  } else {
    write_pch(stdout, " Parser-Table is full", 21L);
    write_line(stdout);
  }
  if (parser_table != NULL)
    fclose(parser_table);
}  /* delete_alias */


/* Local variables for sub_read_command: */
struct LOC_sub_read_command {
  FILE *command_file;
} ;

Local boolean less_than(a, b)
t_command_des *a, *b;
{
  return (a->current_level < b->current_level ||
	  (a->current_level == b->current_level &&
	   strncmp(a->name, b->name, sizeof(t_command_name)) < 0));
}  /* less_than */

Local boolean find_word(command_, pos)
t_command_des *command_;
t_long_integer *pos;
{
  t_long_integer l = 1;
  t_long_integer r, k;

  r = number_of_productions;
  do {
    k = (l + r) / 2;
    if (!less_than(&command_array[k-1], command_))
      r = k - 1;
    if (!less_than(command_, &command_array[k-1]))
      l = k + 1;
  } while (r >= l);
  *pos = r + 1;
  if (l - r > 1) {
    *command_ = command_array[k-1];
    return true;
  } else
    return false;
}  /* find_word */

Local Void print_expected(pos, level)
t_long_integer *pos, *level;
{
  t_long_integer pos_0;

  if (*level == 0 || *level == 200)
    return;
  if (*pos > number_of_productions)
    (*pos)--;
  while (command_array[*pos - 1].current_level >= *level && *pos > 0)
    (*pos)--;
  while (command_array[*pos - 1].current_level != *level &&
	 *pos < number_of_productions)
    (*pos)++;
  write_pch(stdout, " Expected:", 10L);
  write_space(stdout, 1L);
  pos_0 = *pos;
  while (command_array[*pos - 1].current_level == *level) {
    write_command_name(stdout, command_array[*pos - 1].name, 4L);
    write_space(stdout, 1L);
    (*pos)++;
    if ((*pos - pos_0) % 10 == 0 &&
	command_array[*pos - 1].current_level == *level) {
      write_line(stdout);
      write_space(stdout, 11L);
    }
  }
  write_line(stdout);
}  /* print_expected */

Local Void read_stdio_c(command_file, c)
FILE *command_file;
Char *c;
{
  if (eof_command(command_file)) {
    *c = ';';
    return;
  }
  read_text_char(command_file, c);
  if (log_on)
    write_char_text(log_file, *c);
  if (diary)
    write_char_text(diary_file, *c);
  if (!((*c == '\\' || *c == '&') & eoln_command(command_file)))
    return;
  read_text_ln(command_file);
  if (log_on)
    write_line_text(log_file);
  *c = ' ';
  write_pch(stdout, " CONT->", 7L);
}  /* read_stdio_c */

Local boolean get_word(level, offset, next_level, sep, line, line_pos, LINK)
t_long_integer *level, *offset, *next_level;
Char *sep;
Char *line;
t_long_integer *line_pos;
struct LOC_sub_read_command *LINK;
{
  t_long_integer name_pos, pos;
  boolean ok;
  boolean comment = false;
  t_command_des command_;
  long FORLIM;

  command_.current_level = *level;
  for (name_pos = 0; name_pos < COMMAND_LENGTH; name_pos++)
    command_.name[name_pos] = ' ';
  if (*sep != ';') {
    (*line_pos)++;
    read_stdio_c(LINK->command_file, &line[*line_pos - PCH_START]);
    while ((line[*line_pos - PCH_START] == ' ' && *line_pos < PCH_END) &
	   (!eolnorf_command(LINK->command_file))) {
      (*line_pos)++;
      read_stdio_c(LINK->command_file, &line[*line_pos - PCH_START]);
    }
    comment = (line[*line_pos - PCH_START] == '#');
    if ((!P_inset(line[*line_pos - PCH_START], begin_set) &&
	 line[*line_pos - PCH_START] != ';') &
	(!((line[*line_pos - PCH_START] == ' ') & eoln_command(
	     LINK->command_file))) & (!eof_command(LINK->command_file))) {
      name_pos = 1;
      if (islower(line[*line_pos - PCH_START]))
	command_.name[0] = line[*line_pos - PCH_START] - 32;
      else
	command_.name[0] = line[*line_pos - PCH_START];
      while ((P_inset(line[*line_pos - PCH_START], command_char) &&
	      *line_pos < PCH_END &&
	      name_pos < COMMAND_LENGTH) & (!eolnorf_command(LINK->command_file))) {
	(*line_pos)++;
	read_stdio_c(LINK->command_file, &line[*line_pos - PCH_START]);
	name_pos++;
	if (islower(line[*line_pos - PCH_START]))
	  command_.name[name_pos-1] = line[*line_pos - PCH_START] - 32;
	else
	  command_.name[name_pos-1] = line[*line_pos - PCH_START];
      }
      if (!P_inset(command_.name[name_pos-1], command_char))
	command_.name[name_pos-1] = ' ';
      while ((P_inset(line[*line_pos - PCH_START], command_char) &
	      (!eolnorf_command(LINK->command_file))) &&
	     *line_pos < PCH_END) {
	(*line_pos)++;
	read_stdio_c(LINK->command_file, &line[*line_pos - PCH_START]);
      }
    } else
      command_.name[0] = line[*line_pos - PCH_START];
  } else
    command_.name[0] = ';';
  if (command_.name[0] == ' ')
    command_.name[0] = ';';
  ok = find_word(&command_, &pos);
  if (ok) {
    *next_level = command_.next_level;
    *offset += command_.offset;
    *sep = line[*line_pos - PCH_START];
    if (eolnorf_command(LINK->command_file))
      *sep = ';';
    return true;
  }
  while (((line[*line_pos - PCH_START] != ';') &
	  (!eolnorf_command(LINK->command_file))) && *line_pos < PCH_END) {
    (*line_pos)++;
    read_text_char(LINK->command_file, &line[*line_pos - PCH_START]);
    if (log_on)
      write_char_text(log_file, line[*line_pos - PCH_START]);
    if (diary)
      write_char_text(diary_file, line[*line_pos - PCH_START]);
  }
  write_line_diary();
  if (comment)
    write_pch(stdout, " ", 1L);
  else
    write_pch(stdout, " Ignored: ", 10L);
  FORLIM = *line_pos;
  for (name_pos = PCH_START; name_pos <= FORLIM; name_pos++)
    write_char(stdout, line[name_pos - PCH_START]);
  write_line(stdout);
  if (!comment) {
    write_pch(stdout, " Unexpected: ", 13L);
    for (name_pos = 0; name_pos < COMMAND_LENGTH; name_pos++)
      write_char(stdout, command_.name[name_pos]);
    write_line(stdout);
    print_expected(&pos, level);
  }
  /* line_pos := pch_start - 1; */
  *next_level = 0;
  return false;
}  /* get_word */

Local boolean get_words(level, offset, next_level, sep, line, line_pos, LINK)
t_long_integer level, *offset, *next_level;
Char *sep;
Char *line;
t_long_integer *line_pos;
struct LOC_sub_read_command *LINK;
{
  boolean ok;

  if (!get_word(&level, offset, next_level, sep, line, line_pos, LINK))
    return false;
  if (0 < *next_level && *next_level < 200)
    ok = get_words(*next_level, offset, next_level, sep, line, line_pos, LINK);
  else
    ok = true;
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  return ok;
}  /* get_words */


/*@+"parser.p"*/


Static Void sub_read_command(command_file_, line, line_pos, ok, offset, kode,
			     in_help, promb, w, text_offset, level)
FILE *command_file_;
Char *line;
t_long_integer *line_pos;
boolean *ok;
t_long_integer *offset, *kode;
boolean in_help;
Char *promb;
t_long_integer w, text_offset, level;
{
  struct LOC_sub_read_command Local_Var;
  t_long_integer i, next_level;
  Char sep;
  FILE *TEMP;
  long FORLIM;

  Local_Var.command_file = command_file_;
  *ok = false;
  do {
    *offset = 0;
    sep = ' ';
    *line_pos = PCH_START - 1;
    if (eolnorf_command(Local_Var.command_file)) {
      while (eolnorf_command(Local_Var.command_file)) {
	write_line_diary();
	if (log_on)
	  write_line_text(log_file);
	write_pch(stdout, promb, w);
	TEMP = stdout;
	flush_file(&TEMP);
	read_text_ln(Local_Var.command_file);
      }
    } else if (diary)
      write_char_text(diary_file, ' ');
    if (eof_command(Local_Var.command_file)) {
      *ok = true;
      *offset = 0;
      next_level = 0;
    } else
      *ok = get_words(level, offset, &next_level, &sep, line, line_pos,
		      &Local_Var);
    if (in_help)
      *ok = (*ok || next_level != 0);
    else if (next_level == 255) {
      *ok = false;
      write_pch(stdout, " Only in HELP", 13L);
      write_line(stdout);
    }
    if (sep == ';' && level == 100)
      next_level = 200;
    if (next_level == 200 && level == 0)
      *ok = false;
  } while (!(*ok || in_help));
  if (200 < next_level && next_level < 255) {
    if (in_help)
      *kode = next_level;
    else
      *kode = next_level - 200;
  } else
    *kode = next_level;
  if (command_test[*offset][2] == 0 && level != VALUE_OFFSET || echo)
    write_line_diary();
  if (!echo)
    return;
  write_pch(stdout, " GET ->", 7L);
  FORLIM = *line_pos;
  for (i = PCH_START; i <= FORLIM; i++)
    write_char(stdout, line[i - PCH_START]);
  write_line(stdout);
  write_pch(stdout, promb, w);
  write_integer(stdout, *offset, 3L);
  if (text_offset > -99)
    write_pch(stdout, command_text[*offset - text_offset], 30L);
  else if (level == 100) {
    write_space(stdout, 2L);
    print_table_type(*offset, false);
  }
  write_line(stdout);
}


Static Void read_command(command_file, offset, kode, in_help, promb, w,
			 text_offset, level)
FILE *command_file;
t_long_integer *offset, *kode;
boolean in_help;
Char *promb;
t_long_integer w, text_offset, level;
{
  pch_long line;
  t_long_integer line_pos;
  boolean ok;

  sub_read_command(command_file, line, &line_pos, &ok, offset, kode, in_help,
		   promb, w, text_offset, level);
}  /* read_command */


Static Void read_value_type(command_file, promb, w, value_type, code, uniform,
			    rankit, probit, base, current, complete,
			    log_trans, random)
FILE *command_file;
Char *promb;
t_long_integer w, *value_type, *code;
boolean *uniform, *rankit, *probit, *base, *current, *complete, *log_trans,
	*random;
{
  *uniform = false;
  *rankit = false;
  *probit = false;
  *base = false;
  *current = false;
  *complete = false;
  *random = false;
  *log_trans = false;
  do {
    read_command(command_file, value_type, code, false, promb, w, -999L,
		 (long)VALUE_OFFSET);
    if (*code > 0 && *code != 200) {
      switch (*value_type - 100) {

      case 1:
	*uniform = true;
	break;

      case 2:
	*rankit = true;
	break;

      case 3:
	*probit = true;
	break;

      case 4:
	*base = true;
	break;

      case 5:
	*current = true;
	break;

      case 6:
	*complete = true;
	break;

      case 7:
	*log_trans = true;
	break;

      case 8:
	*random = true;
	break;
      }
    }
  } while (*code != 0 && *code != 200);
  if (*complete && *value_type != MAX_NUMBER_OF_TABLE_VALUES * 2 - 1)
    *value_type += MAX_NUMBER_OF_TABLE_VALUES;
  if (*base && *current)
    *base = false;
  *uniform = (!(*probit || *rankit) || *uniform);
}  /* read_value_type */


/*@-"mainok.c"*/
/*@+"mainok.p"*/


/*

2389:    +++  ++
2390:    +++  ++
2391:    ---  -- p/mainok.p          7      23     267 p/mainok.p
2392: |    3:    procedure report_boolean
2393: |   23:    function model_if_empty_gc
2394: |   47:    procedure ni_discrete
2395: |   52:    procedure ni
2396: |   57:    function ok_em:     boolean
2397: |   67:    procedure test_space
2398: |  133:    function test_data
2399:    +++  ++
2400:    +++  ++

*/


Static Void report_boolean(ok, as_argument, ifail, arg_pos_int, nargs,
			   arg_int)
boolean ok, as_argument;
t_integer *ifail, arg_pos_int;
long **nargs, **arg_int;
{
  if (as_argument) {
    if (!ok_int_arg(ifail, arg_pos_int, 1L, nargs, arg_int)) {
      set_ifail(ifail, 60L);
      return;
    }
    if (ok)
      (*arg_int)[0] = 1;
    else
      (*arg_int)[0] = 0;
    return;
  }
  if (ok)
    write_pch(stdout, " True", 5L);
  else
    write_pch(stdout, " False", 6L);
}  /* report_boolean */


Static boolean model_if_empty_gc(gc, ifail, sub_code)
t_set_list **gc;
t_integer *ifail, sub_code;
{
  t_set_list *g_c_old;
  boolean not_empty_gc;
  t_model_list *link_model = NULL;

  not_empty_gc = (*gc != NULL);
  if (not_empty_gc)
    not_empty_gc = !P_setequal((*gc)->vertex_set, empty_set);
  if (not_empty_gc)
    return (!not_empty_gc);
  sub_code_to_model(ifail, &sub_code, &link_model);
  if (*ifail != 0)
    return (!not_empty_gc);
  dispose_set_list(gc);
  g_c_old = return_g_c_copy_for_mixed_model(&link_model->model);
  copy_set_list(g_c_old, gc);
  dispose_g_c_copy_for_mixed_model(&link_model->model, &g_c_old);
  return (!not_empty_gc);
}  /* model_if_empty_gc */


Static Void ni_discrete()
{
  write_pch(stdout, " Not implemented for discrete CoCo.", 35L);
}  /* ni_discrete */


Static Void ni()
{
  write_pch(stdout, " Not implemented.", 17L);
}  /* ni */


Static boolean ok_em()
{
  boolean Result, ok;

  ok = !em;
  Result = ok;
  if (!ok)
    write_pch(stdout, " Not implemented for EM", 23L);
  return Result;
}  /* ok_em */


Static Void test_space()
{
  /*$ifdef On-DOS
  if (memavail < 3 * sizeof(t_model) + 1000) or
     (maxavail < 2 * sizeof(t_model)) then
  begin
     warning_begin(output, false);
     write_pch(output, ' Soon out of space@@', 18);
     write_line(output);
     write_pch(output, ' On model occupy@@@@', 16);
     write_integer(output, sizeof(t_model), 8);
     write_pch(output, ' bytes. @@', 8);
     write_line(output);
     write_pch(output, ' available:   @@@@@@', 14);
     write_integer(output, memavail, 8);
     write_pch(output, ' bytes. @@', 8);
     write_line(output);
     write_pch(output, ' Largest block contains @@@@@@', 24);
     write_integer(output, maxavail, 8);
     write_pch(output, ' bytes. @@', 8);
     write_line(output);
     write_pch(output, ' Dispose some models.   @@@@@@', 24);
     warning_end(output, false)
  end;
  if memavail < 5000 then begin
     warning_begin(output, false);
     write_pch(output, ' Available:   @@@@@@', 14);
     write_integer(output, memavail, 8);
     write_pch(output, ' bytes. @@', 8);
     write_line(output);
     write_pch(output, ' Dispose some models or@@@@@@@', 23);
     write_pch(output, ' dispose tests before@@@@@@@@@', 21);
     write_line(output);
     write_pch(output, ' ''Backward'' or ''Forward''.@@@@@', 25);
     warning_end(output, false)
  end;
   $endif On-DOS*/


  /* #  ifdef Resize-pre-minus


  if (fpa > 0.80 * max_p_cell_number) and turbo_pc then begin
     warning_begin(output, false);
     write_pch(output, ' Soon out of space in P-array ', 30);
     write_line(output);
     write_pch(output, ' Dispose some models', 20);
     write_line(output);
     write_pch(output, ' or dispose probibilities.@@@@', 26);
     warning_end(output, false)
  end;
  if (fna > 0.80 * max_cell_number) and turbo_pc then begin
     warning_begin(output, false);
     write_pch(output, ' Soon out of space in N-array ', 30);
     write_line(output);
     write_pch(output, ' Dispose marginals. ', 20);
     warning_end(output, false)
  end


    #  endif Resize-pre-minus */


}  /* test_space */


Static boolean test_data(choice)
t_integer *choice;
{
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  if (!read_spec && command_test[*choice][0] == 1) {
    write_pch(stdout, " No specification read", 22L);
    return false;
  }
  if (!read_obs && command_test[*choice][1] == 1) {
    write_pch(stdout, " No data read", 13L);
    return false;
  }
  if (true)
    return true;
  write_pch(stdout, " *** ERROR ****", 15L);
  write_line(stdout);
  write_pch(stdout, " HASH OVERFLOW!", 15L);
  write_line(stdout);
  write_pch(stdout, " Use 'Partitioning' or", 22L);
  write_line(stdout);
  write_pch(stdout, " 'Large' and 'Find -2log(Q)'", 28L);
  return false;
}  /* test_data */


/*@-"mainstat.c"*/
/*@+"mainstat.p"*/


/*

2401:    +++  ++
2402:    +++  ++
2403:    ---  -- p/mainstat.p        22      55     834 p/mainstat.p
2404: |    4:    procedure write_integer_left
2405: |   13:    procedure print_variable_description
2406: |   71:    procedure print_variable_description_new
2407: |  279:    procedure print_on_off
2408: |  287:    procedure print_link_unlink
2409: |  295:    procedure print_cell_list
2410: |  321:    procedure status_formats
2411: |  389:    procedure status_tests
2412: |  461:    procedure status_exact_tests
2413: |  520:    procedure status_fix
2414: |  552:    procedure status_ips
2415: |  583:    procedure status_mips
2416: |  617:    procedure status_cips
2417: |  651:    procedure status_em
2418: |  683:    procedure status_old_specification
2419: |  699:    procedure status_specification
2420: |  767:    procedure status_q_tables
2421: |  774:    procedure status_observations
2422: |  862:    procedure status_files
2423: |  920:    procedure status_options
2424: |  948:    procedure status_search
2425: |  998:    procedure status
2426:    +++  ++
2427:    +++  ++

*/


Static Void write_integer_left(f, c)
FILE *f;
t_long_integer c;
{
  if (c == 0)
    write_integer(f, 0, 2L);
  else
    write_integer(f, c, floor_x(2 + log_10((double)c)));
}  /* write_integer_left */


Static Void print_variable_description(variable_description, l_v, dim)
t_variable_description_node **variable_description;
t_vertex *l_v;
t_0_max_dimension dim;
{
  t_vertex v, FORLIM;
  t_long_real p1 = 1.0, p2 = 1.0, p3 = 1.0, p4 = 1.0;

  write_line(stdout);
  write_line(stdout);
  FORLIM = *l_v + 1;
  for (v = first_vertex + 1; v <= FORLIM; v++) {
    p1 *= variable_description[v - MIN_VERTEX - 1]->UU.U0.levels_total;
    p2 *= variable_description[v - MIN_VERTEX - 1]->UU.U0.levels_total + 1;
    p3 *= variable_description[v - MIN_VERTEX - 1]->UU.U0.levels_total -
	  variable_description[v - MIN_VERTEX - 1]->UU.U0.levels_missing;
    p4 *= variable_description[v - MIN_VERTEX - 1]->UU.U0.levels_total -
	  variable_description[v - MIN_VERTEX - 1]->UU.U0.levels_missing + 1;
    write_space(stdout, 1L);
    write_char(stdout, variable_description[v - MIN_VERTEX - 1]->name);
    write_integer(stdout,
      (long)variable_description[v - MIN_VERTEX - 1]->UU.U0.levels, 3L);
    write_integer(stdout,
      (long)variable_description[v - MIN_VERTEX - 1]->UU.U0.levels_total, 3L);
    write_integer(stdout,
      (long)variable_description[v - MIN_VERTEX - 1]->UU.U0.levels_missing,
      3L);
    write_space(stdout, 3L);
    if (dim < 10) {
      switch (dim) {

      case 1:
      case 2:
      case 3:
	/* blank case */
	break;

      case 4:
      case 8:
	if (((v - first_vertex) & 1) == 0)
	  write_line(stdout);
	break;

      case 5:
      case 6:
      case 7:
      case 9:
	if ((v - first_vertex) % 3 == 0)
	  write_line(stdout);
	break;
      }
    } else if ((v - first_vertex) % 5 == 0)
      write_line(stdout);
  }
  write_line(stdout);
  write_line(stdout);
  write_space(stdout, 10L);
  write_pch(stdout, "                         Total", 30L);
  write_pch(stdout, "      Cells with complete obs.", 30L);
  write_line(stdout);
  write_pch(stdout, " TABLE:   ", 10L);
  write_real(stdout, p1, 30L, 0L);
  write_real(stdout, p3, 30L, 0L);
  write_line(stdout);
  write_pch(stdout, " All tabs.", 10L);
  write_real(stdout, p2, 30L, 0L);
  write_real(stdout, p4, 30L, 0L);
  write_line(stdout);
  write_line(stdout);
}  /* print_variable_description */


Static Void print_variable_description_new(full_variable_description,
  full_last_vertex, variable_description, subset, delta_missing_excluded,
  cutpoints)
t_variable_description_node **full_variable_description;
t_vertex *full_last_vertex;
t_variable_description_node **variable_description;
long *subset, *delta_missing_excluded;
t_real_list **cutpoints;
{
  t_integer i;
  t_vertex v, w;
  t_long_real p1 = 1.0, p2 = 1.0, p3 = 1.0, p4 = 1.0, p1f = 1.0, p2f = 1.0,
	      p3f = 1.0, p4f = 1.0;
  t_vertex_name_list *p_name_list;

  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "Variable  ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "Total #   ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "Unmarked #", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "Marked #  ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "Used #    ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_line(stdout);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "name      ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "of levels ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "of levels ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "of levels ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_pch(stdout, "of levels ", 10L);
  write_pch(stdout, " ! ", 3L);
  write_line(stdout);
  write_pch(stdout, " !", 2L);
  for (i = 1; i <= 5; i++)
    write_pch(stdout, "------------!", 13L);
  write_line(stdout);
  w = first_vertex;
  p_name_list = full_name_list;
  for (v = first_vertex; v <= *full_last_vertex; v++) {
    if (full_variable_description[v - MIN_VERTEX]->variable_type != continuous) {
      p1f *= full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total;
      p2f *= full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total + 1;
      p3f *= full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total -
	     full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing;
      p4f *= full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total -
	  full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing + 1;
    }
    write_pch(stdout, " ! ", 3L);
    write_char(stdout, full_variable_description[v - MIN_VERTEX]->name);
    write_space(stdout, 1L);
    if (long_names) {
      if (p_name_list->length > 7)
	write_pch(stdout, p_name_list->name, 8L);
      else {
	write_pch(stdout, p_name_list->name, p_name_list->length);
	write_space(stdout, 8 - p_name_list->length);
      }
      if (true)
	p_name_list = p_name_list->pointer;
    } else
      write_space(stdout, 8L);
    write_pch(stdout, " ! ", 3L);
    if (full_variable_description[v - MIN_VERTEX]->variable_type == continuous)
      write_pch(stdout, "Continuous", 10L);
    else
      write_integer(stdout,
	(long)full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total,
	10L);
    write_pch(stdout, " ! ", 3L);
    if (full_variable_description[v - MIN_VERTEX]->variable_type == continuous) {
      write_space(stdout, 9L);
      write_char(stdout, '-');
    } else
      write_integer(stdout,
	(long)(full_variable_description[v - MIN_VERTEX]->UU.U0.levels_total -
	  full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing),
	10L);
    write_pch(stdout, " ! ", 3L);
    if (full_variable_description[v - MIN_VERTEX]->variable_type == continuous) {
      write_space(stdout, 9L);
      if (full_variable_description[v - MIN_VERTEX]->UU.missing_values)
	write_char(stdout, '+');
      else
	write_char(stdout, '-');
    } else
      write_integer(stdout,
	(long)full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing,
	10L);
    write_pch(stdout, " ! ", 3L);
    if (P_inset(v, subset)) {
      if (variable_description[w - MIN_VERTEX]->variable_type != continuous) {
	p1 *= variable_description[w - MIN_VERTEX]->UU.U0.levels_total;
	p2 *= variable_description[w - MIN_VERTEX]->UU.U0.levels_total + 1;
	p3 *= variable_description[w - MIN_VERTEX]->UU.U0.levels_total -
	      variable_description[w - MIN_VERTEX]->UU.U0.levels_missing;
	p4 *= variable_description[w - MIN_VERTEX]->UU.U0.levels_total -
	      variable_description[w - MIN_VERTEX]->UU.U0.levels_missing + 1;
      }
      if (full_variable_description[v - MIN_VERTEX]->variable_type ==
	  continuous) {
	write_space(stdout, 9L);
	write_char(stdout, '+');
      } else
	write_integer(stdout,
	  (long)variable_description[w - MIN_VERTEX]->UU.U0.levels, 10L);
      write_pch(stdout, " ! ", 3L);
      if (P_inset(w, delta_missing_excluded))
	write_char(stdout, '*');
      else
	write_char(stdout, ' ');
      w++;
    } else {
      write_space(stdout, 9L);
      write_char(stdout, '-');
      write_pch(stdout, " ! ", 3L);
      write_char(stdout, ' ');
    }
    if (cutpoints[v - MIN_VERTEX] != NULL)
      write_pch(stdout, " Cutpoints", 10L);
    if (P_inset(v, subset)) {
      if (full_variable_description[v - MIN_VERTEX]->variable_type == discrete) {
	if (full_variable_description[v - MIN_VERTEX]->UU.U0.ordinal)
	  write_pch(stdout, " Ordinal ", 9L);
      }
    }
    if (P_inset(v, subset)) {
      if (full_variable_description[v - MIN_VERTEX]->stratum != 0)
	write_pch(stdout, " Response ", 10L);
    }
    write_line(stdout);
  }
  write_pch(stdout, " !", 2L);
  for (i = 1; i <= 5; i++)
    write_pch(stdout, "------------!", 13L);
  write_line(stdout);
  if (exclude_missing) {
    write_line(stdout);
    write_pch(stdout, " *: Only observations with this variable unmarked",
		49L);
    write_line(stdout);
  }
  write_line(stdout);
  write_pch(stdout, " Specified factors:", 19L);
  write_line(stdout);
  write_line(stdout);
  write_space(stdout, 2L);
  write_pch(stdout, " Number of cells in:", 20L);
  write_line(stdout);
  write_pch_r(stdout, "full specified table", 20L, 40L);
  write_real(stdout, p1f, 30L, 0L);
  write_line(stdout);
  write_pch_r(stdout, "full table with complete observations", 37L, 40L);
  write_real(stdout, p3f, 30L, 0L);
  write_line(stdout);
  write_pch_r(stdout, "all marginal tables", 19L, 40L);
  write_real(stdout, p2f, 30L, 0L);
  write_line(stdout);
  write_pch_r(stdout, "all tables with complete observations", 37L, 40L);
  write_real(stdout, p4f, 30L, 0L);
  write_line(stdout);
  write_line(stdout);
  write_pch(stdout, " Used factors:", 14L);
  write_line(stdout);
  write_line(stdout);
  write_space(stdout, 2L);
  write_pch(stdout, " Number of cells in:", 20L);
  write_line(stdout);
  write_pch_r(stdout, "full table", 10L, 40L);
  write_real(stdout, p1, 30L, 0L);
  write_line(stdout);
  write_pch_r(stdout, "full table with complete observations", 37L, 40L);
  write_real(stdout, p3, 30L, 0L);
  write_line(stdout);
  write_pch_r(stdout, "all marginal tables", 19L, 40L);
  write_real(stdout, p2, 30L, 0L);
  write_line(stdout);
  write_pch_r(stdout, "all tables with complete observations", 37L, 40L);
  write_real(stdout, p4, 30L, 0L);
  write_line(stdout);
  write_line(stdout);
}  /* print_variable_description_new */


Static Void print_on_off(on)
boolean *on;
{
  if (*on)
    write_pch(stdout, " ON    ", 7L);
  else
    write_pch(stdout, " OFF   ", 7L);
}  /* print_on_off */


Static Void print_link_unlink(on)
boolean *on;
{
  if (*on)
    write_pch(stdout, " KEEP     ", 10L);
  else
    write_pch(stdout, " UNLINKED ", 10L);
}  /* print_link_unlink */


Static Void print_cell_list(list)
t_cell_list *list;
{
  t_vertex_list *p;

  while (list != NULL) {
    write_pch(stdout, "   ( ", 5L);
    p = list->vertex_list;
    while (p != NULL) {
      print_full_vertex_on_file(stdout, p->vertex, 0L);
      write_pch(stdout, " = ", 3L);
      if (list->cell[p->vertex - MIN_VERTEX] != MISSING_LEVEL)
	write_integer(stdout, (long)list->cell[p->vertex - MIN_VERTEX], 1L);
      else
	write_char(stdout, '*');
      p = p->pointer;
      if (p != NULL)
	write_pch(stdout, " & ", 3L);
    }
    write_pch(stdout, " )", 2L);
    list = list->pointer;
    if (list != NULL)
      write_pch(stdout, " !", 2L);
    write_line(stdout);
  }
}  /* print_cell_list */


Static Void status_formats()
{
  write_pch(stdout, " Formats", 8L);
  write_line(stdout);
  write_pch_r(stdout, "Pageformats", 11L, 20L);
  write_pch_r(stdout, "Line length", 11L, 15L);
  write_integer(stdout, line_length, 3L);
  write_line(stdout);
  write_space(stdout, 22L);
  write_pch_r(stdout, "Page length", 11L, 15L);
  write_integer(stdout, page_length, 3L);
  write_line(stdout);
  write_pch_r(stdout, "Tableformats", 12L, 20L);
  write_space(stdout, 17L);
  write_pch_r(stdout, "Width", 5L, 10L);
  write_integer(stdout, width, 3L);
  write_line(stdout);
  write_space(stdout, 22L);
  write_pch_r(stdout, "Probabilities", 13L, 15L);
  write_space(stdout, 15L);
  write_pch_r(stdout, "Decimals", 8L, 10L);
  write_integer(stdout, decprob, 3L);
  write_line(stdout);
  write_space(stdout, 22L);
  write_pch_r(stdout, "Expected counts", 15L, 15L);
  write_space(stdout, 15L);
  write_pch_r(stdout, "Decimals", 8L, 10L);
  write_integer(stdout, decexpt, 3L);
  write_line(stdout);
  write_space(stdout, 22L);
  write_pch_r(stdout, "Residuals", 9L, 15L);
  write_space(stdout, 15L);
  write_pch_r(stdout, "Decimals", 8L, 10L);
  write_integer(stdout, decdiff, 3L);
  write_line(stdout);
  write_pch_r(stdout, "Testformats", 11L, 20L);
  write_pch_r(stdout, "Statistics", 10L, 15L);
  write_pch_r(stdout, "Width", 5L, 10L);
  write_integer(stdout, x_width, 3L);
  write_pch_r(stdout, "Decimals", 8L, 10L);
  write_integer(stdout, x_dec, 3L);
  write_line(stdout);
  write_space(stdout, 22L);
  write_pch_r(stdout, "Probabilities", 13L, 15L);
  write_pch_r(stdout, "Width", 5L, 10L);
  write_integer(stdout, prob_width, 3L);
  write_pch_r(stdout, "Decimals", 8L, 10L);
  write_integer(stdout, prob_dec, 3L);
  write_line(stdout);
  write_pch_r(stdout, "Printformats", 12L, 20L);
  write_space(stdout, 17L);
  write_pch_r(stdout, "Width", 5L, 10L);
  write_integer(stdout, print_width, 3L);
  write_pch_r(stdout, "Decimals", 8L, 10L);
  write_integer(stdout, print_dec, 3L);
  write_line(stdout);
  write_line(stdout);
  write_pch_r(stdout, "ShortTestOutput", 15L, 20L);
  print_on_off(&global_write_options->line_form);
  write_line(stdout);
  write_pch_r(stdout, "Pausing", 7L, 20L);
  print_on_off(&pause_output);
  write_pch_r(stdout, "Pausing length", 14L, 15L);
  write_integer(stdout, page_pause_length, 3L);
  write_line(stdout);
  write_line(stdout);
}  /* status_formats */


Static Void status_tests()
{
  write_pch(stdout, " Test", 5L);
  write_line(stdout);
  write_pch_r(stdout, "Algorithm for factorization", 27L, 40L);
  switch (c_factorizes) {

  case 1:
    write_pch(stdout, " A ", 3L);
    break;

  case 2:
    write_pch(stdout, " B ", 3L);
    break;

  case 3:
    write_pch(stdout, " C ", 3L);
    break;
  }
  write_space(stdout, 4L);
  write_line(stdout);
  write_pch_r(stdout, "Partitioning", 12L, 40L);
  print_on_off(&c_partitioning);
  write_line(stdout);
  write_pch_r(stdout, "Adjusted df.", 12L, 40L);
  print_on_off(&adj_df);
  write_line(stdout);
  write_pch_r(stdout, "Power Lambda", 12L, 40L);
  write_real(stdout, lambda, 12L, 9L);
  if (lambda == 0 || lambda == 1) {
    write_line(stdout);
    write_space(stdout, 42L);
    write_pch(stdout, " Power Divergence not printed", 29L);
  }
  write_line(stdout);
  write_pch_r(stdout, "IC", 2L, 40L);
  print_on_off(&ic);
  write_line(stdout);
  write_pch_r(stdout, "BIC", 3L, 40L);
  print_on_off(&bic);
  write_line(stdout);
  write_pch_r(stdout, "IC Kappa", 8L, 40L);
  if (bic && exclude_missing)
    write_pch(stdout, " Variating", 10L);
  else
    write_real(stdout, ic_lambda, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Decomposable mode", 17L, 40L);
  print_on_off(&decomposable_mode);
  write_line(stdout);
  write_pch_r(stdout, "Search-P-value", 14L, 40L);
  switch (test_choice) {

  case 1:
    write_pch(stdout, " Log(Q)", 7L);
    break;

  case 2:
    write_pch(stdout, " X^2   ", 7L);
    break;

  case 3:
    write_pch(stdout, " Power ", 7L);
    break;
  }
  write_line(stdout);
  write_pch_r(stdout, "Acceptance limit", 16L, 40L);
  write_real(stdout, alfa_, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Rejection limit", 15L, 40L);
  write_real(stdout, alfa_reject, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Components limit", 16L, 40L);
  write_real(stdout, parts_limit, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Separators limit", 16L, 40L);
  write_real(stdout, separators_limit, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Reuse of test", 13L, 40L);
  print_on_off(&re_use_test);
  write_line(stdout);
  write_line(stdout);
}  /* status_tests */


Static Void status_exact_tests()
{
  t_two_integers_list *hpi;

  write_pch(stdout, " Exact Test", 11L);
  write_line(stdout);
  write_pch_r(stdout, "Exact Test", 10L, 40L);
  print_on_off(&exact_test);
  write_line(stdout);
  write_pch_r(stdout, "Epsilon", 7L, 40L);
  write_real(stdout, exact_epsilon, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Exact for un-parted test", 24L, 40L);
  print_on_off(&exact_test_for_test_models);
  write_line(stdout);
  write_pch_r(stdout, "Exact for parts", 15L, 40L);
  print_on_off(&exact_test_for_partitioning);
  write_line(stdout);
  write_pch_r(stdout, "Exact for sum of parts", 22L, 40L);
  print_on_off(&exact_test_for_sum_up);
  write_line(stdout);
  write_pch_r(stdout, "Only Exact for Log(L)", 21L, 40L);
  print_on_off(&exact_log_l);
  write_line(stdout);
  write_pch_r(stdout, "Number of tables to generate", 28L, 40L);
  if (number_of_tables == 0)
    write_pch(stdout, " Variating", 10L);
  else
    write_integer_left(stdout, number_of_tables);
  write_line(stdout);
  write_pch_r(stdout, "Variating number of tables", 26L, 40L);
  if (link_n_of_tables == NULL)
    write_pch(stdout, " 20, (2, 1000), (5, 200), (8, 100), (20, 20)",
		44L);
  else {
    write_integer_left(stdout, init_n_of_tables);
    hpi = link_n_of_tables;
    while (hpi != NULL) {
      write_pch(stdout, ", (", 3L);
      write_integer_left(stdout, hpi->a);
      write_char(stdout, ',');
      write_integer_left(stdout, hpi->b);
      write_char(stdout, ')');
      hpi = hpi->pointer;
    }
  }
  write_line(stdout);
  write_pch_r(stdout, "Asymptotic limit", 16L, 40L);
  write_real(stdout, asymptotic_limit, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Fast", 4L, 40L);
  print_on_off(&fast);
  write_line(stdout);
  write_pch_r(stdout, "Seed for random-generator", 25L, 40L);
  write_integer_left(stdout, seed);
  write_line(stdout);
  write_line(stdout);
}  /* status_exact_tests */


Static Void status_fix()
{
  t_vertex w, v;

  write_pch(stdout, " Fix edges", 10L);
  write_line(stdout);
  write_line(stdout);
  write_space(stdout, 4L);
  for (v = first_vertex; v <= last_vertex; v++) {
    write_char(stdout, variable_description[v - MIN_VERTEX]->name);
    write_space(stdout, 1L);
  }
  write_line(stdout);
  for (v = first_vertex; v <= last_vertex; v++) {
    write_space(stdout, 2L);
    write_char(stdout, variable_description[v - MIN_VERTEX]->name);
    write_space(stdout, 1L);
    for (w = first_vertex; w <= last_vertex; w++) {
      if (P_inset(w, fix_edges_adj_set[v - MIN_VERTEX]))
	write_char(stdout, '*');
      else
	write_char(stdout, ' ');
      write_char(stdout, ' ');
    }
    write_space(stdout, 2L);
    print_vertex_set_table(fix_edges_adj_set[v - MIN_VERTEX]);
    write_line(stdout);
  }
  write_line(stdout);
  write_line(stdout);
}  /* status_fix */


Static Void status_ips()
{
  write_pch(stdout, " IPS-algorithm", 14L);
  write_line(stdout);
  write_pch_r(stdout, "Convergence Criterion", 21L, 40L);
  if (ips_in_use == 1)
    write_pch(stdout, " Cell", 5L);
  else
    write_pch(stdout, " Log(L)", 7L);
  write_line(stdout);
  write_pch_r(stdout, "Type of IPS Algorithm", 21L, 40L);
  switch (mean_ips_in_use) {

  case normal_ips:
    write_pch(stdout, " Normal", 7L);
    break;

  case arithmetic:
    write_pch(stdout, " Arithmetic", 11L);
    break;

  case geometric:
    write_pch(stdout, " Geometric", 10L);
    break;

  case harmonic:
    write_pch(stdout, " Harmonic", 9L);
    break;
  }
  write_line(stdout);
  write_pch_r(stdout, "Maximal number of iterations", 28L, 40L);
  write_integer_left(stdout, ips_max_it);
  write_line(stdout);
  write_pch_r(stdout, "Epsilon", 7L, 40L);
  write_real(stdout, ips_epsilon, 12L, 9L);
  write_line(stdout);
  write_line(stdout);
}  /* status_ips */


Static Void status_mips()
{
  write_pch(stdout, " MIPS-algorithm", 15L);
  write_line(stdout);
  write_pch_r(stdout, "Convergence Criterion", 21L, 40L);
  if (mips_in_use == 1)
    write_pch(stdout, " Cell", 5L);
  else if (mips_in_use == 2)
    write_pch(stdout, " Log(L)", 7L);
  else if (mips_in_use == 3)
    write_pch(stdout, " Sufficnt.", 10L);
  else if (mips_in_use == 4)
    write_pch(stdout, " Rel.Suff.", 10L);
  write_line(stdout);
  write_pch_r(stdout, "Maximal number of iterations", 28L, 40L);
  write_integer_left(stdout, mips_max_it);
  write_line(stdout);
  write_pch_r(stdout, "Epsilon@@ ", 7L, 40L);
  write_real(stdout, mips_epsilon, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Init@@@@@ ", 4L, 40L);
  write_real(stdout, mips_init_epsilon, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Error@@@@ ", 5L, 40L);
  write_real(stdout, mips_log_l_round_error, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Noise@@@@ ", 5L, 40L);
  write_real(stdout, mips_random_noise, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Lambda@@@ ", 6L, 40L);
  write_real(stdout, mips_min_lambda, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Cholesky@ ", 8L, 40L);
  write_real(stdout, cholesky_epsilon, 12L, 9L);
  write_line(stdout);
  write_line(stdout);
}  /* status_mips */


Static Void status_cips()
{
  write_pch(stdout, " CIPS-algorithm", 15L);
  write_line(stdout);
  write_pch_r(stdout, "Convergence Criterion", 21L, 40L);
  if (cips_in_use == 1)
    write_pch(stdout, " Cell", 5L);
  else
    write_pch(stdout, " Log(L)", 7L);
  write_line(stdout);
  write_pch_r(stdout, "Maximal number of iterations", 28L, 40L);
  write_integer_left(stdout, cips_max_it);
  write_line(stdout);
  write_pch_r(stdout, "Epsilon@@ ", 7L, 40L);
  write_real(stdout, cips_epsilon, 12L, 9L);
  /* write_line(output);
     write_pch_r(output, 'Init@@@@@', 4, 40);
     write_real(output, mips_init_epsilon, 12, 9);
     write_line(output);
     write_pch_r(output, 'Error@@@@', 5, 40);
     write_real(output, mips_log_l_round_error, 12, 9);
     write_line(output);
     write_pch_r(output, 'Noise@@@@', 5, 40);
     write_real(output, mips_random_noise, 12, 9);
     write_line(output);
     write_pch_r(output, 'Lambda@@@', 6, 40);
     write_real(output, mips_min_lambda, 12, 9);
     write_line(output);
     write_pch_r(output, 'Cholesky@', 8, 40);
     write_real(output, cholesky_epsilon, 12, 9);
     write_line(output); */
  write_line(stdout);
}  /* status_cips */


Static Void status_em()
{
  write_pch(stdout, " EM-algorithm", 13L);
  write_line(stdout);
  write_pch_r(stdout, "EM", 2L, 40L);
  print_on_off(&em);
  write_line(stdout);
  write_pch_r(stdout, "Maximal number of iterations", 28L, 40L);
  write_integer_left(stdout, em_max_it);
  write_line(stdout);
  write_pch_r(stdout, "Epsilon", 7L, 40L);
  write_real(stdout, em_epsilon, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Initial", 7L, 40L);
  switch (em_initial) {

  case EM_UNIFORM:
    write_pch(stdout, " Uniform", 8L);
    break;

  case EM_FIRST:
    write_pch(stdout, " First  ", 8L);
    break;

  case EM_LAST:
    write_pch(stdout, " Last   ", 8L);
    break;

  case EM_MEAN:
    write_pch(stdout, " Mean   ", 8L);
    break;

  case EM_RANDOM:
    write_pch(stdout, " Random ", 8L);
    break;

  case EM_INPUT:
    write_pch(stdout, " Input  ", 8L);
    break;
  }
  write_line(stdout);
  write_line(stdout);
}  /* status_em */


Static Void status_old_specification()
{
  write_pch(stdout, " Old Specification", 18L);
  write_line(stdout);
  if (read_spec) {
    write_line(stdout);
    write_pch(stdout, " Specifikation read:", 20L);
    print_variable_description(full_variable_description, &full_last_vertex,
			       full_dimension);
    write_pch(stdout, " Factors included:  ", 20L);
    print_variable_description(variable_description, &last_vertex, dimension);
  }
  write_line(stdout);
}


Static Void status_specification()
{
  t_real_list *p_cut;
  t_vertex v;

  write_pch(stdout, " Specification", 14L);
  write_line(stdout);
  if (read_spec)
    print_variable_description_new(full_variable_description,
      &full_last_vertex, variable_description, subset, delta_missing_excluded,
      cutpoints);
  if (causal_structure != NULL) {
    write_pch(stdout, " Causal structure: ", 19L);
    print_g_c(causal_structure, 0L, line_length);
    write_line(stdout);
  }
  if (true) {
    write_pch(stdout, " Response variables:", 20L);
    print_vertex_set(response_variables);
    write_line(stdout);
  }
  if (ordinal_tests) {
    write_pch(stdout, " Ordinal factors: ", 18L);
    print_vertex_set(ordinal_factors);
    write_line(stdout);
  }
  if (read_subset) {
    write_pch(stdout, " Read subset: ", 14L);
    print_vertex_set(delta_gamma);
    write_line(stdout);
  }
  if (link_select != NULL) {
    write_pch(stdout, " Select:", 8L);
    write_line(stdout);
    print_cell_list(link_select);
  }
  if (link_reject != NULL) {
    write_pch(stdout, " Reject:", 8L);
    write_line(stdout);
    print_cell_list(link_reject);
  }
  if (reject_missing) {
    write_pch(stdout, " Skip missing in subset   ", 26L);
    write_line(stdout);
  }
  if (exclude_missing) {
    write_pch(stdout, " Exclude missing in ", 20L);
    print_vertex_set(delta_missing_excluded);
    write_line(stdout);
  }
  for (v = first_vertex; v <= full_last_vertex; v++) {
    if (cutpoints[v - MIN_VERTEX] != NULL) {
      write_pch(stdout, " Cutpoints: ", 12L);
      p_cut = cutpoints[v - MIN_VERTEX];
      print_full_vertex_on_file(stdout, v, 0L);
      while (p_cut != NULL) {
	if (p_cut->x == _INVALID)
	  write_pch(stdout, "          - ", 12L);
	else
	  write_real(stdout, p_cut->x, 12L, 5L);
	p_cut = p_cut->pointer;
      }
      write_line(stdout);
    }
  }
  write_line(stdout);
}  /* status_specification */


Static Void status_q_tables()
{
  write_pch(stdout, " Q-tables: ", 11L);
  print_g_c(g_c_q_tables, 15L, line_length);
  write_line(stdout);
}  /* status_q_tables */


Static Void status_observations()
{
  write_pch(stdout, " Limits", 7L);
  write_line(stdout);
  write_pch_r(stdout, "Datastructure selected", 22L, 40L);
  switch (datastructure) {

  case all:
    write_pch(stdout, " All", 4L);
    break;

  case necessary:
    write_pch(stdout, " Necessary", 10L);
    break;

  case list_file:
    write_pch(stdout, " File", 5L);
    break;
  }
  write_line(stdout);
  if (large) {
    write_space(stdout, 42L);
    write_pch(stdout, " LARGE Datastructure selected", 29L);
    write_line(stdout);
  }
  if (mixed_data) {
    write_space(stdout, 42L);
    write_pch(stdout, " Continuous variables found", 27L);
    write_line(stdout);
  }
  if (permit_log_l) {
    write_space(stdout, 42L);
    write_pch(stdout, " Computation of only Log L permitted", 36L);
    write_line(stdout);
  }
  if (space_for_case_list) {
    write_space(stdout, 42L);
    write_pch(stdout, " Space for Case List", 20L);
    write_line(stdout);
  }
  write_pch_r(stdout, "N-cells in use", 14L, 40L);
  write_integer(stdout, fna, 8L);
  write_pch(stdout, " of ", 4L);
  write_integer(stdout, max_cell_number, 8L);
  write_line(stdout);
  write_pch_r(stdout, "P-cells in use", 14L, 40L);
  write_integer(stdout, fpa, 8L);
  write_pch(stdout, " of ", 4L);
  write_integer(stdout, max_p_cell_number, 8L);
  write_line(stdout);
  write_pch_r(stdout, "Q-cells in use", 14L, 40L);
  write_integer(stdout, fqa, 8L);
  write_pch(stdout, " of ", 4L);
  write_integer(stdout, max_q_cell_number, 8L);
  write_line(stdout);
  write_pch_r(stdout, "R-cells in use", 14L, 40L);
  write_integer(stdout, r_list->fra, 8L);   /* Not used! */
  /* write_pch(output, ' / @@@@@@@', 3);
     write_integer(output, fra, 8); */
  write_pch(stdout, " of ", 4L);
  write_integer(stdout, max_r_cell_number, 8L);
  write_line(stdout);
  write_pch_r(stdout, "S-cells in use", 14L, 40L);
  write_integer(stdout, s_list->fsa, 8L);   /* Not used! */
  /* write_pch(output, ' / @@@@@@@', 3);
     write_integer(output, fsa, 8); */
  write_pch(stdout, " of ", 4L);
  write_integer(stdout, max_s_cell_number, 8L);
  write_line(stdout);
  write_pch_r(stdout, "SS-cells in use", 15L, 40L);
  write_integer(stdout, ss_list->fssa, 8L);   /* Not used! */
  /* write_pch(output, ' / @@@@@@@', 3);
     write_integer(output, fssa, 8); */
  write_pch(stdout, " of ", 4L);
  write_integer(stdout, max_ss_cell_number, 8L);
  write_line(stdout);
  write_pch_r(stdout, "T-cells in use", 14L, 40L);
  write_integer(stdout, t_list->fta, 8L);   /* Not used! */
  /* write_pch(output, ' / @@@@@@@', 3);
     write_integer(output, fta, 8); */
  write_pch(stdout, " of ", 4L);
  write_integer(stdout, max_t_cell_number, 8L);
  write_line(stdout);
  if (incomplete_table)
    status_q_tables();
  write_pch_r(stdout, "Number of variables read", 24L, 40L);
  write_integer_left(stdout, (long)dimension);
  write_line(stdout);
  write_pch_r(stdout, "Maximal number of variables", 28L, 40L);
  write_integer_left(stdout, MAX_DIMENSION - 2L);
  write_line(stdout);
  write_pch_r(stdout, "(Maximal dimension for datastructure ALL", 40L, 40L);
  write_integer_left(stdout, (long)MAX_OFFSET_DIM);
  write_pch(stdout, ")", 1L);
  write_line(stdout);
  write_pch_r(stdout, "Number of observations used", 27L, 40L);
  write_integer_left(stdout, n[0]);
  write_line(stdout);
  write_pch_r(stdout, "Maximum number of observations", 30L, 40L);
  write_integer_left(stdout, MAX_COUNT_NUMBER - 3L);
  write_line(stdout);
  write_pch_r(stdout, "Maximal level", 13L, 40L);
  write_integer_left(stdout, MAX_LEVEL - 3L);
  write_line(stdout);
  /*$ifdef On-DOS
  write_line(output);
  write_integer(output, memavail, 8);
  write_pch(output, ' bytes available. @@', 18);
  write_line(output);
  write_pch(output, '  Largest block contains  @@@@', 26);
  write_integer(output, maxavail, 8);
  write_pch(output, ' bytes. @@', 8);
  write_line(output);
  write_pch(output, '  On model occupy at least@@@@', 26);
  write_integer(output, sizeof(t_model), 8);
  write_pch(output, ' bytes. @@', 8);
  write_line(output);
   $endif On-DOS*/
  write_line(stdout);
}  /* status_observations */


Static Void status_files()
{
  pch_long filename;
  boolean ok;

  write_pch(stdout, " Files", 6L);
  write_line(stdout);
  get_cocolib(filename, &ok);
  write_pch_r(stdout, "CoCo HomeDirectory", 18L, 25L);
  write_pch_to_blank(stdout, filename, (long)PCH_END);
  write_line(stdout);
  write_line(stdout);
  write_pch_r(stdout, "Observations input", 18L, 25L);
  write_pch_to_blank(stdout, data_name, (long)PCH_END);
  if (terminal)
    write_pch(stdout, " Read data from terminal", 24L);
  write_line(stdout);
  write_pch_r(stdout, "Specification input", 19L, 25L);
  write_pch_to_blank(stdout, spec_name, (long)PCH_END);
  if (terminal)
    write_pch(stdout, " Read data from terminal", 24L);
  write_line(stdout);
  write_pch_r(stdout, "Command input", 13L, 20L);
  write_pch_to_blank(stdout, command_name, (long)PCH_END);
  write_line(stdout);
  write_pch_r(stdout, "Results output", 14L, 20L);
  write_pch_to_blank(stdout, results_name, (long)PCH_END);
  write_line(stdout);
  write_pch_r(stdout, "Response output", 15L, 20L);
  write_pch_to_blank(stdout, response_name, (long)PCH_END);
  write_line(stdout);
  write_line(stdout);
  write_pch_r(stdout, "Diary", 5L, 10L);
  print_on_off(&diary);
  print_link_unlink(&diary_set);
  write_pch_to_blank(stdout, diary_name, (long)PCH_END);
  write_line(stdout);
  write_pch_r(stdout, "Log", 3L, 10L);
  print_on_off(&log_on);
  print_link_unlink(&log_set);
  write_pch_to_blank(stdout, log_name, (long)PCH_END);
  write_line(stdout);
  write_pch_r(stdout, "LogData", 7L, 10L);
  print_on_off(&log_data_on);
  write_line(stdout);
  write_pch_r(stdout, "Dump", 4L, 10L);
  print_on_off(&dump);
  print_link_unlink(&dump_set);
  write_pch_to_blank(stdout, dump_name, (long)PCH_END);
  write_line(stdout);
  write_pch_r(stdout, "Report", 6L, 10L);
  print_on_off(&report);
  print_link_unlink(&report_set);
  write_pch_to_blank(stdout, report_name, (long)PCH_END);
  write_line(stdout);
  write_line(stdout);
}  /* status_files */


Static Void status_options()
{
  write_pch(stdout, " Other options", 14L);
  write_line(stdout);
  write_pch_r(stdout, "Graph", 5L, 20L);
  print_on_off(&graph_mode);
  write_line(stdout);
  write_pch_r(stdout, "Report", 6L, 20L);
  print_on_off(&report);
  write_line(stdout);
  write_pch_r(stdout, "Trace", 5L, 20L);
  print_on_off(&trace);
  write_line(stdout);
  write_pch_r(stdout, "Debug", 5L, 20L);
  print_on_off(&debug);
  write_line(stdout);
  write_pch_r(stdout, "Timer", 5L, 20L);
  print_on_off(&timer);
  write_line(stdout);
  write_pch_r(stdout, "Echo", 4L, 20L);
  print_on_off(&echo);
  write_line(stdout);
  write_pch_r(stdout, "Note", 4L, 20L);
  print_on_off(&echo_note);
  write_line(stdout);
  write_line(stdout);
}  /* status_options */


Static Void status_search()
{
  t_eh_pack *WITH;

  if (link_eh_pack == NULL) {
    write_line_diary();
    start_search(&link_eh_pack);
    write_pch(stdout, " Search started", 15L);
    write_line(stdout);
  }
  WITH = link_eh_pack;
  print_models(true);
  page(stdout);
  print_duals(false, false, &WITH->graphical_search, WITH->g, WITH->a,
	      WITH->r, WITH->d_a, WITH->d_r, NULL, NULL);
  write_pch(stdout, " D<A>(R): ", 10L);
  write_line(stdout);
  if (WITH->d_a == NULL) {
    write_line(stdout);
    write_pch(stdout, " Not found/updated.", 19L);
    write_line(stdout);
    write_line(stdout);
  } else
    print_g_c_list(WITH->d_a);
  write_pch(stdout, " D<R>(A): ", 10L);
  write_line(stdout);
  if (WITH->d_r == NULL) {
    write_line(stdout);
    write_pch(stdout, " Not found/updated.", 19L);
    write_line(stdout);
    write_line(stdout);
  } else
    print_g_c_list(WITH->d_r);
  write_line(stdout);
  switch (WITH->search_strategy) {

  case 1:
    write_pch(stdout, " Smallest Search", 16L);
    break;

  case 2:
    write_pch(stdout, " Alternating Search", 19L);
    break;

  case 3:
    write_pch(stdout, " Rough Search", 13L);
    break;
  }
  write_line(stdout);
  page(stdout);
  print_base_fix_out_fix_in();
  write_line(stdout);
  write_pch(stdout, " Main effects: ", 15L);
  print_vertex_set(WITH->g);
  write_line(stdout);
}  /* status_search */


Static Void status(code)
t_long_integer *code;
{
  boolean print_fix = false;
  t_vertex v;

  if (*code == 1 || *code == 2)
    status_formats();
  if (*code == 1 || *code == 3)
    status_tests();
  if (*code == 1 || *code == 4)
    status_exact_tests();
  v = first_vertex;
  while (!print_fix && v <= last_vertex) {
    print_fix = !P_setequal(fix_edges_adj_set[v - MIN_VERTEX], empty_set);
    v++;
  }
  if (print_fix && (*code == 1 || *code == 5))
    status_fix();
  if (*code == 1 || *code == 6) {
    status_ips();
    status_cips();
    status_mips();
  }
  if (*code == 1 || *code == 7)
    status_em();
  if (*code == 18)
    status_old_specification();
  if (*code == 1 || *code == 8)
    status_specification();
  if (*code == 1 || *code == 9)
    status_observations();
  if (*code == 1 || *code == 10)
    status_files();
  if (*code == 1 || *code == 11)
    status_options();
  if (*code == 12)
    status_search();
  write_line(stdout);
}  /* status */


/*@-"mainset.c"*/
/*@+"dumpstat.p"*/


/*

2428:    +++  ++
2429:    +++  ++
2430:    ---  -- p/dumpstat.p        21      58     706 p/dumpstat.p
2431: |   17:    function find_m:     t_long_integer
2432: |   32:    procedure write_end_command
2433: |   38:    procedure dump_on_off
2434: |   46:    procedure write_integer_auto
2435: |   59:    procedure write_real_auto
2436: |   95:    procedure dump_formats
2437: |  133:    procedure dump_tests
2438: |  212:    procedure dump_exact_tests
2439: |  285:    procedure dump_fix
2440: |  307:    procedure dump_ips
2441: |  336:    procedure dump_mips
2442: |  361:    procedure dump_cips
2443: |  386:    procedure dump_em
2444: |  424:    procedure dump_cell_list
2445: |  458:    procedure dump_specification
2446: |  525:    procedure dump_q_tables
2447: |  554:    procedure dump_observations
2448: |  650:    procedure dump_files
2449: |  739:    procedure dump_options
2450: |  769:    procedure dump_search
2451: |  833:    procedure dump_status
2452:    +++  ++
2453:    +++  ++

*/


/* Needs work:

     o Models,
     o Tests,
     o (Cutpoints),
     o (Case selection),
     o (Q-tables),
     o (Fix edges),
     o (Search status).

 */

Static t_long_integer find_m()
{
  t_vertex v;
  t_long_integer m = 1;

  v = first_vertex;
  while (v < last_vertex &&
	 m * variable_description[v - MIN_VERTEX]->UU.U0.levels < 37) {
    m *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
    v++;
  }
  return m;
}  /* find_m */


Static Void write_end_command(f)
FILE *f;
{
  write_char(f, ';');
  write_line(f);
}


Static Void dump_on_off(on)
boolean *on;
{
  if (*on)
    write_pch(stdout, " On", 3L);
  else
    write_pch(stdout, " Off", 4L);
}  /* dump_on_off */


Static Void write_integer_auto(f, i)
FILE *f;
t_long_integer i;
{
  t_long_integer w;

  if (i == 0)
    write_integer(f, 0, 2L);
  else {
    w = floor_x(log((double)labs(i)) / log(10.0)) + 2;
    write_integer(f, i, w);
  }
}  /* write_integer_auto */


Static Void write_real_auto(f, c)
FILE *f;
t_long_real c;
{
  t_long_integer w, d;
  t_long_real x;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2434L, 1L))
    write_char(f, '`');
  /*$endif TRACE*/
  if (c == 0)
    write_pch(f, " 0.00", 5L);
  else {
    d = 0;
    x = c;
    while (fabs(x) < 1 - sqrt(ROUND_ERROR) && d < 7) {
      d++;
      x *= 10;
    }
    while (0.0035 < fabs(x - (long)floor(x + 0.5)) && d < 8) {
      d++;
      x *= 10;
    }
    w = floor_x(log(fabs(c)) / log(10.0)) + d + 1;
    if (trace_flag_set(20L, 2434L, 1L))
      write_integer(f, w, 3L);
    if (trace_flag_set(20L, 2434L, 1L))
      write_integer(f, d, 3L);
    write_char(f, ' ');
    if (d == 8)
      write_real_fix_float(f, c, w, 5L, true);
    else
      write_real_fix_float(f, c, w, d, false);
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2434L, 1L)) {
    /*$endif TRACE*/
    write_char(f, '\'');
  }
}  /* write_real_auto */


Static Void dump_formats()
{
  write_pch(stdout, "# Formats:", 10L);
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, "set page formats", 16L);
  write_integer_auto(stdout, line_length);
  write_integer_auto(stdout, page_length);
  write_end_command(stdout);
  write_pch(stdout, "set table formats", 17L);
  write_integer_auto(stdout, width);
  write_integer_auto(stdout, decprob);
  write_integer_auto(stdout, decexpt);
  write_integer_auto(stdout, decdiff);
  write_end_command(stdout);
  write_pch(stdout, "set test formats", 16L);
  write_integer_auto(stdout, x_width);
  write_integer_auto(stdout, x_dec);
  write_integer_auto(stdout, prob_width);
  write_integer_auto(stdout, prob_dec);
  write_end_command(stdout);
  write_pch(stdout, "set print formats", 17L);
  write_integer_auto(stdout, print_width);
  write_integer_auto(stdout, print_dec);
  write_end_command(stdout);
  write_pch(stdout, "set short", 9L);
  dump_on_off(&global_write_options->line_form);
  write_end_command(stdout);
  write_pch(stdout, "set pause", 9L);
  dump_on_off(&pause_output);
  write_end_command(stdout);
  write_pch(stdout, "set paging length", 17L);
  write_integer_auto(stdout, page_pause_length);
  write_end_command(stdout);
  write_line(stdout);
}  /* dump_formats */


Static Void dump_tests()
{
  write_pch(stdout, "# Test:", 7L);
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, "set algorithm", 13L);
  switch (c_factorizes) {

  case 1:
    write_pch(stdout, " A", 2L);
    break;

  case 2:
    write_pch(stdout, " B", 2L);
    break;

  case 3:
    write_pch(stdout, " C", 2L);
    break;
  }
  write_end_command(stdout);
  write_pch(stdout, "set partitioning", 16L);
  dump_on_off(&c_partitioning);
  write_end_command(stdout);
  write_pch(stdout, "set adjusted df", 15L);
  dump_on_off(&adj_df);
  write_end_command(stdout);
  if (lambda == 0 || lambda == 1) {
    write_pch(stdout, "set power Off", 13L);
    write_end_command(stdout);
    write_pch(stdout, "set power Lambda Null", 21L);
  } else {
    write_pch(stdout, "set power Lambda", 16L);
    write_real_auto(stdout, lambda);
  }
  write_end_command(stdout);
  if (ic) {
    if (bic) {
      if (exclude_missing)
	write_pch(stdout, "set Bic", 7L);
      else {
	write_pch(stdout, "set ic kappa@@@@@@@ ", 13L);
	write_real_auto(stdout, ic_lambda);
      }
    } else
      write_pch(stdout, "set Aic", 7L);
  } else
    write_pch(stdout, "set Ic Off", 10L);
  write_end_command(stdout);

  write_pch(stdout, "set decomposable mode@@@@@@@@ ", 21L);
  dump_on_off(&decomposable_mode);
  write_end_command(stdout);

  write_pch(stdout, "set test", 8L);
  switch (test_choice) {

  case 1:
    write_pch(stdout, " Lr", 3L);
    break;

  case 2:
    write_pch(stdout, " Chi", 4L);
    break;

  case 3:
    write_pch(stdout, " Power", 6L);
    break;
  }
  write_end_command(stdout);

  write_pch(stdout, "set acceptance", 14L);
  write_real_auto(stdout, alfa_);
  write_end_command(stdout);
  write_pch(stdout, "set rejection", 13L);
  write_real_auto(stdout, alfa_reject);
  write_end_command(stdout);
  write_pch(stdout, "set component", 13L);
  write_real_auto(stdout, parts_limit);
  write_end_command(stdout);
  write_pch(stdout, "set separators", 14L);
  write_real_auto(stdout, separators_limit);
  write_end_command(stdout);
  write_pch(stdout, "set reuse of tests", 18L);
  dump_on_off(&re_use_test);
  write_end_command(stdout);
  write_line(stdout);
}  /* dump_tests */


Static Void dump_exact_tests()
{
  t_two_integers_list *hpi;

  write_pch(stdout, "# Exact Test:", 13L);
  write_line(stdout);
  write_line(stdout);

  if (exact_log_l)
    write_pch(stdout, "set exact test deviance", 23L);
  else {
    write_pch(stdout, "set exact test", 14L);
    dump_on_off(&exact_test);
  }
  write_end_command(stdout);

  write_pch(stdout, "set exact epsilon", 17L);
  write_real_auto(stdout, exact_epsilon);
  write_end_command(stdout);

  write_pch(stdout, "set exact for unparted test", 27L);
  dump_on_off(&exact_test_for_test_models);
  write_end_command(stdout);

  write_pch(stdout, "set exact for parts of test", 27L);
  dump_on_off(&exact_test_for_partitioning);
  write_end_command(stdout);

  write_pch(stdout, "set exact for total test", 24L);
  dump_on_off(&exact_test_for_sum_up);
  write_end_command(stdout);

  if (number_of_tables == 0) {
    write_pch(stdout, "set number of tables variating@@@@@@@@@ ", 31L);
    write_end_command(stdout);
    if (link_n_of_tables == NULL) {
      write_pch(stdout, "set list of numbers of tables", 28L);
      write_pch(stdout,
		  " 20,   2, 1000,   5, 200,   8, 100,   20, 20", 44L);
    } else {
      write_pch(stdout, "set list of numbers of tables", 28L);
      write_integer_left(stdout, init_n_of_tables);
      hpi = link_n_of_tables;
      while (hpi != NULL) {
	write_pch(stdout, ",  ", 3L);
	write_integer_left(stdout, hpi->a);
	write_char(stdout, ',');
	write_integer_left(stdout, hpi->b);
	write_char(stdout, ' ');
	hpi = hpi->pointer;
      }
    }
  } else {
    write_pch(stdout, "set numbers of tables", 20L);
    write_integer_left(stdout, number_of_tables);
  }
  write_end_command(stdout);

  write_pch(stdout, "set asymptotic", 14L);
  write_real_auto(stdout, asymptotic_limit);
  write_end_command(stdout);

  write_pch(stdout, "set fast", 8L);
  dump_on_off(&fast);
  write_end_command(stdout);

  write_pch(stdout, "set seed", 8L);
  write_integer_left(stdout, seed);
  write_end_command(stdout);

  write_line(stdout);
}  /* dump_exact_tests */


Static Void dump_fix()
{
  t_set_list *p;

  write_pch(stdout, "# Fix edges:", 12L);
  write_line(stdout);
  write_line(stdout);
  if (fix_edges_gc != NULL) {
    write_pch(stdout, "Fix edges", 9L);
    print_vertex_set(fix_edges_gc->vertex_set);
    write_end_command(stdout);
    p = fix_edges_gc->pointer;
    while (p != NULL) {
      write_pch(stdout, "and fix edges", 13L);
      print_vertex_set(p->vertex_set);
      write_end_command(stdout);
      p = p->pointer;
    }
  }
  write_line(stdout);
}  /* dump_fix */


Static Void dump_ips()
{
  write_pch(stdout, "# IPS-algorithm:", 16L);
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, "set ips", 7L);
  if (ips_in_use == 1)
    write_pch(stdout, " Cell", 5L);
  else
    write_pch(stdout, " Sum", 4L);
  write_end_command(stdout);

  write_pch(stdout, "set ips", 7L);
  switch (mean_ips_in_use) {

  case normal_ips:
    write_pch(stdout, " Normal", 7L);
    break;

  case arithmetic:
    write_pch(stdout, " Arithmetic", 11L);
    break;

  case geometric:
    write_pch(stdout, " Geometric", 10L);
    break;

  case harmonic:
    write_pch(stdout, " Harmonic", 9L);
    break;
  }
  write_end_command(stdout);

  write_pch(stdout, "set ips stop", 12L);
  write_integer_auto(stdout, ips_max_it);
  write_real_auto(stdout, ips_epsilon);
  write_end_command(stdout);
  write_line(stdout);
}  /* dump_ips */


Static Void dump_mips()
{
  write_pch(stdout, "# MIPS-algorithm:", 17L);
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, "#set ips", 8L);
  if (mips_in_use == 1)
    write_pch(stdout, " Cell", 5L);
  else
    write_pch(stdout, " Sum", 4L);
  write_end_command(stdout);

  write_pch(stdout, "set mips", 8L);
  write_integer_auto(stdout, mips_max_it);
  write_real_auto(stdout, mips_epsilon);
  write_real_auto(stdout, mips_init_epsilon);
  write_real_auto(stdout, mips_log_l_round_error);
  write_real_auto(stdout, mips_random_noise);
  write_real_auto(stdout, mips_min_lambda);
  write_real_auto(stdout, cholesky_epsilon);
  write_end_command(stdout);
  write_line(stdout);
}  /* dump_mips */


Static Void dump_cips()
{
  write_pch(stdout, "# CIPS-algorithm:", 17L);
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, "#set ips", 8L);
  if (cips_in_use == 1)
    write_pch(stdout, " Cell", 5L);
  else
    write_pch(stdout, " Sum", 4L);
  write_end_command(stdout);

  write_pch(stdout, "#set cips", 9L);
  write_integer_auto(stdout, cips_max_it);
  write_real_auto(stdout, cips_epsilon);
  /* write_real_auto(output, mips_init_epsilon);
     write_real_auto(output, mips_log_l_round_error);
     write_real_auto(output, mips_random_noise);
     write_real_auto(output, mips_min_lambda);
     write_real_auto(output, cholesky_epsilon); */
  write_end_command(stdout);
  write_line(stdout);
}  /* dump_mips */


Static Void dump_em()
{
  write_pch(stdout, "# EM-algorithm:", 15L);
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, "# em", 4L);
  dump_on_off(&em);
  write_end_command(stdout);

  write_pch(stdout, "set em iterations", 17L);
  write_integer_left(stdout, em_max_it);
  write_end_command(stdout);

  write_pch(stdout, "set em epsilon", 14L);
  write_real_auto(stdout, em_epsilon);
  write_end_command(stdout);

  write_pch(stdout, "set em initial", 14L);
  switch (em_initial) {

  case EM_UNIFORM:
    write_pch(stdout, " Uniform", 8L);
    break;

  case EM_FIRST:
    write_pch(stdout, " First", 6L);
    break;

  case EM_LAST:
    write_pch(stdout, " Last", 5L);
    break;

  case EM_MEAN:
    write_pch(stdout, " Mean", 5L);
    break;

  case EM_RANDOM:
    write_pch(stdout, " Random", 7L);
    break;

  case EM_INPUT:
    write_pch(stdout, " Input", 6L);
    break;
  }
  write_end_command(stdout);

  write_line(stdout);
}  /* dump_em */


Static Void dump_cell_list(list, reject)
t_cell_list *list;
boolean reject;
{
  t_vertex_list *p;

  if (reject)
    write_pch(stdout, "# reject cases@@@@@ ", 18L);
  else
    write_pch(stdout, "# select cases@@@@@ ", 18L);
  while (list != NULL) {
    p = list->vertex_list;
    while (p != NULL) {
      print_full_vertex_on_file(stdout, p->vertex, 0L);
      p = p->pointer;
    }
    p = list->vertex_list;
    while (p != NULL) {
      if (list->cell[p->vertex - MIN_VERTEX] != MISSING_LEVEL)
	write_integer(stdout, (long)list->cell[p->vertex - MIN_VERTEX], 1L);
      else
	write_char(stdout, '*');
      p = p->pointer;
    }
    write_end_command(stdout);
    list = list->pointer;
    if (list == NULL)
      break;
    if (reject)
      write_pch(stdout, "# or reject cases@@ ", 18L);
    else
      write_pch(stdout, "# or select cases@@ ", 18L);
  }
  write_end_command(stdout);
}  /* dump_cell_list */


Static Void dump_specification()
{
  t_real_list *p_cut;
  t_vertex v, FORLIM;

  write_pch(stdout, "# Specification:", 16L);
  write_line(stdout);
  write_line(stdout);

  if (causal_structure != NULL) {
    write_pch(stdout, "set chain@          ", 9L);
    print_g_c(causal_structure, 0L, line_length);
    write_end_command(stdout);
  }

  if (!P_setequal(response_variables, empty_set)) {
    write_pch(stdout, "set response ", 13L);
    print_vertex_set(response_variables);
    write_end_command(stdout);
  }
  if (ordinal_tests) {
    write_pch(stdout, "set ordinal ", 12L);
    print_vertex_set(ordinal_factors);
    write_end_command(stdout);
  }

  if (read_subset) {
    write_pch(stdout, "# set read subset ", 18L);
    print_vertex_set(delta_gamma);
    write_end_command(stdout);
  }

  if (link_select != NULL)
    dump_cell_list(link_select, false);

  if (link_reject != NULL)
    dump_cell_list(link_reject, true);

  if (reject_missing) {
    write_pch(stdout, "# skip missing;", 15L);
    write_line(stdout);
  }

  if (exclude_missing) {
    write_pch(stdout, "# exclude missing in ", 21L);
    print_vertex_set(delta_missing_excluded);
    write_end_command(stdout);
  }

  FORLIM = full_last_vertex;
  for (v = first_vertex; v <= FORLIM; v++) {
    if (cutpoints[v - MIN_VERTEX] != NULL) {
      write_pch(stdout, "# cutpoints ", 12L);
      p_cut = cutpoints[v - MIN_VERTEX];
      print_full_vertex_on_file(stdout, v, 0L);
      while (p_cut != NULL) {
	if (p_cut->x == _INVALID)
	  write_pch(stdout, " - ", 3L);
	else
	  write_real_auto(stdout, p_cut->x);
	p_cut = p_cut->pointer;
      }
      write_end_command(stdout);
    }
  }

  write_line(stdout);
}  /* dump_specification */


Static Void dump_q_tables()
{
  t_long_integer m, ii;
  t_offset_list *p;
  long FORLIM;

  write_pch(stdout, "# Q-tables: ", 12L);
  write_line(stdout);
  write_line(stdout);
  p = q_tables_offsets;
  while (p != NULL) {
    write_pch(stdout, "# read q-table ", 15L);
    print_vertex_set(p->vertex_set);
    write_line(stdout);
    write_pch(stdout, "# ", 2L);
    m = find_m();
    FORLIM = marginal_dimension(p->vertex_set);
    for (ii = 1; ii <= FORLIM; ii++) {
      write_integer_auto(stdout, q_array[ii + p->offset]);
      if (ii % m == 0) {
	write_line(stdout);
	write_pch(stdout, "# ", 2L);
      }
    }
    write_end_command(stdout);
    p = p->pointer;
  }
  write_line(stdout);
}  /* dump_q_tables */


Static Void dump_observations()
{
  write_pch(stdout, "# Limits:", 9L);
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, "#set datastructure", 17L);
  switch (datastructure) {

  case all:
    write_pch(stdout, " All", 4L);
    break;

  case necessary:
    write_pch(stdout, " Necessary", 10L);
    break;

  case list_file:
    write_pch(stdout, " File", 5L);
    break;
  }
  write_end_command(stdout);

  write_pch(stdout, "#set large", 10L);
  dump_on_off(&em);
  write_end_command(stdout);

  /*
  if permit_log_l then begin
     write_space(output, 40 + 2);
     write_pch(output, ' Computation of only Log L permitted@@@@', 36);
     write_line(output)
  end;
  if space_for_case_list then begin
     write_space(output, 40 + 2);
     write_pch(output, ' Space for Case List@@@@@@@@@@', 20);
     write_line(output)
  end;
  */

  /*
  write_pch(output, 'N-cells in use@@@@@@', 14);
  write_integer_auto(output, fna);
  write_pch(output, ' of @@@@@@', 4);
  write_integer_auto(output, max_cell_number);
  write_end_command(output);

  write_pch(output, 'P-cells in use@@@@@@', 14);
  write_integer_auto(output, fpa);
  write_pch(output, ' of @@@@@@', 4);
  write_integer_auto(output, max_p_cell_number);
  write_end_command(output);

  write_pch(output, 'Q-cells in use@@@@@@', 14);
  write_integer_auto(output, fqa);
  write_pch(output, ' of @@@@@@', 4);
  write_integer_auto(output, max_q_cell_number);
  write_end_command(output);
  */

  if (incomplete_table)
    dump_q_tables();

  /*
  write_pch(output, 'Number of variables read@@@@@@', 24);
  write_integer_left(output, dimension);
  write_end_command(output);
  write_pch(output, 'Maximal number of variables@@@', 28);
  write_integer_left(output, max_dimension - 2);
  write_end_command(output);
  write_pch(output,
                '(Maximal dimension for datastructure ALL', 40);
  write_integer_left(output, max_offset_dim);
  write_pch(output, ')@@@@@@@@@', 1);
  write_end_command(output);
  write_pch(output, 'Number of observations used@@@', 27);
  write_integer_left(output, n[0]);
  write_end_command(output);
  write_pch(output, 'Maximum number of observations', 30);
  write_integer_left(output, max_count_number - 3);
  write_end_command(output);
  write_pch(output, 'Maximal level@@@@@@@', 13);
  write_integer_left(output, max_level - 3);
  write_end_command(output);
  */

  /*$ifdef On-DOS
  write_end_command(output);
  write_integer_auto(output, memavail);
  write_pch(output, ' bytes available. @@', 18);
  write_end_command(output);
  write_pch(output, '  Largest block contains  @@@@', 26);
  write_integer_auto(output, maxavail);
  write_pch(output, ' bytes. @@', 8);
  write_end_command(output);
  write_pch(output, '  On model occupy at least@@@@', 26);
  write_integer_auto(output, sizeof(t_model));
  write_pch(output, ' bytes. @@', 8);
  write_end_command(output);
   $endif On-DOS*/

  write_line(stdout);
  write_line(stdout);
}  /* dump_observations */


Static Void dump_files()
{
  write_pch(stdout, "# Files:", 8L);
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, "#set input commands ", 20L);
  write_pch_to_blank(stdout, command_name, (long)PCH_END);
  write_end_command(stdout);

  write_pch(stdout, "#set output results ", 20L);
  write_pch_to_blank(stdout, results_name, (long)PCH_END);
  write_end_command(stdout);

  write_pch(stdout, "#set output commands @@@@@@@@ ", 21L);
  write_pch_to_blank(stdout, response_name, (long)PCH_END);
  write_end_command(stdout);
  write_line(stdout);

  if (!terminal) {
    write_pch(stdout, "# set inputfile specification ", 30L);
    write_pch_to_blank(stdout, spec_name, (long)PCH_END);
    write_end_command(stdout);
  }

  if (!terminal) {
    write_pch(stdout, "# set inputfile observations ", 29L);
    write_pch_to_blank(stdout, data_name, (long)PCH_END);
    write_end_command(stdout);
  }

  write_line(stdout);

  write_pch(stdout, "# set diary", 11L);
  dump_on_off(&diary);
  write_end_command(stdout);
  write_pch(stdout, "# set keep diary", 16L);
  dump_on_off(&diary_set);
  write_end_command(stdout);
  if (diary_set) {
    write_pch(stdout, "# set output diary ", 19L);
    write_pch_to_blank(stdout, diary_name, (long)PCH_END);
    write_end_command(stdout);
  }

  write_pch(stdout, "# set Log", 9L);
  dump_on_off(&log_on);
  write_end_command(stdout);
  write_pch(stdout, "# set keep Log", 14L);
  dump_on_off(&log_set);
  write_end_command(stdout);
  if (log_set) {
    write_pch(stdout, "# set output dump ", 18L);
    write_pch_to_blank(stdout, log_name, (long)PCH_END);
    write_end_command(stdout);
  }

  write_pch(stdout, "# set data log", 14L);
  dump_on_off(&log_data_on);
  write_end_command(stdout);

  write_pch(stdout, "# set dump", 8L);
  dump_on_off(&dump);
  write_end_command(stdout);
  write_pch(stdout, "# set keep Dump", 15L);
  dump_on_off(&dump_set);
  /* dump_on_off(default_dump_set); */
  write_end_command(stdout);
  if (dump_set) {
    write_pch(stdout, "# set output log ", 17L);
    write_pch_to_blank(stdout, dump_name, (long)PCH_END);
    write_end_command(stdout);
  }

  write_pch(stdout, "# set Report", 12L);
  dump_on_off(&report);
  write_end_command(stdout);
  write_pch(stdout, "# set keep report", 17L);
  dump_on_off(&report_set);
  write_end_command(stdout);
  if (report_set) {
    write_pch(stdout, "# set output report ", 20L);
    write_pch_to_blank(stdout, report_name, (long)PCH_END);
    write_end_command(stdout);
  }

  write_line(stdout);
}  /* dump_files */


Static Void dump_options()
{
  write_pch(stdout, "# Other options:", 16L);
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, "set graph mode", 13L);
  dump_on_off(&graph_mode);
  write_end_command(stdout);
  write_pch(stdout, "set report", 10L);
  dump_on_off(&report);
  write_end_command(stdout);
  write_pch(stdout, "set trace", 9L);
  dump_on_off(&trace);
  write_end_command(stdout);
  write_pch(stdout, "set debug", 9L);
  dump_on_off(&debug);
  write_end_command(stdout);
  write_pch(stdout, "set timer", 9L);
  dump_on_off(&timer);
  write_end_command(stdout);
  write_pch(stdout, "set echo", 8L);
  dump_on_off(&echo);
  write_end_command(stdout);
  write_pch(stdout, "set note", 8L);
  dump_on_off(&echo_note);
  write_end_command(stdout);
  write_line(stdout);
}  /* dump_options */


Static Void dump_search()
{
  t_eh_pack *WITH;

  write_pch(stdout, "# EH:", 5L);
  write_line(stdout);
  write_line(stdout);

  if (link_eh_pack == NULL)
    return;
  WITH = link_eh_pack;

  write_pch(stdout, "set main effects: ", 18L);
  print_vertex_set(WITH->g);
  write_end_command(stdout);

  write_pch(stdout, "set ", 4L);
  if (WITH->graphical_search)
    write_pch(stdout, "Graphical ", 10L);
  else
    write_pch(stdout, "Hierarchical@@@@@@@ ", 13L);
  write_pch(stdout, " search", 7L);
  write_end_command(stdout);

  write_pch(stdout, "set ", 4L);
  switch (WITH->search_strategy) {

  case 1:
    write_pch(stdout, "Smallest@ ", 9L);
    break;

  case 2:
    write_pch(stdout, "Alternating@@@@@@@@ ", 12L);
    break;

  case 3:
    write_pch(stdout, "Rough@@@@ ", 13L);
    break;
  }
  write_pch(stdout, " search", 7L);
  write_end_command(stdout);

  /*
  print_models(true);
  page(output);
  print_duals(false, false, graphical_search, g, a, r, d_a, d_r, nil,  nil);
  write_pch(output, ' D<A>(R): ', 10);
  write_end_command(output);
  if d_a = nil then begin
     write_line(output);
     write_pch(output, ' Not found/updated.@', 19);
     write_line(output);
     write_line(output)
  end else
     print_g_c_list(d_a);
  write_pch(output, ' D<R>(A): ', 10);
  write_end_command(output);
  if d_r = nil then begin
     write_line(output);
     write_pch(output, ' Not found/updated.@', 19);
     write_line(output);
     write_line(output)
  end else
     print_g_c_list(d_r);
  write_end_command(output);
  */

  /*
  print_base_fix_out_fix_in;
  write_end_command(output);
  */

  write_line(stdout);
}  /* dump_search */


Static Void dump_status(code)
t_long_integer *code;
{
  boolean print_fix;
  t_vertex v;

  write_line(stdout);
  if (*code == 1 || *code == 2)
    dump_formats();
  if (*code == 1 || *code == 3)
    dump_tests();
  if (*code == 1 || *code == 4)
    dump_exact_tests();
  if (*code == 1 || *code == 5) {
    print_fix = false;
    v = first_vertex;
    while (!print_fix && v <= last_vertex) {
      print_fix = !P_setequal(fix_edges_adj_set[v - MIN_VERTEX], empty_set);
      v++;
    }
    if (print_fix)
      dump_fix();
  }
  if (*code == 1 || *code == 6) {
    dump_ips();
    dump_cips();
    dump_mips();
  }
  if (*code == 1 || *code == 7)
    dump_em();
  if (*code == 18)
    dump_specification();
  if (*code == 1 || *code == 8)
    dump_specification();
  if (*code == 1 || *code == 9)
    dump_observations();
  if (*code == 1 || *code == 10)
    dump_files();
  if (*code == 1 || *code == 11)
    dump_options();
  if (*code == 1 || *code == 12)
    dump_search();
  write_line(stdout);
}  /* dump */


/*@+"import.p"*/


/*

2454:    +++  ++
2455:    +++  ++
2456:    ---  -- p/impexp.p         27     137    1587 p/impexp.p
2457: |    4:    procedure read_boolean_binary
2458: |   13:    procedure skip_char
2459: |   23:    procedure read_line_binary
2460: |   28:    procedure read_begin_binary
2461: |   37:    procedure read_end_binary
2462: |   47:    procedure read_version_from_binary
2463: |   65:    procedure read_factors_from_binary
2464: |  129:    - procedure read_incomplete_table_from_binary
2465: |  135:    procedure read_table_from_binary
2466: |  163:    procedure read_list_from_binary
2467: |  220:    procedure read_q_table_from_binary
2468: |  284:    procedure import_data_arg
2469: |  316:    procedure import_data

*/

Static Void read_binary_char(f, c)
FILE *f;
Char *c;
{
  *c = getc(f);
  if (*c == EOF)
    _EscIO(EndOfFile);
  if (*c == '\n')
    *c = ' ';
}  /* read_binary_char */


Static Void read_binary_name(f, n)
FILE *f;
t_vertex_name *n;
{
  Char c;

  c = getc(f);
  if (c == EOF)
    _EscIO(EndOfFile);
  if (c == '\n')
    c = ' ';
  *n = c;
}  /* read_binary_name */


/* Not used:
procedure read_binary_ln(var f : t_binary_file);
begin
   readln(f)
end; */
/* read_binary_ln */

Static Void read_binary_integer(f, w, i)
FILE *f;
t_integer w;
t_long_integer *i;
{
  if (fscanf(f, "%ld", i) == EOF)
    _EscIO(EndOfFile);
}  /* read_binary_integer */


Static Void read_binary_real(f, x, used_invalid)
FILE *f;
t_real *x, used_invalid;
{
  if (fscanf(f, "%g", x) == EOF)
    _EscIO(EndOfFile);
  if (fabs((*x - used_invalid) / *x) < 0.0001)
    *x = _INFINITY_SHORT_REAL;
  if (false) {
    write_real(stdout, *x, 20L, 0L);
    write_line(stdout);
  }
}  /* read_binary_real */


Static Void read_binary_level(f, w, l)
FILE *f;
t_integer w;
t_level *l;
{
  t_long_integer i;

  read_binary_integer(f, 2L, &i);
  *l = i;
}  /* read_binary_integer */


Static Void read_binary_cell_count(f, w, c)
FILE *f;
t_integer w;
t_cell_count *c;
{
  t_long_integer i;

  read_binary_integer(f, 2L, &i);
  *c = i;
}  /* read_binary_cell_count */


Static Void read_binary_vertex(f, w, v)
FILE *f;
t_integer w;
t_vertex *v;
{
  t_long_integer i;

  read_binary_integer(f, 2L, &i);
  *v = i;
}  /* read_binary_vertex */


Static Void read_boolean_binary(f, b)
FILE *f;
boolean *b;
{
  t_long_integer i;

  read_binary_integer(f, 2L, &i);
  *b = (i == 1);
}  /* read_boolean_binary */


Static Void skip_char(f, n)
FILE *f;
t_integer n;
{
  t_integer i;
  Char c;

  for (i = 1; i <= n; i++)
    read_binary_char(f, &c);
}  /* skip_char */


Static Void read_line_binary(f)
FILE *f;
{
  if (fscanf(f, "%*[^\n]") == EOF)
    _EscIO(EndOfFile);
  if (getc(f) == EOF)
    _EscIO(EndOfFile);
}  /* read_line_binary */


Static Void read_begin_binary(f)
FILE *f;
{
  Char c;

  read_binary_char(f, &c);
  read_binary_char(f, &c);
  read_binary_char(f, &c);
}  /* read_begin_binary */


Static Void read_end_binary(f)
FILE *f;
{
  Char c;

  read_binary_char(f, &c);
  read_binary_char(f, &c);
  read_binary_char(f, &c);
  read_line_binary(f);
}  /* read_end_binary */


Static Void read_version_from_binary(f, n)
FILE *f;
t_long_integer n;
{
  t_long_integer version_a_i, version_b_i, arch_i, mach_i, type_a_i, type_b_i,
		 n_i;

  read_begin_binary(f);
  read_binary_integer(f, 6L, &version_a_i);
  read_binary_integer(f, 6L, &version_b_i);
  read_binary_integer(f, 6L, &mach_i);
  read_binary_integer(f, 6L, &arch_i);
  read_binary_integer(f, 6L, &type_a_i);
  read_binary_integer(f, 6L, &type_b_i);
  read_binary_integer(f, 6L, &n_i);
  read_end_binary(f);
}  /* read_version_from_binary */


Static Void read_factors_from_binary(f)
FILE *f;
{
  Char c;
  t_vertex w, v;
  t_long_integer i, ii;
  long FORLIM1;

  read_spec = true;
  read_obs = false;
  em = false;
  exclude_missing = false;
  for (v = first_vertex; v <= last_vertex; v++)
    dispose_real_list(&cutpoints[v - MIN_VERTEX]);
  dispose_vertex_name_list(&full_name_list);
  read_version_from_binary(f, 1L);
  read_begin_binary(f);
  skip_char(f, 15L);
  read_end_binary(f);
  read_begin_binary(f);
  read_boolean_binary(f, &long_names);
  read_binary_vertex(f, 2L, &full_last_vertex);
  read_boolean_binary(f, &mixed_data);
  read_end_binary(f);
  for (v = first_vertex; v <= full_last_vertex; v++) {
    full_variable_description[v - MIN_VERTEX] =
      (t_variable_description_node *)Malloc(sizeof(t_variable_description_node));
    if (full_variable_description[v - MIN_VERTEX] == NULL)
      _OutMem();
    full_variable_description[v - MIN_VERTEX]->long_name = NULL;
    read_binary_char(f, &c);   /* ! */
    read_binary_char(f, &c);   /* ! */
    read_binary_name(f, &full_variable_description[v - MIN_VERTEX]->name);
    read_binary_char(f, &c);   /* ! */
    /* variable_description[v]^.name := full_variable_description[v]^.name;
       print_full_vertex_on_file(output, v, 0); */
    if (long_names) {
      w = v;
      insert_name_in_name_list(&w, &full_name_list);
      read_binary_integer(f, 2L, &ii);
      full_name_list->length = ii;
      read_binary_char(f, &c);   /* ! */
      read_binary_char(f, &c);   /* ! */
      read_binary_char(f, &c);   /* ! */
      FORLIM1 = full_name_list->length;
      for (i = 1; i <= FORLIM1; i++)   /* ! */
	read_binary_char(f, &full_name_list->name[i - PCH_START]);
      read_binary_char(f, &c);
    }
    read_binary_integer(f, 2L, &i);
    switch (i) {

    case 1:
      full_variable_description[v - MIN_VERTEX]->variable_type = discrete;
      break;

    case 2:
      full_variable_description[v - MIN_VERTEX]->variable_type = continuous;
      break;
    }
    if (full_variable_description[v - MIN_VERTEX]->variable_type == continuous) {
      read_binary_integer(f, 2L, &i);
      read_boolean_binary(f,
	&full_variable_description[v - MIN_VERTEX]->UU.missing_values);
    } else {
      read_binary_level(f, 2L,
	&full_variable_description[v - MIN_VERTEX]->UU.U0.levels);
      read_binary_level(f, 2L,
	&full_variable_description[v - MIN_VERTEX]->UU.U0.levels_missing);
    }
    read_binary_char(f, &c);   /* ! */
    read_binary_char(f, &c);   /* ! */
    if (v == full_last_vertex)   /* ! */
      read_binary_char(f, &c);
    read_line_binary(f);
  }
  revers_vertex_name_list(&full_name_list);
  select_datastructure(true);
}  /* read_factors_from_binary */


/* procedure read_incomplete_table_from_binary(var f : t_binary_file);
var
   i    : t_long_integer;
begin
end; */
/* read_incomplete_table_from_binary */

Static Void read_table_from_binary(f)
FILE *f;
{
  t_long_integer m;
  t_long_integer i = 1;
  t_long_integer number_of_cells_expected;
  Char c;
  boolean ok;

  init_datastructure();
  read_version_from_binary(f, 3L);
  read_begin_binary(f);
  skip_char(f, 6L);
  read_end_binary(f);
  read_begin_binary(f);
  read_binary_cell_count(f, 2L, n);
  read_binary_integer(f, 2L, &number_of_cells_expected);
  read_end_binary(f);
  number_of_cells_expected = marginal_dimension_tf(full_delta, true, true);
  m = find_m();
  while (i <= number_of_cells_expected) {
    read_binary_cell_count(f, 2L, &n[i]);
    if (i % m == 0)
      read_line_binary(f);
    i++;
  }
  read_binary_char(f, &c);
  write_line_diary();
  if (datastructure == all && !mixed_data) {
    if (TURBO_PC)
      write_pch(stdout, " WAIT !! -", 10L);
    write_pch(stdout, " Finding all marginals.", 23L);
    find_all_marginals(&ok);
  }
  close_datastructure();
  read_obs = true;
}  /* read_table_from_binary */


Static Void read_list_from_binary(f)
FILE *f;
{
  t_long_integer ii = 1;
  t_long_integer count;
  t_vertex u;
  /* v: t_discrete_vertex;
     w: t_continuous_vertex; */
  t_cell i;
  t_integer_vector j;
  t_real_vector x;
  Char c;
  t_real used_invalid;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_vertex FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadListFromBinary ", sizeof(pch20));
  ntr(tzt, 20L, 2466L, 1L, -1L, -1L);
  /*$endif TRACE*/
  read_version_from_binary(f, 3L);
  read_begin_binary(f);
  skip_char(f, 5L);
  read_end_binary(f);
  read_begin_binary(f);
  skip_char(f, 15L);
  read_binary_real(f, &used_invalid, _INFINITY_SHORT_REAL);
  read_end_binary(f);
  read_begin_binary(f);
  read_binary_integer(f, 2L, &count);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2466L, 2L, -1L, count);
  /*$endif TRACE*/
  read_end_binary(f);
  init_datastructure();
  for (u = first_vertex; u <= full_last_vertex; u++)
    i[u - MIN_VERTEX] = 1;
  if (mixed_data) {
    while (ii <= count) {
      FORLIM = full_last_vertex;
      /*
      for v := first_vertex to  full_last_discrete_vertex do
         read_binary_integer(f, 2, j[v]);
      read_line_binary(f);
      for w := first_vertex to  full_last_continuous_vertex do
         read_binary_integer(f, 2, x[w]);
      read_line_binary(f);
       */
      for (u = first_vertex; u <= FORLIM; u++) {
	if (P_inset(u, full_delta))
	  read_binary_level(f, 2L,
	    &j[full_to_discrete[u - MIN_VERTEX] - MIN_VERTEX]);
	else
	  read_binary_real(f,
	    &x[full_to_continuous[u - MIN_VERTEX] - MIN_VERTEX],
	    used_invalid);
      }
      read_line_binary(f);   /* n_of_cases */
      insert_mixed_cases(i, j, x, 1L);
      /* new_item(j, x, item_list_read); */
      ii++;
    }
  } else {
    while (ii <= count) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2466L, 3L, -1L, ii);
      /*$endif TRACE*/
      for (u = first_vertex; u <= full_last_vertex; u++)
	read_binary_level(f, 2L, &i[u - MIN_VERTEX]);
      read_line_binary(f);   /* n_of_cases */
      insert_cases_(i, 1L);
      ii++;
    }
  }
  read_binary_char(f, &c);
  write_line_diary();
  close_datastructure();   /* with make_case_list */
  read_obs = true;
}  /* read_list_from_binary */


Static Void read_q_table_from_binary(f)
FILE *f;
{
  t_long_integer m;
  t_long_integer i = 1;
  t_vertex v;
  t_vertex_set a, aa;
  boolean b;
  t_offset_list *p;
  Char c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadQTableFromBinar", sizeof(pch20));
  ntr(tzt, 20L, 2467L, 1L, -1L, -1L);
  /*$endif TRACE*/
  read_version_from_binary(f, 5L);
  read_begin_binary(f);
  skip_char(f, 8L);
  read_end_binary(f);
  P_setcpy(a, empty_set);
  for (v = first_vertex; v <= last_vertex; v++) {
    read_boolean_binary(f, &b);
    if (b)
      P_addset(a, v);
  }
  read_line_binary(f);
  /* insert_offset(a, fqa, q_tables_offsets);
  fqa := fqa + marginal_dimension(a);
  insert_set_in_set_list(a, g_c_q_tables); */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2467L, 2L, -1L, -1L);
  /*$endif TRACE*/
  b = init_q_table(a, true, aa, &p, true, f);
  if (b)
    incomplete_table = true;
  else {
    write_pch(stdout, " Error in init Q-table!       ", 30L);
    print_vertex_set(a);
    print_vertex_set(aa);
    write_line(stdout);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2467L, 2L, -1L, -1L);
  /*$endif TRACE*/
  m = find_m();
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2467L, 3L, -1L, m);
  /*$endif TRACE*/
  number_of_cells = marginal_dimension(a);
  read_begin_binary(f);
  read_binary_integer(f, 2L, &i);
  read_end_binary(f);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2467L, 4L, -1L, i);
  /*$endif TRACE*/
  if (i != number_of_cells) {
    write_pch(stdout, " Wrong number of cells for Q! ", 30L);
    print_vertex_set(a);
    print_vertex_set(aa);
    write_line(stdout);
    number_of_cells = i;
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2467L, 5L, -1L, number_of_cells);
  /*$endif TRACE*/
  i = FIRST_INDEX;
  while (i < FIRST_INDEX + number_of_cells) {
    read_binary_integer(f, 2L, &q_array[i + q_tables_offsets->offset]);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2467L, 6L, i, q_array[i + q_tables_offsets->offset]);
    /*$endif TRACE*/
    if ((i - FIRST_INDEX + 1) % m == 0)
      read_line_binary(f);
    i++;
  }
  read_binary_char(f, &c);
  read_line_binary(f);
}  /* read_q_table_to_binary */


Static Void read_binary_vertex_set(f, a)
FILE *f;
long *a;
{
  t_vertex v;
  t_vertex_set b;
  t_integer number_of_vertices, i;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  P_setcpy(a, empty_set);
  read_binary_integer(f, 4L, &number_of_vertices);
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadBinaryVertexSet", sizeof(pch20));
  ntr(tzt, 20L, 2467L, 1L, -1L, number_of_vertices);
  /*$endif TRACE*/
  for (i = 1; i <= number_of_vertices; i++) {
    read_binary_vertex(f, 2L, &v);
    P_addset(P_expset(b, 0L), v);
    P_setunion(a, a, b);
    /*$ifdef TRACE*/
    ntr_vertex_and_set(tzt, 20L, 2467L, 1L, 1L, i, &v, a);
    /*$endif TRACE*/
  }
  read_binary_integer(f, 4L, &i);
}  /* read_binary_vertex_set */


Static Void read_binary_g_c(f, g_c)
FILE *f;
t_set_list **g_c;
{
  t_set_list *p;
  t_integer number_of_sets, i;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  read_binary_integer(f, 4L, &number_of_sets);
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadBinaryGC       ", sizeof(pch20));
  ntr(tzt, 20L, 2468L, 1L, -1L, number_of_sets);
  /*$endif TRACE*/
  *g_c = NULL;
  for (i = 1; i <= number_of_sets; i++) {
    p = (t_set_list *)Malloc(sizeof(t_set_list));
    if (p == NULL)
      _OutMem();
    p->pointer = *g_c;
    *g_c = p;
    read_binary_vertex_set(f, (*g_c)->vertex_set);
    /*$ifdef TRACE*/
    ntr_set_and_g_c(tzt, 20L, 2468L, 1L, 1L, i, (*g_c)->vertex_set, g_c);
    /*$endif TRACE*/
  }
  read_binary_integer(f, 4L, &i);
}  /* read_binary_g_c */


Static Void read_binary_triple_g_c(f, g_c_list)
FILE *f;
t_g_c_list **g_c_list;
{
  t_g_c_list *p;
  t_integer i, dummy;

  *g_c_list = NULL;
  for (i = 1; i <= 3; i++) {
    p = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (p == NULL)
      _OutMem();
    p->pointer = *g_c_list;
    *g_c_list = p;
    read_binary_g_c(f, &(*g_c_list)->g_c);
    if (i < 3)
      read_binary_integer(f, 4L, &dummy);
  }
  revers_g_c_list(g_c_list);
}  /* read_binary_triple_g_c */


Static Void read_models_from_binary(f)
FILE *f;
{
  t_long_integer number_of_models, model_number;
  t_integer i, dummy, model_tp;
  Char c;
  t_g_c_list *p, *g_c_list;
  t_set_list *g_c, *causal_structure;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadModelsFromBin. ", sizeof(pch20));
  ntr(tzt, 20L, 2466L, 1L, -1L, -1L);
  /*$endif TRACE*/
  read_version_from_binary(f, 3L);
  read_begin_binary(f);
  skip_char(f, 7L);
  read_end_binary(f);
  read_begin_binary(f);
  skip_char(f, 19L);
  read_binary_integer(f, 4L, &number_of_models);
  read_end_binary(f);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2466L, 1L, 2L, number_of_models);
  /*$endif TRACE*/
  for (i = 1; i <= number_of_models; i++) {
    c = ' ';
    while (c != ';')
      read_binary_char(f, &c);

    read_binary_integer(f, 4L, &model_number);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2466L, 1L, 3L, model_number);
    /*$endif TRACE*/
    read_binary_integer(f, 4L, &dummy);
    read_binary_integer(f, 4L, &model_number);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2466L, 1L, 4L, model_number);
    /*$endif TRACE*/
    read_binary_integer(f, 4L, &dummy);
    read_binary_integer(f, 4L, &model_tp);
    read_binary_integer(f, 4L, &dummy);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2466L, 1L, -4L, model_tp);
    /*$endif TRACE*/
    switch (model_tp) {

    case 1:
      read_binary_g_c(f, &g_c);
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 2466L, 1L, 5L, 1L, &g_c);
      /*$endif TRACE*/
      read_binary_integer(f, 4L, &dummy);
      read_binary_g_c(f, &causal_structure);
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 2466L, 1L, 5L, 2L, &causal_structure);
      /*$endif TRACE*/
      insert_g_c_in_new_discrete_model(&g_c, &causal_structure);
      break;

    case 2:
      read_binary_g_c(f, &g_c);
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 2466L, 1L, 6L, 1L, &g_c);
      /*$endif TRACE*/
      read_binary_integer(f, 4L, &dummy);
      read_binary_g_c(f, &causal_structure);
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 2466L, 1L, 6L, 2L, &causal_structure);
      /*$endif TRACE*/
      insert_g_c_in_new_continuous_model(&g_c, &causal_structure);
      break;

    case 3:
      read_binary_triple_g_c(f, &g_c_list);
      /*$ifdef TRACE*/
      ntr_g_c_list(tzt, 20L, 2466L, 1L, 6L, 1L, g_c_list);
      /*$endif TRACE*/
      read_binary_integer(f, 4L, &dummy);
      read_binary_g_c(f, &causal_structure);
      /*$ifdef TRACE*/
      ntr_g_c(tzt, 20L, 2466L, 1L, 6L, 2L, &causal_structure);
      /*$endif TRACE*/
      insert_g_c_list_in_new_model(&g_c_list, &causal_structure, false, false);
      while (g_c_list != NULL) {
	/* dispose_set_list(g_c_list^.g_c); */
	p = g_c_list->pointer;
	_Free(g_c_list);
	g_c_list = p;
      }
      break;
    }
    read_binary_integer(f, 4L, &dummy);
    /*$endif TRACE*/
    ntr(tzt, 20L, 2466L, 1L, 4L, dummy);
    /*$ifdef TRACE*/
  }
  write_line_diary();
}  /* read_models_from_binary */


Static Void import_data_arg(file_name, ok)
Char *file_name;
boolean *ok;
{
  /* ;
  var code: t_integer */
  t_long_integer i;
  FILE *f = NULL;
  pch_long data_name;

  copy_pch_long(file_name, data_name);
  assign_binary_read(&f, data_name, ok);
  read_factors_from_binary(f);
  read_begin_binary(f);
  read_binary_integer(f, 2L, &i);
  read_end_binary(f);
  while (i == 0) {
    read_q_table_from_binary(f);
    read_begin_binary(f);
    read_binary_integer(f, 2L, &i);
    read_end_binary(f);
  }
  switch (i) {

  case 1:
    datastructure = all;
    break;

  case 2:
    datastructure = necessary;
    break;

  case 3:
    datastructure = list_file;
    break;

  case 4:
    datastructure = both;
    break;
  }
  if (datastructure == all && !mixed_data)
    read_table_from_binary(f);
  else
    read_list_from_binary(f);
  read_models_from_binary(f);
  if (f != NULL)
    fclose(f);
}  /* import_data */


Static Void import_data(command_file, as_argument, ifail, sub_code, arg_pos,
			nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long file_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, data_name, file_name))
	/* , sub_code */
	  return;
  import_data_arg(file_name, &ok);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* import_data */


/*@+"export.p"*/


/*

2454:    +++  ++
2455:    +++  ++
2456:    ---  -- p/impexp.p         27     137    1587 p/impexp.p

2470: |  336:    procedure write_integer_binary
2471: |  350:    procedure write_boolean_binary
2472: |  359:    procedure write_real_binary
2473: |  385:    procedure write_line_binary
2474: |  390:    procedure write_begin_binary
2475: |  397:    procedure write_end_binary
2476: |  405:    procedure write_version_to_binary
2477: |  419:    procedure write_factors_to_binary
2478: |  477:    - procedure write_incomplete_table_to_binary
2479: |  483:    procedure write_table_to_binary
2480: |  507:    procedure write_list_to_binary
2481: |  571:    procedure write_q_tables_to_binary
2482: |  607:    procedure export_data_arg
2483: |  635:    procedure export_data
2484:    +++  ++
2485:    +++  ++

*/


Static Void write_integer_binary(f, i)
FILE *f;
t_long_integer i;
{
  t_long_integer w;

  /* write_integer_auto(f, i) */
  if (i == 0) {
    write_integer_text(f, 0, 2L);
    return;
  }
  w = floor_x(log(labs(i) + 0.5) / log(10.0)) + 2;
  if (i < 0)
    w++;
  write_integer_text(f, i, w);
}  /* write_integer_binary */


Static Void write_vertex_binary(f, v)
FILE *f;
t_vertex *v;
{
  t_long_integer i;

  i = *v;
  write_integer_binary(f, i);
}  /* write_vertex_binary */


Static Void write_short_real_binary(f, c)
FILE *f;
t_real c;
{
  t_long_integer w;
  t_long_integer d = 0;
  t_long_real x;

  /* write_real_auto(f, c) */
  if (is_invalid_short_real(c)) {
    /* write_pch_10_text(f, ' NaN@@@@@@', 4) */
    write_char_text(f, ' ');
    x = _INFINITY_SHORT_REAL;
    write_real_text_fix_float(f, &x, 20L, 0L, true);
    return;
  }
  if (c == 0) {
    write_pch_2_text(f, " 0");
    return;
  }
  x = c;
  while (fabs(x) < 1 && d < 7) {
    d++;
    x *= 10;
  }
  while (0.0035 < fabs(x - (long)floor(x + 0.5)) && d < 8) {
    d++;
    x *= 10;
  }
  /* write_pch_2_text(f, '  '); */
  write_char_text(f, ' ');
  w = floor_x(log(fabs(c) + 0.5) / log(10.0));
  if (w < 2) {
    w = 2;
    if (c < 0)
      w++;
  }
  w += d + 1;   /**/
  /**/
  /* Not '+ 1': Exponential notation for 1 to 9 ! */
  x = c;
  write_real_text(f, x, -w, d);
}  /* write_short_real_binary */


Static Void write_line_binary(f)
FILE *f;
{
  write_line_text(f);
}  /* write_line_binary */


Static Void write_char_binary(f, c)
FILE *f;
Char c;
{
  putc(c, f);
}  /* write_char_binary */


Static Void write_pch_2_binary(f, c)
FILE *f;
Char *c;
{
  t_long_integer i;

  for (i = 0; i <= 1; i++)
    putc(c[i], f);
}  /* write_pch_2_binary */


Static Void write_boolean_binary(f, b)
FILE *f;
boolean b;
{
  if (b)
    write_pch_2_binary(f, " 1");
  else
    write_pch_2_binary(f, " 0");
}  /* write_boolean_binary */


Static Void write_space_binary(f, w)
FILE *f;
t_integer w;
{
  t_long_integer i;

  for (i = 1; i <= w; i++)
    putc(' ', f);
}  /* write_space_binary */


Static Void write_pch_binary(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  t_long_integer i;

  for (i = 1; i <= w; i++) {
    putc(c[i - PCH_START], f);
    /* ;
   writeln(f) */
  }
}  /* write_pch_binary */


Static Void write_pch_10_binary(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  t_long_integer i;

  for (i = 0; i < w; i++)
    putc(c[i], f);
}  /* write_pch_10_binary */


Static Void write_pch_20_binary(f, c, w)
FILE *f;
Char *c;
t_integer w;
{
  t_long_integer i;

  for (i = 0; i < w; i++)
    putc(c[i], f);
}  /* write_pch_20_binary */


Static Void write_begin_binary(f)
FILE *f;
{
  write_char_binary(f, '#');
  write_char_binary(f, ' ');
  write_char_binary(f, '<');
}  /* write_begin_binary */


Static Void write_end_binary(f)
FILE *f;
{
  write_char_binary(f, ' ');
  write_char_binary(f, '>');
  write_char_binary(f, ';');
  write_line_binary(f);
}  /* write_end_binary */


Static Void write_version_to_binary(f, n)
FILE *f;
t_long_integer n;
{
  write_begin_binary(f);
  write_integer_binary(f, (long)VERSION_A);
  write_integer_binary(f, (long)VERSION_B);
  write_integer_binary(f, (long)mach);
  write_integer_binary(f, (long)arch);
  write_integer_binary(f, (long)type_a);
  write_integer_binary(f, (long)type_b);
  write_integer_binary(f, n);
  write_end_binary(f);
}  /* write_version_to_binary */


Static Void write_long_name_binary(f, c, l, w)
FILE *f;
Char *c;
t_integer l, w;
{
  if (w == 0) {
    write_char_binary(f, ':');
    write_pch_binary(f, c, l);
    return;
  }
  if (l >= labs(w)) {
    write_char_binary(f, ':');
    write_pch_binary(f, c, labs(w) - 1);
    return;
  }
  if (w < 0)
    write_space(f, w - l - 1);
  write_char_binary(f, ':');
  write_pch_binary(f, c, l);
  if (w > 0)
    write_space(f, w - l - 1);
}  /* write_long_name_binary */


Static Void print_vertex_binary(f, v, w)
FILE *f;
t_vertex v;
t_integer w;
{
  t_vertex_name_list *p_name_list;

  if (v == double_vertex) {
    write_char_binary(f, '^');
    return;
  }
  if (!long_names) {
    write_char_binary(f, variable_description[v - MIN_VERTEX]->name);
    return;
  }
  p_name_list = name_list;
  if (p_name_list != NULL && p_name_list->vertex != v) {
    while (p_name_list->pointer != NULL && p_name_list->vertex != v)
      p_name_list = p_name_list->pointer;
  }
  if (p_name_list == NULL) {
    write_pch_10_binary(f, " Invalid", 8L);
    return;
  }
  if (p_name_list->vertex == v)
    write_long_name_binary(f, p_name_list->name, p_name_list->length, w);
  else
    write_pch_10_binary(f, " Invalid", 8L);
}  /* print_vertex_binary */


Static Void print_vertex_set_binary(f, a)
FILE *f;
long *a;
{
  t_vertex v;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      print_vertex_binary(f, v, 0L);
  }
  if (P_inset(double_vertex, a))
    write_char_binary(f, '^');
}  /* print_vertex_set_binary */


Static Void print_vertex_set_binary_binary(f, a)
FILE *f;
long *a;
{
  t_vertex v;
  t_integer number_of_vertices = 0;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      number_of_vertices++;
  }
  if (P_inset(double_vertex, a))
    number_of_vertices++;
  write_integer_binary(f, number_of_vertices);
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a))
      write_vertex_binary(f, &v);
  }
  if (P_inset(double_vertex, a))
    write_vertex_binary(f, &double_vertex);
}  /* print_vertex_set_binary_binary */


Static Void print_set_list_binary(f, p)
FILE *f;
t_set_list *p;
{
  /*
var
     character_count, set_width : t_integer;
     q      : t_link_set_list;
  */
  /*
  character_count := 0;
  q := p;
  while p <> nil do begin
     if long_names then begin
        set_width := long_name_set_width(p^.vertex_set);
        character_count := character_count + set_width
     end else
        character_count := character_count + cardinality(p^.vertex_set);
     character_count := character_count + 1;
     p := p^.pointer;
  end;
  write_char_binary(f, '(');
  write_integer_binary(f, character_count);
  write_char_binary(f, ')');
  write_char_binary(f, ' ');
  p := q;
  */
  while (p != NULL) {
    print_vertex_set_binary(f, p->vertex_set);
    p = p->pointer;
    if (p != NULL)
      write_char_binary(f, ',');
  }
  write_char_binary(f, '.');
}  /* print_set_list_binary */


Static Void print_set_list_binary_binary(f, p)
FILE *f;
t_set_list *p;
{
  t_integer number_of_sets = 0;
  t_set_list *q = p;

  while (p != NULL) {
    number_of_sets++;
    p = p->pointer;
  }
  write_integer_binary(f, number_of_sets);
  p = q;
  while (p != NULL) {
    print_vertex_set_binary_binary(f, p->vertex_set);
    p = p->pointer;
    /* if p <> nil then */
    write_integer_binary(f, -1L);
  }
  write_integer_binary(f, -2L);
}  /* print_set_list_binary_binary */


Static Void write_factors_to_binary(f)
FILE *f;
{
  t_vertex v;
  t_long_integer i;
  t_vertex_name_list *p;
  long FORLIM1;

  write_version_to_binary(f, 1L);
  write_begin_binary(f);
  write_pch_20_binary(f, " verified names", 15L);
  write_end_binary(f);
  write_begin_binary(f);
  write_boolean_binary(f, long_names);
  i = last_vertex;
  write_integer_binary(f, i);
  write_boolean_binary(f, mixed_data);
  write_end_binary(f);
  p = name_list;
  for (v = first_vertex; v <= last_vertex; v++) {
    write_char_binary(f, ' ');   /* ! */
    write_char_binary(f, '"');   /* ! */
    write_char_binary(f, variable_description[v - MIN_VERTEX]->name);
    write_char_binary(f, '"');   /* ! */
    if (long_names) {
      if (p->length < 10)   /* ! */
	write_char_binary(f, ' ');
      write_integer_binary(f, p->length);
      write_char_binary(f, ' ');   /* ! */
      write_char_binary(f, '"');   /* ! */
      write_char_binary(f, ':');   /* ! */
      FORLIM1 = p->length;
      for (i = 1; i <= FORLIM1; i++)
	write_char_binary(f, p->name[i - PCH_START]);
      write_char_binary(f, '"');   /* ! */
      p = p->pointer;
    }
    switch (variable_description[v - MIN_VERTEX]->variable_type) {

    case discrete:
      i = 1;
      break;

    case continuous:
      i = 2;
      break;
    }
    write_integer_binary(f, i);
    if (variable_description[v - MIN_VERTEX]->variable_type == continuous) {
      write_integer_binary(f, 0L);
      write_boolean_binary(f,
	variable_description[v - MIN_VERTEX]->UU.missing_values);
    } else {
      i = variable_description[v - MIN_VERTEX]->UU.U0.levels_total -
	  variable_description[v - MIN_VERTEX]->UU.U0.levels_missing;
      write_integer_binary(f, i);
      write_integer_binary(f,
	(long)variable_description[v - MIN_VERTEX]->UU.U0.levels_missing);
    }
    write_char_binary(f, ' ');   /* ! */
    write_char_binary(f, '/');   /* ! */
    if (v == last_vertex)   /* ! */
      write_char_binary(f, '/');
    write_line_binary(f);
  }
}  /* write_factors_to_binary */


/* procedure write_incomplete_table_to_binary(var f : t_binary_file);
var
   i    : t_long_integer;
begin
end; */
/* write_incomplete_table_to_binary */

Static Void write_table_to_binary(f)
FILE *f;
{
  t_long_integer m;
  t_long_integer i = 1;
  t_long_integer number_of_cells;

  m = find_m();
  number_of_cells = marginal_dimension_tf(delta, true, false);
  write_version_to_binary(f, 2L);
  write_begin_binary(f);
  write_pch_10_binary(f, " table", 6L);
  write_end_binary(f);
  write_begin_binary(f);
  write_integer_binary(f, n[0]);
  write_integer_binary(f, number_of_cells);
  write_end_binary(f);
  while (i <= number_of_cells) {
    write_integer_binary(f, n[i]);
    if (i % m == 0)
      write_line_binary(f);
    i++;
  }
  write_char_binary(f, ';');
  write_line_binary(f);
}  /* write_table_to_binary */


Static Void write_list_to_binary(f)
FILE *f;
{
  boolean dummy_ok = true;
  t_level level;
  t_long_integer dummy_count, l, case_number;
  t_vertex u;
  t_item_list *link_item_list;
  t_case_list *link_case_list;

  write_version_to_binary(f, 3L);
  write_begin_binary(f);
  write_pch_10_binary(f, " list", 5L);
  write_end_binary(f);
  write_begin_binary(f);
  write_pch_20_binary(f, " Used for NaN: ", 15L);
  write_short_real_binary(f, _INFINITY_SHORT_REAL);
  write_end_binary(f);
  write_begin_binary(f);
  do_exclude(empty_set);
  dummy_count = find_marginal(empty_set, &dummy_ok);
  write_integer_binary(f, n[0]);
  write_end_binary(f);
  if (mixed_data) {
    link_item_list = item_list_read;
    /* for case_number := 1 to  n[0] do begin */
    while (link_item_list != NULL) {
      /*
      for v := first_vertex to  last_discrete_vertex do
         write_integer_binary(f, link_item_list^.item.integer_vector^[v]);
      write_line_binary(f);
      for v := first_vertex to  last_continuous_vertex do
         write_short_real_binary(f, link_item_list^.item.real_vector^[v]);
      write_line_binary(f);
       */
      for (u = first_vertex; u <= last_vertex; u++) {
	if (P_inset(u, delta))
	  write_integer_binary(f,
	    (long)link_item_list->item.integer_vector[to_discrete[u - MIN_VERTEX] -
						      MIN_VERTEX]);
	else
	  write_short_real_binary(f,
	    link_item_list->item.real_vector[to_continuous[u - MIN_VERTEX] -
					     MIN_VERTEX]);
      }
      write_line_binary(f);
      link_item_list = link_item_list->pointer;
    }
  } else if (case_list_read != NULL) {
    link_case_list = case_list_read;
    case_number = 1;
    /* for case_number := 1 to  n[0] do begin */
    while (link_case_list != NULL) {
      for (u = first_vertex; u <= last_vertex; u++)
	write_integer_binary(f, (long)link_case_list->cell[u - MIN_VERTEX]);
      write_line_binary(f);
      case_number++;
      link_case_list = link_case_list->pointer;
    }
  } else {
    rewind(file_read);
    for (case_number = 1; case_number <= n[0]; case_number++) {
      for (u = first_vertex; u <= last_vertex; u++) {
	read_level_file(file_read, &level);
	l = level;
	write_integer_binary(f, l);
      }
      write_line_binary(f);
    }
  }
  write_char_binary(f, ';');
  write_line_binary(f);
}  /* write_list_to_binary */


Static Void write_q_tables_to_binary(f)
FILE *f;
{
  t_long_integer m, i;
  t_offset_list *p;
  t_vertex v;

  p = q_tables_offsets;
  while (p != NULL) {
    m = find_m();
    number_of_cells = marginal_dimension(p->vertex_set);
    write_begin_binary(f);
    write_integer_binary(f, 0L);
    write_end_binary(f);
    write_version_to_binary(f, 5L);
    write_begin_binary(f);
    write_pch_10_binary(f, " q-table", 8L);
    write_end_binary(f);
    for (v = first_vertex; v <= last_vertex; v++)
      write_boolean_binary(f, P_inset(v, p->vertex_set));
    write_line_binary(f);
    write_begin_binary(f);
    write_integer_binary(f, number_of_cells);
    write_end_binary(f);
    i = FIRST_INDEX;
    while (i < FIRST_INDEX + number_of_cells) {
      write_integer_binary(f, q_array[i + p->offset]);
      if ((i - FIRST_INDEX + 1) % m == 0)
	write_line_binary(f);
      i++;
    }
    p = p->pointer;
    write_char_binary(f, ';');
    write_line_binary(f);
  }
}  /* write_q_tables_to_binary */


Static Void write_model_g_c_binary(f, model)
FILE *f;
t_model **model;
{
  if ((*model)->id == NULL)
    return;
  if ((*model)->id->model_type == pure_discrete) {
    write_char_binary(f, 'd');
    write_char_binary(f, ':');
    write_char_binary(f, ' ');
    print_set_list_binary(f, (*model)->id->UU.g_c_log_linear);
  } else if ((*model)->id->model_type == pure_continuous) {
    write_char_binary(f, 'c');
    write_char_binary(f, ':');
    write_char_binary(f, ' ');
    print_set_list_binary(f, (*model)->id->UU.g_c_covariance);
  } else if ((*model)->id->model_type == mixed) {
    write_char_binary(f, 'm');
    write_char_binary(f, ':');
    write_char_binary(f, ' ');
    print_set_list_binary(f, (*model)->id->UU.U1.g_c_discrete);
    write_pch_10_binary(f, " / ", 3L);
    print_set_list_binary(f, (*model)->id->UU.U1.g_c_linear);
    write_pch_10_binary(f, " / ", 3L);
    print_set_list_binary(f, (*model)->id->UU.U1.g_c_quadratic);
  }
  write_pch_10_binary(f, " | ", 3L);
  if ((*model)->id->causal_structure != NULL) {
    if (!P_setequal((*model)->id->causal_structure->vertex_set, empty_set)) {
      write_pch_10_binary(f, " | ", 3L);
      print_set_list_binary(f, (*model)->id->causal_structure);
    }
  }
  write_pch_10_binary(f, " ; ", 3L);
}  /* write_model_g_c_binary */


Static Void write_model_g_c_binary_binary(f, model)
FILE *f;
t_model **model;
{
  if ((*model)->id == NULL)
    return;
  if ((*model)->id->model_type == pure_discrete) {
    write_integer_binary(f, 1L);
    write_integer_binary(f, -6L);
    print_set_list_binary_binary(f, (*model)->id->UU.g_c_log_linear);
  } else if ((*model)->id->model_type == pure_continuous) {
    write_integer_binary(f, 2L);
    write_integer_binary(f, -6L);
    print_set_list_binary_binary(f, (*model)->id->UU.g_c_covariance);
  } else if ((*model)->id->model_type == mixed) {
    write_integer_binary(f, 3L);
    write_integer_binary(f, -6L);
    print_set_list_binary_binary(f, (*model)->id->UU.U1.g_c_discrete);
    write_integer_binary(f, -4L);
    print_set_list_binary_binary(f, (*model)->id->UU.U1.g_c_linear);
    write_integer_binary(f, -4L);
    print_set_list_binary_binary(f, (*model)->id->UU.U1.g_c_quadratic);
  }
  write_integer_binary(f, -5L);
  if ((*model)->id->causal_structure != NULL) {
    if (!P_setequal((*model)->id->causal_structure->vertex_set, empty_set))
      print_set_list_binary_binary(f, (*model)->id->causal_structure);
    else {
      write_integer_binary(f, 0L);
      write_integer_binary(f, -4L);
    }
  } else {
    write_integer_binary(f, 0L);
    write_integer_binary(f, -4L);
  }
  write_integer_binary(f, -6L);
}  /* write_model_g_c_binary_binary */


Static Void write_models_to_binary(f)
FILE *f;
{
  t_model_list *p = NULL;
  t_model_list *q, *link_model;
  t_integer number_of_models = 0;

  link_model = link_model_list;
  while (link_model != NULL) {
    q = (t_model_list *)Malloc(sizeof(t_model_list));
    if (q == NULL)
      _OutMem();
    q->pointer = p;
    p = q;
    p->model = link_model->model;
    /* Also reverse the model list!!! */
    number_of_models++;
    link_model = link_model->pointer;
  }
  write_version_to_binary(f, 3L);
  write_begin_binary(f);
  write_pch_10_binary(f, " models", 7L);
  write_end_binary(f);
  write_begin_binary(f);
  write_pch_20_binary(f, " Number of models: ", 19L);
  write_integer_binary(f, number_of_models);
  write_end_binary(f);
  number_of_models = 1;
  while (p != NULL) {
    write_integer_binary(f, number_of_models);
    write_char_binary(f, '/');
    write_integer_binary(f, p->model->model_number);
    write_char_binary(f, '/');
    write_model_g_c_binary(f, &p->model);
    write_line_binary(f);

    write_integer_binary(f, number_of_models);
    write_integer_binary(f, -6L);
    write_integer_binary(f, p->model->model_number);
    write_integer_binary(f, -6L);
    write_model_g_c_binary_binary(f, &p->model);
    write_line_binary(f);

    number_of_models++;
    q = p;
    p = p->pointer;
    _Free(q);
  }

}  /* write_models_to_binary */


Static Void export_data_arg(file_name, ok, code)
Char *file_name;
boolean *ok;
t_integer *code;
{
  FILE *f = NULL;
  pch_long data_name;
  t_long_integer i;
  boolean export_models;

  export_models = negative_flag_set(code, 0L);
  copy_pch_long(file_name, data_name);
  assign_binary_write(&f, data_name, ok);
  write_factors_to_binary(f);
  write_q_tables_to_binary(f);
  switch (datastructure) {

  case all:
    i = 1;
    break;

  case necessary:
    i = 2;
    break;

  case list_file:
    i = 3;
    break;

  case both:
    i = 4;
    break;
  }
  write_begin_binary(f);
  write_integer_binary(f, i);
  write_end_binary(f);
  if (datastructure == all && !mixed_data)
    write_table_to_binary(f);
  else
    write_list_to_binary(f);
  if (export_models)
    write_models_to_binary(f);
  fflush(f);
  P_ioresult = 0;
  if (f != NULL)
    fclose(f);
}  /* export_data */


Static Void export_data(command_file, as_argument, ifail, sub_code, arg_pos,
			nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long file_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, data_name, file_name))
    return;
  export_data_arg(file_name, &ok, sub_code);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* export_data */


/*@+"mainset.p"*/

/*

2486:    +++  ++
2487:    +++  ++
2488:    ---  -- p/mainset.p         42     153    2246 p/mainset.p
2489: |    4:    procedure set_data
2490: |   83:    procedure proc_set_print_formats
2491: |   99:    procedure proc_set_page_formats
2492: |  127:    procedure proc_set_pause_page_length
2493: |  138:    procedure proc_set_nrow
2494: |  155:    procedure proc_set_ncol
2495: |  187:    procedure proc_set_table_formats
2496: |  207:    procedure proc_set_test_formats
2497: |  227:    procedure proc_set_ips
2498: |  246:    procedure proc_set_mips
2499: |  277:    procedure proc_set_ips_it
2500: |  289:    procedure proc_set_em_it
2501: |  301:    procedure proc_set_ips_eps
2502: |  314:    procedure proc_set_em_eps
2503: |  326:    procedure proc_set_em_initial
2504: |  344:    procedure proc_set_rejection_limit
2505: |  378:    procedure proc_set_acceptance_limit
2506: |  412:    procedure proc_set_parts_limit
2507: |  423:    procedure proc_set_separators_limit
2508: |  434:    procedure proc_set_asymptotic_limit
2509: |  445:    procedure proc_set_power_lambda
2510: |  465:    procedure proc_set_ic_kappa
2511: |  481:    procedure proc_set_ic_on
2512: |  505:    procedure proc_set_aic
2513: |  514:    procedure proc_set_bic
2514: |  531:    procedure proc_set_ic_off
2515: |  538:    procedure proc_set_seed
2516: |  559:    procedure proc_set_exact_eps
2517: |  571:    procedure proc_set_number_of_tables
2518: |  588:    procedure proc_set_list_of_number_of_tables
2519: |  595:    procedure revers_list
2520: |  675:    procedure proc_read_exact_level
2521: |  691:    procedure set_option_on_off
2522: |  735:    procedure set_signal_on_off
2523: |  747:    procedure proc_set_ordinal_factors
2524: |  774:    procedure proc_set_response_variables
2525: |  802:    procedure proc_set_causal_structure
2526: |  846:    procedure proc_em_on
2527: |  877:    procedure proc_excl_on
2528: |  906:    procedure proc_excl_off
2529: |  924:    procedure proc_excl_mis
2530: |  932:    procedure proc_excl_in
2531:    +++  ++
2532:    +++  ++

*/

Static Void set_data(c)
t_datastructure c;
{
  boolean ok;
  t_vertex v;
  t_long_real p1;
  t_long_integer p1i;
  t_datastructure old_c;

  if (mixed_data)
    note_mixed(stdout, " SetData", 8L);
  if (c == necessary) {
    p1 = 1.0;
    for (v = first_vertex; v <= last_vertex; v++)
      p1 *= variable_description[v - MIN_VERTEX]->UU.U0.levels;
    if (p1 > max_cell_number / 3.0) {
      if (p1 < MAX_CELL_NUMBER_MAX / 3.0) {
	p1i = (long)floor(p1 + 0.5);
	if (!TURBO_PC)
	  ok = space_in_n_array(p1i * 3, 0L);
      }
    }
    ok = (p1 * 3 <= max_cell_number);
  } else if (c == all) {
    p1 = 1.0;
    for (v = first_vertex; v <= last_vertex; v++)
      p1 *= variable_description[v - MIN_VERTEX]->UU.U0.levels + 1;
    if (p1 > max_cell_number) {
      if (p1 < MAX_CELL_NUMBER_MAX) {
	p1i = (long)floor(p1 + 0.5);
	if (!TURBO_PC)
	  ok = space_in_n_array(p1i, 0L);
      }
    }
    ok = (p1 <= max_cell_number);
  } else
    ok = true;
#ifdef CoCo_Cygwin
#ifdef NO_LEVEL_FILE
  if (c == list_file || c == both) {
    write_pch(stdout, " Datastructure not valid!!!!", 28L);
    ok = false;
  }
#endif
#endif /* CoCo_Cygwin */
  if (ok) {
    old_c = datastructure;
    datastructure = c;
    datastructure_selected = true;
    write_pch(stdout, " Datastructure selected:  ", 26L);
  } else
    write_pch(stdout, " No space for Datastructure ", 28L);
  switch (c) {

  case all:
    write_pch(stdout, " ALL", 4L);
    break;

  case necessary:
    write_pch(stdout, " NECESSARY", 10L);
    break;

  case list_file:
    write_pch(stdout, " FILE", 5L);
    break;
  }
  if (!(ok && read_obs))
    return;
  if (old_c == all && c == necessary)
    dispose_marginals();
  else if (old_c == all && c == list_file) {
    dispose_marginals();
    read_obs = false;
  } else if (old_c == necessary && c == all) {
    if (!mixed_data) {
      write_line(stdout);
      if (TURBO_PC)
	write_pch(stdout, " Wait !! -", 10L);
      write_pch(stdout, " Finding all marginals", 22L);
      find_all_marginals(&ok);
    } else
      note_mixed(stdout, " FindingAllMarginals", 20L);
  } else if (old_c == necessary && c == list_file) {
    dispose_marginals();
    read_obs = false;
  } else if (old_c == list_file && c == all)
    read_obs = false;
  else if (old_c == list_file && c == necessary)
    read_obs = false;
  if (read_obs == false) {
    write_line(stdout);
    write_pch(stdout, " Note: Observations deleted", 27L);
  }
}  /* set_data */


Static Void proc_set_print_formats(command_file, as_argument, ifail, sub_code,
				   arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_integer i = 0;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Width->  ", 8L, &print_width);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Dec.->   ", 8L, &print_dec);
  if (as_argument)
    (*nargs)[arg_pos] = 2;
}  /* proc_set_print_formats */


Static Void proc_set_page_formats(command_file, as_argument, ifail, sub_code,
				  arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_integer i = 0;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Lenght->", 9L, &line_length);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Hight->", 8L, &page_length);
  if (as_argument)
    (*nargs)[arg_pos] = 2;
  if (line_length > MAX_LINE_LENGTH) {
    line_length = MAX_LINE_LENGTH;
    write_line_diary();
    write_pch(stdout, " Line Lenght set to:", 20L);
    write_integer(stdout, line_length, 5L);
  }
  if (page_length <= MAX_PAGE_LENGTH)
    return;
  page_length = MAX_PAGE_LENGTH;
  write_line_diary();
  write_pch(stdout, " Page Lenght set to:", 20L);
  write_integer(stdout, page_length, 5L);
}  /* proc_set_page_formats */


Static Void proc_set_pause_page_length(command_file, as_argument, ifail,
				       sub_code, arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " LENGTH-> ", 9L, &page_pause_length);
}  /* proc_set_pause_page_length */


Static Void proc_set_nrow(command_file, as_argument, ifail, sub_code, arg_pos,
			  nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " HIGHT->  ", 8L, &page_length);
  if (page_length <= MAX_PAGE_LENGTH)
    return;
  page_length = MAX_PAGE_LENGTH;
  write_line_diary();
  write_pch(stdout, " Page Lenght set to:", 20L);
  write_integer(stdout, page_length, 5L);
}  /* proc_set_nrow */


Static Void proc_set_ncol(command_file, as_argument, ifail, sub_code, arg_pos,
			  nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_integer i, j, n, m;

  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " LENGTH-> ", 9L, &n);
  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      m = sm_index(i, j, n);
      write_integer(stdout, i, 3L);
      write_char(stdout, '/');
      write_integer(stdout, j, 3L);
      write_char(stdout, '/');
      write_integer(stdout, n, 3L);
      write_char(stdout, '/');
      write_integer(stdout, m, 3L);
      write_line(stdout);
    }
  }
  if (line_length <= MAX_LINE_LENGTH)
    return;
  line_length = MAX_LINE_LENGTH;
  write_line_diary();
  write_pch(stdout, " Line Lenght set to:", 20L);
  write_integer(stdout, line_length, 5L);
}  /* proc_set_ncol */


Static Void proc_set_table_formats(command_file, as_argument, ifail, sub_code,
				   arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_integer i = 0;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Width->", 8L, &width);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Prob.->", 8L, &decprob);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Expt.->", 8L, &decexpt);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Resi.->", 8L, &decdiff);
  if (as_argument)
    (*nargs)[arg_pos] = 4;
}  /* proc_set_table_formats */


Static Void proc_set_test_formats(command_file, as_argument, ifail, sub_code,
				  arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_integer i = 0;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " X-width->", 10L, &x_width);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " X-prob.->", 10L, &x_dec);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " P-width->", 10L, &prob_width);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " P-prob.->", 10L, &prob_dec);
  if (as_argument)
    (*nargs)[arg_pos] = 4;
}  /* proc_set_test_formats */


Static Void proc_set_ips(command_file, as_argument, ifail, sub_code,
			 arg_pos_int, arg_pos_double, nargs, arg_int,
			 arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos_int,
		  nargs, arg_int, " MAXIT->  ", 8L, &ips_max_it);
  get_one_long_real(command_file, as_argument, ifail, sub_code,
		    arg_pos_double, nargs, arg_double, " EPS.->   ", 8L,
		    &ips_epsilon);
  note_command_end_pch(stdout, " Ips-Stop selected", 18L);
}  /* proc_set_ips */


Static Void proc_set_cips(command_file, as_argument, ifail, sub_code,
			  arg_pos_int, arg_pos_double, nargs, arg_int,
			  arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos_int,
		  nargs, arg_int, " MAXIT->  ", 8L, &cips_max_it);
  get_one_long_real(command_file, as_argument, ifail, sub_code,
		    arg_pos_double, nargs, arg_double, " EPS.->   ", 8L,
		    &cips_epsilon);
  note_command_end_pch(stdout, " Ips-Stop selected", 18L);
}  /* proc_set_ips */


Static Void proc_set_mips(command_file, as_argument, ifail, sub_code,
			  arg_pos_int, arg_pos_double, nargs, arg_int,
			  arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  t_integer i = 0;

  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos_int,
		  nargs, arg_int, " Cycles-> ", 10L, &mips_max_it);
  if (as_argument)
    (*nargs)[arg_pos_int] = 1;
  get_next_long_real(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_double, nargs, arg_double, " Epsilon->", 10L,
		     &mips_epsilon);
  get_next_long_real(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_double, nargs, arg_double, " Ep.init->", 10L,
		     &mips_init_epsilon);
  get_next_long_real(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_double, nargs, arg_double, " Error->  ", 10L,
		     &mips_log_l_round_error);
  get_next_long_real(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_double, nargs, arg_double, " Noise->  ", 10L,
		     &mips_random_noise);
  get_next_long_real(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_double, nargs, arg_double, " Lambda-> ", 10L,
		     &mips_min_lambda);
  get_next_long_real(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_double, nargs, arg_double, " Chol.e-> ", 10L,
		     &cholesky_epsilon);
  if (as_argument)
    (*nargs)[arg_pos_double] = 7;
  note_command_end_pch(stdout, " Ips-Stop selected", 18L);
}  /* proc_set_mips */


Static Void proc_set_ips_it(command_file, as_argument, ifail, sub_code,
			    arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " MAXIT->  ", 8L, &ips_max_it);
  /* cips_max_it := ips_max_it; */
  /* mips_max_it := ips_max_it; */
  note_command_end_pch(stdout, " Ips-Max-It selected", 20L);
}  /* proc_set_ips_it */


Static Void proc_set_em_it(command_file, as_argument, ifail, sub_code,
			   arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " EM-MAX-> ", 9L, &em_max_it);
  note_command_end_pch(stdout, " Em-Max-IT selected", 19L);
}  /* proc_set_em_it */


Static Void proc_set_ips_eps(command_file, as_argument, ifail, sub_code,
			     arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_double, " EPS.->   ", 8L, &ips_epsilon);
  /* cips_epsilon := ips_epsilon; */
  /* mips_epsilon := ips_epsilon; */
  note_command_end_pch(stdout, " Ips-Stop selected", 18L);
}  /* proc_set_ips_eps */


Static Void proc_set_em_eps(command_file, as_argument, ifail, sub_code,
			    arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_double, " EM-EPS.->", 10L, &em_epsilon);
  note_command_end_pch(stdout, " EM Epsilon read", 16L);
}  /* proc_set_em_eps */


Static Void proc_set_em_initial(as_argument, ifail, sub_code, arg_pos, nargs,
				arg_int)
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  if (!as_argument) {
    em_initial = *sub_code;
    return;
  }
  if (!ok_int_arg(ifail, arg_pos, 1L, nargs, arg_int))
    return;
  if (*sub_code == -1)
    (*arg_int)[0] = em_initial;
  else
    em_initial = (*arg_int)[0];
}  /* proc_set_em_initial */


Static Void proc_set_rejection_limit(command_file, as_argument, ifail,
				     sub_code, arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_double, " Limit->  ", 8L, &alfa_reject);
  if (alfa_reject <= alfa_)
    return;
  write_line_diary();
  write_pch(stdout, " Also change of Acceptance limit:", 33L);
  write_line(stdout);
  write_line(stdout);
  write_pch_r(stdout, "Acceptance limit", 16L, 40L);
  write_real(stdout, alfa_, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Rejection limit", 15L, 40L);
  write_real(stdout, alfa_reject, 12L, 9L);
  write_line(stdout);
  alfa_ = alfa_reject;
  write_pch(stdout, " Changed to:", 12L);
  write_line(stdout);
  write_line(stdout);
  write_pch_r(stdout, "Acceptance limit", 16L, 40L);
  write_real(stdout, alfa_, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Rejection limit", 15L, 40L);
  write_real(stdout, alfa_reject, 12L, 9L);
  write_line(stdout);
}  /* proc_set_rejection_limit */


Static Void proc_set_acceptance_limit(command_file, as_argument, ifail,
				      sub_code, arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_double, " ALFA->   ", 7L, &alfa_);
  if (alfa_reject <= alfa_)
    return;
  write_line_diary();
  write_pch(stdout, " Also change of Rejection limit:", 32L);
  write_line(stdout);
  write_line(stdout);
  write_pch_r(stdout, "Acceptance limit", 16L, 40L);
  write_real(stdout, alfa_, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Rejection limit", 15L, 40L);
  write_real(stdout, alfa_reject, 12L, 9L);
  write_line(stdout);
  alfa_reject = alfa_;
  write_pch(stdout, " Changed to:", 12L);
  write_line(stdout);
  write_line(stdout);
  write_pch_r(stdout, "Acceptance limit", 16L, 40L);
  write_real(stdout, alfa_, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Rejection limit", 15L, 40L);
  write_real(stdout, alfa_reject, 12L, 9L);
  write_line(stdout);
}  /* proc_set_acceptance_limit */


Static Void proc_set_parts_limit(command_file, as_argument, ifail, sub_code,
				 arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_double, " Limit->  ", 8L, &parts_limit);
}  /* proc_set_parts_limit */


Static Void proc_set_separators_limit(command_file, as_argument, ifail,
				      sub_code, arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_double, " Limit->  ", 8L, &separators_limit);
}  /* proc_set_separators_limit */


Static Void proc_set_asymptotic_limit(command_file, as_argument, ifail,
				      sub_code, arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_double, " Limit->  ", 8L, &asymptotic_limit);
}  /* proc_set_asymptotic_limit */


Static Void proc_set_power_lambda(command_file, as_argument, ifail, sub_code,
				  arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  if (*sub_code == 1)
    lambda = 0.0;
  else
    get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		      nargs, arg_double, " Lambda-> ", 9L, &lambda);
  if (lambda == 0 || lambda == -1) {
    lambda = 1.0;
    write_line_diary();
    write_pch(stdout, " Power Divergence not printed", 29L);
  }
  note_command_end_pch(stdout, " Lambda read", 12L);
}  /* proc_set_power_lambda */


Static Void proc_set_ic_kappa(command_file, as_argument, ifail, sub_code,
			      arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  if (*sub_code != -1) {
    ic = true;
    bic = false;
  }
  get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_double, " Kappa->", 8L, &ic_lambda);
  note_command_end_pch(stdout, " Kappa read", 12L);
}  /* proc_set_ic_kappa */


Static Void proc_set_ic_on()
{
  write_line_diary();
  ic = true;
  note_command_end_pch(stdout, " IC set On", 10L);
  write_pch_r(stdout, "Acceptance limit", 16L, 40L);
  write_real(stdout, alfa_, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Rejection limit", 15L, 40L);
  write_real(stdout, alfa_reject, 12L, 9L);
  write_line(stdout);
  alfa_ = 0.0;
  alfa_reject = 0.0;
  write_pch(stdout, " Changed to:", 12L);
  write_line(stdout);
  write_line(stdout);
  write_pch_r(stdout, "Acceptance limit", 16L, 40L);
  write_real(stdout, alfa_, 12L, 9L);
  write_line(stdout);
  write_pch_r(stdout, "Rejection limit", 15L, 40L);
  write_real(stdout, alfa_reject, 12L, 9L);
  write_line(stdout);
}  /* proc_set_ic_on */


Static Void proc_set_aic()
{
  proc_set_ic_on();
  note_command_end_line(stdout);
  bic = false;
  ic_lambda = 2.0;
  note_command_end_pch(stdout, " AIC set", 8L);
}  /* proc_set_aic */


Static Void proc_set_bic()
{
  if (!read_obs) {
    write_line_diary();
    write_pch(stdout, " NO DATA READ", 13L);
    return;
  }
  proc_set_ic_on();
  note_command_end_line(stdout);
  bic = true;
  if (exclude_missing)
    ic_lambda = -1.0;
  else
    ic_lambda = log((double)n[0]);
  note_command_end_pch(stdout, " BIC set", 8L);
}  /* proc_set_bic */


Static Void proc_set_ic_off()
{
  write_line_diary();
  ic = false;
  note_command_end_pch(stdout, " IC set Off", 11L);
}  /* proc_set_ic_off */


Static Void proc_set_seed(command_file, as_argument, ifail, sub_code, arg_pos,
			  nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  if (*sub_code == -1 || *sub_code == 0 || *sub_code == 1)
    get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_int, " Seed ->  ", 8L, &seed);
  else
    seed = MAXIMAL;
  if (seed == MAXIMAL) {
    seed = random_init();
    *sub_code = -1;
    get_one_integer(command_file, true, ifail, sub_code, arg_pos, nargs,
		    arg_int, " Seed ->> ", 9L, &seed);
  }
  note_command_end_pch(stdout, " Seed set", 9L);
}  /* proc_set_seed */


Static Void proc_set_exact_eps(command_file, as_argument, ifail, sub_code,
			       arg_pos, nargs, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
double **arg_double;
{
  get_one_long_real(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_double, " Eps. ->  ", 8L, &exact_epsilon);
  note_command_end_pch(stdout, " Exact epsilon read", 19L);
}  /* proc_set_exact_eps */


Static Void proc_set_number_of_tables(command_file, as_argument, ifail,
				      sub_code, arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  if (*sub_code == 1) {
    number_of_tables = 0;
    write_line_diary();
    write_pch(stdout, " Variating number of tables used in exact test",
		46L);
  } else
    get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_int, " #Tables: ", 10L, &number_of_tables);
  note_command_end_pch(stdout, " # of tables read", 17L);
}  /* proc_set_number_of_tables */


Local Void revers_list__(p)
t_two_integers_list **p;
{
  t_two_integers_list *hp1 = NULL;
  t_two_integers_list *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_list */


Static Void proc_set_list_of_number_of_tables(command_file, as_argument,
  ifail, sub_code, arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_two_integers_list *p;
  t_integer i = 0;
  t_integer a;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Init #T: ", 10L, &init_n_of_tables);
  note_command_end_pch(stdout, " # of tables read", 17L);
  if (*sub_code == -1) {
    p = link_n_of_tables;
    if (p == NULL) {
      /* 20, (2, 1000), (5, 200), (8, 100), (20, 20) */
      a = 2;
      get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		       arg_pos, nargs, arg_int, "", 0L, &a);
      a = 1000;
      get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		       arg_pos, nargs, arg_int, "", 0L, &a);
      a = 8;
      get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		       arg_pos, nargs, arg_int, "", 0L, &a);
      a = 100;
      get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		       arg_pos, nargs, arg_int, "", 0L, &a);
      a = 20;
      get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		       arg_pos, nargs, arg_int, "", 0L, &a);
      a = 20;
      get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		       arg_pos, nargs, arg_int, "", 0L, &a);
    } else {
      while (p != NULL) {
	get_next_integer(command_file, as_argument, &i, ifail, sub_code,
			 arg_pos, nargs, arg_int, "", 0L, &p->a);
	get_next_integer(command_file, as_argument, &i, ifail, sub_code,
			 arg_pos, nargs, arg_int, "", 0L, &p->b);
	p = p->pointer;
      }
    }
    if (*ifail == 70)
      (*nargs)[arg_pos] = i;
    return;
  }
  p = link_n_of_tables;
  while (p != NULL) {
    link_n_of_tables = p;
    p = p->pointer;
    _Free(link_n_of_tables);
  }
  do {
    p = (t_two_integers_list *)Malloc(sizeof(t_two_integers_list));
    if (p == NULL)
      _OutMem();
    p->pointer = link_n_of_tables;
    link_n_of_tables = p;
    get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		     nargs, arg_int, " A:       ", 10L, &p->a);
    get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		     nargs, arg_int, " B:       ", 10L, &p->b);
  } while (init_n_of_tables > p->a && *ifail == 0);
  if (init_n_of_tables > p->a) {
    p = (t_two_integers_list *)Malloc(sizeof(t_two_integers_list));
    if (p == NULL)
      _OutMem();
    p->pointer = link_n_of_tables;
    link_n_of_tables = p;
    p->a = init_n_of_tables;
    p->b = 1000;
  }
  revers_list__(&link_n_of_tables);
}  /* proc_set_list_of_number_of_tables */


Static Void proc_read_exact_level(command_file)
FILE *command_file;
{
  t_integer e_level;

  exact_test_for_sum_up = false;
  exact_test_for_partitioning = false;
  exact_test_for_test_models = false;
  read_integer(command_file, " EXACT:   ", 10L, &e_level);
  exact_test_for_sum_up = (e_level >= 4);
  e_level &= 3;
  exact_test_for_partitioning = (e_level >= 2);
  e_level &= 1;
  exact_test_for_test_models = (e_level >= 1);
  note_command_end_pch(stdout, " Exact level read", 17L);
}  /* proc_read_exact_level */


Static Void set_option_on_off(command_file, as_argument, ifail, sub_code,
			      arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_integer option, code;
  t_integer x_code = 1;

  if (!as_argument && *sub_code == 5) {
    read_command(command_file, &option, &code, false, " Switch ->", 10L,
		 -999L, (long)SWITCH_OFFSET);
    code -= 2;
    if (option == 20 && link_eh_pack == NULL)
      code = 1;
    else
      switch_new(&option, &code);
    return;
  }
  option = -1;
  if (*sub_code == -1)
    code = 2;
  else
    code = *sub_code - 2;
  get_one_integer(command_file, as_argument, ifail, &x_code, arg_pos, nargs,
		  arg_int, " Option-> ", 9L, &option);
  if (option == 20 && link_eh_pack == NULL)
    code = 1;
  else {
    if (!(as_argument && option != -1))
      write_line_diary();
    switch_new(&option, &code);
  }
  if (as_argument && option != -1) {
    if (*sub_code != -1)
      write_line(stdout);
    x_code = -1;
    get_one_integer(command_file, true, ifail, &x_code, arg_pos, nargs,
		    arg_int, "", 0L, &code);
  }
  *sub_code = code;
}  /* set_option_on_off */


Static Void set_signal_on_off(command_file, code)
FILE *command_file;
t_integer code;
{
  if (code == 1) {
    pid = 0;
    sigall = 0;
  } else {
    read_integer(command_file, " pid->    ", 9L, &pid);
    read_integer(command_file, " signal-> ", 9L, &sigall);
  }
}  /* set_signal_on_off */


Static Void proc_set_ordinal_factors(command_file, as_argument, ifail,
				     sub_code, arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex v;
  t_integer i = PCH_START;

  if (!get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		      sub_code, arg_pos, nargs, arg_char, " SET->", 6L,
		      ordinal_factors, ordinal_factors))
    return;
  for (v = first_vertex; v <= last_vertex; v++)
    variable_description[v - MIN_VERTEX]->UU.U0.ordinal = P_inset(v,
	ordinal_factors);
  ordinal_tests = !P_setequal(ordinal_factors, empty_set);
  if (link_test_list == NULL)
    return;
  write_line(stdout);
  write_pch(stdout, " Consider `DISPOSE OF TESTS;'", 29L);
  write_line(stdout);
}  /* proc_set_ordinal_set */


Static Void proc_set_response_variables(command_file, as_argument, ifail,
					sub_code, arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex v;
  t_integer i = PCH_START;

  if (!get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		      sub_code, arg_pos, nargs, arg_char, " SET->", 6L,
		      response_variables, response_variables))
    return;
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, response_variables))
      variable_description[v - MIN_VERTEX]->stratum = 1;
    else
      variable_description[v - MIN_VERTEX]->stratum = 0;
  }
  if (link_test_list != NULL) {
    write_pch(stdout, " Consider `DISPOSE OF TESTS;'", 29L);
    write_line(stdout);
  }
}  /* proc_set_response_variables */


Static Void proc_set_causal_structure(command_file, as_argument, ifail,
				      sub_code, arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex v;
  t_integer i = PCH_START;
  t_set_list *p;
  boolean options;

  if (!(get_ordered_gc(command_file, true, true, false, as_argument, &i,
		       ifail, sub_code, arg_pos, nargs, arg_char, &options,
		       &causal_structure, &p) && *sub_code >= 0))
	/* ' GC->@@@@@', 5, */
	  return;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2525L, 0L)) {
    write_char(stdout, '(');
    print_g_c(p, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, ')');
  }
  /*$endif TRACE*/
  i = 0;
  dispose_set_list(&causal_structure);
  causal_structure = p;
  while (p != NULL) {
    for (v = first_vertex; v <= last_vertex; v++) {
      if (P_inset(v, p->vertex_set))
	variable_description[v - MIN_VERTEX]->stratum = i;
    }
    i++;
    p = p->pointer;
  }
  if (link_test_list != NULL) {
    write_pch(stdout, " Consider `DISPOSE OF TESTS;'", 29L);
    write_line(stdout);
  }
}  /* proc_set_causal_structure */


Static Void proc_em_on()
{
  t_vertex v;

  if (reject_missing) {
    write_pch(stdout, " Not when SKIP MISSING is on", 28L);
    return;
  }
  if (datastructure == list_file) {
    write_pch(stdout, " Since the datastructure File is used", 37L);
    write_line(stdout);
    write_pch(stdout, " the EM algorithm in this version will be slow",
		46L);
    write_line(stdout);
  }
  if (datastructure == all) {
    write_pch(stdout, " Shift to datastructure Necessary and reuse EM ON",
		49L);
    return;
  }
  dispose_all_expressions();
  em = true;
  exclude_missing = false;
  do_exclude(empty_set);
  for (v = first_vertex; v <= last_vertex; v++) {
    variable_description[v - MIN_VERTEX]->UU.U0.levels =
      variable_description[v - MIN_VERTEX]->UU.U0.levels_total -
      variable_description[v - MIN_VERTEX]->UU.U0.levels_missing;
    last_cell[v - MIN_VERTEX] =
      FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1;
  }
  note_command_end_pch(stdout, " EM set On", 10L);
}  /* proc_em_on */


Static Void proc_excl_on()
{
  boolean dummy_ok;

  if (reject_missing) {
    write_pch(stdout, " Not when SKIP MISSING is on", 28L);
    return;
  }
  em = false;
  if (datastructure == all) {
    set_data(necessary);
    write_line(stdout);
  }
  if (datastructure == all) {
    write_pch(stdout, " Shift to datastructure Necessary and Exclude",
		45L);
    return;
  }
  if (!TURBO_PC && datastructure == necessary)
    dummy_ok = space_in_n_array(number_of_cells * 2, 0L);
  if (number_of_cells > max_cell_number / 2 && datastructure != list_file) {
    write_pch(stdout, " Not space for Exclude Missing", 30L);
    return;
  }
  exclude_missing = true;
  new_print_do_exclude(delta_gamma, &global_write_options->line_form);
  note_command_end_pch(stdout, " Missing Excluded", 17L);
}  /* proc_excl_on */


Static Void proc_excl_off()
{
  t_vertex v;

  if (reject_missing) {
    write_pch(stdout, " Not when SKIP MISSING is on", 28L);
    return;
  }
  em = false;
  exclude_missing = false;
  do_exclude(empty_set);
  for (v = first_vertex; v <= last_vertex; v++) {
    variable_description[v - MIN_VERTEX]->UU.U0.levels =
      variable_description[v - MIN_VERTEX]->UU.U0.levels_total;
    last_cell[v - MIN_VERTEX] =
      FIRST_LEVEL + variable_description[v - MIN_VERTEX]->UU.U0.levels - 1;
  }
  note_command_end_pch(stdout, " Missing included", 17L);
}  /* proc_excl_off */


Static Void proc_excl_mis()
{
  if (!exclude_missing)
    proc_excl_on();
  else
    proc_excl_off();
}  /* proc_excl_mis */


Static Void proc_excl_in(command_file, as_argument, ifail, sub_code, arg_pos,
			 nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex_set a;
  t_integer i = PCH_START;

  P_setcpy(a, empty_set);
  if (!get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		      sub_code, arg_pos, nargs, arg_char, " SET->", 6L,
		      delta_missing_excluded, a))
    return;
  em = false;
  if (!exclude_missing)
    proc_excl_on();
  if (exclude_missing) {
    write_line_diary();
    new_print_do_exclude(a, &global_write_options->line_form);
  } else {
    write_line_diary();
    write_pch(stdout, " Use `Exclude missing on;' first", 32L);
  }
}  /* proc_excl_in */


/*@-"mainparser.c"*/
/*@+"mainpar.p"*/


/*

2533:    +++  ++
2534:    +++  ++
2535:    ---  -- p/mainpar.p         13      51     572 p/mainpar.p
2536: |    4:    procedure show_menu
2537: |  261:    function match_line
2538: |  267:    function upper
2539: |  306:    procedure help
2540: |  459:    procedure no_action
2541: |  493:    procedure proc_ma
2542: |  533:    procedure proc_mam
2543: |  548:    procedure proc_da
2544: |  587:    procedure proc_pa
2545: |  596:    procedure read_command_nr
2546: |  625:    procedure menu_nr
2547: |  638:    procedure next_menu
2548: |  647:    procedure previous_menu
2549:    +++  ++
2550:    +++  ++

*/


Static Void show_menu(menu_number)
t_integer *menu_number;
{
  t_integer i1, i2, nr;

  i1 = 0;
  i2 = MAX_NUMBER_OF_COMMANDS;

  switch (*menu_number) {

  case 0:
    i1 = 0;
    i2 = MAX_NUMBER_OF_COMMANDS;
    break;

  case 1:
    i1 = 0;
    i2 = 6;
    break;

  case 2:
    i1 = 7;
    i2 = 11;
    break;

  case 3:
    i1 = 12;
    i2 = 15;
    break;

  case 4:
    i1 = 16;
    i2 = 18;
    break;

  case 5:
    i1 = 19;
    i2 = 23;
    break;

  case 6:
    i1 = 24;
    i2 = 24;
    break;

  case 7:
    i1 = 25;
    i2 = 31;
    break;

  case 8:
    i1 = 32;
    i2 = 44;
    break;

  case 9:
    i1 = 45;
    i2 = 52;
    break;

  case 10:
    i1 = 53;
    i2 = 56;
    break;

  case 11:
    i1 = 57;
    i2 = 62;
    break;

  case 12:
    i1 = 63;
    i2 = 74;
    break;

  case 13:
    i1 = 75;
    i2 = 85;
    break;

  case 14:
    i1 = 86;
    i2 = 87;
    break;

  case 15:
    i1 = 88;
    i2 = 91;
    break;

  case 16:
    i1 = 92;
    i2 = 102;
    break;

  case 17:
    i1 = 103;
    i2 = 108;
    break;

  case 18:
    i1 = 109;
    i2 = 112;
    break;

  case 19:
    i1 = 113;
    i2 = 124;
    break;

  case 20:
    i1 = 125;
    i2 = 133;
    break;

  case 21:
    i1 = 134;
    i2 = 139;
    break;

  case 22:
    i1 = 140;
    i2 = 145;
    break;

  case 23:
    i1 = 146;
    i2 = 150;
    break;

  case 24:
    i1 = 151;
    i2 = 156;
    break;

  case 25:
    i1 = 157;
    i2 = 158;
    break;

  case 26:
    i1 = 159;
    i2 = 169;
    break;

  case 27:
    i1 = 170;
    i2 = 175;
    break;

  case 28:
    i1 = 176;
    i2 = 186;
    break;

  case 29:
    i1 = 187;
    i2 = 190;
    break;

  case 30:
    i1 = 191;
    i2 = 192;
    break;

  case 31:
    i1 = 193;
    i2 = 198;
    break;

  case 32:
    i1 = 199;
    i2 = 201;
    break;

  case 33:
    i1 = 202;
    i2 = 205;
    break;

  case 34:
    i1 = 206;
    i2 = 207;
    break;

  case 35:
    i1 = 208;
    i2 = 213;
    break;

  case 36:
    i1 = 214;
    i2 = 216;
    break;

  case 37:
    i1 = 217;
    i2 = 219;
    break;

  case 38:
    i1 = 220;
    i2 = 220;
    break;

  case 39:
    i1 = 221;
    i2 = 227;
    break;

  case 40:
    i1 = 228;
    i2 = 228;
    break;

  case 41:
    i1 = 229;
    i2 = 246;
    break;

  case 42:
    i1 = 247;
    i2 = 250;
    break;

  case 43:
    i1 = 251;
    i2 = 255;
    break;

  case 44:
    i1 = 0;
    i2 = MAX_NUMBER_OF_COMMANDS;
    break;
  }
  write_line(stdout);
  for (nr = i1; nr <= i2; nr++) {
    write_integer(stdout, nr, 5L);
    write_pch(stdout, " : ", 3L);
    write_pch(stdout, command_text[nr], 30L);
    if (command_text[nr][0] == '%')
      write_pch(stdout, " - Not implemented", 18L);
    if (command_text[nr][0] == '?')
      write_pch(stdout, " - No normal use", 16L);
    write_line(stdout);
  }
  if (mode != menu)
    return;
  write_line(stdout);
  write_integer(stdout, 3L, 5L);
  write_pch(stdout, " : ", 3L);
  write_pch(stdout, command_text[3], 16L);
  write_integer(stdout, 4L, 5L);
  write_pch(stdout, " : ", 3L);
  write_pch(stdout, command_text[4], 10L);
  write_integer(stdout, 5L, 5L);
  write_pch(stdout, " : ", 3L);
  write_pch(stdout, command_text[5], 16L);
  write_line(stdout);
}  /* show_menu */


Local Char upper(c)
Char *c;
{
  if (islower(*c))
    return (*c - 32);
  else
    return (*c);
}


Static boolean match_line(word_line, help_line, word_pos, help_pos)
Char *word_line, *help_line;
t_integer *word_pos, *help_pos;
{
  boolean ok = false;
  t_integer pos = PCH_START;
  t_integer j;

  /* write_integer(output, word_pos, 3);
     write_integer(output, help_pos, 3);
     write_line(output); */
  while (pos < *help_pos && !ok) {
    j = 0;
    ok = true;
    /* write_char(output, '<'); */
    while (j <= *word_pos - PCH_START && j <= *help_pos - pos &&
	   word_line[j] != ' ' && ok) {
      /* write_char(output, help_line[pos + j]); */
      ok = (upper(&word_line[j]) == upper(&help_line[pos + j - PCH_START]));
      j++;
    }
    /* write_char(output, '|'); */
    if (ok)
      break;
    /* write_char(output, '>');
       write_line(output) */
    while (help_line[pos - PCH_START] != ' ' && pos < *help_pos) {
      /* write_char(output, help_line[pos]); */
      pos++;
    }
    /* write_char(output, help_line[pos]); */
    pos++;
  }
  return ok;
}


Static Void help(command_file)
FILE *command_file;
{
  FILE *guide = NULL;
  Char c;
  t_integer prod_nr, next_level, i, j, help_pos, line_pos;
  boolean not_impl, found, ok;
  pch_long filename, help_line, line;

  if (eoln_command(command_file)) {
    prod_nr = 255;
    next_level = 255;
  } else
    sub_read_command(command_file, line, &line_pos, &ok, &prod_nr,
		     &next_level, true, "Help->    ", 6L, 0L, 0L);
  write_line_diary();
  default_to_file_name(FILE_NAME_HLP, filename);
  assign_read_cocolib(&guide, filename, &found);
  if (found) {
    if (!ok) {
      write_line(stdout);
      do {
	read_guide_char(guide, &c);
	/* write_char(output, c); */
	while ((c != '*') & (!eof_guide(guide))) {
	  read_guide_ln(guide);
	  if (!eof_guide(guide))
	    read_guide_char(guide, &c);
	  /* write_char(output, c); */
	}
	if (c == '*') {
	  read_guide_char(guide, &c);
	  read_guide_char(guide, &c);
	  read_guide_integer(guide, 7L, &i);
	  /* write_integer(output, i, 3);
	     write_line(output); */
	  while ((c != '$') & (!eolnorf_guide(guide)))
	    read_guide_char(guide, &c);
	  read_guide_char(guide, &c);
	  help_pos = PCH_START - 1;
	  while ((c != ';') & (!eolnorf_guide(guide))) {
	    help_pos++;
	    read_guide_char(guide, &c);
	    help_line[help_pos - PCH_START] = c;
	  }
	  if (eoln_guide(guide))
	    read_guide_ln(guide);
	  found = match_line(line, help_line, &line_pos, &help_pos);
	  if (found) {
	    write_space(stdout, 4L);
	    for (i = PCH_START; i <= help_pos; i++)
	      write_char(stdout, help_line[i - PCH_START]);
	    write_line(stdout);
	  }
	}
      } while (!eof_guide(guide));
      write_line(stdout);
    } else {
      found = false;
      do {
	read_guide_char(guide, &c);
	while ((c == '!' || c == '&' || c == '#') & (!eof_guide(guide))) {
	  read_guide_ln(guide);
	  read_guide_char(guide, &c);
	}
	if ((c == '*' &&
	     (next_level == 0 || 200 < next_level && next_level < 255)) ||
	    c == '-' && next_level == 255 ||
	    c == '+' && 0 < next_level && next_level < 200) {
	  read_guide_char(guide, &c);
	  read_guide_char(guide, &c);
	  read_guide_integer(guide, 7L, &i);
	  if (0 < next_level && next_level < 200)
	    found = (i == next_level);
	  else
	    found = (i == prod_nr);
	} else
	  read_guide_ln(guide);
      } while (!(found | eof_guide(guide)));
      if (found) {
	for (i = 1; i <= 4; i++)
	  read_guide_char(guide, &c);
	i = 0;
	not_impl = false;
	while (!eoln_guide(guide)) {
	  read_guide_char(guide, &c);
	  if (c == '%')
	    not_impl = true;
	  write_char(stdout, c);
	}
	do {
	  while (!eolnorf_guide(guide)) {
	    read_guide_char(guide, &c);
	    write_char(stdout, c);
	  }
	  if (eof_guide(guide))
	    c = '/';
	  else {
	    read_guide_ln(guide);
	    write_line(stdout);
	    read_guide_char(guide, &c);
	  }
	  if (c == '%')
	    not_impl = true;
	  if (c == '&') {
	    write_pch(stdout, " See also:", 10L);
	    read_guide_char(guide, &c);
	    read_guide_char(guide, &c);
	    read_guide_integer(guide, 7L, &i);
	    while (!eoln_guide(guide)) {
	      read_guide_char(guide, &c);
	      write_char(stdout, c);
	    }
	    read_guide_ln(guide);
	    write_line(stdout);
	    read_guide_char(guide, &c);
	  }
	} while (!((c != '!') | eof_guide(guide)));
	if (i > 0) {
	  do {
	    while ((c != '*') & (!eof_guide(guide))) {
	      read_guide_ln(guide);
	      read_guide_char(guide, &c);
	    }
	    if ((c == '*') & (!eof_guide(guide))) {
	      read_guide_char(guide, &c);
	      read_guide_char(guide, &c);
	      read_guide_integer(guide, 7L, &j);
	      while (!eoln_guide(guide)) {
		read_guide_char(guide, &c);
		write_char(stdout, c);
	      }
	      write_line(stdout);
	      read_guide_ln(guide);
	      if (!eof_guide(guide))
		read_guide_char(guide, &c);
	      i--;
	    }
	  } while (!((i == 0) | eof_guide(guide)));
	}
	if (not_impl) {
	  write_pch(stdout, " Not implemented", 16L);
	  write_line(stdout);
	}
      } else {
	write_pch(stdout, " No Help for this command", 25L);
	write_line(stdout);
      }
    }
  }
  if (guide != NULL)
    fclose(guide);
}  /* help */


Static Void no_action(command_file)
FILE *command_file;
{
  t_integer choice, code, table_c;

  write_pch(stdout, " Enter abbreviation and see full command name",
	      45L);
  write_line(stdout);
  write_pch(stdout, " Exit help with end", 19L);
  write_line(stdout);
  do {
    read_command(command_file, &choice, &code, false, " CoCo :   ", 7L, 0L,
		 0L);
    if (choice == 250) {
      write_pch(stdout, " Exit search help with end", 26L);
      write_line(stdout);
      do {
	read_command(command_file, &choice, &code, false, " SEARCH : ", 9L,
		     0L, 0L);
      } while (choice != 0);
    } else if (choice == 114 || choice == 119 || choice == 123)
      read_command(command_file, &table_c, &code, false, " TYPE->   ", 7L,
		   -999L, (long)VALUE_OFFSET);
    else if (choice == 125) {
      read_command(command_file, &table_c, &code, false, " TYPE->   ", 7L,
		   -999L, (long)VALUE_OFFSET);
      read_command(command_file, &table_c, &code, false, " TYPE->   ", 7L,
		   -999L, (long)VALUE_OFFSET);
    } else if (choice == 115) {
      do {
	read_command(command_file, &table_c, &code, false, " TYPE->   ", 7L,
		     -999L, (long)VALUE_OFFSET);
      } while (code != 200);
    }
  } while (choice != 0);   /* no_action */
}


Static Void proc_ma(command_file)
FILE *command_file;
{
  t_integer kode, nr, i;
  t_command_name name;
  Char c;

  read_command(command_file, &nr, &kode, false, " ALIAS->  ", 8L, 0L, 0L);
  for (i = 0; i < COMMAND_LENGTH; i++)
    name[i] = ' ';
  while (eoln_command(command_file)) {
    read_text_ln(command_file);
    if (log_on)
      write_line_text(log_file);
    write_line_diary();
    write_pch(stdout, " NEW->", 6L);
  }
  write_line_diary();
  write_pch(stdout, " NEW->", 6L);
  read_char(command_file, &c);
  while ((c == ' ') & (!eoln_command(command_file)))
    read_char(command_file, &c);
  i = 1;
  while ((c != ';' && i <= COMMAND_LENGTH) & (!eoln_command(command_file))) {
    name[i-1] = c;
    read_char(command_file, &c);
    i++;
  }
  if (eoln_command(command_file))
    name[i-1] = c;
  for (i = 0; i < COMMAND_LENGTH; i++) {
    if (islower(name[i]))
      name[i] -= 32;
  }
  while ((c != ';') & (!eoln_command(command_file)))
    read_char(command_file, &c);
  write_line(stdout);
  make_alias(&nr, &kode, name, 0L);
  note_command_end_pch(stdout, " Alias made", 11L);
}  /* proc_ma */


Static Void proc_mam()
{
  t_integer kode = 0, nr = 0;
  t_integer i;
  t_command_name name;

  for (i = 0; i < COMMAND_LENGTH; i++)
    name[i] = ' ';
  name[0] = 'Z';
  make_alias(&nr, &kode, name, 0L);
  note_command_end_pch(stdout, " Alias made", 11L);
}  /* proc_mam */


Static Void proc_da(command_file)
FILE *command_file;
{
  t_integer i;
  t_command_name name;
  Char c;

  for (i = 0; i < COMMAND_LENGTH; i++)
    name[i] = ' ';
  while (eoln_command(command_file)) {
    read_text_ln(command_file);
    if (log_on)
      write_line_text(log_file);
    write_line_diary();
    write_pch(stdout, " NEW->", 6L);
  }
  write_line_diary();
  write_pch(stdout, " NEW->", 6L);
  read_char(command_file, &c);
  while ((c == ' ') & (!eoln_command(command_file)))
    read_char(command_file, &c);
  i = 1;
  while ((c != ';' && i <= COMMAND_LENGTH) & (!eoln_command(command_file))) {
    name[i-1] = c;
    read_char(command_file, &c);
    i++;
  }
  if (eoln_command(command_file))
    name[i-1] = c;
  for (i = 0; i < COMMAND_LENGTH; i++) {
    if (islower(name[i]))
      name[i] -= 32;
  }
  while ((c != ';') & (!eoln_command(command_file)))
    read_char(command_file, &c);
  write_line(stdout);
  delete_alias(name, 0L);
  note_command_end_pch(stdout, " Alias deleted", 14L);
}  /* proc_da */


Static Void proc_pa(command_file)
FILE *command_file;
{
  t_integer kode, nr;

  read_command(command_file, &nr, &kode, false, " ALIAS->  ", 8L, 0L, 0L);
  print_alias(&nr, 0L);
  note_command_end_pch(stdout, " Alias printed", 14L);
}  /* proc_pa */


Static Void read_command_nr(command_file, offset, kode, promb, w, text_offset,
			    dummy_level)
FILE *command_file;
t_integer *offset, *kode;
Char *promb;
t_integer w, text_offset, dummy_level;
{
  do {
    if ((unsigned long)(*offset) >= 32 || ((1L << (*offset)) & 0x3c) == 0) {
      show_menu(&menu_number);
      write_line(stdout);
    }
    *offset = 0;
    while (eoln_command(command_file)) {
      write_pch(stdout, promb, w);
      if (log_on)
	write_line_text(log_file);
      read_text_ln(command_file);
    }
    read_integer(command_file, promb, w, offset);
  } while ((unsigned long)(*offset) > 256);
  *kode = 0;
  write_line_diary();
  if (!echo)
    return;
  write_pch(stdout, promb, w);
  write_integer(stdout, *offset, 3L);
  write_pch(stdout, command_text[*offset - text_offset], 30L);
  write_line(stdout);
}  /* read_command_nr */


Static Void menu_nr(command_file)
FILE *command_file;
{
  t_integer nr;

  read_integer(command_file, " NUMBER-> ", 9L, &nr);
  if ((unsigned long)nr > NUMBER_OF_MENUS) {
    write_pch(stdout, " No menu with that number", 25L);
    return;
  }
  menu_number = nr;
  write_line_diary();
  show_menu(&menu_number);
}  /* menu_nr */


Static Void next_menu()
{
  if (menu_number < NUMBER_OF_MENUS)
    menu_number++;
  else
    menu_number = 1;
  show_menu(&menu_number);
}  /* next_menu */


Static Void previous_menu()
{
  if (menu_number > 1)
    menu_number--;
  else
    menu_number = NUMBER_OF_MENUS;
  show_menu(&menu_number);
}  /* previous_menu */


/*@-"maindescribe.c"*/
/*@+"maindesc.p"*/


/*

2551:    +++  ++
2552:    +++  ++
2553:    ---  -- p/maindesc.p        17      66     905 p/maindesc.p
2554: |    4:    function ok_prepare_table_values
2555: |  153:    function find_model_offset
2556: |  160:    function simple_value_type
2557: |  168:    procedure dispose_collapsed_model
2558: |  184:    procedure revers_vertex_list_delta
2559: |  204:    procedure print_table_argument
2560: |  340:    procedure fraction_model
2561: |  378:    procedure proc_print_table
2562: |  567:    procedure proc_print_continuous
2563: |  725:    procedure proc_substitute
2564: |  733:    procedure proc_print_sparse_table
2565: |  788:    procedure proc_return_matrix
2566: |  823:    procedure revers_list
2567: | 1002:    procedure plot_argument
2568: | 1078:    procedure proc_plot
2569: | 1142:    procedure list_argument
2570: | 1209:    procedure proc_list
2571:    +++  ++
2572:    +++  ++

*/

Static boolean ok_prepare_table_values(link_old_model, link_new_model, a,
  collaps, a_set_offset, model_set_offset, random_offset, item_list, random)
t_model_list **link_old_model, **link_new_model;
long *a;
boolean *collaps;
t_offset *a_set_offset, *model_set_offset, *random_offset;
boolean item_list, random;
{
  boolean Result = false;
  t_long_real log_l;
  boolean tmp_print_case_list;
  boolean ok = true;
  boolean ok_n, ok_p;
  t_vertex_set b;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  if (mixed_data) {
    /* and
       (link_old_model^.model^.id^.model_type <> pure_discrete) */
    note_mixed(stdout, " PrepareTableValues", 19L);
  }
  /*$ifdef TRACE*/
  memcpy(tzt, " OkPrepareTableValue", sizeof(pch20));
  if (trace_flag_set(20L, 2554L, 1L)) {
    write_pch(stdout, " OkPrepareTableValues:", 22L);
    write_integer(stdout, fpa, 6L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (em && incomplete_table) {
    write_pch(stdout, " Warning: Using EM on Incomplete table!", 39L);
    write_line(stdout);
  }
  if (!large)
    ok = ok_model_fit_values(&(*link_old_model)->model);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2554L, 1L, -1L, -1L, ok);
  /*$endif TRACE*/
  if (ok) {
    *link_new_model = (t_model_list *)Malloc(sizeof(t_model_list));
    if (*link_new_model == NULL)
      _OutMem();
    new_model(&(*link_new_model)->model);
    erase_model(&(*link_new_model)->model, pure_discrete, true);
    *collaps = collaps_model(a, &(*link_old_model)->model,
			     &(*link_new_model)->model);
    if (!*collaps) {
      dispose_model_link(&(*link_new_model)->model);
      _Free(*link_new_model);
      *link_new_model = *link_old_model;
    }
    P_setunion(b, a, (*link_new_model)->model->id->vertices);
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2554L, 1L, -1L, -2L, *collaps);
    /*$endif TRACE*/
    if (ok_miss_model(b, false)) {
      if (em) {
	*model_set_offset = fpa;
	if (!P_setequal(b, a))
	  *a_set_offset = *model_set_offset + marginal_dimension(b);
	else
	  *a_set_offset = *model_set_offset;
	if (!TURBO_PC)
	  ok_p = space_in_p_array(marginal_dimension(a), *a_set_offset);
	ok = (last_index(a) <= max_p_cell_number - *a_set_offset);
	/*$ifdef TRACE*/
	ntr_boolean(tzt, 20L, 2554L, 1L, -1L, -3L, ok);
	/*$endif TRACE*/
	if (ok) {
	  fpa = *a_set_offset + marginal_dimension(a);
	  if (item_list) {
	    tmp_print_case_list = print_case_list;
	    print_case_list = true;
	    find_expected_table(a, *a_set_offset, &(*link_new_model)->model,
				&log_l, false, false);
	    /* Offsets are invalid !!!! */
	    print_case_list = tmp_print_case_list;
	  } else {
	    find_expected_table(b, *model_set_offset,
				&(*link_new_model)->model, &log_l, false,
				false);
	    /* Offsets are invalid !!!! */
	    if (!P_setequal(b, a))
	      find_marginal_expected_table(a, b, *a_set_offset,
					   *model_set_offset);
	  }
	}
      } else {
	if (em)
	  write_warning_em(stdout, 2554L, " PrepareTableValues ");
	/*$ifdef TRACE*/
	ntr_set(tzt, 20L, 2554L, 1L, -2L, -1L, b);
	/*$endif TRACE*/
	P_setint(b, b, delta);
	/*$ifdef TRACE*/
	ntr_set(tzt, 20L, 2554L, 1L, -2L, -2L, b);
	/*$endif TRACE*/
	*model_set_offset = return_offset(b, &ok);
	/*$ifdef TRACE*/
	ntr_boolean(tzt, 20L, 2554L, 1L, -2L, *model_set_offset, ok);
	ntr_set(tzt, 20L, 2554L, 1L, -3L, -4L, a);
	/*$endif TRACE*/
	P_setint(a, a, delta);
	/*$ifdef TRACE*/
	ntr_set(tzt, 20L, 2554L, 1L, -3L, -5L, a);
	/*$endif TRACE*/
	*a_set_offset = return_offset(a, &ok);
	/*$ifdef TRACE*/
	ntr_boolean(tzt, 20L, 2554L, 1L, -3L, *a_set_offset, ok);
	/*$endif TRACE*/
      }
    }
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2554L, 1L, -1L, -4L, ok);
    /*$endif TRACE*/
    if (large && ok) {
      if (!(*link_new_model)->model->found_ps) {
	ok = ok_model_fit_values(&(*link_new_model)->model);
	find_offsets_and_marginals(&(*link_new_model)->model, true, &ok_n,
				   &ok_p);
	(*link_new_model)->model->found_ps = (ok && ok_n && ok_p);
	if ((*link_new_model)->model->found_ps)
	  estimate_model(&(*link_new_model)->model);
      }
      if (!ok)
	write_pch(stdout, " Out of space: Prepare@@@@@@@ ", 22L);
    }
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2554L, 1L, -1L, -5L, ok);
    /*$endif TRACE*/
    if (ok)
      ok = (*link_new_model)->model->found_ps;
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2554L, 1L, -1L, -6L, ok);
    /*$endif TRACE*/
    if (random) {
      if ((*link_new_model)->model->decomposable &&
	  (*link_new_model)->model->graphical) {
	return_random_vector(&(*link_new_model)->model, a, model_set_offset,
			     &ok);
	*random_offset = *model_set_offset;
	fna += marginal_dimension(a);
      } else {
	write_pch(stdout, " Since model not is decomposable", 32L);
	write_pch(stdout, " observed counts are used.", 26L);
	*random_offset = *a_set_offset;
      }
    } else
      *random_offset = *a_set_offset;
    /*$ifdef TRACE*/
    ntr_boolean(tzt, 20L, 2554L, 1L, -1L, *random_offset, ok);
    /*$endif TRACE*/
    if (ok)
      Result = true;
    else {
      write_pch(stdout, " Dispose marginals and try again.", 33L);
      write_line(stdout);
    }
  } else {
    *model_set_offset = -1;
    *a_set_offset = -1;
    *random_offset = -1;
    *collaps = false;
    Result = false;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2554L, 1L)) {
    ntr_boolean(tzt, 20L, 2554L, 1L, -1L, -8L, ok);
    ntr_4(tzt, 20L, 2554L, 1L, fpa, *model_set_offset, *a_set_offset,
	  *random_offset);
	/*ntr*/
  }
  /*$endif TRACE*/
  return Result;
}  /* ok_prepare_table_values */


Static boolean find_model_offset(value_name)
t_integer *value_name;
{
  return (((*value_name) & (MAX_NUMBER_OF_TABLE_VALUES - 1)) < 4 ||
	  ((*value_name) & (MAX_NUMBER_OF_TABLE_VALUES - 1)) == 5 ||
	  ((*value_name) & (MAX_NUMBER_OF_TABLE_VALUES - 1)) == 6);
}  /* find_model_offset */


Static boolean simple_value_type(value_name)
t_integer *value_name;
{
  return (((*value_name) & (MAX_NUMBER_OF_TABLE_VALUES - 1)) == 0 ||
	  ((*value_name) & (MAX_NUMBER_OF_TABLE_VALUES - 1)) == 14 ||
	  ((*value_name) & (MAX_NUMBER_OF_TABLE_VALUES - 1)) == 15 ||
	  *value_name == MAX_NUMBER_OF_TABLE_VALUES * 2 - 1);
}  /* simple_value_type */


Static Void dispose_collapsed_model(link_model)
t_model_list **link_model;
{
  if (!large)
    clear_offsets(&(*link_model)->model, d_ips_node);
  dispose_model_and_link(&(*link_model)->model);
  _Free(*link_model);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2557L, 1L)) {
    write_pch(stdout, " DisposeCollapsedModel:", 23L);
    write_integer(stdout, fpa, 6L);
    write_line(stdout);
  }
  /*$endif TRACE*/
  *link_model = NULL;
}  /* dispose_collapsed_model */


Static Void revers_vertex_list_delta(p)
t_vertex_list **p;
{
  t_vertex_list *hp1 = NULL;
  t_vertex_list *hp2;

  while (*p != NULL) {
    if (P_inset((*p)->vertex, delta)) {
      hp2 = hp1;
      hp1 = *p;
      *p = (*p)->pointer;
      hp1->pointer = hp2;
    } else {
      hp2 = *p;
      *p = (*p)->pointer;
      _Free(hp2);
    }
  }
  *p = hp1;
}  /* revers_vertex_list_delta */


Static Void print_table_argument(do_print_table, do_return_vector,
  do_write_vector, permuted, percent, as_argument, ifail, p, link_model_1,
  value_type, probit, rankit, uniform, log_trans, random, arg_double)
boolean *do_print_table, *do_return_vector, *do_write_vector, *permuted,
	percent, as_argument;
t_integer *ifail;
t_vertex_list **p;
t_model_list *link_model_1;
t_integer value_type;
boolean *probit, *rankit, *uniform, *log_trans, *random;
double **arg_double;
{
  boolean ok = true, collaps = false;
  t_vertex_set a, vertex_set;
  t_offset a_set_offset, model_set_offset, random_offset;
  t_integer tmp_first_p;
  t_model_list *link_model_2;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " PrintTableArgument ", sizeof(pch20));
  ntr(tzt, 20L, 2559L, 1L, -1L, value_type);
  /*$endif TRACE*/
  tmp_first_p = fpa;
  list_of_vertices_to_set(*p, a);
  P_setint(a, a, delta);
  revers_vertex_list_delta(p);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2559L, 1L, -1L, 1L);
  /*$endif TRACE*/
  if (!simple_value_type(&value_type) || em) {
    P_setunion(vertex_set, link_model_1->model->id->vertices, a);
    ok = ok_miss_model(vertex_set, false);
  } else if (exclude_missing && !P_subset(a, delta_missing_excluded))
    ok = ok_miss_model(a, false);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2559L, 1L, -1L, 2L);
  /*$endif TRACE*/
  if (ok) {
    if ((!simple_value_type(&value_type) || em || *random) && !percent) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2559L, 2L, -1L, 1L);
      /*$endif TRACE*/
      if (!large)
	ok = ok_model_fit_values(&link_model_1->model);
      tmp_first_p = fpa;
      ok = ok_prepare_table_values(&link_model_1, &link_model_2, a, &collaps,
				   &a_set_offset, &model_set_offset,
				   &random_offset, false, *random);
      if (*random)
	a_set_offset = random_offset;
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2559L, 2L, -1L, 2L);
      /*$endif TRACE*/
      link_model_2 = link_model_1;
      if (em)
	write_warning_em(stdout, 2559L, " PrintTableArgument!");
      a_set_offset = return_offset(a, &ok);
      if (percent) {
	P_setunion(vertex_set, a, link_model_2->model->id->vertices);
	model_set_offset = return_offset(vertex_set, &ok);
      } else
	model_set_offset = N_START - FIRST_INDEX;
    }
  }
  if (ok) {
    if (*do_return_vector) {
      if (*do_write_vector) {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2559L, 2L, -1L, 0L);
	/*$endif TRACE*/
	print_vector(a, p, &value_type, log_trans, permuted, &a_set_offset,
		     (double)n[0], &model_set_offset, &link_model_2->model);
	note_command_end_pch(stdout, " Vector printed", 15L);
      } else {
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2559L, 2L, -1L, 1L);
	/*$endif TRACE*/
	return_vector(a, p, &value_type, log_trans, permuted, &a_set_offset,
		      (double)n[0], &model_set_offset, &link_model_2->model,
		      arg_double);
	note_command_end_pch(stdout, " Vector computed", 16L);
      }
    } else if (*do_print_table) {
      page(stdout);
      write_line(stdout);
      write_space(stdout, 4L);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2559L, 2L, -1L, 2L);
      /*$endif TRACE*/
      print_table(a, *p, value_type, *log_trans, percent, *permuted,
		  &a_set_offset, (double)n[0], &model_set_offset,
		  &link_model_2->model);
      note_command_end_pch(stdout, " Table printed", 14L);
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2559L, 2L, -1L, 3L);
      /*$endif TRACE*/
      describe_table(a, &value_type, uniform, rankit, probit, log_trans,
		     &a_set_offset, (double)n[0], &model_set_offset,
		     &link_model_2->model);
      note_command_end_pch(stdout, " Table described", 16L);
    }
  }
  if (!ok) {
    if (as_argument) {
      if (mixed_data)
	set_ifail(ifail, 29L);
      else
	set_ifail(ifail, 30L);
    } else if (*do_return_vector)
      write_pch(stdout,
		  " Out of space in 'RETURN VECTOR <value> <set>;'", 47L);
    else if (*do_print_table) {
      write_pch(stdout, " Out of space: Try 'CASE LIST <set>;'", 37L);
      write_line(stdout);
      write_pch(stdout,
		  " instead of 'PRINT TABLE OBSERVED <set>;'.", 42L);
    } else
      write_pch(stdout,
		  " Out of space in 'DESCRIBE TABLE <value> <set>;'", 48L);
  }
  dispose_vertex_list(p);
  if (collaps)
    dispose_collapsed_model(&link_model_2);
  if (*random)
    fna -= marginal_dimension(a);
  fpa = tmp_first_p;
}  /* print_table_argument */


Static Void fraction_model(r, s, model)
t_vertex_list **r, **s;
t_model **model;
{
  t_vertex_set a, b;
  t_set_list *g_c_a = NULL;
  t_formula_node *link_formula_node;
  t_decomposition_element *decomposition_element;
  t_set_list *causal_structure = NULL;
  boolean homogeneous = false;
  t_model *WITH;

  erase_model(model, pure_discrete, true);
  WITH = *model;
  WITH->graphical = true;
  WITH->decomposable = true;
  list_of_vertices_to_set(*r, a);
  P_setint(WITH->id->vertices, a, delta);
  list_of_vertices_to_set(*s, b);
  P_setint(b, b, WITH->id->vertices);
  insert_set_in_set_list(a, &g_c_a);
  if (WITH->id->model_type == mixed)
    homogeneous = WITH->id->UU.U1.homogeneous;
  decompose_model(a, empty_set, b, &g_c_a, &causal_structure, model,
		  WITH->id->causal_structure, homogeneous, pure_discrete);
  decomposition_element = (*model)->formula_node->UU.decomposition_node_;
  insert_in_complete_node(a, &link_formula_node, pure_discrete);
  decomposition_element->left_model->dim = 0;
  decomposition_element->left_model->formula_node = link_formula_node;
  insert_in_complete_node(empty_set, &link_formula_node, pure_discrete);
  decomposition_element->right_model->dim = 0;
  decomposition_element->right_model->formula_node = link_formula_node;
  if (exclude_missing) {
    ok_miss_model(WITH->id->vertices, false);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  }
  P_setdiff(b, delta, WITH->id->vertices);
  WITH->constant = 100 / marginal_dimension_real(b) / n[0];
  WITH->model_number = -1;
  WITH->found_expression = true;
  WITH->found_ps = true;
}  /* fraction_model */


Static Void proc_print_table(command_file, print_table, permuted,
  return_vector, as_argument, ifail, sub_code, arg_pos_char, arg_pos_int,
  arg_pos_double, nargs, arg_char, arg_int, arg_double)
FILE *command_file;
boolean print_table, permuted, return_vector, as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int, arg_pos_double;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
{
  boolean ok, probit, rankit, uniform, complete, from_base, from_current,
	  log_trans, random, local_permuted, do_print_table, do_return_vector;
  boolean do_write_vector = true;
  t_integer i, x, value_type, code;
  t_vertex_list *p = NULL;
  t_vertex_list *q;
  t_vertex_set a, b;
  t_model_list *c;
  Char sep = ' ';
  t_model_list *tmp_link_model;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ProcPrintTable     ", sizeof(pch20));
  ntr(tzt, 20L, 2561L, 1L, -1L, 0L);
  /*$endif TRACE*/
  if (as_argument) {
    do_write_vector = (*sub_code == 0);
    *sub_code = 0;
    i = 0;
    get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_int, nargs, arg_int, " Number-> ", 9L,
		     &value_type);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 1L, -1L, value_type);
    /*$endif TRACE*/
    get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_int, nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 1L, -1L, x);
    /*$endif TRACE*/
    from_base = (x == -1);
    get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_int, nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 2L, 2L, x);
    /*$endif TRACE*/
    random = (x == 1);
    get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_int, nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 2L, 3L, x);
    /*$endif TRACE*/
    log_trans = (x == 1);
    get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_int, nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 2L, 4L, x);
    /*$endif TRACE*/
    complete = (x == 1);
    get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_int, nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 2L, 5L, x);
    /*$endif TRACE*/
    permuted = (x == 1);
    get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_int, nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 2L, 6L, x);
    /*$endif TRACE*/
    uniform = (x == 1);
    get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_int, nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 2L, 7L, x);
    /*$endif TRACE*/
    rankit = (x == 1);
    get_next_integer(command_file, as_argument, &i, ifail, sub_code,
		     arg_pos_int, nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 2L, 8L, x);
    /*$endif TRACE*/
    probit = (x == 1);
  } else if (*sub_code == 0) {
    /*$ifdef TRACE*/
    read_value_type(command_file, " Value->  ", 9L, &value_type, &code,
		    &uniform, &rankit, &probit, &from_base, &from_current,
		    &complete, &log_trans, &random);
    ntr(tzt, 20L, 2561L, 1L, -1L, 3L);
    /*$endif TRACE*/
  } else {
    value_type = (*sub_code) & (MAX_NUMBER_OF_TABLE_VALUES - 1);
    if (value_type == 16)
      value_type = 0;
    uniform = false;
    rankit = false;
    probit = false;
    from_base = false;
    from_current = false;
    complete = false;
    random = false;
    log_trans = false;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 1L, -1L, 4L);
    /*$endif TRACE*/
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2561L, 1L, -1L, 5L);
  /*$endif TRACE*/
  do_print_table = print_table;
  do_return_vector = return_vector;
  local_permuted = permuted;
  i = PCH_START;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2561L, 2L, 10L, value_type);
  /*$endif TRACE*/
  ok = get_vertex_list_sep(command_file, true, true, false, as_argument, &sep,
			   &i, ifail, sub_code, arg_pos_char, nargs, arg_char,
			   &p, &p);
      /* ' Set->@@@@', 6, */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2561L, 1L, -1L, -1L);
  /*$endif TRACE*/
  list_of_vertices_to_set(p, a);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2561L, 1L, -1L, -1L);
  /*$endif TRACE*/
  P_setdiff(b, a, delta);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 2561L, 1L, -1L, 11L, a);
  ntr_set(tzt, 20L, 2561L, 1L, -1L, 12L, b);
  /*$endif TRACE*/
  if ((do_return_vector || do_print_table) && !P_setequal(b, empty_set)) {
    if (value_type == 14 || value_type == 15 || from_base || from_current) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2561L, 2L, 2L, value_type);
      /*$endif TRACE*/
      if (value_type == 0)
	value_type = 2;
      if (value_type == 14)
	value_type = 2;
      if (value_type == 15)
	value_type = 12;
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2561L, 2L, 2L, value_type);
      /*$endif TRACE*/
      tmp_link_model = NULL;
      write_pch(stdout, " Skipping prepare !!", 20L);
      write_line(stdout);
      if (from_base)
	ok = base_ifail(ifail);
      else
	ok = current_ifail(ifail);
      if (ok) {
	if (from_base)
	  tmp_link_model = link_base;
	else
	  tmp_link_model = link_current;
      }
    } else
      tmp_link_model = NULL;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 1L, 1L, 0L);
    /*$endif TRACE*/
    find_and_print_covariance(&tmp_link_model, &value_type, a, p,
      do_return_vector, probit, rankit, local_permuted, ifail, arg_pos_double,
      nargs, arg_double);
    return;
  }
  if (value_type == 0 && sep == '/') {
    q = NULL;
    sep = ' ';
    i++;
    ok = get_vertex_list_sep(command_file, true, true, false, as_argument,
			     &sep, &i, ifail, sub_code, arg_pos_char, nargs,
			     arg_char, &q, &q);
	/* ' Set->@@@@', 6, */
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2561L, 1L, 2L, 0L);
    /*$endif TRACE*/
    if (current() & ok_em()) {
      c = link_current;
      link_current = (t_model_list *)Malloc(sizeof(t_model_list));
      if (link_current == NULL)
	_OutMem();
      new_model(&link_current->model);
      erase_model(&link_current->model, pure_discrete, true);
      link_current->pointer = NULL;
      fraction_model(&p, &q, &link_current->model);
      find_decomposable_offsets_and_marginals(&link_current->model, &ok);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2561L, 1L, 2L, 1L);
      /*$endif TRACE*/
      print_table_argument(&do_print_table, &do_return_vector,
			   &do_write_vector, &local_permuted, true,
			   as_argument, ifail, &p, link_current, 2L, &probit,
			   &rankit, &uniform, &log_trans, &random,
			   arg_double);
      dispose_model_and_link(&link_current->model);
      _Free(link_current);
      link_current = c;
    }
    dispose_vertex_list(&q);
    return;
  }
  if (!simple_value_type(&value_type) || em || random || exclude_missing) {
    if (from_base)
      ok = base_ifail(ifail);
    else
      ok = current_ifail(ifail);
    if (ok) {
      if (from_base)
	tmp_link_model = link_base;
      else
	tmp_link_model = link_current;
    }
  } else
    tmp_link_model = NULL;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2561L, 1L, 3L, 0L);
  /*$endif TRACE*/
  if (ok && do_return_vector && as_argument && !do_write_vector) {
    list_of_vertices_to_set(p, a);
    P_setint(a, a, delta);
    if (!ok_double_arg(ifail, arg_pos_double, marginal_dimension(a), nargs,
		       arg_double)) {
      ok = false;
      set_ifail(ifail, 70L);
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2561L, 1L, 3L, 1L);
  /*$endif TRACE*/
  if (ok)
    print_table_argument(&do_print_table, &do_return_vector, &do_write_vector,
			 &local_permuted, false, as_argument, ifail, &p,
			 tmp_link_model, value_type, &probit, &rankit,
			 &uniform, &log_trans, &random, arg_double);
  else
    dispose_vertex_list(&p);
}  /* proc_print_table */


Static Void proc_print_continuous(command_file, print_table, permuted,
  return_vector, as_argument, ifail, sub_code, arg_pos_char, arg_pos_int,
  arg_pos_double, nargs, arg_char, arg_int, arg_double)
FILE *command_file;
boolean print_table, permuted, return_vector, as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int, arg_pos_double;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
{
  boolean ok;
  boolean collaps = false;
  boolean probit, rankit, uniform, complete, from_base, from_current,
	  log_trans, random, local_permuted, do_print_table, do_return_vector;
  t_integer i, x, value_type, code;
  t_vertex_list *p = NULL;
  t_vertex_set a, b;
  Char sep = ' ';
  t_model_list *tmp_link_model_1 = NULL, *tmp_link_model_2 = NULL;
  t_offset a_set_offset, model_set_offset, random_offset;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ProcPrintContinuous", sizeof(pch20));
  ntr(tzt, 20L, 2562L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if (as_argument) {
    *sub_code = 0;
    i = 0;
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &value_type);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 1L, -1L, value_type);
    /*$endif TRACE*/
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 1L, -1L, x);
    /*$endif TRACE*/
    from_current = false;
    from_base = (x == -1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 2L, 2L, x);
    /*$endif TRACE*/
    random = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 2L, 3L, x);
    /*$endif TRACE*/
    log_trans = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 2L, 4L, x);
    /*$endif TRACE*/
    complete = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 2L, 5L, x);
    /*$endif TRACE*/
    permuted = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 2L, 6L, x);
    /*$endif TRACE*/
    uniform = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 2L, 7L, x);
    /*$endif TRACE*/
    rankit = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 2L, 8L, x);
    /*$endif TRACE*/
    probit = (x == 1);
  } else if (*sub_code == 0) {
    /*$ifdef TRACE*/
    read_value_type(command_file, " Value->  ", 9L, &value_type, &code,
		    &uniform, &rankit, &probit, &from_base, &from_current,
		    &complete, &log_trans, &random);
    ntr(tzt, 20L, 2562L, 1L, -1L, 3L);
    /*$endif TRACE*/
  } else {
    value_type = (*sub_code) & (MAX_NUMBER_OF_TABLE_VALUES - 1);
    if (value_type == 16)
      value_type = 0;
    uniform = false;
    rankit = false;
    probit = false;
    from_base = false;
    from_current = false;
    complete = false;
    random = false;
    log_trans = false;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 1L, -1L, 4L);
    /*$endif TRACE*/
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2562L, 1L, -1L, 5L);
  /*$endif TRACE*/
  do_print_table = print_table;
  do_return_vector = return_vector;
  local_permuted = permuted;
  i = PCH_START;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2562L, 2L, 10L, value_type);
  /*$endif TRACE*/
  ok = get_vertex_list_sep(command_file, true, true, false, as_argument, &sep,
			   &i, ifail, sub_code, arg_pos_char, nargs, arg_char,
			   &p, &p);
      /* ' Set->@@@@', 6, */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2562L, 1L, -1L, -1L);
  /*$endif TRACE*/
  list_of_vertices_to_set(p, a);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2562L, 1L, -1L, -1L);
  /*$endif TRACE*/
  P_setdiff(b, a, delta);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 2562L, 1L, -1L, 11L, a);
  ntr_set(tzt, 20L, 2562L, 1L, -1L, 12L, b);
  /*$endif TRACE*/
  if (!(do_return_vector || do_print_table) || P_setequal(b, empty_set))
    return;
  if (value_type == 14 || value_type == 15 || from_base || from_current) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 2L, 2L, value_type);
    /*$endif TRACE*/
    if (value_type == 0)
      value_type = 2;
    if (value_type == 14)
      value_type = 2;
    if (value_type == 15)
      value_type = 12;
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2562L, 2L, 2L, value_type);
    /*$endif TRACE*/
    tmp_link_model_1 = NULL;
    if (from_base)
      ok = base_ifail(ifail);
    else
      ok = current_ifail(ifail);
    if (ok) {
      if (from_base)
	tmp_link_model_1 = link_base;
      else
	tmp_link_model_1 = link_current;
    }
  } else
    tmp_link_model_1 = NULL;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2562L, 8L, -1L, -1L);
  /*$endif TRACE*/
  /*
  if not do_return_vector then begin
     page(output);
     write_line(output);
     write_space(output, 4)
  end;
  */
  if (tmp_link_model_1 != NULL)
    ok = ok_prepare_table_values(&tmp_link_model_1, &tmp_link_model_2, a,
				 &collaps, &a_set_offset, &model_set_offset,
				 &random_offset, false, random);
  else if (exclude_missing && !P_subset(a, delta_missing_excluded))
    ok = ok_miss_model(a, false);
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2562L, 2L, 3L, -1L, ok);
  /*$endif TRACE*/
  if (ok)
    find_and_print_covariance(&tmp_link_model_2, &value_type, a, p,
      do_return_vector, probit, rankit, local_permuted, ifail, arg_pos_double,
      nargs, arg_double);
  if (collaps)
    dispose_collapsed_model(&tmp_link_model_2);
  if (random)
    fna -= marginal_dimension(a);
}  /* proc_print_continuous */


Static Void proc_substitute()
{
  boolean ok;

  if (current())
    substitute(&link_current->model, &ok);
}  /* proc_substitute */


Static Void proc_print_sparse_table(command_file, as_argument, ifail,
  sub_code, arg_pos_char, arg_pos_int, arg_pos_double, nargs, arg_char,
  arg_int, arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int, arg_pos_double;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
{
  t_long_real dummy;
  t_vertex_set a, b;
  t_vertex_list *p = NULL;
  t_vertex_list *q;
  boolean ok;
  t_integer sub_code_ = 1, i = PCH_START;
  Char sep = ' ';
  t_offset b_offset;

  if (!get_vertex_list_sep(command_file, true, true, false, as_argument, &sep,
			   &i, ifail, &sub_code_, arg_pos_char, nargs,
			   arg_char, &p, &p))
    return;
  /* ' Set->@@@@', 6, */
  list_of_vertices_to_set(p, a);
  revers_vertex_list(&p);
  if (sep == '/') {
    q = NULL;
    sep = ' ';
    i++;
    ok = get_vertex_list_sep(command_file, true, true, false, as_argument,
			     &sep, &i, ifail, &sub_code_, arg_pos_char, nargs,
			     arg_char, &q, &q);
    /* ' Set->@@@@', 6, */
    list_of_vertices_to_set(q, b);
    if (em)
      write_warning_em(stdout, 2564L, " ProcPrintSparseTab.");
    b_offset = return_offset(b, &ok);
    if (ok)
      dummy = find_log_l(a, true, &ok, true, b_offset, b, as_argument, ifail,
			 sub_code, arg_pos_int, arg_pos_double, nargs,
			 arg_int, arg_double);
    else
      write_pch(stdout, " Out of space in 'CASE LIST <set/set>;'", 39L);
    dispose_vertex_list(&q);
  } else
    dummy = find_log_l(a, true, &ok, false, -1L, empty_set, as_argument,
		       ifail, sub_code, arg_pos_int, arg_pos_double, nargs,
		       arg_int, arg_double);
  note_command_end_pch(stdout, " Table printed", 14L);
  dispose_vertex_list(&p);
}  /* proc_print_sparse_table */


typedef struct t_value_type_list {
  t_integer value_type;
  boolean log_t, base, complete, random;
  t_offset model_set_offset, set_offset;
  t_model_list *link_model;
  struct t_value_type_list *pointer;
} t_value_type_list;


Local Void revers_list___(p)
t_value_type_list **p;
{
  t_value_type_list *hp1 = NULL;
  t_value_type_list *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_list */


Static Void proc_return_matrix(command_file, permuted)
FILE *command_file;
boolean permuted;
{
  t_cell cell;
  t_long_real x, n_total;
  t_vertex_set a;
  t_offset current_set_offset, base_set_offset, current_random_offset,
	   base_random_offset, current_offset, base_offset;
  t_integer tmp_first_p, p_value_type, code;
  t_integer i = 0;
  t_integer ii, j;
  t_model_list *link_current_2, *link_base_2;
  boolean find_base_offset = false, find_current_offset = false;
  boolean p_complete, p_log_t, p_base, p_current, p_random, probit, rankit,
	  uniform;
  boolean base = false, current = false, complete = false,
	  base_random = false, current_random = false;
  boolean current_collaps, base_collaps, ok_c, ok_b;
  t_value_type_list *p;
  t_value_type_list *link_value_type = NULL;
  t_vertex_list *pvl;
  long FORLIM;

  if (!current_and_base())
    return;
  if (!ok_miss())
    return;
  do {
    p = (t_value_type_list *)Malloc(sizeof(t_value_type_list));
    if (p == NULL)
      _OutMem();
    p->pointer = link_value_type;
    link_value_type = p;
    i++;
    if (eoln_command(command_file)) {
      write_pch(stdout, " Value nr.", 10L);
      write_integer(stdout, i, 10L);
      write_line(stdout);
    }
    read_value_type(command_file, " Value->  ", 10L, &p_value_type, &code,
		    &uniform, &rankit, &probit, &p_base, &p_current,
		    &p_complete, &p_log_t, &p_random);
    if (p_base)
      find_base_offset |= find_model_offset(&p_value_type);
    else
      find_current_offset |= find_model_offset(&p_value_type);
    p->value_type = p_value_type;
    p->base = p_base;
    p->complete = p_complete;
    p->random = p_random;
    p->log_t = p_log_t;
    p_current = !p->base;
    base = (base || p->base);
    current = (current || p_current);
    base_random = (base_random || p->base && p->random);
    current_random = (current_random || p_current && p->random);
    complete = (complete || p->complete);
  } while (code != 200);
  revers_list___(&link_value_type);
  read_promb_vertex_list(command_file, true, true, false, " SET->", 6L,
			 &pvl);
  list_of_vertices_to_set(pvl, a);
  revers_vertex_list(&pvl);
  write_line_diary();
  if (!large)
    ok_c = ok_model_fit_values(&link_current->model);
  if (base && link_base != link_current)
    ok_b = ok_model(&link_base->model);
  tmp_first_p = fpa;
  ok_c = true;
  if (current)
    ok_c = ok_prepare_table_values(&link_current, &link_current_2, a,
	&current_collaps, &current_set_offset, &current_offset,
	&current_random_offset, false, current_random);
  ok_b = true;
  if (base && link_base != link_current)
    ok_b = ok_prepare_table_values(&link_base, &link_base_2, a, &base_collaps,
				   &base_set_offset, &base_offset,
				   &base_random_offset, false, base_random);
  if (ok_c && ok_b) {
    p = link_value_type;
    while (p != NULL) {
      if (p->base && link_base != link_current) {
	p->link_model = link_base_2;
	if (p->random) {
	  p->set_offset = base_random_offset;
	  p->model_set_offset = base_random_offset;
	} else {
	  p->set_offset = base_set_offset;
	  p->model_set_offset = base_offset;
	}
      } else {
	p->link_model = link_current_2;
	if (p->random) {
	  p->set_offset = current_random_offset;
	  p->model_set_offset = current_random_offset;
	} else {
	  p->set_offset = current_set_offset;
	  p->model_set_offset = current_offset;
	}
      }
      p = p->pointer;
    }
    if (!dump)
      write_line(stdout);
    memcpy(cell, first_cell, sizeof(t_cell));
    n_total = n[0];
    FORLIM = marginal_dimension(a);
    for (i = 1; i <= FORLIM; i++) {
      ii = marginal_hash(a, cell);
      p = link_value_type;
      j = 1;
      while (p != NULL) {
	x = return_table_value(a, p->value_type, &p->set_offset, &n_total, ii,
			       cell, &p->model_set_offset,
			       &p->link_model->model);
	if (p->log_t) {
	  if (!is_infinity_real(x) && 0 < x)
	    x = log_10(x);
	  else
	    x = _INVALID_REAL;
	}
	if (dump) {
	  write_valid_real_text(dump_file, is_invalid_real(x), &x,
				labs(width), decdiff);
	  if (p->pointer == NULL)
	    write_char_text(dump_file, ';');
	  else
	    write_char_text(dump_file, ',');
	} else
	  write_real(stdout, x, width, decdiff);
	if (j % (line_length / labs(width)) == 0) {
	  if (dump)
	    write_line_text(dump_file);
	  else
	    write_line(stdout);
	}
	j++;
	p = p->pointer;
      }
      if (dump)
	write_line_text(dump_file);
      else
	write_line(stdout);
      if (permuted)
	next_marginal_cell_list(pvl, cell);
      else
	next_marginal_cell(a, cell);
    }
    if (dump) {
      write_pch_10_text(dump_file, " ;;", 3L);
      write_line_text(dump_file);
    } else
      write_line(stdout);
    note_command_end_pch(stdout, " Matrix printed", 15L);
  } else
    write_pch(stdout, " Out of space in 'RETURN MATRIX <values> <set>;'",
		48L);
  while (link_value_type != NULL) {
    p = link_value_type->pointer;
    _Free(link_value_type);
    link_value_type = p;
  }
  dispose_vertex_list(&pvl);
  if (base_collaps && ok_b && base && link_base != link_current)
    dispose_collapsed_model(&link_base_2);
  if (current_collaps && ok_c && current)
    dispose_collapsed_model(&link_current_2);
  if (current && current_random)
    fna -= marginal_dimension(a);
  if (base && link_base != link_current && base_random)
    fna -= marginal_dimension(a);
  fpa = tmp_first_p;
}  /* proc_return_matrix */


Static Void plot_argument(a, x_t, y_t, x_base, x_current, x_random, y_base,
			  y_current, y_random, log_x, log_y)
long *a;
t_integer *x_t, *y_t;
boolean *x_base, *x_current, *x_random, *y_base, *y_current, *y_random,
	*log_x, *log_y;
{
  t_offset x_random_offset, y_random_offset, x_set_offset, y_set_offset,
	   x_model_set_offset, y_model_set_offset;
  t_integer tmp_first_p;
  t_model_list *tmp_link_model, *x_model, *y_model;
  boolean x_collaps, y_collaps;
  boolean ok = true;
  boolean ok_x, ok_y;

  if (true)
    ok = current_and_base();
  if (ok & true)
    ok = ok_miss();
  if (!ok)
    return;
  if (*x_base || *y_base)
    ok = ok_model(&link_base->model);
  if (*x_current || *y_current)
    ok = ok_model(&link_current->model);
  tmp_first_p = fpa;
  if (*x_base)
    tmp_link_model = link_base;
  else
    tmp_link_model = link_current;
  ok_x = ok_prepare_table_values(&tmp_link_model, &x_model, a, &x_collaps,
      &x_set_offset, &x_model_set_offset, &x_random_offset, false, *x_random);
  if (*x_random)
    x_set_offset = x_random_offset;
  if ((*x_base && *y_base || !*x_base && !*y_base) &&
      (*x_random && *y_random || !*x_random && !*y_random)) {
    y_model = x_model;
    y_model_set_offset = x_model_set_offset;
    y_set_offset = x_set_offset;
    ok_y = true;
    y_collaps = false;
  } else {
    if (*y_base)
      tmp_link_model = link_base;
    else
      tmp_link_model = link_current;
    ok_y = ok_prepare_table_values(&tmp_link_model, &y_model, a, &y_collaps,
				   &y_set_offset, &y_model_set_offset,
				   &y_random_offset, false, *y_random);
    if (*y_random)
      y_set_offset = y_random_offset;
  }
  ok = (ok_x && ok_y);
  if (ok) {
    plot(a, x_t, y_t, log_x, log_y, &x_set_offset, &y_set_offset,
	 (double)n[0], &x_model_set_offset, &x_model->model,
	 &y_model_set_offset, &y_model->model);
    note_command_end_pch(stdout, " Plot made", 10L);
  } else
    write_pch(stdout, " Out of space in 'PLOT <value> <value> <set>;'",
		46L);
  if (y_collaps && ok_y)
    dispose_collapsed_model(&y_model);
  if (x_collaps && ok_x)
    dispose_collapsed_model(&x_model);
  if (*x_random)
    fna -= marginal_dimension(a);
  if ((*x_base != *y_base || *x_random != *y_random) && *y_random)
    fna -= marginal_dimension(a);
  fpa = tmp_first_p;
}  /* plot_argument */


Static Void proc_plot(command_file, as_argument, ifail, sub_code,
		      arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  boolean x_base, x_current, x_random, y_base, y_current, y_random, complete,
	  probit, rankit, uniform, log_x, log_y;
  t_vertex_set a;
  t_integer x_t, y_t, code, i, x;

  if (as_argument) {
    probit = false;
    rankit = false;
    uniform = false;
    i = 0;
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x_t);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    x_base = (x == -1);
    x_current = !x_base;
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    x_random = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    log_x = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &y_t);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    y_base = (x == -1);
    y_current = !y_base;
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    y_random = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    log_y = (x == 1);
    get_next_integer(command_file, true, &i, ifail, sub_code, arg_pos_int,
		     nargs, arg_int, " Number-> ", 9L, &x);
    complete = (x == 1);
  } else {
    read_value_type(command_file, " X-Value->", 10L, &x_t, &code, &uniform,
		    &rankit, &probit, &x_base, &x_current, &complete, &log_x,
		    &x_random);
    read_value_type(command_file, " Y-Value->", 10L, &y_t, &code, &uniform,
		    &rankit, &probit, &y_base, &y_current, &complete, &log_y,
		    &y_random);
  }
  P_setcpy(a, empty_set);
  i = PCH_START;
  if (get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		     sub_code, arg_pos_char, nargs, arg_char, " SET->",
		     6L, a, a))
    plot_argument(a, &x_t, &y_t, &x_base, &x_current, &x_random, &y_base,
		  &y_current, &y_random, &log_x, &log_y);
}  /* proc_plot */


Static Void list_argument(case_list, permuted, p, marginal_percentages,
			  b_offset, b, as_argument, ifail, sub_code,
			  arg_pos_int, arg_pos_double, nargs, arg_int,
			  arg_double)
boolean *case_list, *permuted;
t_vertex_list **p;
boolean marginal_percentages;
t_offset b_offset;
long *b;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  t_model_list *link_model;
  t_long_real dummy;
  t_offset a_set_offset, model_set_offset, random_offset;
  t_integer tmp_first_p;
  boolean collaps, ok;
  t_vertex_set a;

  list_of_vertices_to_set(*p, a);
  if (*case_list && !em) {
    dummy = find_log_l(a, true, &ok, marginal_percentages, b_offset, b,
		       as_argument, ifail, sub_code, arg_pos_int,
		       arg_pos_double, nargs, arg_int, arg_double);
    return;
  }
  if (!current())
    return;
  if (!ok_miss_model(link_current->model->id->vertices, false))
    return;
  if (*case_list && P_setequal(a, empty_set))
    P_setcpy(a, delta);
  if (!large)
    ok = ok_model_fit_values(&link_current->model);
  tmp_first_p = fpa;
  if (ok_prepare_table_values(&link_current, &link_model, a, &collaps,
			      &a_set_offset, &model_set_offset,
			      &random_offset, *case_list, false)) {
    ok = link_current->model->found_ps;
    if (ok) {
      revers_vertex_list(p);
      if (*case_list) {
	if (!em || marginal_percentages)
	  dummy = find_log_l(a, true, &ok, marginal_percentages, b_offset, b,
			     as_argument, ifail, sub_code, arg_pos_int,
			     arg_pos_double, nargs, arg_int, arg_double);
      } else
	print_list(a, p, permuted, &a_set_offset, (double)n[0],
		   &model_set_offset, &link_model->model);
      note_command_end_pch(stdout, " List printed", 13L);
    } else
      write_pch(stdout, " Out of space in 'LIST <set>;'", 30L);
  } else
    write_pch(stdout, " Out of space in 'LIST <set>;'", 30L);
  if (collaps)
    dispose_collapsed_model(&link_model);
  if (false)
    fna -= marginal_dimension(a);
  fpa = tmp_first_p;
}  /* list_argument */


Static Void proc_list(command_file, case_list, permuted, as_argument, ifail,
		      sub_code, arg_pos_char, arg_pos_int, arg_pos_double,
		      nargs, arg_char, arg_int, arg_double)
FILE *command_file;
boolean case_list, permuted, as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int, arg_pos_double;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
{
  t_vertex_set b;
  t_vertex_list *p = NULL;
  t_vertex_list *q;
  t_integer sub_code_ = 1, i = PCH_START;
  Char sep = ' ';
  boolean local_case_list, local_permuted, ok;
  t_offset b_offset;

  if (!get_vertex_list_sep(command_file, true, true, false, as_argument, &sep,
			   &i, ifail, &sub_code_, arg_pos_char, nargs,
			   arg_char, &p, &p))
	/* ' Set->@@@@', 6, */
	  return;
  local_permuted = permuted;
  local_case_list = case_list;
  if (sep == '/') {
    q = NULL;
    sep = ' ';
    i++;
    ok = get_vertex_list_sep(command_file, true, true, false, as_argument,
			     &sep, &i, ifail, &sub_code_, arg_pos_char, nargs,
			     arg_char, &q, &q);
    /* ' Set->@@@@', 6, */
    list_of_vertices_to_set(q, b);
    if (em)
      write_warning_em(stdout, 2570L, " PrintList          ");
    b_offset = return_offset(b, &ok);
    if (ok)
      list_argument(&local_case_list, &local_permuted, &p, true, b_offset, b,
		    as_argument, ifail, sub_code, arg_pos_int, arg_pos_double,
		    nargs, arg_int, arg_double);
    else
      write_pch(stdout, " Out of space in 'CASE LIST <set/set>;'", 39L);
    dispose_vertex_list(&q);
  } else
    list_argument(&local_case_list, &local_permuted, &p, false, -1L,
		  empty_set, as_argument, ifail, sub_code, arg_pos_int,
		  arg_pos_double, nargs, arg_int, arg_double);
  dispose_vertex_list(&p);
}  /* proc_list */


/*@-"mainmodel.c"*/
/*@+"mainmdl1.p"*/

/*

2573:    +++  ++
2574:    +++  ++
2575:    ---  -- p/mainmdl1.p        13      51     664 p/mainmdl1.p
2576: |    4:    procedure proc_base
2577: |   10:    procedure proc_current
2578: |   16:    procedure proc_make_base
2579: |   91:    procedure proc_make_current
2580: |  177:    procedure get_discrete_model
2581: |  177:    procedure get_continuous_model
2582: |  273:    function seek_heterogeneous
2583: |  297:    procedure get_mixed_model
2584: |  404:    procedure proc_get_model
2585: |  435:    procedure proc_set_base_model
2586: |  473:    procedure read_n_interaction_argument
2587: |  480:    procedure find_d
2588: |  514:    procedure proc_read_n_interactions
2589:    +++  ++
2590:    +++  ++

*/

Static Void proc_base()
{
  link_base = link_current;
  note_command_end_pch(stdout, " Base pointer moved to Current", 30L);
}  /* proc_base */


Static Void proc_current()
{
  link_current = link_model_list;
  note_command_end_pch(stdout, " Current pointer moved to Last", 30L);
}  /* proc_current */


Static Void proc_make_base(command_file, as_argument, ifail, sub_code,
			   arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  boolean set_both = false;
  boolean b;
  t_integer nr;
  t_model_list *p;

  if (*sub_code < 0 && as_argument) {
    nr = 0;
    sub_code_to_model(ifail, sub_code, &p);
    if (p != NULL)
      nr = p->model->model_number;
    *sub_code = -1;
  } else {
    if (neg_pos_flag_set(sub_code, 2L))
      set_both = true;
  }
  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " Number-> ", 9L, &nr);
  if (*ifail != 0 || *sub_code < 0)
    return;
  if (*sub_code > 0 && nr == 0) {
    nr = *sub_code;   /* where used ?!? */
    *sub_code = 0;
  }
  if (nr < 1) {
    switch (nr) {

    case -1:
      /* blank case */
      break;

    case -2:
      link_base = link_current;
      break;

    case -3:
      link_base = link_model_list;
      break;

    case -4:
      if (link_base != NULL)
	link_base = link_base->pointer;
      break;

    case -5:
      if (link_base != NULL) {
	nr = link_base->model->model_number;
	link_base = link_model_list;
	b = false;
	while (link_base->pointer != NULL && !b) {
	  if (link_base->pointer->model->model_number == nr)
	    b = true;
	  else
	    link_base = link_base->pointer;
	}
      }
      break;
    }
  } else {
    link_base = link_model_list;
    b = true;
    while (link_base != NULL && b) {
      if (link_base->model->model_number == nr)
	b = false;
      else
	link_base = link_base->pointer;
    }
  }
  if (set_both)
    link_current = link_base;
  if (link_base != NULL) {
    note_command_end_pch(stdout, " Shift to test against model", 28L);
    return;
  }
  if (*sub_code == 0) {
    write_pch(stdout, " Model not found", 16L);
    set_ifail(ifail, 20L);
  } else
    *sub_code = -1;
  nr = 0;
  if (link_base != NULL)
    nr = link_base->model->model_number;

  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " Number-> ", 9L, &nr);
}  /* proc_make_base */


Static Void proc_make_current(command_file, as_argument, ifail, sub_code,
			      arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  boolean set_both = false;
  boolean b;
  t_integer nr;
  t_model_list *p;

  /*

          |  long |sub_code |
   make   | +/- n |    0(1) |
   return |     0 | (+/) -m |

   long \ sub_code |     -m |    0 |    1 |     m |
                -n |        | make | make |       |
                 0 | return |    0 | - | [make m] |
                 n |        | make | make |       |

   */
  if (*sub_code < 0 && as_argument) {
    nr = 0;
    sub_code_to_model(ifail, sub_code, &p);
    if (p != NULL)
      nr = p->model->model_number;
    *sub_code = -1;
  } else {
    if (neg_pos_flag_set(sub_code, 2L))
      set_both = true;
  }
  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " Number-> ", 9L, &nr);
  if (*ifail != 0 || *sub_code < 0)
    return;
  if (*sub_code > 0 && nr == 0) {
    nr = *sub_code;   /* where used ?!? */
    *sub_code = 0;
  }
  if (nr < 1) {
    switch (nr) {

    case -1:
      link_current = link_base;
      break;

    case -2:
      /* blank case */
      break;

    case -3:
      link_current = link_model_list;
      break;

    case -4:
      if (link_current != NULL)
	link_current = link_current->pointer;
      break;

    case -5:
      if (link_current != NULL) {
	nr = link_current->model->model_number;
	link_current = link_model_list;
	b = false;
	while (link_current->pointer != NULL && !b) {
	  if (link_current->pointer->model->model_number == nr)
	    b = true;
	  else
	    link_current = link_current->pointer;
	}
      }
      break;
    }
  } else {
    link_current = link_model_list;
    b = true;
    while (link_current != NULL && b) {
      if (link_current->model->model_number == nr)
	b = false;
      else
	link_current = link_current->pointer;
    }
  }
  if (set_both)
    link_base = link_current;
  if (link_current != NULL) {
    note_command_end_pch(stdout, " Current pointer moved", 22L);
    return;
  }
  if (*sub_code == 0) {
    write_pch(stdout, " Model not found", 16L);
    set_ifail(ifail, 20L);
  } else
    *sub_code = -1;
  nr = 0;
  if (link_current != NULL)
    nr = link_current->model->model_number;
  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " Number-> ", 9L, &nr);
}  /* proc_make_current */


Static Void get_discrete_model(command_file, as_argument, ifail, sub_code,
			       arg_pos, nargs, arg_char, q)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
t_model_list **q;
{
  t_integer i = PCH_START;
  t_integer tmp;
  t_set_list *causal_structure = NULL;
  t_set_list *p;
  boolean ok;
  boolean options = false, eoc = false;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GetDiscreteModel   ", sizeof(pch20));
  /*$endif TRACE*/
  if (*sub_code < 0 && *q != NULL) {
    if ((*q)->model->id->model_type == pure_discrete) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2580L, 1L, -1L, *sub_code);
      /*$endif TRACE*/
      switch (*sub_code) {

      case -1:
	p = (*q)->model->id->UU.g_c_log_linear;
	break;

      case -2:
	p = NULL;
	break;

      case -3:
	p = (*q)->model->id->UU.g_c_log_linear;
	break;
      }
      if (-4 < *sub_code && *sub_code < -1)
	causal_structure = (*q)->model->id->causal_structure;
      else
	causal_structure = NULL;
      *sub_code = -1;
    } else
      set_ifail(ifail, 28L);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2580L, 2L, i, *ifail);
  /*$endif TRACE*/
  if (as_argument)
    tmp = (*nargs)[arg_pos];
  ok = sub_get_gc(command_file, true, true, false, as_argument, &i, ifail,
		  sub_code, arg_pos, nargs, arg_char, &p, &p, &eoc);
  /* ' GC->@@@@@', 5, */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2580L, 3L, i, *ifail);
  /*$endif TRACE*/
  if (causal_structure != NULL && *sub_code == -1 && as_argument) {
    (*nargs)[arg_pos] = tmp;   /* Undo StringEnd !!! */
    if (p == NULL)
      i = PCH_START;   /* subCode was -2 */
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2580L, 4L, i, *ifail);
  /*$endif TRACE*/
  if (ok && !eoc && !options || causal_structure != NULL && *sub_code == -1) {
    ok = get_ordered_gc(command_file, true, true, false, as_argument, &i,
			ifail, sub_code, arg_pos, nargs, arg_char, &options,
			&causal_structure, &causal_structure);
    /* ' GC->@@@@@', 5, */
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2580L, 5L, i, *ifail);
  /*$endif TRACE*/
  if (*ifail != 0 && causal_structure != NULL && *sub_code == -1 &&
      as_argument)
    (*nargs)[arg_pos] += 10;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2580L, 6L, i, *ifail);
  if (as_argument)
    ntr(tzt, 20L, 2580L, 7L, i, (*nargs)[arg_pos]);
  /*$endif TRACE*/
  if (!(ok && *sub_code >= 0)) {
    first_model_available++;
    return;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2580L, 1L)) {
    write_char(stdout, '(');
    print_g_c(causal_structure, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, ')');
  }
  /*$endif TRACE*/
  if (causal_structure == NULL) {
    /* write_pch(output, ' (Causal structure@@', 18);
       write_pch(output, ' empty)@@@', 7);
       write_line(output); */
    insert_set_in_set_list(empty_set, &causal_structure);
  }
  insert_g_c_in_new_discrete_model(&p, &causal_structure);
  dispose_set_list(&causal_structure);
  link_current = link_model_list;
  *q = link_model_list;
  if (link_base == NULL)
    link_base = link_current;
  if (echo)
    write_model(&link_current->model, false);
  note_command_end_pch(stdout, " Model read", 11L);
}  /* get_discrete_model */


Static Void get_continuous_model(command_file, as_argument, ifail, sub_code,
				 arg_pos, nargs, arg_char, q)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
t_model_list **q;
{
  t_integer i = PCH_START;
  t_integer tmp;
  t_set_list *causal_structure = NULL;
  t_set_list *p;
  boolean ok;
  boolean options = false, eoc = false;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GetContinuousModel ", sizeof(pch20));
  /*$endif TRACE*/
  if (*sub_code < 0 && *q != NULL) {
    if ((*q)->model->id->model_type == pure_continuous) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2581L, 1L, -1L, *sub_code);
      /*$endif TRACE*/
      switch (*sub_code) {

      case -1:
	p = (*q)->model->id->UU.g_c_covariance;
	break;

      case -2:
	p = NULL;
	break;

      case -3:
	p = (*q)->model->id->UU.g_c_covariance;
	break;
      }
      if (-4 < *sub_code && *sub_code < -1)
	causal_structure = (*q)->model->id->causal_structure;
      else
	causal_structure = NULL;
      *sub_code = -1;
    } else
      set_ifail(ifail, 28L);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2581L, 2L, i, *ifail);
  /*$endif TRACE*/
  if (as_argument)
    tmp = (*nargs)[arg_pos];
  ok = sub_get_gc(command_file, true, true, false, as_argument, &i, ifail,
		  sub_code, arg_pos, nargs, arg_char, &p, &p, &eoc);
  /* ' GC->@@@@@', 5, */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2581L, 3L, i, *ifail);
  /*$endif TRACE*/
  if (causal_structure != NULL && *sub_code == -1 && as_argument) {
    (*nargs)[arg_pos] = tmp;   /* Undo StringEnd !!! */
    if (p == NULL)
      i = PCH_START;   /* subCode was -2 */
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2581L, 4L, i, *ifail);
  /*$endif TRACE*/
  if (ok && !eoc && !options || causal_structure != NULL && *sub_code == -1) {
    ok = get_ordered_gc(command_file, true, true, false, as_argument, &i,
			ifail, sub_code, arg_pos, nargs, arg_char, &options,
			&causal_structure, &causal_structure);
    /* ' GC->@@@@@', 5, */
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2581L, 5L, i, *ifail);
  /*$endif TRACE*/
  if (*ifail != 0 && causal_structure != NULL && *sub_code == -1 &&
      as_argument)
    (*nargs)[arg_pos] += 10;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2581L, 6L, i, *ifail);
  if (as_argument)
    ntr(tzt, 20L, 2581L, 7L, i, (*nargs)[arg_pos]);
  /*$endif TRACE*/
  if (!(ok && *sub_code >= 0)) {
    first_model_available++;
    return;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2581L, 1L)) {
    write_char(stdout, '(');
    print_g_c(causal_structure, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, ')');
  }
  /*$endif TRACE*/
  if (causal_structure == NULL) {
    /* write_pch(output, ' (Causal structure@@', 18);
       write_pch(output, ' empty)@@@', 7);
       write_line(output); */
    insert_set_in_set_list(empty_set, &causal_structure);
  }
  insert_g_c_in_new_continuous_model(&p, &causal_structure);
  dispose_set_list(&causal_structure);
  link_current = link_model_list;
  *q = link_model_list;
  if (link_base == NULL)
    link_base = link_current;
  if (echo)
    write_model(&link_current->model, false);
  note_command_end_pch(stdout, " Model read", 11L);
}  /* get_continuous_model */


Static boolean seek_heterogeneous(fil, command_, keyboard, promb, w)
FILE *fil;
boolean command_, keyboard;
Char *promb;
t_integer w;
{
  boolean Result;
  Char c;

  Result = false;
  seek_non_blank(fil, command_, keyboard, promb, w, &c);
  if (c != 'h' && c != 'H')
    return Result;
  read_character(fil, command_, keyboard, &c);
  if (c == 'e' || c == 'E') {
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    seek_word(fil, command_, keyboard, "heterogeneous", 3L, 13L, 0L,
	      true);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
    return true;
  }
  if (c == 'o' || c == 'O') {
    Result = false;
    seek_word(fil, command_, keyboard, "homogeneous", 3L, 11L, 0L,
	      true);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  }
  return Result;
}  /* seek_heterogene */


Static Void get_mixed_model(command_file, as_argument, ifail, sub_code,
			    arg_pos, nargs, arg_char, q)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
t_model_list **q;
{
  t_integer i = PCH_START;
  t_integer tmp;
  t_g_c_list *p, *pp;
  t_set_list *causal_structure = NULL;
  boolean eoc = false;
  boolean ok;
  boolean options = false;
  boolean heterogene;
  t_set_list *r;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " GetMixedModel      ", sizeof(pch20));
  /*$endif TRACE*/
  if (*sub_code < 0 && *q != NULL) {
    if ((*q)->model->id->model_type == mixed) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2583L, 1L, -1L, *sub_code);
      /*$endif TRACE*/
      switch (*sub_code) {

      case -1:
	r = return_g_c_copy(&(*q)->model);
	break;

      /* Dispose ? */
      case -2:
	r = NULL;
	break;

      case -3:
	r = return_g_c_copy(&(*q)->model);
	break;

      /* Dispose ? */
      case -4:
	r = (*q)->model->id->UU.U1.g_c_discrete;
	break;

      case -5:
	r = (*q)->model->id->UU.U1.g_c_linear;
	break;

      case -6:
	r = (*q)->model->id->UU.U1.g_c_quadratic;
	break;
      }
      p = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
      if (p == NULL)
	_OutMem();
      p->pointer = NULL;
      p->g_c = r;
      if (-4 < *sub_code && *sub_code < -1)
	causal_structure = (*q)->model->id->causal_structure;
      else
	causal_structure = NULL;
      *sub_code = -1;
    } else
      set_ifail(ifail, 29L);
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2583L, 2L, i, *ifail);
  /*$endif TRACE*/
  if (as_argument)
    tmp = (*nargs)[arg_pos];
  ok = sub_get_gc_list(command_file, true, true, false, false, as_argument,
		       &i, ifail, sub_code, arg_pos, nargs, arg_char, &p, &p,
		       &eoc, &options);
  /* ' GC->@@@@@', 5, */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2583L, 3L, i, *ifail);
  /*$endif TRACE*/
  if (causal_structure != NULL && *sub_code == -1 && as_argument) {
    (*nargs)[arg_pos] = tmp;   /* Undo StringEnd !!! */
    if (r == NULL)
      i = PCH_START;   /* subCode was -2 */
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2583L, 4L, i, *ifail);
  /*$endif TRACE*/
  if (ok && !eoc && !options || causal_structure != NULL && *sub_code == -1) {
    ok = get_ordered_gc(command_file, true, true, false, as_argument, &i,
			ifail, sub_code, arg_pos, nargs, arg_char, &options,
			&causal_structure, &causal_structure);
    /* ' GC->@@@@@', 5, */
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2583L, 5L, i, *ifail);
  /*$endif TRACE*/
  if (*ifail != 0 && causal_structure != NULL && *sub_code == -1 &&
      as_argument)
    (*nargs)[arg_pos] += 10;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2583L, 1L, i, *ifail);
  if (as_argument)
    ntr(tzt, 20L, 2583L, 6L, i, (*nargs)[arg_pos]);
  /*$endif TRACE*/
  if (*sub_code == 3 || *sub_code == 4) {
    options = true;
    heterogene = (*sub_code == 4);
  } else {
    if (ok && options && !eoc && !as_argument)
      heterogene = seek_heterogeneous(command_file, true, true, " H.->",
				      5L);
  }
  if (!(ok && *sub_code >= 0)) {
    first_model_available++;   /* ? */
    return;
  }
  /*$ifdef TRACE*/
  ntr_g_c(tzt, 20L, 2583L, 1L, 1L, *ifail, &causal_structure);
  /*$endif TRACE*/
  revers_g_c_list(&p);
  if (causal_structure == NULL) {
    /* write_pch(output, ' (Causal structure@@', 18);
       write_pch(output, ' empty)@@@', 7);
       write_line(output); */
    insert_set_in_set_list(empty_set, &causal_structure);
  }
  insert_g_c_list_in_new_model(&p, &causal_structure, options, heterogene);
  /* dispose_g_c_list(p); */
  while (p != NULL) {
    /* dispose_set_list(p^.g_c); */
    pp = p->pointer;
    _Free(p);
    p = pp;
  }
  dispose_set_list(&causal_structure);
  link_current = link_model_list;
  *q = link_model_list;
  if (link_base == NULL)
    link_base = link_current;
  if (echo)
    write_model(&link_current->model, false);
  note_command_end_pch(stdout, " Model read", 11L);
}  /* get_mixed_model */


Static Void proc_get_model(command_file, as_argument, ifail, sub_code,
			   arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_model_list *q = NULL;
  t_integer model_code;
  t_model_type model_type = pure_discrete;

  /*2003-10-23: sub_code < -10 ? */
  if (*sub_code < 0) {
    model_code = *sub_code % 10;
    sub_code_to_model(ifail, &model_code, &q);
    if (q != NULL)
      *sub_code /= 10;
    else
      set_ifail(ifail, 20L);
  }
  if (mixed_data) {
    model_type = mixed;
    if (*sub_code < 0 && q != NULL)
      model_type = q->model->id->model_type;
  }
  if (model_type == mixed) {
    get_mixed_model(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_char, &q);
    return;
  }
  if (model_type == pure_continuous)
    get_continuous_model(command_file, as_argument, ifail, sub_code, arg_pos,
			 nargs, arg_char, &q);
  else if (model_type == pure_discrete)
    get_discrete_model(command_file, as_argument, ifail, sub_code, arg_pos,
		       nargs, arg_char, &q);
}  /* proc_get_model */


Static Void proc_set_base_model(command_file, as_argument, ifail, sub_code,
				arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_model_list *q = NULL;
  boolean mixed_model;
  t_set_list *gc;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReadBaseModel      ", sizeof(pch20));
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2585L, 1L, -1L, 1L);
  /*$endif TRACE*/
  if (mixed_data)
    note_mixed(stdout, " ReadBaseModel      ", 20L);
  if (*sub_code < 0)
    q = link_eh_pack->link_base;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2585L, 2L, -1L, 2L);
  /*$endif TRACE*/
  mixed_model = mixed_data;
  if (mixed_data && *sub_code < 0 && q != NULL)
    mixed_model = (q->model->id->model_type == mixed);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2585L, 3L, -1L, 3L);
  /*$endif TRACE*/
  if (mixed_model)
    get_mixed_model(command_file, as_argument, ifail, sub_code, arg_pos,
		    nargs, arg_char, &q);
  else
    get_discrete_model(command_file, as_argument, ifail, sub_code, arg_pos,
		       nargs, arg_char, &q);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2585L, 4L, -1L, 4L);
  /*$endif TRACE*/
  if (*sub_code == -1)
    return;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2585L, 5L, -1L, 1L);
  /*$endif TRACE*/
  gc = return_g_c_copy(&q->model);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2585L, 6L, -1L, 2L);
  /*$endif TRACE*/
  insert_base_model(&gc, &q->model->id->causal_structure,
		    &q->model->id->UU.U1.homogeneous);
}  /* proc_set_base_model */


/* Local variables for read_n_interaction_argument: */
struct LOC_read_n_interaction_argument {
  long *a;
  t_set_list *p;
} ;

Local Void find_d___(v1, v2, d, LINK)
t_vertex v1, v2;
long *d;
struct LOC_read_n_interaction_argument *LINK;
{
  t_vertex v;
  t_vertex_set b;

  if (v2 == last_vertex) {
    for (v = v1; v <= v2; v++) {
      P_setcpy(b, d);
      P_addset(b, v);
      if (P_subset(b, LINK->a))
	insert_set_in_set_list(b, &LINK->p);
    }
    return;
  }
  for (v = v1; v <= v2; v++) {
    P_setcpy(b, d);
    P_addset(b, v);
    find_d___(v + 1, v2 + 1, b, LINK);
  }
}  /* find_d */


Static Void read_n_interaction_argument(a_, n_int)
long *a_;
t_integer *n_int;
{
  struct LOC_read_n_interaction_argument Local_Var;
  t_vertex v;
  t_integer i;
  t_set_list *tmp_cs;

  Local_Var.a = a_;
  tmp_cs = causal_structure;   /* CausalStructure !!! */
  v = last_vertex;
  for (i = *n_int; i >= 1; i--)
    v--;
  Local_Var.p = NULL;
  find_d___(first_vertex, v, empty_set, &Local_Var);   /* full_specified: */
  /* homogeneous: */
  insert_g_c_in_new_model(&Local_Var.p, Local_Var.a, &tmp_cs, false, false);
  link_current = link_model_list;
  if (link_base == NULL)
    link_base = link_current;
  write_model(&link_current->model, false);
}  /* read_n_interaction_argument */


Static Void proc_read_n_interactions(command_file, as_argument, ifail,
  sub_code, arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_integer n_int, i = PCH_START;
  t_vertex_set a;

  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos_int,
		  nargs, arg_int, " Order->", 8L, &n_int);
  P_setcpy(a, empty_set);
  if (get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		     sub_code, arg_pos_char, nargs, arg_char, " SET->",
		     6L, a, a)) {
    read_n_interaction_argument(a, &n_int);
    note_command_end_pch(stdout, " Model read", 11L);
  }
}  /* proc_read_n_interactions */


/*@+"mainmdl2.p"*/


/*

2591:    +++  ++
2592:    +++  ++
2593:    ---  -- p/mainmdl2.p        30      95    1507 p/mainmdl2.p
2594: |    4:    procedure show_tests
2595: |   49:    procedure sub_find_model
2596: |   63:    procedure sub_print_model
2597: |   90:    procedure proc_print_base
2598: |   97:    procedure proc_print_last
2599: |  103:    procedure proc_print_current
2600: |  105:    procedure print_true_false
2601: |  147:    procedure proc_print_all
2602: |  159:    - procedure proc_print_internal_models
2603: |  170:    procedure proc_print_internal_models
2604: |  182:    procedure proc_print_model
2605: |  204:    procedure proc_print_models
2606: |  230:    procedure proc_print_form
2607: |  255:    procedure proc_print_order
2608: |  263:    procedure proc_print_common
2609: |  278:    procedure sub_dispose_model
2610: |  299:    procedure proc_dispose_of_base
2611: |  307:    procedure proc_dispose_of_current
2612: |  315:    procedure proc_dispose_of_last
2613: |  323:    procedure proc_dispose_of_model
2614: |  345:    procedure proc_dispose_of_models
2615: |  376:    procedure proc_dispose_of_all
2616: |  382:    procedure proc_dispose_of_form
2617: |  393:    procedure proc_dispose_of_marginals
2618: |  399:    procedure proc_dispose_of_all_q
2619: |  410:    procedure remove_set
2620: |  440:    procedure remove_offset
2621: |  446:    procedure move_down
2622: |  494:    procedure dispose_of_q_table_argument
2623: |  500:    procedure proc_dispose_of_q_table
2624:    +++  ++
2625:    +++  ++

*/


Static Void show_tests()
{
  t_test_list *p;
  t_vertex_set g;
  t_set_list *tmp_g_c;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_true();
  local_write_options->write_models = !global_write_options->line_form;
  local_test_labels = new_test_labels_empty();
  if (local_write_options->write_models)   /* 0, -1, */
    write_test_head(stdout, "          ", 6L, 0L, " Models ", 8L,
		    local_write_options, local_test_labels);
  else
    write_test_head(stdout, "          ", 6L, 0L, " GC Edges", 9L,
		    local_write_options, local_test_labels);
  p = link_test_list;
  while (p != NULL) {
    if (local_write_options->line_form)
      write_pch(stdout, "       ", 7L);
    if (exclude_missing && partitioning_output) {
      P_setcpy(g, empty_set);
      add_union_of_id(&p->test.id_1, g);
      add_union_of_id(&p->test.id_2, g);
      print_n_total_exclude(g, &local_write_options, &local_test_labels,
			    p->test.n_count);
    }
    write_test(&p->test, &local_write_options, &local_test_labels);
    if (!local_write_options->write_models) {
      g_c_minus_id(&tmp_g_c, p->test.id_2, p->test.id_1);
      print_g_c(tmp_g_c, 16L, line_length);
      dispose_set_list(&tmp_g_c);
      write_char(stdout, ' ');
      edge_minus_id(&tmp_g_c, p->test.id_2, p->test.id_1);
      print_g_c(tmp_g_c, 16L, line_length);
      dispose_set_list(&tmp_g_c);
      write_line(stdout);
    }
    p = p->pointer;
  }
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* show_tests */


Static Void sub_find_model(number, link_model)
t_integer *number;
t_model_list **link_model;
{
  boolean b = true;

  *link_model = link_model_list;
  while (*link_model != NULL && b) {
    if ((*link_model)->model->model_number == *number)
      b = false;
    else
      *link_model = (*link_model)->pointer;
  }
}  /* sub_find_model */


Static Void sub_print_model(mark_model, print_model, number, link_model)
boolean mark_model, print_model;
t_integer number;
t_model_list **link_model;
{
  if (*link_model == NULL)
    return;
  if (true) {
    write_pch(stdout, " Model no. ", 11L);
    write_integer(stdout, (*link_model)->model->model_number, 4L);
    if (number != -1) {
      write_char(stdout, '/');
      write_integer(stdout, number, 4L);
    }
    write_char(stdout, ' ');
    print_model_g_c(&(*link_model)->model, 16L);
  }
  if (mark_model) {
    if (*link_model == link_base)
      write_pch(stdout, " /BASE/   ", 10L);
    if (*link_model == link_current)
      write_pch(stdout, " /CURRENT/", 10L);
  }
  write_line(stdout);
  if (!print_model)
    write_model(&(*link_model)->model, false);
}  /* sub_print_model */


Static Void proc_print_base(print_model)
boolean print_model;
{
  if (base())
    sub_print_model(false, print_model, -1L, &link_base);
  note_command_end_pch(stdout, " Base printed", 13L);
}  /* proc_print_base */


Static Void proc_print_last(print_model)
boolean print_model;
{
  sub_print_model(false, print_model, -1L, &link_model_list);
  note_command_end_pch(stdout, " Last printed", 13L);
}  /* proc_print_last */


Local Void print_true_false(on)
boolean on;
{
  if (on)
    write_pch(stdout, " True  ", 7L);
  else
    write_pch(stdout, " False ", 7L);
}  /* print_true_false */


Static Void proc_print_current(print_model)
boolean print_model;
{
  if (current()) {
    if (print_model)
      sub_print_model(false, print_model, -1L, &link_current);
    else {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2599L, 1L)) {
	write_pch_r(stdout, " Graphical", 10L, 20L);
	print_true_false(link_current->model->graphical);
	write_line(stdout);
	write_pch_r(stdout, " Decomposable", 13L, 20L);
	print_true_false(link_current->model->decomposable);
	write_line(stdout);
	write_pch_r(stdout, " Fund Log(L)", 12L, 20L);
	print_true_false(link_current->model->found_log_l);
	write_line(stdout);
	write_pch_r(stdout, " Fund expression", 16L, 20L);
	print_true_false(link_current->model->found_expression);
	write_line(stdout);
	write_pch_r(stdout, " Fund probabilities", 19L, 20L);
	print_true_false(link_current->model->found_ps);
	write_line(stdout);
	write_pch_r(stdout, " Model set", 10L, 20L);
	print_vertex_set(link_current->model->id->vertices);
	write_line(stdout);
	write_line(stdout);
      }
      /*$endif TRACE*/
      describe_model(&link_current->model, false, false);
    }
  }
  note_command_end_pch(stdout, " Current printed", 16L);
}  /* proc_print_current */


Static Void proc_print_all(print_model)
boolean print_model;
{
  t_model_list *link_model;

  link_model = link_model_list;
  while (link_model != NULL) {
    sub_print_model(true, print_model, -1L, &link_model);
    link_model = link_model->pointer;
  }
  note_command_end_pch(stdout, " All models printed", 19L);
}  /* proc_print_all */


/* procedure proc_print_internal_models(print_model : boolean);
var
   link_model : t_link_model_list;
begin
   link_model := internal_model_list;
   while link_model <> nil do begin
      sub_print_model(true, print_model, -1, link_model);
      link_model := link_model^.pointer
   end
end; */
/* proc_print_internal_models */

Static Void proc_print_internal_models(print_model)
boolean print_model;
{
  t_list_of_model_lists *link_list_of_model;

  link_list_of_model = internal_model_list;
  while (link_list_of_model != NULL) {
    sub_print_model(true, print_model, link_list_of_model->model_number,
		    &link_list_of_model->model_list);
    link_list_of_model = link_list_of_model->pointer;
  }
}  /* proc_print_internal_models */


Static Void proc_print_model(command_file, print_model, as_argument, ifail,
			     sub_code, arg_pos, nargs, arg_int)
FILE *command_file;
boolean print_model, as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_model_list *link_model;
  t_integer nr;

  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " Number->", 9L, &nr);
  write_line_diary();
  sub_find_model(&nr, &link_model);
  if (link_model == NULL)
    write_pch(stdout, " Model not found", 16L);
  else {
    sub_print_model(false, print_model, -1L, &link_model);
    note_command_end_pch(stdout, " Model printed", 14L);
  }
}  /* proc_print_model */


Static Void proc_print_models(command_file, print_model, as_argument, ifail,
			      sub_code, arg_pos, nargs, arg_int)
FILE *command_file;
boolean print_model, as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_model_list *link_model;
  t_integer nr1, nr2;
  t_integer i = 0;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Number->", 9L, &nr1);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Number->", 9L, &nr2);
  write_line_diary();
  link_model = link_model_list;
  while (link_model != NULL) {
    if (nr1 <= link_model->model->model_number &&
	link_model->model->model_number <= nr2)
      sub_print_model(true, print_model, -1L, &link_model);
    link_model = link_model->pointer;
  }
  note_command_end_pch(stdout, " Models printed", 15L);
}  /* proc_print_models */


Static Void proc_print_form()
{
  t_integer stop = 4;

  if (mixed_data)
    note_mixed(stdout, " ProcPrintForm", 16L);
  if (!current())   /* and not mixed_data */
    return;
  if (!ok_current_expression())
    return;
  write_pch(stdout, " P ", 3L);
  print_model_g_c(&link_current->model, stop);
  if (stop > line_length - cardinality(delta_gamma) &&
      line_length < MAX_LINE_LENGTH) {
    write_line(stdout);
    write_space(stdout, 3L);
  }
  write_pch(stdout, " ( I ", 5L);
  print_vertex_set(delta_gamma);
  write_pch(stdout, " ) = ", 5L);
  write_line(stdout);
  describe_formula(&link_current->model, false);
  note_command_end_pch(stdout, " Expression printed", 19L);
}  /* proc_print_form */


Static Void proc_print_order(sub_code)
t_integer *sub_code;
{
  if (current()) {
    print_order(&link_current->model, *sub_code != 0);
    note_command_end_pch(stdout, " Ordering printed", 17L);
  }
}  /* proc_print_order */


Static Void proc_print_common()
{
  if (!current_and_base())
    return;
  write_pch(stdout, " Decomposition of ", 18L);
  print_model_g_c(&link_current->model, 19L);
  write_line(stdout);
  write_pch(stdout, " and              ", 18L);
  print_model_g_c(&link_base->model, 19L);
  write_line(stdout);
  write_partitioning(&link_current->model, &link_base->model);
  note_command_end_pch(stdout, " Common decompositions writed", 29L);
}  /* proc_print_common */


Static Void sub_dispose_model(link_model)
t_model_list *link_model;
{
  t_model_list *tmp_link_model;

  dispose_model(&link_model->model);
  if (link_model == link_model_list)
    link_model_list = link_model_list->pointer;
  else {
    tmp_link_model = link_model_list;
    while (tmp_link_model->pointer != link_model)
      tmp_link_model = tmp_link_model->pointer;
    tmp_link_model->pointer = link_model->pointer;
  }
  tmp_link_model = link_model;
  if (link_model == link_current)
    link_current = NULL;
  if (link_model == link_base)
    link_base = NULL;
  _Free(tmp_link_model);
}  /* sub_dispose_model */


Static Void proc_dispose_of_base()
{
  if (base()) {
    sub_dispose_model(link_base);
    note_command_end_pch(stdout, " Base disposed of", 17L);
  }
}  /* proc_dispose_of_base */


Static Void proc_dispose_of_current()
{
  if (current()) {
    sub_dispose_model(link_current);
    note_command_end_pch(stdout, " Current disposed of", 20L);
  }
}  /* proc_dispose_of_current */


Static Void proc_dispose_of_last()
{
  if (link_model_list != NULL) {
    sub_dispose_model(link_model_list);
    note_command_end_pch(stdout, " Last disposed of", 17L);
  }
}  /* proc_dispose_of_last */


Static Void proc_dispose_of_model(command_file, as_argument, ifail, sub_code,
				  arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_model_list *link_model;
  t_integer nr;

  get_one_integer(command_file, as_argument, ifail, sub_code, arg_pos, nargs,
		  arg_int, " Number-> ", 9L, &nr);
  write_line_diary();
  sub_find_model(&nr, &link_model);
  if (link_model == NULL)
    write_pch(stdout, " Model not found", 16L);
  else {
    sub_dispose_model(link_model);
    note_command_end_pch(stdout, " Model disposed of", 18L);
  }
}  /* proc_dispose_of_model */


Static Void proc_dispose_of_models(command_file, as_argument, ifail, sub_code,
				   arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_model_list *tmp_link_model, *link_model;
  t_integer nr1, nr2;
  t_integer i = 0;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Number-> ", 9L, &nr1);
  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Number-> ", 9L, &nr2);
  write_line_diary();
  sub_find_model(&nr2, &link_model);
  if (link_model == NULL) {
    write_pch(stdout, " Models not found", 17L);
    return;
  }
  while (link_model != NULL) {
    if (link_model->model->model_number < nr1) {
      link_model = NULL;
      break;
    }
    tmp_link_model = link_model;
    link_model = link_model->pointer;
    sub_dispose_model(tmp_link_model);
  }
  note_command_end_pch(stdout, " Models disposed of", 19L);
}  /* proc_dispose_of_models */


Static Void proc_dispose_of_all()
{
  dispose_all_models();
  note_command_end_pch(stdout, " All models disposed", 20L);
}  /* proc_dispose_of_all */


Static Void proc_dispose_of_form()
{
  if (em) {
    dispose_all_expressions();
    return;
  }
  if (!current())
    return;
  dispose_formula(&link_current->model);
  note_command_end_pch(stdout, " Expression and ips-", 20L);
  note_command_end_pch(stdout, "list disposed of", 16L);
}  /* proc_dispose_of_form */


Static Void proc_dispose_of_marginals()
{
  dispose_marginals();
  note_command_end_pch(stdout, " Marginals disposed", 19L);
}  /* proc_dispose_of_marginals */


Static Void proc_dispose_of_all_q()
{
  dispose_set_list(&g_c_q_tables);
  dispose_offset_list(&q_tables_offsets);
  g_c_q_tables = NULL;
  q_tables_offsets = NULL;
  fqa = Q_START - FIRST_INDEX;
  incomplete_table = false;
  note_command_end_pch(stdout, " Q-tables disposed", 18L);
}  /* proc_dispose_of_all_q */


Static Void remove_set(a, list_of_sets)
long *a;
t_set_list **list_of_sets;
{
  t_set_list *p, *q;
  boolean b = true;

  while (*list_of_sets != NULL && b) {
    if (!P_setequal((*list_of_sets)->vertex_set, a)) {
      b = false;
      break;
    }
    q = *list_of_sets;
    *list_of_sets = (*list_of_sets)->pointer;
    _Free(q);
  }
  if (*list_of_sets == NULL || b)
    return;
  q = *list_of_sets;
  p = (*list_of_sets)->pointer;
  while (p != NULL) {
    if (P_setequal(a, p->vertex_set)) {
      q->pointer = p->pointer;
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* remove_set */


Local Void move_down(p_dispose, list_of_offsets)
t_offset_list **p_dispose, **list_of_offsets;
{
  t_offset_list *p;
  t_q_cell_index index, min_q, max_q, FORLIM;

  min_q = (*p_dispose)->offset;
  max_q = min_q + marginal_dimension((*p_dispose)->vertex_set);
  if (fqa > max_q) {
    FORLIM = fqa;
    for (index = max_q; index <= FORLIM - 1; index++)
      q_array[index - max_q + min_q] = q_array[index];
    p = *list_of_offsets;
    while (p != NULL) {
      if (p->offset > min_q)
	p->offset += min_q - max_q;
      p = p->pointer;
    }
  }
  fqa += min_q - max_q;
}  /* move_down */


Static Void remove_offset(a, list_of_offsets)
long *a;
t_offset_list **list_of_offsets;
{
  t_offset_list *p, *q;
  boolean b = true;

  while (*list_of_offsets != NULL && b) {
    if (!P_setequal((*list_of_offsets)->vertex_set, a)) {
      b = false;
      break;
    }
    q = *list_of_offsets;
    *list_of_offsets = (*list_of_offsets)->pointer;
    move_down(&q, list_of_offsets);
    _Free(q);
  }
  if (*list_of_offsets == NULL || b)
    return;
  q = *list_of_offsets;
  p = (*list_of_offsets)->pointer;
  while (p != NULL) {
    if (P_setequal(a, p->vertex_set)) {
      q->pointer = p->pointer;
      move_down(&p, list_of_offsets);
      _Free(p);
      p = q->pointer;
    } else {
      q = p;
      p = p->pointer;
    }
  }
}  /* remove_offset */


Static Void dispose_of_q_table_argument(a)
long *a;
{
  remove_set(a, &g_c_q_tables);
  remove_offset(a, &q_tables_offsets);
}  /* dispose_of_q_table_argument */


Static Void proc_dispose_of_q_table(command_file, as_argument, ifail,
				    sub_code, arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex_set a;
  t_integer i = PCH_START;

  P_setcpy(a, empty_set);
  if (get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		     sub_code, arg_pos, nargs, arg_char, " SET->", 6L, a,
		     a)) {
    dispose_of_q_table_argument(a);
    note_command_end_pch(stdout, " Q-table disposed of", 20L);
  }
}  /* proc_dispose_of_q_table */


/*@-"maintest.c"*/
/*@+"maintest.p"*/


/*

2626:    +++  ++
2627:    +++  ++
2628:    ---  -- p/maintest.p        24      97    1394 p/maintest.p
2629: |    4:    procedure proc_sum_up_partitioning
2630: |   29:    procedure test_current_against_base
2631: |  117:    procedure read_model_gc
2632: |  140:    - function not_empty_model
2633: |  165:    function model_to_read
2634: |  188:    procedure proc_test
2635: |  204:    procedure return_test_values
2636: |  332:    procedure proc_compute_test
2637: |  352:    procedure proc_log_l
2638: |  371:    procedure sub_find_model_complexity
2639: |  416:    procedure find_model_complexity
2640: |  435:    procedure write_sub_super_deviance_on_dump_file
2641: |  484:    procedure write_deviance_on_dump_file
2642: |  642:    procedure proc_2_log_q
2643: |  820:    procedure return_deviance
2644: |  886:    procedure proc_compute_deviance
2645: |  906:    procedure proc_exact_test
2646: |  948:    procedure proc_decompose
2647: |  980:    procedure proc_partitioning
2648: |  989:    procedure proc_test_one_edge
2649: | 1034:    procedure fact_edge_argument
2650: | 1102:    procedure proc_fact_edge
2651: | 1129:    procedure fact_inter_argument
2652: | 1176:    procedure proc_fact_inter
2653:    +++  ++
2654:    +++  ++

*/

Static Void proc_sum_up_partitioning(direction, parted, write_options,
				     test_labels, s)
t_integer direction;
boolean *parted;
t_test_write_options **write_options;
t_test_labels **test_labels;
t_integer s;
{
  t_sort_list *link_sort_list;

  if (link_part_list == NULL)
    return;
  if (link_part_list->pointer != NULL) {
    if ((*write_options)->line_form) {
      if ((*write_options)->write_models) {
	write_pch(stdout, "   =", 4L);
	write_space(stdout, s - 4);
      }
    } else {
      write_pch(stdout, " Total", 6L);
      write_line(stdout);
    }
  }
  sum_up_partitioning(&link_sort_list, direction, parted, write_options,
		      test_labels, exclude_missing && partitioning_output);
  dispose_sort_list(&link_sort_list);
}  /* proc_sum_up_partitioning */


Static Void test_current_against_base(current_model, base_model)
t_model **current_model, **base_model;
{
  t_integer dummy;
  t_vertex_set a;
  t_set_list *current_g_c, *base_g_c;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;
  boolean homogeneous;

  local_write_options = new_test_write_options_true();
  local_write_options->line_form = false;
  local_write_options->write_models = true;
  local_test_labels = new_test_labels_empty();
  /* local_test_labels^.indent := 7; */
  if (!global_write_options->write_test)
    global_write_options->write_test = true;
  else {
    if (is_submodel(&(*current_model)->id, &(*base_model)->id, false)) {
      if ((in_test && !graph_mode || !partitioning_output) && !ordinal_tests) {
	if (ok_two_to_test(current_model, base_model, a, false, permit_log_l,
			   &dummy)) {
	  test_models(current_model, base_model, a, &local_write_options,
		      &local_test_labels);
	  note_command_end_pch(stdout, " Test computed", 14L);
	}
      } else {
	if (global_write_options->line_form) {
	  print_test_of(current_model, base_model);
	  if (global_write_options->write_models)
	    write_test_head(stdout, "  Edge    ", 6L, 0L, " Models ", 8L,
			    global_write_options, global_test_labels);
	  else
	    write_test_head(stdout, "          ", 0L, -1L, " Edge ", 6L,
			    global_write_options, global_test_labels);
	  write_char(stdout, ' ');
	  write_pch(stdout, "      ", 6L);
	}
	dummy = 0;
	current_g_c = return_g_c_copy_for_mixed_model(current_model);
	base_g_c = return_g_c_copy_for_mixed_model(base_model);
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 2630L, 1L)) {
	  print_g_c((*current_model)->id->causal_structure, 0L, line_length);
	  print_g_c((*base_model)->id->causal_structure, 0L, line_length);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	if ((*current_model)->id->model_type == mixed)
	  homogeneous = (*current_model)->id->UU.U1.homogeneous;
	else
	  homogeneous = false;
	partitioning_hierarchical(&current_g_c, &base_g_c,
	  &(*current_model)->id->causal_structure, &homogeneous,
	  &global_write_options, &global_test_labels, &dummy);
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 2630L, 1L)) {
	  print_g_c((*current_model)->id->causal_structure, 0L, line_length);
	  print_g_c((*base_model)->id->causal_structure, 0L, line_length);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	dispose_g_c_copy_for_mixed_model(current_model, &current_g_c);
	dispose_g_c_copy_for_mixed_model(base_model, &base_g_c);
	proc_sum_up_partitioning(0L, &partitioning_output,
				 &global_write_options, &global_test_labels,
				 7L);
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 2630L, 1L)) {
	  print_g_c((*current_model)->id->causal_structure, 0L, line_length);
	  print_g_c((*base_model)->id->causal_structure, 0L, line_length);
	  write_line(stdout);
	}
	/*$endif TRACE*/
	if (global_write_options->line_form)
	  write_line(stdout);
	note_command_end_pch(stdout, " Partitioning made", 18L);
      }
    }
  }
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* test_current_against_base */


Static Void read_model_gc(command_file, h_g_c)
FILE *command_file;
t_set_list **h_g_c;
{
  t_list_of_vertex_lists *lists_h_g_c;

  if (echo)
    write_space(stdout, 1L);
  read_list_of_vertex_lists(command_file, true, true, false, &lists_h_g_c);
  list_of_lists_to_list_of_sets(lists_h_g_c, h_g_c);
  dispose_list_of_vertex_lists(&lists_h_g_c);
  if (echo)
    write_line(stdout);
  if (test_hierarchical(*h_g_c))
    return;
  write_pch(stdout, " READ: ", 7L);
  print_g_c(*h_g_c, 1L, line_length);
  dispose_set_list(h_g_c);
  write_line(stdout);
  write_pch(stdout, " SET OF SETS IS NOT A GENERATING CLASS  ", 40L);
  write_line(stdout);
}  /* read_model_gc */


/* Not used:
function not_empty_model(var model: t_link_model): boolean;
var
   g_c : t_link_set_list;
   ok  :  boolean;
begin
   ok := false;
   if model^.id^.model_type = mixed then begin
      g_c := return_g_c_copy(model);
      if g_c = nil then
         dispose_model(model)
      else if g_c^.vertex_set = empty_set then
         dispose_model(model)
      else
         ok := true;
      dispose(g_c)
   end
   else
      if model^.id^.g_c_log_linear = nil then
         dispose_model(model)
      else if model^.id^.g_c_log_linear^.vertex_set = empty_set then
         dispose_model(model)
      else ok := true;
   not_empty_model := ok
end; */
/* not_empty_model */

Static boolean model_to_read(command_file)
FILE *command_file;
{
  t_vertex_set a;
  t_set_list *g_c;
  boolean full_specified;
  boolean ok = false;
  t_set_list *tmp_cs;

  tmp_cs = causal_structure;   /* CausalStructure !!! */
  if (mixed_data)
    note_mixed(stdout, " EnterModel", 11L);
  read_model_gc(command_file, &g_c);
  if (g_c != NULL) {
    if (P_setequal(g_c->vertex_set, empty_set))
      _Free(g_c);
    else
      ok = true;
  }
  if (!ok)
    return false;
  P_setcpy(a, empty_set);
  add_union_of_gc(g_c, a);
  full_specified = subset_of_an_edge(double_vertex_set, &g_c);   /* nil !!! */
  insert_g_c_in_new_model(&g_c, a, &tmp_cs, full_specified, homogeneous_mode);
  return true;
}  /* model_to_read */


Static Void proc_test(command_file, code)
FILE *command_file;
t_integer *code;
{
  if (mixed_data)
    note_mixed(stdout, " TestModel", 10L);
  if (*code == 1) {
    if (model_to_read(command_file))
      link_current = link_model_list;
    if (model_to_read(command_file))
      link_base = link_model_list;
  }
  write_line_diary();
  if (test_current_submodel_of_base(false))
    test_current_against_base(&link_current->model, &link_base->model);
}  /* proc_test */


Static Void return_test_values(current_model, base_model, ifail, arg_pos_int,
			       arg_pos_double, nargs, arg_int, arg_double)
t_model **current_model, **base_model;
t_integer *ifail, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  /* , sub_code */
  t_sort_list *link_sort_list = NULL;
  t_test_list *p = NULL;
  t_integer dummy, off_pos_int, off_pos_double;
  t_test test;
  t_vertex_set a;
  t_set_list *g_c_current, *g_c_base;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;
  boolean homogeneous;

  local_write_options = new_test_write_options_false();
  local_test_labels = new_test_labels_empty();
  (*arg_int)[0] = n[0];
  if (!test_current_submodel_of_base_ifail(ifail, false)) {
    *ifail = 27;
    return;
  }
  clear_test(&test);
  if (!sub_return_test_id(&(*current_model)->id, &(*base_model)->id, &p,
			  &test)) {
    P_setunion(a, (*current_model)->id->vertices, (*base_model)->id->vertices);
    if (!c_partitioning || (*current_model)->id->model_type == mixed) {
      if (ok_two_to_test(current_model, base_model, a, true, false, ifail)) {
	*ifail = 0;
	compute_test(current_model, base_model, a, &p, &test);
	if (exact_test_for_test_models && exact_test &&
	    (*current_model)->decomposable && (*base_model)->decomposable)
	  test_exact_test(current_model, base_model, &p, &test);
      }
    } else {
      dummy = 0;
      local_write_options->write_test = false;
      if ((*current_model)->id->model_type == mixed)
	homogeneous = (*current_model)->id->UU.U1.homogeneous;
      else
	homogeneous = false;
      g_c_current = return_g_c_copy(current_model);
      g_c_base = return_g_c_copy(base_model);
      partitioning_hierarchical(&g_c_current, &g_c_base,
	&(*current_model)->id->causal_structure, &homogeneous,
	&local_write_options, &local_test_labels, &dummy);
      dispose_set_list(&g_c_current);
      dispose_set_list(&g_c_base);
      if (link_part_list != NULL) {
	if (link_part_list->pointer != NULL) {
	  sum_up_partitioning(&link_sort_list, 0L, &c_partitioning,
			      &local_write_options, &local_test_labels,
			      exclude_missing && partitioning_output);
	  p = link_sort_list->link_test_list;
	} else
	  p = link_part_list->link_test_list;
      }
    }
  }
  if (p != NULL) {
    off_pos_int = 0;
    off_pos_double = 0;
    put_test_values(&p->test, empty_set, 0L, ifail, &off_pos_int,
		    &off_pos_double, arg_pos_int, arg_pos_double, nargs,
		    arg_int, arg_double);
  }
  dispose_part_list(&link_part_list);
  dispose_sort_list(&link_sort_list);
}  /* return_test_values */


Static Void proc_compute_test(command_file, as_argument, ifail, sub_code,
			      arg_pos_int, arg_pos_double, nargs, arg_int,
			      arg_double)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  if (as_argument && *sub_code != 0) {
    if (ok_int_arg(ifail, arg_pos_int, 4L, nargs, arg_int) &
	ok_double_arg(ifail, arg_pos_double, 12L, nargs, arg_double)) {
      /* sub_code, */
      return_test_values(&link_current->model, &link_base->model, ifail,
			 arg_pos_int, arg_pos_double, nargs, arg_int,
			 arg_double);
    }
  } else
    proc_test(command_file, sub_code);
}  /* proc_compute_test */


Static Void proc_log_l()
{
  if (!current())
    return;
  if (!ok_miss_model(link_current->model->id->vertices, false))
    return;
  if (!ok_log_model(&link_current->model, false))
    return;
  write_pch(stdout, " Log(L):            ", 20L);
  if (link_current->model->model_ifail == 0)
    write_real(stdout, link_current->model->log_l, print_width, print_dec);
  else
    write_real(stdout, _INVALID_REAL, print_width, print_dec);
  write_line(stdout);
  write_pch(stdout, " Dimension:         ", 20L);
  write_integer(stdout, link_current->model->dim, print_width);
  write_line(stdout);
  note_command_end_pch(stdout, " Test computed", 14L);
}  /* proc_log_l */


Static Void sub_find_model_complexity(link_model, count_0, count_1, count_2,
				      count_3, ifail, max_cycles, max_delta)
t_model **link_model;
t_integer *count_0, *count_1, *count_2, *count_3, *ifail, *max_cycles;
t_long_real *max_delta;
{
  t_decomposition_element *decomposition_element;
  t_formula_node *formula;

  formula = (*link_model)->formula_node;
  if (formula == NULL)
    return;
  switch (formula->node_type) {

  case null_node:
    /* blank case */
    break;

  case decomposition_node:
    decomposition_element = formula->UU.decomposition_node_;
    sub_find_model_complexity(&decomposition_element->left_model, count_0,
			      count_1, count_2, count_3, ifail, max_cycles,
			      max_delta);
    sub_find_model_complexity(&decomposition_element->right_model, count_0,
			      count_1, count_2, count_3, ifail, max_cycles,
			      max_delta);
    break;

  case d_complete_node:
    /* blank case */
    break;

  case c_complete_node:
    /* blank case */
    break;

  case m_complete_node:
    /* blank case */
    break;

  case d_ips_node:
    /* blank case */
    break;

  case r_ips_node:
    /* blank case */
    break;

  case c_ips_node:
    /* blank case */
    break;

  case m_ips_node:
    (*count_1)++;
    if (!formula->UU.m_ips_leaf->complete)
      (*count_2)++;
    if (!formula->UU.m_ips_leaf->complete &&
	!formula->UU.m_ips_leaf->convergence)
      (*count_3)++;
    if (fabs(formula->UU.m_ips_leaf->mips_delta) > *max_delta)
      *max_delta = fabs(formula->UU.m_ips_leaf->mips_delta);
    if (formula->UU.m_ips_leaf->cycles > *max_cycles)
      *max_cycles = formula->UU.m_ips_leaf->cycles;
    if (formula->UU.m_ips_leaf->ifail > 0)
      *ifail = *ifail * 1000 + formula->UU.m_ips_leaf->ifail;
    break;
  }
}  /* sub_find_model_complexity */


Static Void find_model_complexity(link_model, count_0, count_1, count_2,
				  count_3, ifail, max_cycles, max_delta)
t_model **link_model;
t_integer *count_0, *count_1, *count_2, *count_3, *ifail, *max_cycles;
t_long_real *max_delta;
{
  *count_0 = 0;
  *count_1 = 0;
  *count_2 = 0;
  *count_3 = 0;
  *ifail = 0;
  *max_delta = 0.0;
  *max_cycles = 0;
  sub_find_model_complexity(link_model, count_0, count_1, count_2, count_3,
			    ifail, max_cycles, max_delta);
}  /* find_model_complexity */


Static Void write_sub_super_deviance_on_dump_file()
{
  t_model *sub_model, *super_model;
  boolean dummy_ok;

  new_model(&sub_model);
  erase_model(&sub_model, link_current->model->id->model_type, false);
  generate_decomposable_submodel(&sub_model, &link_current->model);
  dummy_ok = ok_log_model(&sub_model, true);

  new_model(&super_model);
  erase_model(&super_model, link_current->model->id->model_type, false);
  generate_decomposable_model(&super_model, &link_current->model);
  dummy_ok = ok_log_model(&super_model, true);   /* print_width - print_dec */

  write_dump_integer(super_model->dim, 3L);
  write_dump_real(super_model->log_l, print_width, print_dec);
  write_dump_pch10(" / ", 3L);

  if (sub_model->dim <= link_current->model->dim)
    write_dump_pch10(" ", 1L);
  else
    write_dump_pch10("?", 1L);
  /* print_width - print_dec */
  write_dump_integer(link_current->model->dim, 2L);
  if (link_current->model->dim <= super_model->dim)
    write_dump_pch10(" ", 1L);
  else
    write_dump_pch10("?", 1L);

  if (sub_model->log_l <= link_current->model->log_l)
    write_dump_pch10(" ", 1L);
  else
    write_dump_pch10("%", 1L);
  write_dump_real(link_current->model->log_l, print_width, print_dec);
  if (link_current->model->log_l <= super_model->log_l)
    write_dump_pch10(" ", 1L);
  else
    write_dump_pch10("%", 1L);
  write_dump_pch10(" / ", 3L);   /* print_width - print_dec */

  write_dump_integer(sub_model->dim, 3L);
  write_dump_real(sub_model->log_l, print_width, print_dec);
  write_dump_pch10(" / ", 3L);

  dispose_model_and_link(&sub_model);

  dispose_model_and_link(&super_model);
}  /* write_sub_super_deviance_on_dump_file */


Static Void write_deviance_on_dump_file()
{
  t_long_integer count_0, count_1, count_2, count_3, difficulty, df;
  t_integer ifail, max_cycles;
  t_long_real df_real, max_delta;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " WriteDevianceOnDump", sizeof(pch20));
  ntr(tzt, 20L, 2641L, 1L, -1L, -1L);
  /*$endif TRACE*/

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2641L, 1L)) {
    write_pch(report_file, " /n/p/q/r/s/S/t: ", 17L);
    write_integer(report_file, fna, 8L);
    write_integer(report_file, fpa, 3L);
    write_integer(report_file, fqa, 3L);
    write_integer(report_file, fra, 3L);   /* Not used! */
    write_integer(report_file, fsa, 3L);   /* Not used! */
    write_integer(report_file, fssa, 3L);   /* Not used! */
    write_integer(report_file, fta, 3L);   /* Not used! */
    write_pch(report_file, " r: @@@@@@          ", 4L);
    if (r_list != NULL) {
      write_integer(report_file, r_list->fra, 8L);
      if (r_list->pointer != NULL)
	write_integer(report_file, r_list->fra, 8L);
      else
	write_integer(report_file, _INVALID, 8L);
    } else
      write_integer(report_file, _INFINITY, 16L);
    write_pch(report_file, " s: @@@@@@          ", 4L);
    if (s_list != NULL) {
      write_integer(report_file, s_list->fsa, 8L);
      if (s_list->pointer != NULL)
	write_integer(report_file, s_list->fsa, 8L);
      else
	write_integer(report_file, _INVALID, 8L);
    } else
      write_integer(report_file, _INFINITY, 16L);
    write_pch(report_file, " S: @@@@@@          ", 4L);
    if (ss_list != NULL) {
      write_integer(report_file, ss_list->fssa, 8L);
      if (ss_list->pointer != NULL)
	write_integer(report_file, ss_list->fssa, 8L);
      else
	write_integer(report_file, _INVALID, 8L);
    } else
      write_integer(report_file, _INFINITY, 16L);
    write_pch(report_file, " t: @@@@@@          ", 4L);
    if (t_list != NULL) {
      write_integer(report_file, t_list->fta, 8L);
      if (t_list->pointer != NULL)
	write_integer(report_file, t_list->fta, 8L);
      else
	write_integer(report_file, _INVALID, 8L);
    } else
      write_integer(report_file, _INFINITY, 16L);
    write_line(report_file);
  }
  /*$endif TRACE*/

  df = mysubi(&link_base->model->dim, link_current->model->dim);
  if (df == _INFINITY)
    df = return_df(&link_current->model, &link_base->model, &df_real);

  find_model_complexity(&link_current->model, &count_0, &count_1, &count_2,
			&count_3, &ifail, &max_cycles, &max_delta);

  if (is_invalid_real(link_base->model->log_l) |
      is_invalid_real(link_current->model->log_l))
    count_0 = 2;
  else if (2 * (link_base->model->log_l - link_current->model->log_l) > 100)
    count_0 = 1;
  else
    count_0 = 0;

  /* print_width - print_dec */
  write_dump_integer(count_0, 2L);

  write_dump_integer(ifail, print_width - print_dec);

  write_dump_integer(link_current->model->model_ifail,
		     print_width - print_dec);

  if (max_cycles <= 0)
    difficulty = -2;
  else if (max_cycles <= 20)
    difficulty = -1;
  else if (max_cycles <= 50)
    difficulty = 0;
  else if (max_cycles <= 100)
    difficulty = 1;
  else if (max_cycles <= 200)
    difficulty = 2;
  else if (max_cycles <= 500)
    difficulty = 3;
  else if (max_cycles <= 1000)
    difficulty = 4;
  else if (max_cycles <= 2000)
    difficulty = 5;
  else if (max_cycles <= 5000)
    difficulty = 6;
  else if (max_cycles <= 10000)
    difficulty = 7;
  else if (max_delta <= 0.01)
    difficulty = 8;
  else
    difficulty = 9;

  /* print_width - print_dec */
  write_dump_integer(difficulty + 2, 3L);

  if (df == _INFINITY)
    write_dump_real(df_real, print_width, print_dec);
  else
    write_dump_integer(df, 3L);
  /* print_width - print_dec */

  if (ifail == 0 && link_current->model->model_ifail == 0 &&
      link_base->model->model_ifail == 0)
    write_dump_real(2 * (link_base->model->log_l - link_current->model->log_l),
		    print_width, print_dec);
  else
    write_dump_real(_INVALID_REAL, print_width, print_dec);

  write_dump_pch10(" / ", 3L);   /* print_width - print_dec */

  write_dump_integer(count_1, 2L);   /* print_width - print_dec */
  write_dump_integer(count_2, 2L);   /* print_width - print_dec */
  write_dump_integer(count_3, 2L);

  write_dump_integer(max_cycles, print_width - print_dec);

  write_dump_real(10000 * max_delta, print_width, print_dec - 2);
  /* write_dump_real(max_delta, print_width, print_dec + 2); */

  write_dump_pch10(" / ", 3L);   /* print_width - print_dec */

  write_dump_integer(link_base->model->dim, 3L);
  write_dump_real(link_base->model->log_l, print_width, print_dec);

  if (false) {
    write_dump_real(link_current->model->log_l, print_width, print_dec);
	/* print_width - print_dec */
    write_dump_integer(link_current->model->dim, 3L);
  }

  write_dump_pch10(" / ", 3L);

  write_sub_super_deviance_on_dump_file();


  write_line_dump();
}  /* write_deviance_on_dump_file */


Static Void proc_2_log_q()
{
  t_long_integer dummy, f_df, adj, exp_zero_base, obs_zero_curr,
		 obs_zero_base, df;
  t_long_real f, df_real;

  /*$ifdef TRACE*/
  /*  tzt : pch20; */
  /*$endif TRACE*/
  /*$ifdef TRACE*/
  /*  tzt := ' Proc2LogQ          '; */
  /*$endif TRACE*/
  if (test_current_submodel_of_base(false)) {
    print_test_of(&link_current->model, &link_base->model);
    if (ok_two_log(&link_current->model, &link_base->model, false, &dummy)) {
      if (default_dump_set || dump_set)
	write_deviance_on_dump_file();
      write_pch(stdout, " -2Log(Q) = 2 * ( ", 18L);
      if (link_base->model->model_ifail == 0)
	write_real(stdout, link_base->model->log_l, print_width, print_dec);
      else
	write_real(stdout, _INVALID_REAL, print_width, print_dec);
      write_pch(stdout, " - ", 3L);
      if (link_current->model->model_ifail == 0)
	write_real(stdout, link_current->model->log_l, print_width, print_dec);
      else
	write_real(stdout, _INVALID_REAL, print_width, print_dec);
      write_pch(stdout, " ) = ", 5L);
      if (link_base->model->model_ifail == 0 &&
	  link_current->model->model_ifail == 0)
	write_real(stdout,
		   2 * (link_base->model->log_l - link_current->model->log_l),
		   print_width, print_dec);
      else
	write_real(stdout, _INVALID_REAL, print_width, print_dec);
      df = mysubi(&link_base->model->dim, link_current->model->dim);
      if (df == _INFINITY)
	df = return_df(&link_current->model, &link_base->model, &df_real);
      write_line(stdout);

      write_pch(stdout, " DF.      =       ", 18L);
      write_integer(stdout, link_base->model->dim, print_width);
      write_pch(stdout, " - ", 3L);
      write_integer(stdout, link_current->model->dim, print_width);
      write_pch(stdout, " =   ", 5L);
      if (df == _INFINITY)
	write_real(stdout, df_real, print_width, print_dec);
      else
	write_integer(stdout, df, print_width);
      write_pch(stdout, "   P = ", 7L);
      if (link_base->model->model_ifail == 0 &&
	  link_current->model->model_ifail == 0)
	write_real(stdout,
	  khi(df, 2 * (link_base->model->log_l - link_current->model->log_l)),
	  print_width, print_dec);
      else
	write_real(stdout, _INVALID_REAL, print_width, print_dec);
      write_line(stdout);
      if (ok_to_f_test(&link_current->model, &link_base->model, &f_df) &&
	  link_base->model->model_ifail == 0 &&
	  link_current->model->model_ifail == 0) {
	if (trace_flag_set(20L, 2642L, 1L)) {
	  write_pch(stdout, " :", 2L);
	  write_integer(stdout, link_base->model->dim, 4L);
	  write_pch(stdout, " -", 2L);
	  write_integer(stdout, link_current->model->dim, 4L);
	  write_pch(stdout, " =", 2L);
	  write_integer(stdout, df, 4L);
	  write_pch(stdout, " |", 2L);
	  write_integer(stdout, f_df, 4L);
	  write_integer(stdout, n[0] - f_df, 4L);
	  write_pch(stdout, " :", 2L);
	  write_integer(stdout, link_base->model->dim - f_df, 4L);
	  write_integer(stdout, n[0] - link_base->model->dim + f_df, 4L);
	  write_pch(stdout, " :", 2L);
	  write_integer(stdout, link_current->model->dim - f_df, 4L);
	  write_integer(stdout, n[0] - link_current->model->dim + f_df, 4L);
	  write_pch(stdout, " |", 2L);
	  write_line(stdout);
	}
	f = deviance_to_f_value(df, n[0], f_df,
	    2 * (link_base->model->log_l - link_current->model->log_l));
	write_pch(stdout, " F-Test/1 DF.  =  ", 18L);
	/*write_pch(output, ' DF.      =       @@', 18); */
	write_integer(stdout, df, print_width);
	write_pch(stdout, " , ", 3L);
	write_integer(stdout, n[0] - f_df, print_width);
	write_pch(stdout, " F =   ", 5L);
	write_real(stdout, f, print_width, print_dec);
	write_pch(stdout, "   P = ", 7L);
	if (is_invalid_real(f))
	  write_real(stdout, _INVALID_REAL, print_width, print_dec);
	else
	  write_real(stdout, 1 - ffisher(df, n[0] - f_df, f), print_width,
		     print_dec);
	write_line(stdout);
      }

      if (adj_df && df != _INFINITY &&
	  !(mixed_data &&
	    (link_current->model->id->model_type != pure_discrete ||
	     link_base->model->id->model_type != pure_discrete))) {
	obs_zero_base = count_zero_n(&link_base->model);
	obs_zero_curr = count_zero_n(&link_current->model);
	exp_zero_base = count_zero_par(&link_current->model, &link_base->model);
	adj = mysubi(&exp_zero_base, obs_zero_curr);
	write_pch(stdout, " Adjustment:      ", 18L);
	write_integer(stdout, exp_zero_base, print_width);
	write_pch(stdout, " - ", 3L);
	write_integer(stdout, obs_zero_curr, print_width);
	write_pch(stdout, " =   ", 5L);
	write_integer(stdout, adj, print_width);
	write_line(stdout);
	write_pch(stdout, "                 (", 18L);
	write_integer(stdout, obs_zero_base, print_width);
	write_pch(stdout, ")  ", 3L);
	write_space(stdout, labs(print_width));
	write_pch(stdout, "     ", 5L);
	df = mysubi(&link_base->model->dim, link_current->model->dim);
	df = mysubi(&df, adj);
	write_integer(stdout, df, print_width);
	write_pch(stdout, "   P = ", 7L);
	if (link_base->model->model_ifail == 0 &&
	    link_current->model->model_ifail == 0)
	  write_real(stdout,
	    khi(df,
		2 * (link_base->model->log_l - link_current->model->log_l)),
	    print_width, print_dec);
	else
	  write_real(stdout, _INVALID_REAL, print_width, print_dec);
	write_line(stdout);
      }
      if (em) {
	write_line(stdout);
	write_space(stdout, 1L);
	write_pch(stdout, "Warning: ", 9L);
	write_pch(stdout, "DF. not correct for latent variables!", 37L);
      }
      note_command_end_pch(stdout, " Test computed", 14L);
      return;
    }
    if (default_dump_set || dump_set) {
      write_dump_pch10(" Not OK! ", 9L);
      write_line_dump();
    }
    return;
  }
  if (default_dump_set || dump_set) {
    write_dump_pch10(" Collaps ", 9L);
    write_line_dump();
  }
}  /* proc_2_log_q */


Static Void return_deviance(current_model, base_model, ifail, arg_pos_int,
			    arg_pos_double, nargs, arg_int, arg_double)
t_model **current_model, **base_model;
t_integer *ifail, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  /* , sub_code */
  t_long_integer exp_zero_base, obs_zero_curr, adj, df, dummy, f_df;
  t_long_real x_deviance;

  if (!is_submodel(&(*current_model)->id, &(*base_model)->id, true))
    return;
  if (!ok_two_log(current_model, base_model, true, ifail))
    return;
  *ifail = 0;
  if (link_base->model->model_ifail == 0 &&
      link_current->model->model_ifail == 0) {
    (*arg_double)[0] = (*base_model)->log_l;
    (*arg_double)[1] = (*current_model)->log_l;
    (*arg_double)[0] = (*current_model)->log_l;
    (*arg_double)[1] = (*base_model)->log_l;
    ddiff_ifail(current_model, base_model, &x_deviance, ifail);
    (*arg_double)[2] = x_deviance;
    if (!test_ok(*ifail))
      x_deviance = my_var_na_double;
  }
  (*arg_int)[0] = (*current_model)->dim;
  (*arg_int)[1] = (*base_model)->dim;
  df = mysubi(&(*base_model)->dim, (*current_model)->dim);
  (*arg_int)[2] = df;
  (*arg_double)[3] = khi(df, (*arg_double)[2]);
  if (ok_int_arg(ifail, arg_pos_int, 9L, nargs, arg_int)) {
    if (ok_to_f_test(current_model, base_model, &f_df) &&
	link_base->model->model_ifail == 0 &&
	link_current->model->model_ifail == 0) {
      f_df = (*arg_int)[8];
      if (ok_double_arg(ifail, arg_pos_double, 7L, nargs, arg_double)) {
	(*arg_double)[5] = deviance_to_f_value(df, n[0], f_df, (*arg_double)[2]);
	if (is_invalid_real((*arg_double)[5]))
	  (*arg_double)[6] = _INVALID_REAL;
	else
	  (*arg_double)[6] = 1 - ffisher(df, n[0] - f_df, (*arg_double)[5]);
      }
    }
  }
  if (adj_df &&
      !(mixed_data && (link_current->model->id->model_type != pure_discrete ||
		       link_base->model->id->model_type != pure_discrete))) {
    (*arg_int)[3] = count_zero_n(base_model);
    obs_zero_curr = count_zero_n(current_model);
    (*arg_int)[4] = count_zero_n(current_model);
    exp_zero_base = count_zero_par(current_model, base_model);
    (*arg_int)[5] = count_zero_par(current_model, base_model);
    adj = mysubi(&exp_zero_base, obs_zero_curr);
    (*arg_int)[6] = adj;
    (*arg_int)[7] = mysubi(&df, adj);
    (*arg_double)[4] = khi((*arg_int)[7], (*arg_double)[2]);
  }
  for (dummy = 0; dummy <= 6; dummy++) {
    if (is_invalid_real((*arg_double)[dummy]))
      (*arg_double)[dummy] = my_var_na_double;
  }
}  /* return_deviance */


Static Void proc_compute_deviance(as_argument, ifail, sub_code, arg_pos_int,
				  arg_pos_double, nargs, arg_int, arg_double)
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_int, arg_pos_double;
long **nargs, **arg_int;
double **arg_double;
{
  if (as_argument && *sub_code != 0) {
    if (ok_int_arg(ifail, arg_pos_int, 8L, nargs, arg_int) &
	ok_double_arg(ifail, arg_pos_double, 5L, nargs, arg_double)) {
      /* sub_code,  */
      return_deviance(&link_current->model, &link_base->model, ifail,
		      arg_pos_int, arg_pos_double, nargs, arg_int,
		      arg_double);
    }
  } else
    proc_2_log_q();
}  /* proc_compute_deviance */


Static Void proc_exact_test()
{
  t_test_list *p_test;
  boolean ok, et;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_true();
  local_write_options->line_form = false;
  local_write_options->write_models = true;
  local_write_options->write_test = true;
  local_test_labels = new_test_labels_empty();
  if (test_current_submodel_of_base(false)) {
    if (ok_current()) {
      if (ok_base()) {
	if (!(link_current->model->decomposable &&
	      link_current->model->graphical &&
	      link_base->model->decomposable && link_base->model->graphical))
	  write_pch(stdout, " Both models not decomposable", 29L);
	else {
	  ok = true;
	  if (!c_partitioning)
	    ok = ok_miss();
	  if (ok) {
	    et = exact_test;
	    exact_test = true;
	    factorization_one_edge_exact(&link_current->model,
	      &link_base->model, &p_test, &local_write_options,
	      &local_test_labels);
	    exact_test = et;
	    note_command_end_pch(stdout, " Exact test computed", 20L);
	  }
	}
      }
    }
  }
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* proc_exact_test */


Static Void proc_decompose(command_file, as_argument, ifail, sub_code,
			   arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex_set a;
  t_integer i = PCH_START;

  if (!test_current_submodel_of_base_ifail(ifail, false))
    return;
  global_write_options->write_test = true;
  P_setcpy(a, empty_set);
  if (!get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		      sub_code, arg_pos, nargs, arg_char, " SET->", 6L, a,
		      a))
    return;
  write_line_diary();
  write_pch(stdout, " Partitioning of ", 17L);
  print_model_g_c(&link_current->model, 17L);
  write_line(stdout);
  write_pch(stdout, " and ", 5L);
  print_model_g_c(&link_base->model, 5L);
  write_line(stdout);
  do_partitioning(a, &link_current->model, &link_base->model);
  note_command_end_pch(stdout, " Models parted", 14L);
}  /* proc_decompose */


Static Void proc_partitioning()
{
  global_write_options->write_test = true;
  partitioning_output = true;
  if (test_current_submodel_of_base(false))
    test_current_against_base(&link_current->model, &link_base->model);
  partitioning_output = c_partitioning;
}  /* proc_partitioning */


Static Void proc_test_one_edge()
{
  t_test_list *p_test;
  /* test : t_test; */
  t_test_write_options *write_options;
  t_test_labels *test_labels;
  t_set_list *g_c_current, *g_c_base;
  boolean homogeneous;

  if (!test_current_submodel_of_base(false))
    return;
  if (!ok_current_expression())
    return;
  if (!ok_base_expression())
    return;
  if (!(link_current->model->decomposable && link_current->model->graphical &&
	link_base->model->decomposable && link_base->model->graphical)) {
    write_pch(stdout, " Both models not decomposable", 29L);
    return;
  }
  global_write_options->write_test = true;
  print_test_of(&link_current->model, &link_base->model);
  write_options = new_test_write_options_false();
  write_options->examin_terms = true;
  test_labels = new_test_labels_empty();
  g_c_current = return_g_c_copy_for_mixed_model(&link_current->model);
  g_c_base = return_g_c_copy_for_mixed_model(&link_base->model);
  if (link_current->model->id->model_type == mixed)
    homogeneous = link_current->model->id->UU.U1.homogeneous;
  else
    homogeneous = false;
  if (!test_if_one_edge_decomposable(&g_c_current, &g_c_base,
	&link_current->model->id->causal_structure, &homogeneous, &p_test,
	&write_options, &test_labels))
    write_pch(stdout, " More than one edge.", 20L);
  dispose_g_c_copy_for_mixed_model(&link_current->model, &g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_base->model, &g_c_base);
  _Free(write_options);
  _Free(test_labels);
  note_command_end_pch(stdout, " Partitioning made", 18L);
}  /* proc_test_one_edge */


Static Void fact_edge_argument(vertex_order)
t_vertex_list **vertex_order;
{
  boolean ok;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_true();
  local_write_options->write_models = !global_write_options->line_form;
  local_test_labels = new_test_labels_empty();
  /* local_test_labels^.indent := 7; */
  if (em)
    write_pch(stdout, " Not when EM", 12L);
  else if (test_current_submodel_of_base(false)) {
    if (ok_current_expression()) {
      if (ok_base_expression()) {
	global_write_options->write_test = true;
	print_test_of(&link_current->model, &link_base->model);
	if (!(link_current->model->decomposable &&
	      link_current->model->graphical &&
	      link_base->model->decomposable && link_base->model->graphical))
	  write_pch(stdout, " Both models not decomposable", 29L);
	else {
	  ok = true;
	  if (!c_partitioning)
	    ok = ok_miss();
	  if (ok) {
	    if (local_write_options->write_models)
	      write_test_head(stdout, "  Edge    ", 6L, 0L, " Models ", 8L,
			      local_write_options, local_test_labels);
	    else
	      write_test_head(stdout, "          ", 0L, -1L, " Edge ", 6L,
			      local_write_options, local_test_labels);
	    if (c_factorizes == 1) {
	      factorizes_a(&link_current->model, &link_base->model,
			   *vertex_order, c_partitioning,
			   &local_write_options, &local_test_labels);
	      proc_sum_up_partitioning(1L, &c_partitioning,
				       &local_write_options,
				       &local_test_labels, 7L);
	    } else if (c_factorizes == 2) {
	      factorizes_b(&link_current->model, &link_base->model,
			   *vertex_order, c_partitioning,
			   &local_write_options, &local_test_labels);
	      proc_sum_up_partitioning(1L, &c_partitioning,
				       &local_write_options,
				       &local_test_labels, 7L);
	    } else if (c_factorizes == 3) {
	      factorizes_c(&link_current->model, &link_base->model,
			   *vertex_order, c_partitioning,
			   &local_write_options, &local_test_labels);
	      proc_sum_up_partitioning(-1L, &c_partitioning,
				       &local_write_options,
				       &local_test_labels, 7L);
	    }
	    if (local_write_options->line_form)
	      write_line(stdout);
	    note_command_end_pch(stdout, " Models factorized", 18L);
	  }
	}
      }
    }
  }
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* fact_edge_argument */


Static Void proc_fact_edge(command_file, as_argument, ifail, sub_code,
			   arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex_list *vertex_order = NULL;
  t_integer i = PCH_START;

  if (em) {
    write_pch(stdout, " Not when EM", 12L);
    return;
  }
  if (*sub_code == 1) {
    if (get_vertex_list(command_file, true, true, false, as_argument, &i,
			ifail, sub_code, arg_pos, nargs, arg_char,
			" Order->", 8L, &vertex_order, &vertex_order))
      revers_vertex_list(&vertex_order);
  }
  write_line_diary();
  if (test_current_submodel_of_base_ifail(ifail, false))
    fact_edge_argument(&vertex_order);
  dispose_vertex_list(&vertex_order);
}  /* proc_fact_edge */


Static Void fact_inter_argument(vertex_order)
t_vertex_list **vertex_order;
{
  boolean ok;
  t_test_write_options *local_write_options;
  t_test_labels *local_test_labels;

  local_write_options = new_test_write_options_true();
  local_write_options->write_models = !global_write_options->line_form;
  local_test_labels = new_test_labels_empty();
  if (test_current_submodel_of_base(false)) {
    ok = true;
    if (!c_partitioning)
      ok = ok_miss();
    if (ok) {
      global_write_options->write_test = true;
      print_test_of(&link_current->model, &link_base->model);
      if (local_write_options->write_models)
	write_test_head(stdout, "  Edge    ", 9L, dimension - 5L,
			" Models ", 8L, local_write_options,
			local_test_labels);
      else
	write_test_head(stdout, "          ", 0L, -1L, " Edge ", 6L,
			local_write_options, local_test_labels);
      in_fact_inter = true;
      if (c_partitioning || mixed_data)
	test_one_inter_part(&link_current->model, &link_base->model,
			    *vertex_order, &local_write_options,
			    &local_test_labels);
      else
	test_one_inter_fast(&link_current->model, &link_base->model,
			    *vertex_order, &local_write_options,
			    &local_test_labels);
      proc_sum_up_partitioning(1L, &c_partitioning, &local_write_options,
			       &local_test_labels, dimension + 6L);
      in_fact_inter = false;
      if (local_write_options->line_form)
	write_line(stdout);
      note_command_end_pch(stdout, " Test factorized", 16L);
    }
  }
  _Free(local_write_options);
  _Free(local_test_labels);
}  /* fact_inter_argument */


Static Void proc_fact_inter(command_file, as_argument, ifail, sub_code,
			    arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  t_vertex_list *vertex_order = NULL;
  t_integer i = PCH_START;

  if (em) {
    write_pch(stdout, " Not when EM", 12L);
    return;
  }
  if (*sub_code == 1) {
    if (get_vertex_list(command_file, true, true, false, as_argument, &i,
			ifail, sub_code, arg_pos, nargs, arg_char,
			" Order->", 8L, &vertex_order, &vertex_order))
      revers_vertex_list(&vertex_order);
  }
  write_line_diary();
  if (test_current_submodel_of_base_ifail(ifail, false))
    fact_inter_argument(&vertex_order);
  dispose_vertex_list(&vertex_order);
}  /* proc_fact_inter */


/*@+"maindrop.p"*/


/*

2655:    +++  ++
2656:    +++  ++
2657:    ---  -- p/maindrop.p        40     208    2571 p/maindrop.p
2658: |    4:    procedure proc_fix_edges
2659: |   26:    procedure proc_and_fix_edges
2660: |   48:    procedure after_edit_drop
2661: |   76:    procedure after_edit_add
2662: |  107:    procedure proc_drop_edges
2663: |  141:    procedure proc_add_edges
2664: |  168:    procedure proc_drop_interactions
2665: |  194:    procedure proc_add_interactions
2666: |  220:    procedure proc_add_fill_in
2667: |  239:    procedure proc_generate_graphical
2668: |  257:    function collaps_model_argument
2669: |  346:    procedure proc_collaps_model
2670: |  378:    procedure proc_meet_models
2671: |  415:    procedure proc_join_models
2672: |  452:    procedure proc_difference_models
2673: |  486:    procedure proc_normal_to_dual
2674: |  513:    procedure proc_dual_to_normal
2675: |  540:    procedure proc_remove_generator
2676: |  567:    procedure proc_drop_generator_total
2677: |  594:    procedure proc_reduce_generator
2678: |  621:    procedure proc_drop_factor
2679: |  649:    procedure proc_connected_components
2680: |  700:    procedure proc_connected_component
2681: |  760:    procedure return_shortest_paths
2682: |  774:    procedure proc_shortest_paths
2683: |  827:    procedure return_all_cut_sets
2684: |  841:    procedure proc_all_cut_sets
2685: |  894:    procedure find_minimal_cut_sets_sets
2686: |  941:    procedure return_all_cut_sets_sets
2687: |  960:    procedure proc_all_cut_sets_sets
2688: | 1026:    function is_tree
2689: | 1038:    function is_connected
2690: | 1056:    function is_graphical_or_decomposable_argument
2691: | 1109:    procedure proc_is_graphical_or_decomposable
2692: | 1133:    function is_submodel_of_argument
2693: | 1171:    procedure proc_is_submodel_of
2694: | 1199:    procedure proc_is_in_one_clique
2695: | 1244:    function is_decomposition
2696: | 1301:    procedure proc_is_decomposition
2697: | 1398:    procedure proc_slice
2698:    +++  ++
2699:    +++  ++

*/

Static Void proc_fix_edges(command_file, as_argument, ifail, sub_code,
			   arg_pos_char, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char;
long **nargs;
Char **arg_char;
{
  t_set_list *gc = NULL;
  t_integer i = PCH_START;

  if (!get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			   ifail, sub_code, arg_pos_char, nargs, arg_char,
			   " GC->", 5L, &fix_edges_gc, &gc))
    return;
  fix_edges_argument(&gc);
  note_command_end_pch(stdout, " Fix read", 9L);
  note_command_end_line(stdout);
}  /* proc_fix_edges */


Static Void proc_and_fix_edges(command_file, as_argument, ifail, sub_code,
			       arg_pos_char, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char;
long **nargs;
Char **arg_char;
{
  t_set_list *gc = NULL;
  t_integer i = PCH_START;

  if (!get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			   ifail, sub_code, arg_pos_char, nargs, arg_char,
			   " GC->", 5L, &fix_edges_gc, &gc))
    return;
  and_fix_edges_argument(&gc);
  note_command_end_pch(stdout, " Fix read", 9L);
  note_command_end_line(stdout);
}  /* proc_and_fix_edges */


Static Void after_edit_drop(as_argument, ifail, sub_code, arg_pos_char,
			    arg_pos_int, nargs, arg_char, arg_int)
boolean *as_argument;
t_integer *ifail, *sub_code, *arg_pos_char, *arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *g_c_current, *g_c_last;
  boolean no_change;

  if (!*as_argument) {
    write_model(&link_model_list->model, false);
    note_command_end_pch(stdout, " Model generated", 16L);
    note_command_end_line(stdout);
  }
  test_current_against_base(&link_model_list->model, &link_base->model);
  g_c_current = return_g_c_copy_for_mixed_model(&link_current->model);
  g_c_last = return_g_c_copy_for_mixed_model(&link_model_list->model);
  no_change = test_sub_g_c(g_c_current, g_c_last);
  dispose_g_c_copy_for_mixed_model(&link_current->model, &g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_model_list->model, &g_c_last);
  if (ok_int_arg(ifail, *arg_pos_int, 1L, nargs, arg_int))
    report_boolean(!no_change, *as_argument, ifail, *arg_pos_int, nargs,
		   arg_int);
  else
    set_ifail(ifail, 0L);
}  /* after_edit_drop */


Static Void after_edit_add(as_argument, ifail, sub_code, arg_pos_char,
			   arg_pos_int, nargs, arg_char, arg_int)
boolean *as_argument;
t_integer *ifail, *sub_code, *arg_pos_char, *arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *g_c_current, *g_c_last;
  boolean no_change;

  if (!*as_argument) {
    write_model(&link_model_list->model, false);
    note_command_end_pch(stdout, " Model generated", 16L);
    note_command_end_line(stdout);
  }
  if (link_base == link_current)
    test_current_against_base(&link_base->model, &link_model_list->model);
  else
    test_current_against_base(&link_model_list->model, &link_base->model);
  g_c_current = return_g_c_copy_for_mixed_model(&link_current->model);
  g_c_last = return_g_c_copy_for_mixed_model(&link_model_list->model);
  no_change = test_sub_g_c(g_c_last, g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_current->model, &g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_model_list->model, &g_c_last);
  if (ok_int_arg(ifail, *arg_pos_int, 1L, nargs, arg_int))
    report_boolean(!no_change, *as_argument, ifail, *arg_pos_int, nargs,
		   arg_int);
  else
    set_ifail(ifail, 0L);
}  /* after_edit_add */


/* Local variables for proc_drop_edges: */
struct LOC_proc_drop_edges {
  boolean as_argument;
} ;


Static Void proc_drop_edges(command_file, as_argument_, ifail, sub_code,
			    arg_pos_char, arg_pos_int, nargs, arg_char,
			    arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_drop_edges Local_Var;
  t_set_list *p = NULL;
  t_set_list *g_c_old;
  t_integer i = PCH_START;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  if (!current_and_base_ifail(ifail))
    return;
  if (!get_gc(command_file, true, true, false, Local_Var.as_argument, &i,
	      ifail, sub_code, arg_pos_char, nargs, arg_char, &p, &p))
    return;
  /* ' GC->@@@@@', 5, */
  g_c_old = return_g_c_copy_for_mixed_model(&link_current->model);
  if (test_sub_g_c(p, g_c_old)) {
    new_model_in_list(&link_model_list, &first_model_available);
    drop_edge(&link_model_list->model, &link_current->model, &p);
    dispose_set_list(&p);
    after_edit_drop(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		    &arg_pos_int, nargs, arg_char, arg_int);
  } else {
    write_pch(stdout, " Edges not in CURRENT model!", 28L);
    write_line(stdout);
  }
  dispose_g_c_copy_for_mixed_model(&link_current->model, &g_c_old);
}  /* proc_drop_edges */


/* Local variables for proc_add_edges: */
struct LOC_proc_add_edges {
  boolean as_argument;
} ;


Static Void proc_add_edges(command_file, as_argument_, ifail, sub_code,
			   arg_pos_char, arg_pos_int, nargs, arg_char,
			   arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_add_edges Local_Var;
  t_set_list *p = NULL;
  t_integer i = PCH_START;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  if (!current_and_base_ifail(ifail))
    return;
  if (!get_gc(command_file, true, true, false, Local_Var.as_argument, &i,
	      ifail, sub_code, arg_pos_char, nargs, arg_char, &p, &p))
    return;
  /* ' GC->@@@@@', 5, */
  new_model_in_list(&link_model_list, &first_model_available);
  add_edge(&link_model_list->model, &link_current->model, &p);
  dispose_set_list(&p);
  after_edit_add(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		 &arg_pos_int, nargs, arg_char, arg_int);
}  /* proc_add_edges */


/* Local variables for proc_drop_interactions: */
struct LOC_proc_drop_interactions {
  boolean as_argument;
} ;


Static Void proc_drop_interactions(command_file, as_argument_, ifail,
  sub_code, arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_drop_interactions Local_Var;
  t_set_list *p = NULL;
  t_integer i = PCH_START;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  if (!current_and_base_ifail(ifail))
    return;
  if (!get_gc(command_file, true, true, false, Local_Var.as_argument, &i,
	      ifail, sub_code, arg_pos_char, nargs, arg_char, &p, &p))
    return;
  /* ' GC->@@@@@', 5, */
  new_model_in_list(&link_model_list, &first_model_available);
  drop_interactions(&link_model_list->model, &link_current->model, &p,
		    sub_code);
  after_edit_drop(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		  &arg_pos_int, nargs, arg_char, arg_int);
}  /* proc_drop_interactions */


/* Local variables for proc_add_interactions: */
struct LOC_proc_add_interactions {
  boolean as_argument;
} ;


Static Void proc_add_interactions(command_file, as_argument_, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_add_interactions Local_Var;
  t_set_list *p = NULL;
  t_integer i = PCH_START;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  if (!current_and_base_ifail(ifail))
    return;
  if (!get_gc(command_file, true, true, false, Local_Var.as_argument, &i,
	      ifail, sub_code, arg_pos_char, nargs, arg_char, &p, &p))
    return;
  /* ' GC->@@@@@', 5, */
  new_model_in_list(&link_model_list, &first_model_available);
  add_interactions(&link_model_list->model, &link_current->model, &p);
  after_edit_add(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		 &arg_pos_int, nargs, arg_char, arg_int);
}  /* proc_add_interactions */


/* Local variables for proc_add_fill_in: */
struct LOC_proc_add_fill_in {
  boolean as_argument;
} ;


Static Void proc_add_fill_in(command_file, as_argument_, ifail, sub_code,
			     arg_pos_char, arg_pos_int, nargs, arg_char,
			     arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_add_fill_in Local_Var;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  if (!current_and_base())
    return;
  new_model_in_list(&link_model_list, &first_model_available);
  erase_model(&link_model_list->model, link_current->model->id->model_type,
	      false);
  generate_decomposable_model(&link_model_list->model, &link_current->model);
  after_edit_add(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		 &arg_pos_int, nargs, arg_char, arg_int);
}  /* proc_add_fill_in */


/* Local variables for proc_generate_graphical: */
struct LOC_proc_generate_graphical {
  boolean as_argument;
} ;


Static Void proc_generate_graphical(command_file, as_argument_, ifail,
  sub_code, arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_generate_graphical Local_Var;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  if (!current_and_base())
    return;
  new_model_in_list(&link_model_list, &first_model_available);
  generate_graphical_model(&link_model_list->model, &link_current->model);
  after_edit_add(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		 &arg_pos_int, nargs, arg_char, arg_int);
}  /* proc_generate_graphical */


Static boolean collaps_model_argument(as_argument, sub_code, a)
boolean as_argument;
t_integer *sub_code;
long *a;
{
  t_vertex_set r;
  t_set_list *g_c_current, *g_c, *new_g_c;
  t_model_list *link_model;
  boolean ok, marginalize;

  P_setcpy(r, empty_set);
  if (mixed_data)
    note_mixed(stdout, " CollapsModelArgumnt", 20L);
  if (current()) {
    ok = true;
    new_model_in_list(&link_model_list, &first_model_available);
    /* p_list := return_atoms_from_expression(link_current^.model); */
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 2668L, 1L)) {   /* p_list, */
      write_char(stdout, '<');
      print_vertex_set(a);
      write_char(stdout, ':');
      g_c_current = return_g_c_copy_for_mixed_model(&link_current->model);
      print_g_c(g_c_current, 0L, line_length);
      dispose_g_c_copy_for_mixed_model(&link_current->model, &g_c_current);
      write_char(stdout, '>');
      write_line(stdout);
    }
    /*$endif TRACE*/
    return_collaps_set(a, &link_current->model, r);
    if (!P_setequal(r, link_current->model->id->vertices))
      return_restricted_discrete_model(&link_model_list->model,
				       &link_current->model, r);
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 2668L, 1L)) {
      write_char(stdout, '<');
      print_vertex_set(r);
      write_integer(stdout, *sub_code, 2L);
      write_char(stdout, '>');
      write_line(stdout);
    }
    /*$endif TRACE*/
    marginalize = (*sub_code == 2);
    marginalize = (marginalize || *sub_code == -2);
    if (!P_setequal(r, link_current->model->id->vertices) ||
	marginalize && !P_setequal(a, link_current->model->id->vertices)) {
      return_restricted_discrete_model(&link_model_list->model,
				       &link_current->model, r);
      if (marginalize) {
	g_c = return_g_c_copy_for_mixed_model(&link_model_list->model);
	P_setcpy(link_model_list->model->id->vertices, a);
	marginalize_model(r, &g_c, a, &new_g_c);
	dispose_g_c_copy_for_mixed_model(&link_model_list->model, &g_c);
	dispose_set_list(&g_c);
	/*$ifdef TRACE*/
	if (trace_flag_set(20L, 2668L, 1L)) {
	  write_char(stdout, '[');
	  print_vertex_set(r);
	  write_char(stdout, ':');
	  print_g_c(new_g_c, 0L, line_length);
	  write_char(stdout, ']');
	  write_line(stdout);
	}
	/*$endif TRACE*/
      }
      if (!as_argument) {
	write_line_diary();
	write_pch(stdout, " Collaps on:        ", 20L);
	print_vertex_set_table(r);
	write_line(stdout);
	write_model(&link_model_list->model, false);
	note_command_end_pch(stdout, " Model generated", 16L);
	write_line(stdout);
      }
    } else {
      ok = false;
      link_model = link_model_list;
      link_model_list = link_model_list->pointer;
      _Free(link_model);
      write_line_diary();
      write_pch(stdout, " No model generated", 19L);
      write_line(stdout);
    }
  }
  P_setcpy(a, r);
  return ok;
}  /* collaps_model_argument */


Static Void proc_collaps_model(command_file, as_argument, ifail, sub_code,
			       arg_pos_char, arg_pos_int, nargs, arg_char,
			       arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_vertex_set a;
  t_integer sub_code_ = 1, i = PCH_START;
  boolean full = true;
  boolean ok;

  P_setcpy(a, empty_set);
  if (!current_ifail(ifail))
    return;
  if (!get_vertex_set(command_file, true, true, false, as_argument, &i, ifail,
		      &sub_code_, arg_pos_char, nargs, arg_char, " SET->",
		      6L, a, a))
    return;
  ok = collaps_model_argument(as_argument, sub_code, a);
  if (ok_int_arg(ifail, arg_pos_int, 1L, nargs, arg_int))
    report_boolean(ok, as_argument, ifail, arg_pos_int, nargs, arg_int);
  else
    set_ifail(ifail, 0L);
  if (!ok_char_arg(ifail, arg_pos_char, (long)PCH_START, nargs, arg_char))
    return;
  i = PCH_START;
  return_vertex_set_in_pch(a, &full, *arg_char, &i, &arg_pos_char);
  set_string_end(&i, ifail, arg_pos_char, nargs, arg_char);
}  /* proc_collaps_model */


Static Void proc_meet_models(command_file, as_argument, ifail, sub_code,
			     arg_pos_char, arg_pos_int, nargs, arg_char,
			     arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *g_c_current, *g_c_last;
  boolean no_change;

  if (!current_and_base())
    return;
  if (!test_identical_c_s_ifail(link_base->model, link_current->model, ifail))
    return;
  new_model_in_list(&link_model_list, &first_model_available);
  meet_models(&link_model_list->model, &link_current->model,
	      &link_base->model, true);
  if (!as_argument) {
    write_model(&link_model_list->model, false);
    note_command_end_pch(stdout, " Model generated", 16L);
    note_command_end_line(stdout);
  }
  test_current_against_base(&link_model_list->model, &link_current->model);
  g_c_current = return_g_c_copy_for_mixed_model(&link_current->model);
  g_c_last = return_g_c_copy_for_mixed_model(&link_model_list->model);
  no_change = test_sub_g_c(g_c_current, g_c_last);
  dispose_g_c_copy_for_mixed_model(&link_current->model, &g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_model_list->model, &g_c_last);
  if (ok_int_arg(ifail, arg_pos_int, 1L, nargs, arg_int))
    report_boolean(!no_change, as_argument, ifail, arg_pos_int, nargs,
		   arg_int);
  else
    set_ifail(ifail, 0L);
}  /* proc_meet_models */


Static Void proc_join_models(command_file, as_argument, ifail, sub_code,
			     arg_pos_char, arg_pos_int, nargs, arg_char,
			     arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *g_c_current, *g_c_last;
  boolean no_change;

  if (!current_and_base())
    return;
  if (!test_identical_c_s_ifail(link_base->model, link_current->model, ifail))
    return;
  new_model_in_list(&link_model_list, &first_model_available);
  join_models(&link_model_list->model, &link_current->model,
	      &link_base->model, true);
  if (!as_argument) {
    write_model(&link_model_list->model, false);
    note_command_end_pch(stdout, " Model generated", 16L);
    note_command_end_line(stdout);
  }
  test_current_against_base(&link_current->model, &link_model_list->model);
  g_c_current = return_g_c_copy_for_mixed_model(&link_current->model);
  g_c_last = return_g_c_copy_for_mixed_model(&link_model_list->model);
  no_change = test_sub_g_c(g_c_last, g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_current->model, &g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_model_list->model, &g_c_last);
  if (ok_int_arg(ifail, arg_pos_int, 1L, nargs, arg_int))
    report_boolean(!no_change, as_argument, ifail, arg_pos_int, nargs,
		   arg_int);
  else
    set_ifail(ifail, 0L);
}  /* proc_join_models */


Static Void proc_difference_models(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *g_c_current, *g_c_last;
  boolean no_change, edges;

  if (!current_and_base())
    return;
  new_model_in_list(&link_model_list, &first_model_available);
  edges = (*sub_code == 1);
  difference_models(&link_model_list->model, &link_base->model,
		    &link_current->model, edges);
  if (!as_argument) {
    write_model(&link_model_list->model, false);
    note_command_end_pch(stdout, " Model generated", 16L);
    note_command_end_line(stdout);
  }
  g_c_current = return_g_c_copy_for_mixed_model(&link_current->model);
  g_c_last = return_g_c_copy_for_mixed_model(&link_model_list->model);
  no_change = test_sub_g_c(g_c_last, g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_current->model, &g_c_current);
  dispose_g_c_copy_for_mixed_model(&link_model_list->model, &g_c_last);
  if (ok_int_arg(ifail, arg_pos_int, 1L, nargs, arg_int))
    report_boolean(!no_change, as_argument, ifail, arg_pos_int, nargs,
		   arg_int);
  else
    set_ifail(ifail, 0L);
}  /* proc_difference_models */


Static Void proc_normal_to_dual(as_argument)
boolean as_argument;
{
  /* var command_file  : text; */
  /*;
                              var ifail, sub_code : t_integer;
  arg_pos_char  : t_integer;
                              var nargs  : t_p_int_array;
                              var arg_char  : t_p_char_array */
  t_set_list *g_c_old, *g_c_new;

  if (mixed_data) {
    note_mixed(stdout, " ProcNormalToDual", 17L);
    return;
  }
  if (!current())
    return;
  g_c_old = return_g_c_copy(&link_current->model);
  normal_to_dual(g_c_old, delta_gamma, &g_c_new);
  insert_g_c_in_new_model(&g_c_new, delta_gamma,
    &link_current->model->id->causal_structure,
    link_current->model->id->UU.U1.full_specified,
    link_current->model->id->UU.U1.homogeneous);
  dispose_set_list(&g_c_old);
  /* link_model_list^.model^.id^.vertices := delta_gamma; */
  if (as_argument)
    return;
  write_model(&link_model_list->model, false);
  note_command_end_pch(stdout, " Model generated", 16L);
  note_command_end_line(stdout);
}  /* proc_normal_to_dual */


Static Void proc_dual_to_normal(as_argument)
boolean as_argument;
{
  /* var command_file  : text; */
  /* ;
                              var ifail, sub_code : t_integer;
  arg_pos_char  : t_integer;
                              var nargs  : t_p_int_array;
                              var arg_char  : t_p_char_array */
  t_set_list *g_c_old, *g_c_new;

  if (mixed_data) {
    note_mixed(stdout, " ProcDualToNormal", 17L);
    return;
  }
  if (!current())
    return;
  g_c_old = return_g_c_copy(&link_current->model);
  dual_to_normal(g_c_old, delta_gamma, &g_c_new);
  insert_g_c_in_new_model(&g_c_new, delta_gamma,
    &link_current->model->id->causal_structure,
    link_current->model->id->UU.U1.full_specified,
    link_current->model->id->UU.U1.homogeneous);
  dispose_set_list(&g_c_old);
  /* link_model_list^.model^.id^.vertices := delta_gamma; */
  if (as_argument)
    return;
  write_model(&link_model_list->model, false);
  note_command_end_pch(stdout, " Model generated", 16L);
  note_command_end_line(stdout);
}  /* proc_dual_to_normal */


/* Local variables for proc_remove_generator: */
struct LOC_proc_remove_generator {
  boolean as_argument;
} ;


Static Void proc_remove_generator(command_file, as_argument_, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_remove_generator Local_Var;
  t_vertex_set a;
  t_integer i = PCH_START;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  P_setcpy(a, empty_set);
  if (!current_and_base_ifail(ifail))
    return;
  if (!get_vertex_set(command_file, true, true, false, Local_Var.as_argument,
		      &i, ifail, sub_code, arg_pos_char, nargs, arg_char,
		      " SET->", 6L, a, a))
    return;
  new_model_in_list(&link_model_list, &first_model_available);
  remove_generator(&link_model_list->model, &link_current->model, a);
  after_edit_drop(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		  &arg_pos_int, nargs, arg_char, arg_int);
}  /* proc_remove_generator */


/* Local variables for proc_drop_generator_total: */
struct LOC_proc_drop_generator_total {
  boolean as_argument;
} ;


Static Void proc_drop_generator_total(command_file, as_argument_, ifail,
  sub_code, arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_drop_generator_total Local_Var;
  t_vertex_set a;
  t_integer i = PCH_START;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  P_setcpy(a, empty_set);
  if (!current_and_base_ifail(ifail))
    return;
  if (!get_vertex_set(command_file, true, true, false, Local_Var.as_argument,
		      &i, ifail, sub_code, arg_pos_char, nargs, arg_char,
		      " SET->", 6L, a, a))
    return;
  new_model_in_list(&link_model_list, &first_model_available);
  drop_total_generator(&link_model_list->model, &link_current->model, a);
  after_edit_drop(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		  &arg_pos_int, nargs, arg_char, arg_int);
}  /* proc_drop_generator_total */


/* Local variables for proc_reduce_generator: */
struct LOC_proc_reduce_generator {
  boolean as_argument;
} ;


Static Void proc_reduce_generator(command_file, as_argument_, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_reduce_generator Local_Var;
  t_vertex_set a;
  t_integer i = PCH_START;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  P_setcpy(a, empty_set);
  if (!current_and_base_ifail(ifail))
    return;
  if (!get_vertex_set(command_file, true, true, false, Local_Var.as_argument,
		      &i, ifail, sub_code, arg_pos_char, nargs, arg_char,
		      " SET->", 6L, a, a))
    return;
  new_model_in_list(&link_model_list, &first_model_available);
  reduce_generator(&link_model_list->model, &link_current->model, a);
  after_edit_drop(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		  &arg_pos_int, nargs, arg_char, arg_int);
}  /* proc_reduce_generator */


/* Local variables for proc_drop_factor: */
struct LOC_proc_drop_factor {
  boolean as_argument;
} ;


Static Void proc_drop_factor(command_file, as_argument_, ifail, sub_code,
			     arg_pos_char, arg_pos_int, nargs, arg_char,
			     arg_int)
FILE *command_file;
boolean as_argument_;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  struct LOC_proc_drop_factor Local_Var;
  t_vertex v;
  t_integer i = PCH_START;

  Local_Var.as_argument = as_argument_;
  if (link_base == NULL)
    link_base = link_current;
  if (!current_and_base_ifail(ifail))
    return;
  v = first_vertex;
  if (!get_vertex(command_file, true, true, false, Local_Var.as_argument, &i,
		  ifail, sub_code, arg_pos_char, nargs, arg_char,
		  " FACTOR-> ", 9L, &v, &v))
    return;
  new_model_in_list(&link_model_list, &first_model_available);
  drop_factor(&link_model_list->model, &link_current->model, &v);
  after_edit_drop(&Local_Var.as_argument, ifail, sub_code, &arg_pos_char,
		  &arg_pos_int, nargs, arg_char, arg_int);
}  /* proc_drop_factor */


Static Void proc_connected_components(command_file, as_argument, ifail,
  sub_code, arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *gc = NULL;
  boolean dummy_empty_gc, full;
  t_set_list *paths;
  t_integer i = PCH_START;

  *sub_code = 1;
  if (!get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			   ifail, sub_code, arg_pos_char, nargs, arg_char,
			   " GC->", 5L, &gc, &gc))
    return;
  dummy_empty_gc = model_if_empty_gc(&gc, ifail, -2L);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2679L, 1L)) {
    write_char(stdout, '<');
    print_g_c(gc, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  return_connected_components(&gc, &paths);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2679L, 1L)) {
    write_char(stdout, '[');
    print_g_c(paths, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, ']');
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (ok_char_arg(ifail, arg_pos_char, (long)PCH_START, nargs, arg_char)) {
    i = PCH_START;
    full = true;
    return_g_c_in_pch(paths, &full, *arg_char, &i, &(*nargs)[arg_pos_char]);
    set_string_end(&i, ifail, arg_pos_char, nargs, arg_char);
  }
  dispose_set_list(&gc);
}  /* proc_connected_components */


Static Void proc_connected_component(command_file, as_argument, ifail,
  sub_code, arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *p;
  t_set_list *gc = NULL;
  t_vertex_set a;
  boolean dummy_empty_gc, full;
  t_set_list *paths;
  t_integer i = PCH_START;

  *sub_code = 1;
  if (!get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			   ifail, sub_code, arg_pos_char, nargs, arg_char,
			   " GC->", 5L, &gc, &gc))
    return;
  p = gc;
  P_setcpy(a, empty_set);
  if (gc != NULL) {
    P_setcpy(a, gc->vertex_set);
    gc = gc->pointer;
  }
  dummy_empty_gc = model_if_empty_gc(&gc, ifail, -2L);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2680L, 1L)) {
    write_char(stdout, '<');
    print_vertex_set(a);
    write_char(stdout, ':');
    print_g_c(gc, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  return_connected_component(a, &gc, &paths);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2680L, 1L)) {
    write_char(stdout, '[');
    print_g_c(paths, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, ']');
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (ok_char_arg(ifail, arg_pos_char, (long)PCH_START, nargs, arg_char)) {
    i = PCH_START;
    full = true;
    return_g_c_in_pch(paths, &full, *arg_char, &i, &(*nargs)[arg_pos_char]);
    set_string_end(&i, ifail, arg_pos_char, nargs, arg_char);
  }
  dispose_set_list(&p);
}  /* proc_connected_component */


Static Void return_shortest_paths(v, w, g_c, paths)
t_vertex *v, *w;
t_set_list **g_c, **paths;
{
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_v_lists adj_list;
  t_vertex_set g;

  hypergraph_sets_to_graph_sets(*g_c, g, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  *paths = NULL;
  find_shortest_path(v, w, adj_list, paths);
}  /* return_shortest_paths */


Static Void proc_shortest_paths(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *gc;
  t_vertex v, w;
  boolean dummy_empty_gc, full;
  t_set_list *paths;
  t_integer i;

  *sub_code = 1;
  get_two_vertices_and_set_list(command_file, as_argument, true, ifail,
				sub_code, arg_pos_char, nargs, arg_char, &v,
				&w, &gc);
  if (*ifail != 0)
    return;
  dummy_empty_gc = model_if_empty_gc(&gc, ifail, -2L);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2681L, 1L)) {
    write_char(stdout, '<');
    print_vertex(v);
    write_char(stdout, ',');
    print_vertex(w);
    write_char(stdout, '|');
    print_g_c(gc, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  return_shortest_paths(&v, &w, &gc, &paths);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2681L, 1L)) {
    write_char(stdout, '[');
    print_g_c(paths, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, ']');
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (ok_char_arg(ifail, arg_pos_char, (long)PCH_START, nargs, arg_char)) {
    i = PCH_START;
    full = true;
    return_g_c_in_pch(paths, &full, *arg_char, &i, &(*nargs)[arg_pos_char]);
    set_string_end(&i, ifail, arg_pos_char, nargs, arg_char);
  }
  dispose_set_list(&gc);
}  /* proc_shortest_paths */


Static Void return_all_cut_sets(v, w, g_c, cut_sets)
t_vertex *v, *w;
t_set_list **g_c, **cut_sets;
{
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_v_lists adj_list;
  t_vertex_set a;

  hypergraph_sets_to_graph_sets(*g_c, a, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  find_minimal_cut_sets(v, w, adj_list, cut_sets);
  dispose_adj_list(adj_list);
}  /* return_all_cut_sets */


Static Void proc_all_cut_sets(command_file, as_argument, ifail, sub_code,
			      arg_pos_char, arg_pos_int, nargs, arg_char,
			      arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *gc;
  t_vertex v, w;
  boolean dummy_empty_gc, full;
  t_set_list *paths;
  t_integer i;

  *sub_code = 1;
  get_two_vertices_and_set_list(command_file, as_argument, true, ifail,
				sub_code, arg_pos_char, nargs, arg_char, &v,
				&w, &gc);
  if (*ifail != 0)
    return;
  dummy_empty_gc = model_if_empty_gc(&gc, ifail, -2L);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2684L, 1L)) {
    write_char(stdout, '<');
    print_vertex(v);
    write_char(stdout, ',');
    print_vertex(w);
    write_char(stdout, '|');
    print_g_c(gc, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  return_all_cut_sets(&v, &w, &gc, &paths);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2684L, 1L)) {
    write_char(stdout, '[');
    print_g_c(paths, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, ']');
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (ok_char_arg(ifail, arg_pos_char, (long)PCH_START, nargs, arg_char)) {
    i = PCH_START;
    full = true;
    return_g_c_in_pch(paths, &full, *arg_char, &i, &(*nargs)[arg_pos_char]);
    set_string_end(&i, ifail, arg_pos_char, nargs, arg_char);
  }
  dispose_set_list(&gc);
}  /* proc_all_cut_sets */


Static Void find_minimal_cut_sets_sets(a, b, adj_list, cut_sets)
long *a, *b;
t_vertex_list **adj_list;
t_set_list **cut_sets;
{
  t_vertex v, w;
  t_set_list *p;
  t_set_list *paths = NULL;

  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, a)) {
      for (w = first_vertex; w <= last_vertex; w++) {
	if (P_inset(w, b))
	  find_shortest_path(&v, &w, adj_list, &paths);
      }
    }
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2685L, 1L)) {
    write_pch(stdout, "Paths :   ", 10L);
    if (paths != NULL)
      print_g_c(paths, 10L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (paths == NULL) {
    *cut_sets = NULL;
    return;
  }
  p = paths;
  while (p != NULL) {
    P_setdiff(p->vertex_set, delta_gamma, p->vertex_set);
    p = p->pointer;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2685L, 1L)) {
    write_pch(stdout, "*\\Paths : ", 10L);
    print_g_c(paths, 10L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  normal_to_dual(paths, delta_gamma, cut_sets);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2685L, 1L)) {
    write_pch(stdout, "Cut Sets: ", 10L);
    print_g_c(*cut_sets, 10L, line_length);
    write_line(stdout);
  }
  /*$endif TRACE*/
  dispose_set_list(&paths);
}  /* find_minimal_cut_sets_sets */


Static Void return_all_cut_sets_sets(a, b, g_c, cut_sets)
long *a, *b;
t_set_list **g_c, **cut_sets;
{
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_v_lists adj_list;
  t_vertex_set g;

  P_setint(g, a, b);
  if (!P_setequal(g, empty_set)) {
    *cut_sets = NULL;
    return;
  }
  hypergraph_sets_to_graph_sets(*g_c, g, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  find_minimal_cut_sets_sets(a, b, adj_list, cut_sets);
  dispose_adj_list(adj_list);
}  /* return_all_cut_sets_sets */


Static Void proc_all_cut_sets_sets(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *p;
  t_set_list *gc = NULL;
  t_vertex_set a, b;
  boolean dummy_empty_gc, full;
  t_set_list *paths;
  t_integer i = PCH_START;

  *sub_code = 1;
  if (!get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			   ifail, sub_code, arg_pos_char, nargs, arg_char,
			   " GC->", 5L, &gc, &gc))
    return;
  p = gc;
  P_setcpy(a, empty_set);
  P_setcpy(b, empty_set);
  if (gc != NULL) {
    P_setcpy(a, gc->vertex_set);
    gc = gc->pointer;
  }
  if (gc != NULL) {
    P_setcpy(b, gc->vertex_set);
    gc = gc->pointer;
  }
  dummy_empty_gc = model_if_empty_gc(&gc, ifail, -2L);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2687L, 1L)) {
    write_char(stdout, '<');
    print_vertex_set(a);
    write_char(stdout, ',');
    print_vertex_set(b);
    write_char(stdout, ':');
    print_g_c(gc, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  return_all_cut_sets_sets(a, b, &gc, &paths);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2687L, 1L)) {
    write_char(stdout, '[');
    print_g_c(paths, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, ']');
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (ok_char_arg(ifail, arg_pos_char, (long)PCH_START, nargs, arg_char)) {
    i = PCH_START;
    full = true;
    return_g_c_in_pch(paths, &full, *arg_char, &i, &(*nargs)[arg_pos_char]);
    set_string_end(&i, ifail, arg_pos_char, nargs, arg_char);
  }
  dispose_set_list(&p);
}  /* proc_all_cut_sets_sets */


Static boolean is_tree(p)
t_set_list *p;
{
  boolean ok = true;

  while (p != NULL && ok) {
    ok = (cardinality(p->vertex_set) <= 2);
    p = p->pointer;
  }
  return ok;
}  /* is_tree */


Static boolean is_connected(g_c)
t_set_list **g_c;
{
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_v_lists adj_list;
  t_vertex_set g, a;
  t_vertex u;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IsConnected        ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 2688L, 1L, -1L, -1L, g_c);
  /*$endif TRACE*/
  hypergraph_sets_to_graph_sets(*g_c, g, adj_set);
  adj_set_to_adj_list(adj_set, adj_list);
  u = first_vertex;
  /*$ifdef TRACE*/
  ntr_vertex_and_set(tzt, 20L, 2688L, 1L, -1L, -2L, &u, g);
  /*$endif TRACE*/
  while (!P_inset(u, g) && u < MAX_VERTEX)
    u++;
  if (P_inset(u, g)) {
    P_setcpy(a, empty_set);
    find_connected_component(g, empty_set, a, &u, adj_list);
    /*$ifdef TRACE*/
    ntr_set(tzt, 20L, 2688L, 1L, -1L, -3L, a);
    /*$endif TRACE*/
    dispose_adj_list(adj_list);
    return P_setequal(a, g);
  } else
    return true;
}  /* is_connected */


Static boolean is_graphical_or_decomposable_argument(code, h_g_c, ifail)
t_integer *code;
t_set_list **h_g_c;
t_integer *ifail;
{
  boolean Result = false, ok = false;
  boolean decomposable, graphical, tree, connected;
  t_set_list *d_g_c, *g_g_c;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnMixedCharArg ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 2689L, 1L, *ifail, *code, h_g_c);
  /*$endif TRACE*/
  if (P_setequal((*h_g_c)->vertex_set, empty_set)) {
    if (current_ifail(ifail)) {
      if (*code == 5) {
	ok = true;
	*h_g_c = return_g_c_copy(&link_current->model);
	connected = is_connected(h_g_c);
	dispose_set_list(h_g_c);
      } else {
	if (link_current->model->found_expression) {
	  ok = true;
	  graphical = link_current->model->graphical;
	  decomposable = link_current->model->decomposable;
	  if (graphical && decomposable && *code == 3) {
	    *h_g_c = return_g_c_copy(&link_current->model);
	    tree = is_tree(*h_g_c);
	    dispose_set_list(h_g_c);
	  }
	} else {
	  dispose_set_list(h_g_c);
	  *h_g_c = return_g_c_copy(&link_current->model);
	  find_graphical_and_decomposable_gc(h_g_c, &d_g_c, &g_g_c,
					     &decomposable, &graphical);
	  ok = true;
	  if (graphical && decomposable && *code == 3)
	    tree = is_tree(*h_g_c);
	  dispose_set_list(h_g_c);
	  dispose_set_list(&g_g_c);
	  dispose_set_list(&d_g_c);
	}
      }
    }
  } else {
    if (*code == 5) {
      ok = true;
      connected = is_connected(h_g_c);
    } else {
      find_graphical_and_decomposable_gc(h_g_c, &d_g_c, &g_g_c, &decomposable,
					 &graphical);
      ok = true;
      dispose_set_list(&g_g_c);
      dispose_set_list(&d_g_c);
      if (graphical && decomposable && *code == 3)
	tree = is_tree(*h_g_c);
    }
  }
  /*$ifdef TRACE*/
  ntr_boolean(tzt, 20L, 2689L, 1L, 2L, 0L, ok);
  ntr_boolean(tzt, 20L, 2689L, 1L, 2L, 1L, decomposable);
  ntr_boolean(tzt, 20L, 2689L, 1L, 2L, 2L, graphical);
  ntr_boolean(tzt, 20L, 2689L, 1L, 2L, 3L, tree);
  ntr_boolean(tzt, 20L, 2689L, 1L, 2L, 5L, connected);
  /*$endif TRACE*/
  dispose_set_list(h_g_c);
  if (ok) {
    if (*code == 1 && graphical || *code == 2 && graphical && decomposable ||
	*code == 3 && tree || *code == 5 && connected)
      return true;
  }
  return Result;
}  /* is_graphical_or_decomposable_argument */


Static boolean return_mixed_characteristics_argument(code, h_g_c,
  full_specified, homogeneous, ifail)
t_integer *code;
t_set_list **h_g_c;
boolean full_specified, homogeneous;
t_integer *ifail;
{
  boolean Result = false;
  t_mixed_characteristics *mixed_characteristics = NULL;
  t_model *p;
  t_vertex_set a;
  boolean ok = false;
  t_set_list *tmp_cs;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  tmp_cs = causal_structure;   /* CausalStructure !!! */
  /*$ifdef TRACE*/
  memcpy(tzt, " ReturnMixedCharArg ", sizeof(pch20));
  ntr_g_c(tzt, 20L, 2690L, 1L, -1L, -1L, h_g_c);
  /*$endif TRACE*/
  if (P_setequal((*h_g_c)->vertex_set, empty_set)) {
    if (current_ifail(ifail)) {
      ok = true;
      p = link_current->model;
      if (p->id->model_type == mixed)
	mixed_characteristics = return_mixed_characteristics(&link_current->model);
    }
  } else {
    ok = true;
    P_setcpy(a, empty_set);
    add_union_of_gc(*h_g_c, a);   /* nil !!! */
    insert_g_c_in_new_model(h_g_c, a, &tmp_cs, full_specified, homogeneous);
    p = link_model_list->model;
    if (p->id->model_type == mixed)
      mixed_characteristics = return_mixed_characteristics(&link_model_list->model);
  }
  /* dispose_set_list(h_g_c); */
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2690L, 1L, -2L, -2L);
  /*$endif TRACE*/
  if (ok) {
    switch (*code) {

    case 1:
      break;
      /* ("graphical") */

    case 2:
      break;
      /* ("decomposable") | ("chordal") | ("rigid.circuit") */

    case 3:
      break;
      /* ("tree") */

    case 5:
      break;
      /* ("connected") */

    case 7:   /* ("undirected") | ("skeleton") */
      ni_discrete();
      break;

    case 8:   /* ("moral") */
      ni_discrete();
      break;

    case 9:   /* ("acyclic") */
      ni_discrete();
      break;

    case 11:
      if (mixed_characteristics == NULL)
	ok = true;
      else
	ok = mixed_characteristics->mim_model;
      break;

    case 12:
      if (mixed_characteristics == NULL)
	ok = true;
      else
	ok = mixed_characteristics->degenerated;
      break;

    case 13:
      if (mixed_characteristics == NULL)
	ok = true;
      else
	ok = mixed_characteristics->mean_linear;
      break;

    case 14:
      if (mixed_characteristics == NULL)
	ok = true;
      else
	ok = mixed_characteristics->d_collapsible;
      break;

    case 15:
      if (mixed_characteristics == NULL)
	ok = true;
      else
	ok = mixed_characteristics->q_equivalent;
      break;

    case 16:
      if (p->id->model_type == mixed)
	ok = p->id->UU.U1.homogeneous;
      break;

    case 17:
      if (p->id->model_type == mixed)
	ok = p->id->UU.U1.full_specified;
      break;

    case 21:
      ok = (p->id->model_type == pure_discrete);
      break;

    case 22:
      ok = (p->id->model_type == pure_continuous);
      break;

    case 23:
      ok = (p->id->model_type == mixed);
      break;

    case 24:
      ok = (p->id->model_type == cg_regression);
      break;
    }
  }
  Result = ok;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2690L, 1L, -3L, -3L);
  /*$endif TRACE*/
  if (mixed_characteristics != NULL)
    _Free(mixed_characteristics);
  return Result;
}  /* return_mixed_characteristics_argument */


Static Void proc_property_model(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *gc = NULL;
  t_integer i = PCH_START;
  boolean not_empty_gc;
  /*, dummy_empty_gc */
  boolean ok;

  if (!get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			   ifail, sub_code, arg_pos_char, nargs, arg_char,
			   " GC->", 5L, &gc, &gc))
    return;
  /* dummy_empty_gc := model_if_empty_gc(gc, ifail, -2); */
  /* Not good for mixed! */
  not_empty_gc = (gc != NULL);
  if (not_empty_gc)
    not_empty_gc = !P_setequal(gc->vertex_set, empty_set);
  if (!not_empty_gc) {
    gc = (t_set_list *)Malloc(sizeof(t_set_list));
    if (gc == NULL)
      _OutMem();
    P_setcpy(gc->vertex_set, empty_set);
    gc->pointer = NULL;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2691L, 1L)) {
    write_char(stdout, '<');
    print_g_c(gc, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (*sub_code <= 5)
    ok = is_graphical_or_decomposable_argument(sub_code, &gc, ifail);
  else
    ok = return_mixed_characteristics_argument(sub_code, &gc, false, false,
					       ifail);
  report_boolean(ok, as_argument, ifail, arg_pos_int, nargs, arg_int);
}  /* proc_property_model */


Static boolean is_submodel_of_argument(sub_code, current_g_c, base_g_c, ifail)
t_integer *sub_code;
t_set_list **current_g_c, **base_g_c;
t_integer *ifail;
{
  boolean ok = false;
  boolean dummy;
  t_model_specification *base_id = NULL, *current_id = NULL;
  t_set_list *causal_structure;

  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2692L, 1L)) {
    write_char(stdout, '<');
    print_g_c(*current_g_c, 0L, line_length);
    write_char(stdout, ',');
    print_g_c(*base_g_c, 0L, line_length);
    write_integer(stdout, *sub_code, 2L);
    write_char(stdout, '>');
    write_line(stdout);
    /*$endif TRACE*/
  }
  if (P_setequal((*current_g_c)->vertex_set, empty_set)) {
    /*$ifdef TRACE*/
    if (trace_flag_set(20L, 2692L, 1L)) {
      write_char(stdout, '<');
      write_char(stdout, 'A');
      write_char(stdout, '>');
      write_line(stdout);
    }
    /*$endif TRACE*/
    if (current_and_base_ifail(ifail)) {
      dummy = test_identical_c_s_ifail(link_base->model, link_current->model,
				       ifail);
      if (*sub_code == 1)
	ok = is_submodel(&link_base->model->id, &link_current->model->id,
			 true);
      else
	ok = is_submodel(&link_current->model->id, &link_base->model->id,
			 true);
    }
  } else {
    if (P_setequal((*base_g_c)->vertex_set, empty_set)) {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2692L, 1L)) {
	write_char(stdout, '<');
	write_char(stdout, 'B');
	write_char(stdout, '>');
	write_line(stdout);
      }
      /*$endif TRACE*/
      if (current_ifail(ifail)) {
	/* link_current^.model^.id^.full_specified, */
	insert_g_c_in_id(current_g_c,
			 &link_current->model->id->causal_structure, true,
			 link_current->model->id->UU.U1.homogeneous,
			 &current_id);
	if (*sub_code == 1)
	  ok = is_submodel(&link_current->model->id, &current_id, true);
	else
	  ok = is_submodel(&current_id, &link_current->model->id, true);
	dispose_identification(&current_id);
      }
    } else {
      /*$ifdef TRACE*/
      if (trace_flag_set(20L, 2692L, 1L)) {
	write_char(stdout, '<');
	write_char(stdout, 'C');
	write_char(stdout, '>');
	write_line(stdout);
      }
      /*$endif TRACE*/
      causal_structure = NULL;
      /* full_specified, */
      /* homogeneous */
      insert_g_c_in_id(current_g_c, &causal_structure, true, false,
		       &current_id);
      /* full_specified, */
      /* homogeneous */
      insert_g_c_in_id(base_g_c, &causal_structure, true, false, &base_id);
      if (*sub_code == 1)
	ok = is_submodel(&base_id, &current_id, true);
      else
	ok = is_submodel(&current_id, &base_id, true);
      dispose_identification(&current_id);
      dispose_identification(&base_id);
    }
  }
  dispose_set_list(current_g_c);
  dispose_set_list(base_g_c);
  return ok;
}  /* is_submodel_of_argument */


Static Void proc_is_submodel_of(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *gc1 = NULL, *gc2 = NULL;
  t_integer i = PCH_START;
  boolean ok;

  /* Note gc1 and gc2 are entered as models in R before call with 204 from R. */
  if (!get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			   ifail, sub_code, arg_pos_char, nargs, arg_char,
			   " GC->", 5L, &gc1, &gc1))
    return;
  if (!get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			   ifail, sub_code, arg_pos_char, nargs, arg_char,
			   " GC->", 5L, &gc2, &gc2))
    return;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2693L, 1L)) {
    write_char(stdout, '<');
    print_g_c(gc1, 0L, line_length);
    write_char(stdout, ',');
    print_g_c(gc2, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  ok = is_submodel_of_argument(sub_code, &gc1, &gc2, ifail);
  report_boolean(ok, as_argument, ifail, arg_pos_int, nargs, arg_int);
}  /* proc_is_submodel_of */


Static Void proc_is_in_one_clique(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  t_set_list *gc;
  t_vertex v, w;
  t_vertex_set a;
  boolean ok = true;

  *sub_code = 1;
  get_two_vertices_and_set_list(command_file, as_argument, true, ifail,
				sub_code, arg_pos_char, nargs, arg_char, &v,
				&w, &gc);
  if (*ifail != 0)
    return;
  if (P_setequal(gc->vertex_set, empty_set)) {
    dispose_set_list(&gc);
    if (current_ifail(ifail))
      gc = return_g_c_copy(&link_current->model);
    else
      ok = false;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2694L, 1L)) {
    write_char(stdout, '<');
    print_vertex(v);
    write_char(stdout, ',');
    print_vertex(w);
    write_char(stdout, ':');
    print_g_c(gc, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  if (ok) {
    ok = was_edge_in_one_clique(&v, &w, &gc, a);
    /*
    if ok and mixed_data then begin
       bv :=  [w];
       bv :=  a - bv;
       bw :=  [v];
       bw :=  bv - bw;
       bw :=  bw * gamma_;
       if bw <> empty_set then
          ok := (v in gamma_) or (2 in gamma_)
    end;
     */
    report_boolean(ok, as_argument, ifail, arg_pos_int, nargs, arg_int);
  }
  dispose_set_list(&gc);
}  /* proc_is_in_one_clique */


Static boolean is_decomposition_of_gc(d, a, b, g, g_c, causal_structure)
long *d, *a, *b, *g;
t_set_list **g_c, **causal_structure;
{
  t_v_arr_of_v_lists adj_list;
  t_v_arr_of_v_sets adj_set;
  t_vertex_set a0, vertex_set;
  t_vertex u;
  boolean ok;

/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  hypergraph_sets_to_graph_sets(*g_c, g, adj_set);
  if (P_setequal(g, d)) {
    ok = false;
    return false;
  }
  ok = true;
  adj_set_to_adj_list(adj_set, adj_list);
  u = first_vertex;
  if (!P_setequal(a, empty_set))
    P_setcpy(vertex_set, a);
  else
    P_setdiff(vertex_set, g, d);
  while ((u < last_vertex) & (!P_inset(u, vertex_set)))
    u++;
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2695L, 1L)) {
    write_char(stdout, '<');
    write_char(stdout, 'A');
    write_char(stdout, ':');
    print_vertex_set(a);
    write_char(stdout, '/');
    print_vertex_set(vertex_set);
    write_char(stdout, 'G');
    write_char(stdout, ':');
    print_vertex_set(g);
    write_char(stdout, 'D');
    write_char(stdout, ':');
    print_vertex_set(d);
    write_char(stdout, '/');
    print_vertex(u);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  find_connected_component(g, d, a0, &u, adj_list);
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2695L, 1L)) {
    write_char(stdout, '<');
    write_char(stdout, 'A');
    write_char(stdout, '0');
    write_char(stdout, ':');
    print_vertex_set(a0);
    write_char(stdout, 'G');
    write_char(stdout, ':');
    print_vertex_set(g);
    write_char(stdout, 'D');
    write_char(stdout, ':');
    print_vertex_set(d);
    write_boolean_text(stdout, true, 5L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  dispose_adj_list(adj_list);
  P_setunion(a0, a0, d);
  if (!P_setequal(a, empty_set))
    ok = P_setequal(a, a0);
  P_setcpy(a, a0);
  P_setdiff(a0, g, a0);
  if (ok && !P_setequal(b, empty_set))
    ok = P_setequal(b, a0);
  P_setcpy(b, a0);
  P_setunion(b, b, d);
  /*$ifdef TRACE*/
  if (!trace_flag_set(20L, 2695L, 1L))
    return ok;
  /*$endif TRACE*/
  write_char(stdout, '<');
  write_char(stdout, 'A');
  write_char(stdout, ':');
  print_vertex_set(a);
  write_char(stdout, 'B');
  write_char(stdout, ':');
  print_vertex_set(b);
  write_char(stdout, 'D');
  write_char(stdout, ':');
  print_vertex_set(d);
  write_boolean_text(stdout, ok, 5L);
  write_char(stdout, '>');
  write_line(stdout);
  return ok;
}  /* is_decomposition_of_gc */


Static boolean is_decomposition(d, a, b, g_c, causal_structure, create_models,
				ifail, sub_code)
long *d, *a, *b;
t_set_list **g_c, **causal_structure;
boolean *create_models;
t_integer *ifail, *sub_code;
{
  t_model *p;
  t_set_list *g_c_a, *g_c_b;
  t_vertex_set g;
  boolean unfolded;
  boolean empty_gc = false;
  boolean ok;

  if (P_setequal((*g_c)->vertex_set, empty_set)) {
    if (current_ifail(ifail)) {
      ok = true;
      p = link_current->model;
      if (p->id->model_type == mixed) {
	empty_gc = model_if_empty_gc(g_c, ifail, -2L);
	unfolded = true;
	ok = ok_to_decompose_mixed_gc(&unfolded, &p->graphical,
	    &p->id->UU.U1.full_specified, &p->id->UU.U1.homogeneous,
	    &p->id->UU.U1.g_c_discrete, &p->id->UU.U1.g_c_linear,
	    &p->id->UU.U1.g_c_quadratic, d, a, b, g);
      } else {
	empty_gc = model_if_empty_gc(g_c, ifail, -2L);
	ok = is_decomposition_of_gc(d, a, b, g, g_c, causal_structure);
      }
    }
  } else
    ok = is_decomposition_of_gc(d, a, b, g, g_c, causal_structure);

  if (!P_setequal(g, d)) {
    if (ok && !P_setequal(g, a)) {
      if (test_decomposable_hypergraph(g_c, a, b, d, &g_c_a, &g_c_b)) {
	ok = true;
	if (*create_models) {
	  insert_g_c_in_new_model(&g_c_a, a, causal_structure,
				  p->id->UU.U1.full_specified,
				  p->id->UU.U1.homogeneous);
	  insert_g_c_in_new_model(&g_c_b, b, causal_structure,
				  p->id->UU.U1.full_specified,
				  p->id->UU.U1.homogeneous);
	}
      } else {
	ok = false;
	dispose_set_list(&g_c_a);
	dispose_set_list(&g_c_b);
      }
    } else
      ok = false;
  } else
    ok = false;
  if (!ok && *sub_code > 0) {
    write_pch(stdout, " No partitioning", 16L);
    write_line(stdout);
  }
  if (empty_gc)
    dispose_set_list(g_c);
  return ok;
}  /* is_decomposition */


Static Void proc_is_decomposition(command_file, as_argument, ifail, sub_code,
  arg_pos_char, arg_pos_int, nargs, arg_char, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char, arg_pos_int;
long **nargs;
Char **arg_char;
long **arg_int;
{
  boolean a_given, b_given, create_models, not_empty_gc, ok, full;
  t_set_list *gc = NULL;
  t_vertex_set d, a, b;
  t_integer i = PCH_START;
  t_integer j;
  t_set_list *causal_structure = NULL;
  /*$ifdef TRACE*/
  pch20 tzt;
  long FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " ProcIsDecomposition", sizeof(pch20));
  /*$endif TRACE*/
  /* Need to be tested !!!! */
  b_given = negative_flag_set(sub_code, 16L);
  a_given = negative_flag_set(sub_code, 8L);
  create_models = negative_flag_set(sub_code, 4L);
  *sub_code = 1;
  if (!get_vertex_set_list(command_file, true, true, false, as_argument, &i,
			   ifail, sub_code, arg_pos_char, nargs, arg_char,
			   " GC->", 5L, &gc, &gc))
    return;
  P_setcpy(d, empty_set);
  P_setcpy(a, empty_set);
  P_setcpy(b, empty_set);
  if (gc != NULL) {
    P_setcpy(d, gc->vertex_set);
    gc = gc->pointer;
  }
  if (a_given && gc != NULL) {
    P_setcpy(a, gc->vertex_set);
    gc = gc->pointer;
  }
  if (b_given && gc != NULL) {
    P_setcpy(b, gc->vertex_set);
    gc = gc->pointer;
  }
  /* empty_gc := model_if_empty_gc(gc, ifail, -2); */
  /* Not good for mixed! */
  not_empty_gc = (gc != NULL);
  if (not_empty_gc)
    not_empty_gc = !P_setequal(gc->vertex_set, empty_set);
  if (!not_empty_gc) {
    gc = (t_set_list *)Malloc(sizeof(t_set_list));
    if (gc == NULL)
      _OutMem();
    P_setcpy(gc->vertex_set, empty_set);
    gc->pointer = NULL;
  }
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2696L, 1L)) {
    write_char(stdout, '<');
    write_char(stdout, 'A');
    write_char(stdout, ':');
    print_vertex_set(a);
    write_char(stdout, 'B');
    write_char(stdout, ':');
    print_vertex_set(b);
    write_char(stdout, 'D');
    write_char(stdout, ':');
    print_vertex_set(d);
    write_char(stdout, ':');
    print_g_c(gc, 0L, line_length);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, '>');
    write_line(stdout);
  }
  /*$endif TRACE*/
  *sub_code = -1;
  /* This is not used !!!!! */
  /* copy_set_list(current_model^.id^.causal_structure,
                causal_structure); */
  ok = is_decomposition(d, a, b, &gc, &causal_structure, &create_models,
			ifail, sub_code);
  /* dispose_set_list(causal_structure); */
  /*$ifdef TRACE*/
  if (trace_flag_set(20L, 2696L, 1L)) {
    write_char(stdout, '[');
    write_char(stdout, 'A');
    write_char(stdout, ':');
    print_vertex_set(a);
    write_char(stdout, 'B');
    write_char(stdout, ':');
    print_vertex_set(b);
    write_char(stdout, 'D');
    write_char(stdout, ':');
    print_vertex_set(d);
    write_boolean_text(stdout, ok, 5L);
    if (*ifail != 0)
      write_integer(stdout, *ifail, 2L);
    write_char(stdout, ']');
    write_line(stdout);
  }
  /*$endif TRACE*/
  report_boolean(ok, as_argument, ifail, arg_pos_int, nargs, arg_int);
  i = PCH_START;
  return_vertex_set_in_pch(d, &full, *arg_char, &i, &(*nargs)[arg_pos_char]);
  return_vertex_set_in_pch(a, &full, *arg_char, &i, &(*nargs)[arg_pos_char]);
  return_vertex_set_in_pch(b, &full, *arg_char, &i, &(*nargs)[arg_pos_char]);
  return_vertex_set_in_pch(empty_set, &full, *arg_char, &i,
			   &(*nargs)[arg_pos_char]);
  /*$ifdef TRACE*/
  ntr_set(tzt, 20L, 2696L, 8L, i, (*nargs)[arg_pos_char], d);
  /*$endif TRACE*/
  if (!ok_char_arg(ifail, arg_pos_char, (long)PCH_START, nargs, arg_char))
    return;
  FORLIM = (*nargs)[arg_pos_char];
  for (j = i - 1; j < FORLIM; j++)
    (*arg_char)[j] = ';';
  set_string_end(&i, ifail, arg_pos_char, nargs, arg_char);
}  /* proc_is_decomposition */


Static Void proc_slice(command_file, as_argument, ifail, sub_code,
		       arg_pos_char, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos_char;
long **nargs;
Char **arg_char;
{
  /* , arg_pos_int */
  /* ;
  var arg_int: t_p_int_array */
  t_vertex_set b, bv, bw, c;
  t_vertex v, w;
  t_long_real gamma, s, s1;
  t_set_list *gc;
  boolean ok = true;
  t_slice_pack slice_pack;

  get_two_vertices_and_set_list(command_file, as_argument, false, ifail,
				sub_code, arg_pos_char, nargs, arg_char, &v,
				&w, &gc);
  if (em) {
    write_warning_em(stdout, 2697L, " Procslice          ");
    return;
  }
  if (*ifail != 0)
    return;
  P_setcpy(b, empty_set);
  if (gc != NULL) {
    add_union_of_gc(gc, b);
    dispose_set_list(&gc);
  }
  P_remset(b, v);
  P_remset(b, w);
  P_setcpy(bv, b);
  P_addset(bv, v);
  P_setcpy(bw, b);
  P_addset(bw, w);
  P_setunion(c, bv, bw);
  if (!ok_em()) {
    set_ifail(ifail, 72L);
    return;
  }
  if (ok_miss_model(c, false)) {
    find_slice_products(b, bv, bw, c, &v, &w, &slice_pack);
    compute_slice_statistics(&v, &w,
      &variable_description[v - MIN_VERTEX]->UU.U0.levels,
      &variable_description[w - MIN_VERTEX]->UU.U0.levels, b,
      return_offset(bv, &ok), return_offset(bw, &ok), return_offset(c, &ok),
      &slice_pack, &gamma, &s, &s1, true);
  } else
    set_ifail(ifail, 99L);
}  /* proc_slice */


#define pos_char        0
#define pos_int         1
#define pos_double      2
#define pos_char_int    3


/*@-"maininit.c"*/
/*@+"maininit.p"*/


/*

2700:    +++  ++
2701:    +++  ++
2702:    ---  -- p/maininit.p        31     117    1575 p/maininit.p
2703: |    4:    procedure test_arguments
2704: |  104:    procedure arg_int_to_pch
2705: |  159:    procedure version_stamp
2706: |  169:    procedure set_observations_file_arg
2707: |  189:    procedure set_observations_file
2708: |  209:    procedure set_spec_file_arg
2709: |  229:    procedure set_spec_file
2710: |  249:    procedure set_data_file_arg
2711: |  271:    procedure set_data_file
2712: |  291:    procedure set_output_file_arg
2713: |  302:    procedure set_output
2714: |  322:    procedure set_diary_file_arg
2715: |  340:    procedure set_diary_file
2716: |  360:    procedure set_log_file_arg
2717: |  378:    procedure set_log_file
2718: |  398:    procedure set_dump_file_arg
2719: |  416:    procedure set_dump_file
2720: |  436:    procedure set_default_dump_file
2721: |  446:    procedure set_output
2722: |  459:    procedure set_report_file_arg
2723: |  472:    procedure set_report_file
2724: |  492:    procedure init_coco_variables
2725: |  744:    procedure init_coco_files
2726: |  818:    procedure note_coco_started
2727: |  843:    procedure init_coco
2728: |  871:    procedure write_terminating
2729: |  903:    procedure start_coco
2730: | 1135:    procedure start_coco_s
2731: | 1422:    procedure clear
2732: | 1489:    procedure restart
2733: | 1505:    procedure end_coco
2734:    +++  ++
2735:    +++  ++

*/

Static Void test_arguments(site, ifail, code, sub_code, nargs, arg_char,
			   arg_int, arg_double, arg_char_int)
t_integer site, *ifail, code, sub_code;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
long **arg_char_int;
{
  t_integer i;

  write_pch_10_text(stdout, " Site:    ", 10L);
  write_integer_text(stdout, site, 2L);
  write_pch_10_text(stdout, " Ifail:   ", 10L);
  write_integer_text(stdout, *ifail, 2L);
  write_pch_10_text(stdout, "; Code:   ", 10L);
  write_integer_text(stdout, code, 3L);
  write_pch_10_text(stdout, "; Subcode:", 10L);
  write_integer_text(stdout, sub_code, 2L);
  write_pch_10_text(stdout, "", 0L);
  for (i = 0; i <= 3; i++) {
    write_pch_10_text(stdout, "; N[", 4L);
    write_integer_text(stdout, i, 1L);
    write_pch_10_text(stdout, "] = ", 4L);
    write_integer_text(stdout, (*nargs)[i], 2L);
  }
  write_char_stdout(';');
  write_line_stdout();
  write_pch_20_text(stdout, " Char:     ", 11L);
  write_integer_text(stdout, (*nargs)[0], 3L);
  write_pch_10_text(stdout, " | ", 3L);
  write_char_stdout('"');
  i = 1;
  while (i <= (*nargs)[pos_char]) {
    if ((*arg_char)[i - PCH_START] != '\0') {
      write_char_stdout((*arg_char)[i - PCH_START]);
      if (i % 60 == 0) {
	write_line_stdout();
	write_space_text(stdout, 17L);
      }
    }
    i++;
  }
  write_char_stdout('"');
  write_line_stdout();
  write_pch_20_text(stdout, " Int:      ", 11L);
  write_integer_text(stdout, (*nargs)[1], 3L);
  write_pch_10_text(stdout, " | ", 3L);
  i = 0;
  while (i < (*nargs)[pos_int]) {
    if ((*arg_int)[i] < _INFINITY) {
      write_integer_text(stdout, (*arg_int)[i], 3L);
      write_pch_10_text(stdout, ", ", 2L);
      if ((i + 1) % 12 == 0) {
	write_line_stdout();
	write_space_text(stdout, 17L);
      }
    }
    i++;
  }
  write_line_stdout();
  write_pch_20_text(stdout, " Double:   @@@@@@@@ ", 11L);
  write_integer_text(stdout, (*nargs)[2], 3L);
  write_pch_10_text(stdout, " | ", 3L);
  i = 0;
  while (i < (*nargs)[pos_double]) {
    if (!is_invalid_real((*arg_double)[i])) {
      write_real_text(stdout, (*arg_double)[i], 10L, 5L);
      write_pch_10_text(stdout, ", ", 2L);
      if ((i + 1) % 5 == 0) {
	write_line_stdout();
	write_space_text(stdout, 17L);
      }
    }
    i++;
  }
  write_line_stdout();
  write_pch_20_text(stdout, " CharInt:  ", 11L);
  write_integer_text(stdout, (*nargs)[3], 3L);
  write_pch_10_text(stdout, " | ", 3L);
  i = 0;
  while (i < (*nargs)[pos_char_int]) {
    if ((*arg_char_int)[i] > 0 && (*arg_char_int)[i] < _INFINITY) {
      write_integer_text(stdout, (*arg_char_int)[i], 3L);
      write_pch_10_text(stdout, ", ", 2L);
      if ((i + 1) % 12 == 0) {
	write_line_stdout();
	write_space_text(stdout, 17L);
      }
    }
    i++;
  }
  write_line_stdout();
}  /* test_arguments */

#undef pos_char
#undef pos_int
#undef pos_double
#undef pos_char_int


Static Void arg_int_to_pch(ifail, code, sub_code, nargs, arg_string, arg_int,
			   arg_double, arg_char_int, arg_char, char_input)
t_integer *ifail, *code, *sub_code;
long **nargs;
t_char_array **arg_string;
long **arg_int;
double **arg_double;
long **arg_char_int;
Char **arg_char;
boolean *char_input;
{
  t_integer i;
  long FORLIM;

  /*$ifdef TRACE*/
  /* Remove for DOS */
  if (trace_flag_set(20L, 2704L, 1L) && *code > 1) {
    write_line_stdout();
    write_pch_20_text(stdout, " String:     ", 13L);
    write_char_stdout('"');
    FORLIM = (*nargs)[0];
    for (i = 1; i <= FORLIM; i++) {
      write_char_stdout((*arg_string)[0][i-1]);
      if (i % 60 == 0) {
	write_line_stdout();
	write_space_text(stdout, 11L);
      }
    }
    write_char_stdout('"');
    write_line_stdout();
  }
  /*$endif TRACE*/
  /* Remove for DOS */
  *arg_char = NULL;

  
   *arg_char = (Char * )Malloc((*nargs)[3]*sizeof(Char));
  

  /* #  ifdef CC-minus     
  *arg_char = (Char *)Malloc(sizeof(pch_long));
  if (*arg_char == NULL)
    _OutMem();
       #  endif CC-minus */
  if ((*nargs)[0] > 0) {
    *char_input = true;
    FORLIM = (*nargs)[0];
    for (i = 1; i <= FORLIM; i++)
      (*arg_char)[i - PCH_START] = (*arg_string)[0][i-1];
  } else {
    *char_input = false;

    
     int_vector_to_pch(*arg_char_int, (*nargs)[3], *arg_char);
    

    /* #  ifdef CC-minus     
    int_vector_to_pch(*arg_char_int, (long)PCH_END, *arg_char);
         #  endif CC-minus */
    (*nargs)[0] = (*nargs)[3];
  }
  /*$ifdef TRACE*/
  /* Remove for DOS */
  if (trace_flag_set(20L, 2704L, 8L) && *code > 1)
    test_arguments(31L, ifail, *code, *sub_code, nargs, arg_char, arg_int,
		   arg_double, arg_char_int);
  /*$endif TRACE*/
  /* Remove for DOS */
}  /* arg_int_to_pch */


Static Void version_stamp(f)
FILE *f;
{
/* p2c: coco_d_p2c.p, line 82845:
 * Warning: Too many characters for packed array of char [162] */
  writeln_pch_50_text(f, '#', VERSION, 50L);
  writeln_pch_50_text(f, '#', COMP_MACH, 50L);
  writeln_pch_50_text(f, '#', COMP_TIME, 50L);
  writeln_pch_50_text(f, '#', COPYRIGHT, 50L);
  writeln_pch_50_text(f, '#', LICENSE, 50L);
  write_line_text(f);
}  /* version_stamp */


Static Void set_observations_file_arg(new_name, ok)
Char *new_name;
boolean *ok;
{
  data_line_number = 0;
  data_line_position = 0;
  copy_pch_long(new_name, data_name);
  terminal = false;
  if (!strncmp(data_name, command_name, sizeof(pch_long)))
    return;
  if (data_file_set)
    close_file(data_file);
  assign_read(&data_file, data_name, ok);
  if (*ok) {
    data_file_set = true;
    return;
  }
  write_file_not_found(stdout, data_name);
  default_to_file_name(DEFAULT_OBSERVATION, data_name);
  assign_read_cocolib(&data_file, data_name, ok);
}  /* set_observations_file_arg */


Static Void set_observations_file(command_file, as_argument, ifail, sub_code,
				  arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long new_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, data_name, new_name))
    return;
  set_observations_file_arg(new_name, &ok);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* set_observations_file */


Static Void set_spec_file_arg(new_name, ok)
Char *new_name;
boolean *ok;
{
  data_line_number = 0;
  data_line_position = 0;
  copy_pch_long(new_name, spec_name);
  terminal = false;
  if (!strncmp(spec_name, command_name, sizeof(pch_long)))
    return;
  if (spec_file_set)
    close_file(spec_file);
  assign_read(&spec_file, spec_name, ok);
  if (*ok) {
    spec_file_set = true;
    return;
  }
  write_file_not_found(stdout, spec_name);
  default_to_file_name(DEFAULT_OBSERVATION, spec_name);
  assign_read_cocolib(&spec_file, spec_name, ok);
}  /* set_spec_file_arg */


Static Void set_spec_file(command_file, as_argument, ifail, sub_code, arg_pos,
			  nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long new_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, spec_name, new_name))
    return;
  set_spec_file_arg(new_name, &ok);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* set_spec_file */


Static Void set_data_file_arg(new_name, ok)
Char *new_name;
boolean *ok;
{
  data_line_number = 0;
  data_line_position = 0;
  copy_pch_long(new_name, data_name);
  memcpy(spec_name, data_name, sizeof(pch_long));
  terminal = false;
  if (!strncmp(spec_name, command_name, sizeof(pch_long)))
    return;
  if (spec_file_set)
    close_file(spec_file);
  assign_read(&spec_file, spec_name, ok);
  if (*ok) {
    spec_file_set = true;
    return;
  }
  write_file_not_found(stdout, spec_name);
  default_to_file_name(DEFAULT_OBSERVATION, spec_name);
  assign_read_cocolib(&spec_file, spec_name, ok);
  memcpy(data_name, spec_name, sizeof(pch_long));
}  /* set_data_file_arg */


Static Void set_data_file(command_file, as_argument, ifail, sub_code, arg_pos,
			  nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long new_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, data_name, new_name))
    return;
  set_data_file_arg(new_name, &ok);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* set_data_file */


Static Void set_output_file_arg(new_name, ok)
Char *new_name;
boolean *ok;
{
  FILE *TEMP;

  copy_pch_long(new_name, results_name);
  TEMP = stdout;
  flush_file(&TEMP);
  close_file(stdout);
  TEMP = stdout;
  assign_write(&TEMP, results_name, ok);
  if (!*ok)
    write_file_not_opened(stdout, results_name);
}  /* set_output_file_arg */


Static Void set_output(command_file, as_argument, ifail, sub_code, arg_pos,
		       nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long new_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, results_name, new_name))
    return;
  set_output_file_arg(new_name, &ok);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}


Static Void set_diary_file_arg(new_name, ok)
Char *new_name;
boolean *ok;
{
  unlink_tmp_file(&diary_file, diary_name, diary_set);
  copy_pch_long(new_name, diary_name);
  flush_file(&diary_file);
  close_file(diary_file);
  assign_write(&diary_file, diary_name, ok);
  diary_set = true;
  if (!*ok) {
    write_file_not_opened(stdout, diary_name);
    return;
  }
  version_stamp(diary_file);
  write_line_diary();
  switch_(4L, 1L);
}  /* set_diary_file_arg */


Static Void set_diary_file(command_file, as_argument, ifail, sub_code,
			   arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long new_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, diary_name, new_name))
    return;
  set_diary_file_arg(new_name, &ok);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* set_diary_file */


Static Void set_log_file_arg(new_name, ok)
Char *new_name;
boolean *ok;
{
  unlink_tmp_file(&log_file, log_name, log_set);
  copy_pch_long(new_name, log_name);
  flush_file(&log_file);
  close_file(log_file);
  assign_write(&log_file, log_name, ok);
  log_set = true;
  if (!*ok) {
    write_file_not_opened(stdout, log_name);
    return;
  }
  version_stamp(log_file);
  switch_(24L, 1L);
  switch_(30L, 1L);
}  /* set_log_file_arg */


Static Void set_log_file(command_file, as_argument, ifail, sub_code, arg_pos,
			 nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long new_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, log_name, new_name))
    return;
  set_log_file_arg(new_name, &ok);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* set_log_file */


Static Void set_dump_file_arg(new_name, ok)
Char *new_name;
boolean *ok;
{
  if (default_dump_set || dump_set) {
    flush_file(&dump_file);
    close_file(dump_file);
    unlink_tmp_file(&dump_file, dump_name, dump_set || !default_dump_set);
  }
  copy_pch_long(new_name, dump_name);
  assign_write(&dump_file, dump_name, ok);
  dump_set = true;
  if (!*ok)
    write_file_not_opened(stdout, dump_name);
  else
    switch_(25L, 1L);
}  /* set_dump_file_arg */


Static Void set_dump_file(command_file, as_argument, ifail, sub_code, arg_pos,
			  nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long new_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, dump_name, new_name))
    return;
  set_dump_file_arg(new_name, &ok);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* set_dump_file */


Static Void set_default_dump_file()
{
  boolean ok;

  default_dump_set = true;
  default_to_file_name(DEFAULT_DUMP, dump_name);
  assign_tmp_write(&dump_file, dump_name, &tmp_count, &ok);
}  /* set_default_dump_file */


/*$ifdef On-DOS
procedure set_output(var command_file: text);
var
   ok : boolean;
begin
   read_file_name(command_file, response_name);
   flush_file(output);
   close_file(output);
   assign_write(output, response_name, ok);
   if not ok then
      write_file_not_opened(output, response_name)
end;
 $endif On-DOS*/

Static Void set_report_file_arg(new_name, ok)
Char *new_name;
boolean *ok;
{
  flush_file(&report_file);
  close_file(report_file);
  unlink_tmp_file(&report_file, report_name, report_set);
  copy_pch_long(new_name, report_name);
  assign_write(&report_file, report_name, ok);
  report_set = true;
  if (!*ok)
    write_file_not_opened(stdout, report_name);
}  /* set_report_file_arg */


Static Void set_report_file(command_file, as_argument, ifail, sub_code,
			    arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  pch_long new_name;
  boolean ok;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, report_name, new_name))
    return;
  set_report_file_arg(new_name, &ok);
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* set_report_file */


Static Void init_coco_variables()
{
  t_vertex_name name;
  t_vertex v;
  t_integer i;
  short TEMP;

  /*$ifdef On-DOS
  new(n);
  new(p);
  write_pch_30_text(output,' After New(N) and New(P):@@@@@', 25);
  write_line_text(output);
  write_pch_30_text(output,' Memory available:       @@@@@', 25);
  write_integer_text(output, memavail, 8);
  write_pch_10_text(output, ' bytes.@@@', 7);
  write_line_text(output);
  write_pch_30_text(output,' Largest block contains  @@@@@', 25);
  write_integer_text(output, maxavail, 8);
  write_pch_10_text(output, ' bytes.''@@@', 7);
  write_line_text(output);
   $endif On-DOS*/
  P_addset(P_expset(begin_set, 0L), ':');
  P_addset(begin_set, '[');
  P_addset(P_expset(end_set, 0L), ',');
  P_addset(end_set, ']');
  P_addset(P_expset(end_gc, 0L), '.');
  P_addset(end_gc, ']');
  P_addset(end_gc, '/');
  P_addset(P_expset(end_gc_list, 0L), ']');
  P_addset(end_gc_list, '/');
  P_addset(end_gc_list, ';');
  P_addset(P_expset(end_mark, 0L), ',');
  P_addset(end_mark, '.');
  P_addset(end_mark, '<');
  P_addset(end_mark, '|');
  P_addset(end_mark, '>');
  P_addset(end_mark, ']');
  P_addset(end_mark, '/');
  P_addset(end_mark, ';');
  P_addset(P_expset(order_mark, 0L), '<');
  P_addset(order_mark, '|');
  P_addset(order_mark, '>');
  P_setcpy(end_mark_plus, end_mark);
  P_addset(end_mark_plus, '*');
  char_count = 0;
  line_count = 0;
  /* page_count := 0; */
  page_pause_length = 22;
  pause_output = false;
  page_length = 65;
  line_length = 127;
  data_line_number = 0;
  data_line_position = 0;
  width = 10;
  decprob = 6;
  decexpt = 2;
  decdiff = 4;
  print_width = 10;
  print_dec = 4;
  x_width = 9;
  x_dec = 4;
  prob_width = 7;
  prob_dec = 5;
  read_spec = false;
  read_obs = false;
  hash_overflow = false;
  global_write_options = new_test_write_options_true();
  global_write_options->line_form = false;
  global_write_options->write_models = true;
  global_write_options->write_test = true;
  global_test_labels = new_test_labels_empty();
  global_stepwise_options = (t_stepwise_options *)Malloc(sizeof(t_stepwise_options));
  if (global_stepwise_options == NULL)
    _OutMem();
  clear_stepwise_options(&global_stepwise_options);
  datastructure = necessary;
  number_of_cells = 0;
  datastructure_selected = false;
  large = false;
  permit_log_l = true;
  space_for_case_list = false;
  item_list = NULL;
  item_list_read = NULL;
  item_list_excluded = NULL;
  case_list = NULL;
  case_list_read = NULL;
  case_list_excluded = NULL;
  print_case_list = false;
  continuous_name_list = NULL;
  /* full_continuous_name_list := nil; */
  discrete_name_list = NULL;
  /* full_discrete_name_list := nil; */
  name_list = NULL;
  full_name_list = NULL;
  long_names = false;
  re_use_test = true;
  sorted = false;
  exclude_missing = false;
  ic = false;
  bic = false;
  decomposable_mode = false;
  homogeneous_mode = true;
  graph_mode = false;
  adj_df = true;
  test_choice = 1;
  alfa_ = 0.05;
  alfa_reject = 0.05;
  parts_limit = 2.0;
  separators_limit = 2.0;
  asymptotic_limit = 2.0;
  init_n_of_tables = 20;
  link_n_of_tables = NULL;
  P_expset(delta_missing_excluded, 0L);
  ic_lambda = 3.0;
  lambda = 1.0;   /* 2 / 3 */
  exact_epsilon = 0.0000001;
  ips_in_use = 1;
  mean_ips_in_use = normal_ips;
  ips_max_it = 100;
  ips_epsilon = 0.0000001;
  mips_in_use = 4;
  mips_max_it = 2000;
  mips_epsilon = 0.0001;
  mips_init_epsilon = 0.001;
  mips_log_l_round_error = 0.00001;
  mips_random_noise = 0.0001;
  mips_min_lambda = 0.001;
  cholesky_epsilon = 0.0001;
  cips_in_use = 1;
  cips_max_it = 100;
  cips_epsilon = 0.0000001;
  em_epsilon = 0.0000001;
  em_initial = EM_UNIFORM;
  em_max_it = 100;
  pid = 0;
  sigall = 0;
  menu_number = 1;
  mode = command;
  first_model_available = 0;
  link_model_list = NULL;
  internal_model_list = NULL;
  model_2_3_tree = NULL;
  test_2_3_tree = NULL;
  link_test_list = NULL;
  link_part_list = NULL;
  offset_2_3_tree = NULL;
  link_offset_list = NULL;
  link_s_offset_list = NULL;
  s_offset_2_3_tree = NULL;
  link_ss_offset_list = NULL;
  ss_offset_2_3_tree = NULL;
  link_t_offset_list = NULL;
  /* t_offset_2_3_tree := nil; */
  link_r_offset_list = NULL;
  r_offset_2_3_tree = NULL;
  link_current = NULL;
  link_base = NULL;
  link_full = NULL;
  model_references = NULL;
  fna = N_START - FIRST_INDEX;
  fpa = P_START - FIRST_INDEX;
  fra = R_START - FIRST_INDEX;   /* Not used! */
  fsa = S_START - FIRST_INDEX;   /* Not used! */
  fssa = SS_START - FIRST_INDEX;   /* Not used! */
  fta = T_START - FIRST_INDEX;   /* Not used! */
  double_vertex = MIN_VERTEX;
  first_vertex = MIN_VERTEX + 1;
  first_discrete_vertex = MIN_VERTEX + 1;
  first_continuous_vertex = MIN_VERTEX + 1;
  last_vertex = first_vertex;
  full_last_vertex = first_vertex;
  last_discrete_vertex = first_discrete_vertex;
  full_last_discrete_vertex = first_discrete_vertex;
  last_continuous_vertex = first_continuous_vertex;
  full_last_continuous_vertex = first_continuous_vertex;
  P_expset(empty_set, 0L);
  P_expset(empty_name_set, 0L);
  P_addset(P_expset(double_vertex_set, 0L), double_vertex);
      /* empty_set + */
  for (TEMP = MIN_NAME; TEMP <= MAX_NAME; TEMP++) {
    name = TEMP;
    full_name_to_vertex[name - MIN_NAME] = MAX_VERTEX;
    name_to_vertex[name - MIN_NAME] = MAX_VERTEX;
  }
  for (v = MIN_VERTEX; v <= MAX_VERTEX; v++) {
    full_to_discrete[v - MIN_VERTEX] = first_vertex;
    full_to_continuous[v - MIN_VERTEX] = first_vertex;
    to_discrete[v - MIN_VERTEX] = first_vertex;
    to_continuous[v - MIN_VERTEX] = first_vertex;
    full_variable_description[v - MIN_VERTEX] = NULL;
    variable_description[v - MIN_VERTEX] = NULL;
    full_discrete_variable_description[v - MIN_VERTEX] = NULL;
    discrete_variable_description[v - MIN_VERTEX] = NULL;
    full_continuous_variable_description[v - MIN_VERTEX] = NULL;
    continuous_variable_description[v - MIN_VERTEX] = NULL;
    /* full_last_cell[v] := first_level; */
    last_cell[v - MIN_VERTEX] = FIRST_LEVEL;
    first_cell[v - MIN_VERTEX] = FIRST_LEVEL;
    cutpoints[v - MIN_VERTEX] = NULL;
    /* discrete_cutpoints[v] := nil; */
    P_setcpy(fix_edges_adj_set[v - MIN_VERTEX], empty_set);
  }
  P_setcpy(full_delta_gamma, empty_set);
  P_setcpy(delta_gamma, empty_set);
  P_setcpy(full_delta, empty_set);
  P_setcpy(delta, empty_set);
  P_setcpy(full_gamma, empty_set);
  P_setcpy(gamma_, empty_set);
  mixed_data = false;
  /* explanatory := empty_set; */
  /* response := empty_set; */
  causal_structure = NULL;
  P_setcpy(subset, empty_set);
  P_setcpy(continuous_subset, empty_set);
  P_setcpy(discrete_subset, empty_set);
  P_setcpy(ordinal_factors, empty_set);
  P_setcpy(response_variables, empty_set);
  initial_values_for_ips = false;
  ordinal_tests = false;
  P_setcpy(full_names, empty_name_set);
  P_setcpy(names, empty_name_set);
  full_dimension = 0;
  dimension = 0;
  link_select = NULL;
  link_reject = NULL;
  reject_missing = false;
  read_subset = false;
  trace = false;
  debug = false;
  timer = false;
  echo = false;
  echo_note = false;
  note_warnings = true;
  permit_condensed = true;
  std_input_set = true;
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  for (i = 0; i <= 127; i++)
    boolean_option[i] = false;
  boolean_option[0] = true;
  boolean_option[72] = true;
  boolean_option[80] = true;
  boolean_option[83] = true;
  boolean_option[85] = true;
  boolean_option[107] = true;
  boolean_option[110] = true;
  /*$ifdef TRACE*/
  /*$endif TRACE*/
  dummy_option = false;
  n[0] = 0;
  c_factorizes = 3;
  c_partitioning = true;
  terminal = true;
  partitioning_output = true;
  in_fact_inter = false;
  in_test = false;
  in_search = false;
  decompose_incomplete = true;
  incomplete_table = false;
  g_c_q_tables = NULL;
  q_tables_offsets = NULL;
  fqa = Q_START - FIRST_INDEX;
  r_list = NULL;
  malloc_r_array(max_r_cell_number, &r_list);
  s_list = NULL;
  malloc_s_array(max_s_cell_number, &s_list);
  ss_list = NULL;
  malloc_ss_array(max_ss_cell_number, &ss_list);
  t_list = NULL;
  malloc_t_array(max_t_cell_number, &t_list);
  em = false;
  max_fact_found = -1;
  seed = 0;
  fast = true;
  exact_test = false;
  exact_log_l = true;
  number_of_tables = 1000;
  exact_test_for_test_models = true;
  exact_test_for_partitioning = true;
  exact_test_for_sum_up = true;
  link_eh_pack = NULL;
}  /* init_coco_variables */


Static Void init_coco_files(ifail, note_init)
t_integer *ifail;
boolean note_init;
{
  boolean ok = true;

  log_on = false;
  data_line_number = 0;
  data_line_position = 0;
  file_read_set = false;
  default_to_file_name("                                        ",
		       file_name_read);
  file_excluded_set = false;
  default_to_file_name("                                        ",
		       file_name_excluded);

  default_to_file_name("OUTPUT                                  ",
		       response_name);
  default_to_file_name("INPUT                                   ",
		       command_name);
  default_to_file_name("OUTPUT                                  ",
		       results_name);

  /*$ifdef On-DOS
  default_to_file_name('                                        ',
                       response_name);
  assign_write(output, response_name, ok);
  default_to_file_name('                                        ',
                       command_name);
  assign_read(command_file, command_name, ok);
  default_to_file_name('                                        ',
                       results_name);
  assign_write(output, results_name, ok);
   $endif On-DOS*/
  if (ok && note_init) {
    /* 2002, okt. 29: Tmp-files are shared among objects !!! */
    diary = false;
    diary_set = false;
    default_to_file_name(DEFAULT_DIARY, diary_name);
    assign_tmp_write(&diary_file, diary_name, &tmp_count, &ok);
    /* write_pch_10_text(output, ' Diary    ', 10); write_line_stdout; */
  } else
    ok = false;
  if (ok) {
    log_on = true;
    log_data_on = true;
    log_set = false;
    default_to_file_name(DEFAULT_LOG, log_name);
    assign_tmp_write(&log_file, log_name, &tmp_count, &ok);
    /* write_pch_10_text(output, ' Log      ', 10); write_line_stdout; */
  }
  if (ok) {
    report = false;
    report_set = false;
    default_to_file_name(DEFAULT_REPORT, report_name);
    assign_tmp_write(&report_file, report_name, &tmp_count, &ok);
    /* write_pch_10_text(output, ' Report   ', 10); write_line_stdout; */
  }
  if (ok) {
    dump = false;
    dump_set = false;
    default_dump_set = false;
    default_to_file_name("                                        ",
			 dump_name);
  }
  data_file_set = false;
  default_to_file_name("                                        ", data_name);
  spec_file_set = false;
  default_to_file_name("                                        ", spec_name);
  if (note_init && !ok)
    *ifail = 56;   /* Unable to write in temporary directory */
}  /* init_coco_files */


Static Void note_coco_started()
{
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("note_coco_started 1 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
  data_line_number = 0;
  data_line_position = 0;
  write_line(stdout);
  write_pch(stdout, " CoCo-Cg   -    CoCo with CG-distributions.       ",
	      50L);
  /* ' No-Name   -    A program for estimation (etc.) in', 50); */
  /* ' CoCo+Mips  -   A program for estimation (etc.) in', 50); */
  write_line(stdout);
  /* write_pch(output,
                ' Mixed Interaction Models and small CGregressions.', 50);
    write_line(output); */
/* p2c: coco_d_p2c.p, line 83526:
 * Warning: Too many characters for packed array of char [162] */
  write_pch(stdout, VERSION, 50L);
  write_line(stdout);
  /* write_pch(output, comp_mach, 50);
     write_line(output); */
  write_pch(stdout, COPYRIGHT, 50L);
  /* write_line(output);
     write_pch(output, license, 50);
     write_line(output); */
  write_line(stdout);
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("note_coco_started 2 \n");
#endif /* G */
  /* #ifndef S_APIX */
#endif /* CoCo_Cygwin */
  if (log_on)
    version_stamp(log_file);
#ifdef CoCo_Cygwin
  /* #endif */
#ifdef DEBUG_G
    /* G */ printf("note_coco_started 3 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
}  /* note_coco_started */


Static Void init_coco(ifail, note_init, as_argument)
t_integer *ifail;
boolean note_init, as_argument;
{
  pch_long filename;
  boolean ok = true;

  get_cocolib(filename, &ok);
  if (!ok) {
    *ifail = 58;   /* No COCO_LIB environment variable */
    return;
  }
  get_cocotmp(filename, &ok);
  if (ok) {
    init_coco_variables();
    init_coco_files(ifail, note_init);
  } else
    *ifail = 57;   /* No COCO_TMP environment variable */
}  /* init_coco */


/*@-"mainstart.c"*/


Static Void write_terminating(f, ifail)
FILE *f;
t_integer ifail;
{
  write_pch_30_text(f, "CoCo terminating, Ifail = ", 26L);
  write_integer_text(f, ifail, 3L);
  write_char_text(f, '.');
  write_line_text(f);
  write_pch_30_text(f, "Check environments variables ", 29L);
  write_pch_30_text(f, "$COCOTMP (57), $COCOLIB (58), ", 30L);
  write_line_text(f);
  write_pch_30_text(f, "temporary directory (56), and ", 30L);
  write_pch_30_text(f, "parser table, COCO.TAB (52). ", 29L);
  write_line_text(f);
  write_line_text(f);
}  /* write_terminating */




/* #  ifdef Resize-post-plus-x */

Static Void start_coco(argc, argv)
int argc;
Char *argv[];
{

  /* #  endif Resize-post-plus-x */

/* #  ifdef Resize-post-minus   



Static Void start_coco()
{



     #  endif Resize-post-minus */
  t_integer i;
  t_integer ifail = 0;



  /* #  ifdef Resize-post-plus-1 */

  int found, exit_a;

  max_cell_number    =    MAX_CELL_NUMBER_INIT;
  max_p_cell_number  =  MAX_P_CELL_NUMBER_INIT;
  max_q_cell_number  =  MAX_Q_CELL_NUMBER_INIT;
  max_r_cell_number  =  MAX_R_CELL_NUMBER_INIT;
  max_s_cell_number  =  MAX_S_CELL_NUMBER_INIT;
  max_ss_cell_number = MAX_SS_CELL_NUMBER_INIT;
  max_t_cell_number  =  MAX_T_CELL_NUMBER_INIT;
  max_cases_in_list_var  =  MAX_CASES_IN_LIST;

  found = getarg(&argc, argv, &max_cell_number,
                 &max_p_cell_number,
                 &max_q_cell_number,
                 &max_s_cell_number,
                 &max_ss_cell_number,
                 &max_r_cell_number,
                 &max_t_cell_number,
                 &exit_a);

  if (FALSE) {
     printf(" N-array:  %7d\n",    max_cell_number);
     printf(" P-array:  %7d\n",  max_p_cell_number);
     printf(" Q-array:  %7d\n",  max_q_cell_number);
     printf(" R-array:  %7d\n",  max_r_cell_number);
     printf(" S-array:  %7d\n",  max_s_cell_number);
     printf(" SS-array: %7d\n", max_ss_cell_number);
     printf(" T-array:  %7d\n",  max_t_cell_number);
  }

  if (found != 0)
    printf(" Usage: coco -e -Nn -Pn -Qn -Rn -Sn -sn -Tn -Cn ( -on -rn -t ) \n");

    /* #  endif Resize-post-plus-1 */

  /* #  ifdef Resize-post-plus-2

  int found, exit_a;

  LINK->max_cell_number    =    MAX_CELL_NUMBER_INIT;
  LINK->max_p_cell_number  =  MAX_P_CELL_NUMBER_INIT;
  LINK->max_q_cell_number  =  MAX_Q_CELL_NUMBER_INIT;
  LINK->max_r_cell_number  =  MAX_R_CELL_NUMBER_INIT;
  LINK->max_s_cell_number  =  MAX_S_CELL_NUMBER_INIT;
  LINK->max_ss_cell_number = MAX_SS_CELL_NUMBER_INIT;
  LINK->max_t_cell_number  =  MAX_T_CELL_NUMBER_INIT;
  LINK->max_cases_in_list_var  =  MAX_CASES_IN_LIST;

  found = getarg(&argc, argv, &(LINK->max_cell_number),
                 &(LINK->max_p_cell_number),
                 &(LINK->max_q_cell_number),
                 &(LINK->max_s_cell_number),
                 &(LINK->max_ss_cell_number),
                 &(LINK->max_r_cell_number),
                 &(LINK->max_t_cell_number),
                 &exit_a);

  if (FALSE) {
     printf("  N-array:  %7d\n", LINK->max_cell_number  );
     printf("  P-array:  %7d\n", LINK->max_p_cell_number);
     printf("  Q-array:  %7d\n", LINK->max_q_cell_number);
     printf("  R-array:  %7d\n", LINK->max_r_cell_number);
     printf("  S-array:  %7d\n", LINK->max_s_cell_number);
     printf(" SS-array:  %7d\n", LINK->max_ss_cell_number);
     printf("  T-array:  %7d\n", LINK->max_t_cell_number);
  }

  if (found != 0)
    printf(" Usage: coco -e -Nn -Pn -Qn -Rn -Sn -sn -Tn -Cn ( -on -rn -t ) \n");

    #  endif Resize-post-plus-2 */



  /*$ifdef TRACE*/
  /*$endif TRACE*/
  for (i = 1; i <= 31; i++)
    boolean_option[i] = false;
  /* for i := 0 to 4095 do
       boolean_flag[i] := false; */
  for (i = 0; i <= 32767; i++)
    trace_flag[i] = false;
  /*$ifdef TRACE*/
  /*$endif TRACE*/



  malloc_n(&n, MAX_CELL_NUMBER_INIT, &max_cell_number);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  malloc_p(&p, MAX_P_CELL_NUMBER_INIT, &max_p_cell_number);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  malloc_q(&q_array, (long)MAX_Q_CELL_NUMBER_INIT, &max_q_cell_number);





/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  /* #  ifdef Resize-pre-minus


  max_cell_number := max_cell_number;
  max_p_cell_number := max_p_cell_number;
  max_q_cell_number := max_q_cell_number;
  max_r_cell_number := max_r_cell_number;
  max_s_cell_number := max_s_cell_number;
  max_ss_cell_number := max_ss_cell_number;
  max_t_cell_number := max_t_cell_number;
  max_cases_in_list_var := max_cases_in_list;


    #  endif Resize-pre-minus */


  tmp_count = 0;
  link_coco_tmp = NULL;
  link_coco_lib = NULL;
  /* link_coco_home := nil; */
  init_coco(&ifail, true, false);
  if (ifail == 0) {
    note_coco_started();
    memcpy(prompt, ">", sizeof(pch10));
    prompt_length = 1;
    init_command_parser(&ifail, false);
    write_line(stdout);
    write_pch(stdout, prompt, prompt_length);
    set_interrupt();
  }
  if (ifail != 0) {
    write_terminating(stdout, ifail);
    _Escape(0);
  }
}  /* start_coco */


#define pos_char        0
#define pos_char_int    3



Static Void start_coco_s(init_only, note_init, ifail, nargs, narg, parg, qarg,
			 rarg, sarg, ssarg, targ, arg_string, arg_int,
			 arg_double, arg_char_int)
boolean init_only, note_init;
t_integer *ifail;
long **nargs;
t_integer narg, parg, qarg, rarg, sarg, ssarg, targ;
t_char_array **arg_string;
long **arg_int;
double **arg_double;
long **arg_char_int;
{
  Char *arg_char;
  boolean char_input;
  FILE *command_file = NULL;
  Char c;
  t_integer i, j, nn;
  pch_long dummy_name, name;
  long TEMP, TEMP1;

  /*$ifdef TRACE*/
  /* Remove for DOS */
  /*$endif TRACE*/
  /* Remove for DOS */
  for (i = 1; i <= 31; i++)
    boolean_option[i] = false;
  for (i = 0; i <= 32767; i++)
    trace_flag[i] = false;
  /*$ifdef TRACE*/
  /* Remove for DOS */
  /*$endif TRACE*/
  /* Remove for DOS */

  /* #  ifdef Resize-post-plus-1 */

#ifdef DEBUG_GETENV
  if (note_init) {
      printf(" Ifail:   %7d\n", *ifail);
      printf(" nargs,0: %7d\n", (*nargs)[0]);
      printf(" nargs,1: %7d\n", (*nargs)[1]);
      printf(" nargs,2: %7d\n", (*nargs)[2]);
      printf(" nargs,3: %7d\n", (*nargs)[3]);
      printf(" narg:    %7d\n", narg);
      printf(" parg:    %7d\n", parg);
      printf(" qarg:    %7d\n", qarg);
      printf(" rarg:    %7d\n", rarg);
      printf(" sarg:    %7d\n", sarg);
      printf(" ssarg:   %7d\n", ssarg);
      printf(" targ:    %7d\n", targ);
  }
#endif

  max_cell_number    =  narg;
  max_p_cell_number  =  parg;
  max_q_cell_number  =  qarg;
  max_r_cell_number  =  rarg;
  max_s_cell_number  =  sarg;
  max_ss_cell_number =  ssarg;
  max_t_cell_number  =  targ;
  max_cases_in_list_var  =  MAX_CASES_IN_LIST;

  if (note_init && FALSE) {
      printf(" n-array: %7d\n",   max_cell_number);
      printf(" p-array: %7d\n", max_p_cell_number);
      printf(" q-array: %7d\n", max_q_cell_number);
      printf(" r-array: %7d\n", max_r_cell_number);
      printf(" s-array: %7d\n", max_s_cell_number);
      printf("ss-array: %7d\n", max_ss_cell_number);
      printf(" t-array: %7d\n", max_t_cell_number);
  }

    /* #  endif Resize-post-plus-1 */

  /* #  ifdef Resize-post-plus-2

  LINK->max_cell_number    =   narg;
  LINK->max_p_cell_number  =   parg;
  LINK->max_q_cell_number  =   qarg;
  LINK->max_r_cell_number  =   rarg;
  LINK->max_s_cell_number  =   sarg;
  LINK->max_ss_cell_number =  ssarg;
  LINK->max_t_cell_number  =   targ;
  LINK->max_cases_in_list_var  =  MAX_CASES_IN_LIST;

  if (note_init && FALSE) {
      printf("  n-array: %7d\n",   LINK->max_cell_number);
      printf("  p-array: %7d\n", LINK->max_p_cell_number);
      printf("  q-array: %7d\n", LINK->max_q_cell_number);
      printf("  r-array: %7d\n", LINK->max_r_cell_number);
      printf("  s-array: %7d\n", LINK->max_s_cell_number);
      printf(" ss-array: %7d\n", LINK->max_ss_cell_number);
      printf("  t-array: %7d\n", LINK->max_t_cell_number);
  }

    #  endif Resize-post-plus-2 */

  malloc_n(&n, MAX_CELL_NUMBER_INIT, &max_cell_number);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  malloc_p(&p, MAX_P_CELL_NUMBER_INIT, &max_p_cell_number);
/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  malloc_q(&q_array, (long)MAX_Q_CELL_NUMBER_INIT, &max_q_cell_number);

/* p2c: coco_d_p2c.p: Note: Eliminated unused assignment statement [338] */
  /* #  ifdef Resize-pre-minus

       max_cell_number :=    max_cell_number;
     max_p_cell_number :=  max_p_cell_number;
     max_q_cell_number :=  max_q_cell_number;
     max_r_cell_number :=  max_r_cell_number;
     max_s_cell_number :=  max_s_cell_number;
    max_ss_cell_number := max_ss_cell_number;
     max_t_cell_number :=  max_t_cell_number;
     max_cases_in_list_var :=  max_cases_in_list;

    #  endif Resize-pre-minus */

  tmp_count = 0;
  link_coco_tmp = NULL;
  link_coco_lib = NULL;

  if ((*nargs)[pos_char] > 1 || (*nargs)[pos_char_int] > 1) {
    /*$ifdef TRACE*/
    /* Remove for DOS */
    if (qarg == 1)
      test_arguments(21L, ifail, 456L, 9L, nargs, &arg_char, arg_int,
		     arg_double, arg_char_int);
    /*$endif TRACE*/
    /* Remove for DOS */

    TEMP = 1;
    TEMP1 = 0;
    arg_int_to_pch(ifail, &TEMP, &TEMP1, nargs, arg_string, arg_int,
		   arg_double, arg_char_int, &arg_char, &char_input);

    /*$ifdef TRACE*/
    /* Remove for DOS */
    if (qarg == 1)
      test_arguments(22L, ifail, 456L, 9L, nargs, &arg_char, arg_int,
		     arg_double, arg_char_int);
    /*$endif TRACE*/
    /* Remove for DOS */

    if (get_file_name(NULL, true, ifail, 0L, (long)pos_char, nargs, &arg_char,
		      dummy_name, name)) {
      if (*ifail == 0) {
	nn = PCH_START;
	my_strchr(name, '\0', &nn, (long)FILE_NAME_LENGTH);
	c = name[nn - PCH_START - 1];
	nn -= PCH_START;
	if (c == name[0] && nn > 1) {
	  i = PCH_START;
	  j = PCH_START + 1;
	  link_coco_lib = (Char *)Malloc(sizeof(pch_long));
	  if (link_coco_lib == NULL)
	    _OutMem();
	  my_strncp(link_coco_lib, name, c, &i, &j, &nn,
		    (long)FILE_NAME_LENGTH);
	  my_strcct(link_coco_lib, '\0', &i, (long)FILE_NAME_LENGTH);
	  if (j - PCH_START < nn) {
	    i = PCH_START;
	    j++;
	    link_coco_tmp = (Char *)Malloc(sizeof(pch_long));
	    if (link_coco_tmp == NULL)
	      _OutMem();
	    my_strncp(link_coco_tmp, name, c, &i, &j, &nn,
		      (long)FILE_NAME_LENGTH);
	    my_strcct(link_coco_tmp, '\0', &i, (long)FILE_NAME_LENGTH);
	  }
	} else {
	  link_coco_lib = (Char *)Malloc(sizeof(pch_long));
	  if (link_coco_lib == NULL)
	    _OutMem();
	  memcpy(link_coco_lib, name, sizeof(pch_long));
	}
      }
    }
  }



#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("start_coco_s 1 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
  init_coco(ifail, note_init, true);
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("start_coco_s 2 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
  if (*ifail == 0) {
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("start_coco_s 3 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
    if (note_init)
      note_coco_started();
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("start_coco_s 4 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
    memcpy(prompt, "CoCo>", sizeof(pch10));
    prompt_length = 5;
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("start_coco_s 5 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
    init_command_parser(ifail, false);
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("start_coco_s 6 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
    if (!init_only) {
      write_line(stdout);
      write_pch(stdout, prompt, prompt_length);
    }
  }
  if (*ifail != 0)
    write_terminating(stdout, *ifail);
}

#undef pos_char
#undef pos_char_int


Static Void clear()
{
  t_two_integers_list *q;
  t_vertex v;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " Clear              ", sizeof(pch20));
  ntr(tzt, 20L, 2731L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if (space_for_case_list)
    dispose_case_list(&case_list);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -1L, -2L);
  /*$endif TRACE*/
  dispose_tests();
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -1L, -3L);
  /*$endif TRACE*/
  end_search(&link_eh_pack);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -1L, -4L);
  /*$endif TRACE*/
  note_command_end_pch(stdout, " Tests disposed ", 16L);
  note_command_end_line(stdout);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -1L, -5L);
  /*$endif TRACE*/
  proc_dispose_of_all();
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -1L, -6L);
  /*$endif TRACE*/
  note_command_end_line(stdout);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -1L, -7L);
  /*$endif TRACE*/
  proc_dispose_of_marginals();
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -1L, -7L);
  /*$endif TRACE*/
  /*$ifdef On-DOS
  dispose(n);
  dispose(p);
   $endif On-DOS*/
  _Free(global_write_options);
  _Free(global_test_labels);
  _Free(global_stepwise_options);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -2L, 1L);
  /*$endif TRACE*/
  q = link_n_of_tables;
  while (q != NULL) {
    link_n_of_tables = q;
    q = q->pointer;
    _Free(link_n_of_tables);
  }
  proc_dispose_of_all_q();
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -2L, 2L);
  /*$endif TRACE*/
  dispose_r_arrays(&r_list);
  dispose_s_arrays(&s_list);
  dispose_ss_arrays(&ss_list);
  dispose_t_arrays(&t_list);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -2L, 3L);
  /*$endif TRACE*/
  dispose_cell_list(&link_select);
  dispose_cell_list(&link_reject);
  dispose_vertex_name_list(&full_name_list);
  dispose_vertex_name_list(&name_list);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -2L, 4L);
  /*$endif TRACE*/
  _Free(link_coco_tmp);
  _Free(link_coco_lib);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -2L, 5L);
  /*$endif TRACE*/
  dispose_item_list(&item_list_excluded, false);
  dispose_item_list(&item_list_read, true);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -2L, 6L);
  /*$endif TRACE*/
  for (v = first_vertex; v <= last_vertex; v++) {
    _Free(variable_description[v - MIN_VERTEX]);
    dispose_real_list(&cutpoints[v - MIN_VERTEX]);
  }
  dispose_offsets();
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2731L, 1L, -2L, 7L);
  /*$endif TRACE*/
  if (file_read_set)
    close_level_file(file_read);
  if (file_excluded_set)
    close_level_file(file_excluded);
  if (data_file_set)
    close_file(data_file);
  if (spec_file_set)
    close_file(spec_file);
  if (true)
    close_file(log_file);
  if (true)
    close_file(diary_file);
  if (true)
    close_file(report_file);
  if (default_dump_set || dump_set)
    close_file(dump_file);
  unlink_tmp_file(&log_file, log_name, log_set);
  unlink_tmp_file(&diary_file, diary_name, diary_set);
  unlink_tmp_file(&report_file, report_name, report_set);
  if (default_dump_set || dump_set) {
    /*$ifdef TRACE*/
    unlink_tmp_file(&dump_file, dump_name, dump_set || !default_dump_set);
  }
  ntr(tzt, 20L, 2731L, 1L, -2L, 0L);
  /*$endif TRACE*/
}  /* clear */


Static Void restart(command_file)
FILE *command_file;
{
  t_integer ifail;

  clear();
  close_file(stdout);
  close_file(stdout);
  init_coco(&ifail, true, false);
  note_coco_started();
  read_text_ln(command_file);
  if (log_on)
    write_line_text(log_file);
  write_pch(stdout, prompt, prompt_length);
}  /* restart */


Static Void end_coco()
{
  /*$ifdef TRACE*/
  pch20 tzt;
  FILE *TEMP;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " EndCoCo            ", sizeof(pch20));
  ntr(tzt, 20L, 2733L, 1L, 0L, 0L);
  /*$endif TRACE*/
  clear();


  /* #  ifdef Resize-post-plus-1 */

   _Free(n);
   _Free(p);
   _Free( q_array);

    /* #  endif Resize-post-plus-1 */

  /*$ifdef TRACE*/
  /* Remove for DOS */
  ntr(tzt, 20L, 2733L, 1L, 0L, 1L);
  /*$endif TRACE*/
  /* Remove for DOS */

  /* #  ifdef Resize-post-plus-2

   _Free(LINK->n);
   _Free(LINK->p);
   _Free(LINK->q_array);

    #  endif Resize-post-plus-2 */



  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2733L, 1L, 0L, 2L);
  TEMP = stdout;
  /*$endif TRACE*/
  flush_file(&TEMP);
  close_file(stdout);
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2733L, 1L, 0L, 3L);
  TEMP = stdout;
  /*$endif TRACE*/
  flush_file(&TEMP);
  /*$ifdef TRACE*/
  close_file(stdout);
  ntr(tzt, 20L, 2733L, 9L, 9L, 9L);
  /*$endif TRACE*/
}  /* end_coco */


/*@-"mainprog.c"*/
/*@+"countm.p"*/


/*

2736:    +++  ++
2737:    +++  ++
2738:    ---  -- p/countm.p         27     117    1654 p/countm.p
2739: |    4:    procedure move_formula
2740: |   12:    procedure sub_insert_model
2741: |   42:    procedure insert_model_in_model_tree
2742: |   53:    procedure revers_node_list
2743: |  169:    procedure super_insert_model_in_model_tree
2744: |  185:    procedure print_tree_model
2745: |  224:    procedure print_model_tree
2746: |  385:    procedure dispose_model_tree
2747: |  423:    procedure redo_model_tree
2748: |  462:    procedure permute_set_list
2749: |  494:    function return_union_g_c
2750: |  510:    function check_quadratic
2751: |  531:    function from_discrete_vertex
2752: |  548:    function from_continuous_vertex
2753: |  565:    procedure find_set_number
2754: |  582:    procedure identify_super
2755: |  604:    function ok_log_super
2756: |  649:    procedure new_count_mixed_models
2757: |  670:    procedure find_quadratic_gc
2758: | 1048:    procedure find_linear_gc
2759: | 1132:    procedure find_discrete_gc
2760: | 1246:    procedure count_mixed_models
2761: | 1256:    procedure split_mixed
2762: | 1263:    procedure test_mixed_model
2763: | 1332:    procedure find_mixed_list_of_sets
2764: | 1387:    procedure find_list_of_sets
2765: | 1430:    procedure proc_count_mixed
2766:    +++  ++
2767:    +++  ++

*/


/* new page */

Static Void move_formula(a_model, b_model)
t_model **a_model, **b_model;
{
  /* What is this ? */
  (*b_model)->id->model_type = (*a_model)->id->model_type;
  (*b_model)->formula_node = (*a_model)->formula_node;
  (*a_model)->formula_node = NULL;
}  /* move_formula */


Static Void sub_insert_model(link_model_tree, link_model)
t_model_tree_node **link_model_tree;
t_model_list **link_model;
{
  t_model_tree_node *tmp_link_tree;
  t_list_of_model_tree_nodes *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " SubInsertModel     ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 2740L, 1L, -1L, -1L, &(*link_model)->model);
  /*$endif TRACE*/
  tmp_link_tree = (t_model_tree_node *)Malloc(sizeof(t_model_tree_node));
  if (tmp_link_tree == NULL)
    _OutMem();
  /* link_model^.pointer := nil; */
  tmp_link_tree->link_model = *link_model;
  if (*link_model_tree != NULL) {
    p = (t_list_of_model_tree_nodes *)Malloc(sizeof(t_list_of_model_tree_nodes));
    if (p == NULL)
      _OutMem();
    p->pointer = NULL;
    p->node = *link_model_tree;
    tmp_link_tree->sub_models = p;
  } else
    tmp_link_tree->sub_models = NULL;
  *link_model_tree = tmp_link_tree;
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2740L, 8L, -1L, -1L);
  /*$endif TRACE*/
}  /* sub_insert_model */


/*$endif TRACE*/

Local Void revers_node_list(p)
t_list_of_model_tree_nodes **p;
{
  t_list_of_model_tree_nodes *hp1 = NULL;
  t_list_of_model_tree_nodes *hp2;

  while (*p != NULL) {
    hp2 = hp1;
    hp1 = *p;
    *p = (*p)->pointer;
    hp1->pointer = hp2;
  }
  *p = hp1;
}  /* revers_node_list */


Static Void insert_model_in_model_tree(link_model_tree, link_model, skew)
t_model_tree_node **link_model_tree;
t_model_list **link_model;
boolean skew;
{
  t_list_of_model_tree_nodes *p, *q, *r;
  boolean continue_;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$ifdef TRACE*/
  memcpy(tzt, " InsertModelInModelT", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 2741L, 1L, -1L, -1L, &(*link_model)->model);
  /*$endif TRACE*/
  if (*link_model_tree == NULL) {
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2741L, 2L, -1L, -1L);
    /*$endif TRACE*/
    sub_insert_model(link_model_tree, link_model);
  } else {
    /*$ifdef TRACE*/
    ntr_model_g_c(tzt, 20L, 2741L, 3L, -1L, -1L,
		  &(*link_model_tree)->link_model->model);
    /*$endif TRACE*/
    if (is_hierarchical_submodel(&(*link_model_tree)->link_model->model->id,
				 &(*link_model)->model->id, true, true,
				 false)) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2741L, 4L, -1L, -1L);
      /*$endif TRACE*/
      sub_insert_model(link_model_tree, link_model);
    } else {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2741L, 5L, -1L, -1L);
      /*$endif TRACE*/
      p = (*link_model_tree)->sub_models;
      continue_ = true;
      while (continue_ && p != NULL) {
	/*$ifdef TRACE*/
	ntr_model_g_c(tzt, 20L, 2741L, 6L, -1L, -1L,
		      &p->node->link_model->model);
	/*$endif TRACE*/
	if (is_hierarchical_submodel(&(*link_model)->model->id,
	      &p->node->link_model->model->id, true, true, false)) {
	  /*$ifdef TRACE*/
	  ntr(tzt, 20L, 2741L, 7L, -1L, -1L);
	  /*$endif TRACE*/
	  insert_model_in_model_tree(&p->node, link_model, skew);
	  continue_ = false;
	}
	p = p->pointer;
      }
      if (continue_) {   /* p = nil */
	/*$ifdef TRACE*/
	ntr(tzt, 20L, 2741L, 6L, -1L, 2L);
	/*$endif TRACE*/
	p = (t_list_of_model_tree_nodes *)
	    Malloc(sizeof(t_list_of_model_tree_nodes));
	if (p == NULL)
	  _OutMem();
	if (skew)
	  revers_node_list(&(*link_model_tree)->sub_models);
	p->pointer = (*link_model_tree)->sub_models;
	p->node = NULL;
	sub_insert_model(&p->node, link_model);
	(*link_model_tree)->sub_models = p;
	q = p->pointer;
	while (q != NULL) {
	  /*$ifdef TRACE*/
	  ntr_model_g_c(tzt, 20L, 2741L, 7L, -1L, 2L,
			&p->pointer->node->link_model->model);
	  /*$endif TRACE*/
	  if (is_hierarchical_submodel(&q->node->link_model->model->id,
				       &(*link_model)->model->id, true, true,
				       false)) {
	    /*$ifdef TRACE*/
	    ntr(tzt, 20L, 2741L, 8L, -1L, 2L);
	    /*$endif TRACE*/
	    r = q->pointer;
	    q->pointer = (*link_model_tree)->sub_models->node->sub_models;
	    (*link_model_tree)->sub_models->node->sub_models = q;
	    p->pointer = r;
	    /*$ifdef TRACE*/
	    ntr(tzt, 20L, 2741L, 8L, -1L, 5L);
	    /*$endif TRACE*/
	    q = r;
	  } else {
	    /*$ifdef TRACE*/
	    ntr(tzt, 20L, 2741L, 8L, -1L, 9L);
	    /*$endif TRACE*/
	    p = q;
	    q = q->pointer;
	  }
	  /*$ifdef TRACE*/
	  ntr(tzt, 20L, 2741L, 7L, -1L, 5L);
	  /*$endif TRACE*/
	}
	if (skew)
	  revers_node_list(&(*link_model_tree)->sub_models);
      }
    }
  }
  /*$ifdef TRACE*/
  ntr(tzt, 20L, 2741L, 8L, -1L, -1L);
  /*$endif TRACE*/
}  /* insert_model_in_model_tree */


Static Void super_insert_model_in_model_tree(link_model_tree, model, skew)
t_model_tree_node **link_model_tree;
t_model **model;
boolean skew;
{
  t_model_list *link_model;

  link_model = (t_model_list *)Malloc(sizeof(t_model_list));
  if (link_model == NULL)
    _OutMem();
  link_model->pointer = NULL;
  new_model(&link_model->model);
  copy_model(model, &link_model->model);
  move_formula(model, &link_model->model);
  link_model->model->found_expression = true;
  insert_model_in_model_tree(link_model_tree, &link_model, skew);
}  /* super_insert_model_in_model_tree */


Static Void print_tree_model(model, parant_model)
t_model **model, **parant_model;
{
  if ((*parant_model)->dim != _INFINITY)
    write_integer(stdout, (*parant_model)->dim - (*model)->dim, 3L);
  else
    write_integer(stdout, _INFINITY, 3L);

  if ((*parant_model)->dim != _INFINITY &&
      (*parant_model)->dim - (*model)->dim <= 0) {
    if ((*parant_model)->dim - (*model)->dim < 0)
      write_char(stdout, '%');
    else
      write_char(stdout, '+');
  } else
    write_char(stdout, ' ');

  /* print_vertex_set_table(model^.id^.vertices); */
  /* print_vertex_set_table(parant_model^.id^.vertices); */
  if (!P_subset((*parant_model)->id->vertices, (*model)->id->vertices) &&
      !boolean_option[111]) {
    write_space(stdout, print_width - 1);
    write_char(stdout, '.');
    write_char(stdout, ' ');
    return;
  }
  if (is_infinity_real((*parant_model)->log_l) |
      is_infinity_real((*model)->log_l)) {
    write_real(stdout, _INFINITY_REAL, print_width, print_dec);
    write_char(stdout, ' ');
    return;
  }
  if (!different_reals(&(*parant_model)->log_l, &(*model)->log_l)) {
    write_real(stdout, 0.0, print_width, print_dec);
    write_char(stdout, ' ');
    return;
  }
  write_real(stdout, 2 * ((*parant_model)->log_l - (*model)->log_l),
	     print_width, print_dec);
  if ((*parant_model)->log_l - (*model)->log_l < 0)
    write_char(stdout, '*');
  else
    write_char(stdout, ' ');
}  /* print_tree_model */


Static Void print_model_tree(link_model_tree, link_parant_model,
			     link_parant_decomposable, dept)
t_model_tree_node **link_model_tree;
t_model_list **link_parant_model, *link_parant_decomposable;
t_integer dept;
{
  t_integer count_0, count_1, count_2, count_3, i_fail, max_cycles;
  t_list_of_model_tree_nodes *p;
  t_long_real max_delta;
  t_mixed_characteristics *mixed_characteristics;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  if (*link_model_tree == NULL)
    return;
  write_integer(stdout, (*link_model_tree)->link_model->model->dim, 3L);
  write_integer(stdout, (*link_model_tree)->link_model->model->dimdec -
			(*link_model_tree)->link_model->model->dim, 3L);
  if ((*link_model_tree)->link_model->model->dim !=
      (*link_model_tree)->link_model->model->dimdec)
    write_char(stdout, '%');
  else
    write_char(stdout, ' ');

  write_real(stdout, (*link_model_tree)->link_model->model->log_l,
	     print_width, print_dec);

  print_tree_model(&(*link_model_tree)->link_model->model,
		   &(*link_parant_model)->model);

  print_tree_model(&(*link_model_tree)->link_model->model,
		   &link_parant_decomposable->model);

  find_model_complexity(&(*link_model_tree)->link_model->model, &count_0,
			&count_1, &count_2, &count_3, &i_fail, &max_cycles,
			&max_delta);

  if (is_invalid_real((*link_parant_model)->model->log_l) |
      is_invalid_real((*link_model_tree)->link_model->model->log_l))
    count_0 = 2;
  else if ((*link_parant_model)->model->log_l -
	   (*link_model_tree)->link_model->model->log_l > 50 ||
	   (*link_parant_model)->model->log_l -
	   (*link_model_tree)->link_model->model->log_l < 0) {
    if (!P_subset((*link_parant_model)->model->id->vertices,
		  (*link_model_tree)->link_model->model->id->vertices))
      count_0 = -1;
    else
      count_0 = 1;
  } else
    count_0 = 0;

  /* print_width - print_dec */
  write_integer(stdout, count_0, 2L);
  write_integer(stdout, i_fail, print_width - print_dec);

  if (max_cycles <= 0)
    i_fail = -2;
  else if (max_cycles <= 20)
    i_fail = -1;
  else if (max_cycles <= 50)
    i_fail = 0;
  else if (max_cycles <= 100)
    i_fail = 1;
  else if (max_cycles <= 200)
    i_fail = 2;
  else if (max_cycles <= 500)
    i_fail = 3;
  else if (max_cycles <= 1000)
    i_fail = 4;
  else if (max_cycles <= 2000)
    i_fail = 5;
  else if (max_cycles <= 5000)
    i_fail = 6;
  else if (max_cycles <= 10000)
    i_fail = 7;
  else if (max_delta <= 0.01)
    i_fail = 8;
  else
    i_fail = 99;

  /* print_width - print_dec */
  write_integer(stdout, i_fail + 2, 3L);   /* print_width - print_dec */

  write_integer(stdout, count_1, 2L);   /* print_width - print_dec */
  write_integer(stdout, count_2, 2L);   /* print_width - print_dec */
  write_integer(stdout, count_3, 2L);

  write_integer(stdout, max_cycles, print_width - print_dec);

  write_real(stdout, 10000 * max_delta, print_width, print_dec - 2);

  mixed_characteristics = return_mixed_characteristics(
      &(*link_model_tree)->link_model->model);
  write_char(stdout, ' ');
  if (mixed_characteristics->mim_model)
    write_char(stdout, 'M');
  else
    write_char(stdout, ' ');
  if (mixed_characteristics->degenerated)
    write_char(stdout, '0');
  else
    write_char(stdout, ' ');
  if ((*link_model_tree)->link_model->model->graphical)
    write_char(stdout, 'G');
  else
    write_char(stdout, ' ');
  if ((*link_model_tree)->link_model->model->decomposable)
    write_char(stdout, 'D');
  else
    write_char(stdout, ' ');
  /* mixed_characteristics^. */
  if ((*link_model_tree)->link_model->model->id->model_type == mixed) {
    if ((*link_model_tree)->link_model->model->id->UU.U1.homogeneous)
      write_char(stdout, 'H');
    else
      write_char(stdout, ' ');
  } else
    write_char(stdout, ' ');
  if (mixed_characteristics->mean_linear)
    write_char(stdout, 'L');
  else
    write_char(stdout, ' ');
  _Free(mixed_characteristics);

  write_char(stdout, ' ');
  write_char(stdout, '|');
  write_char(stdout, ' ');
  print_vertex_set_table((*link_model_tree)->link_model->model->id->vertices);
  /* print_vertex_set_table(link_parant_decomposable^.model^.id^.vertices); */
  write_char(stdout, ' ');
  write_char(stdout, '|');
  write_space(stdout, dept + 1);
  print_model_g_c(&(*link_model_tree)->link_model->model, dept);
  write_char(stdout, ' ');
  write_char(stdout, '|');
  write_line(stdout);

  /*$ifdef TRACE*/
  memcpy(tzt, " PrintModelTree     ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 2745L, 2L, -1L, -1L,
		&(*link_model_tree)->link_model->model);
  /*$endif TRACE*/
  if ((*link_model_tree)->link_model->model->graphical &&
      (*link_model_tree)->link_model->model->decomposable)
    link_parant_decomposable = (*link_model_tree)->link_model;
  p = (*link_model_tree)->sub_models;
  while (p != NULL) {
    /* write_space(output, dept); */
    /*$ifdef TRACE*/
    ntr_model_g_c(tzt, 20L, 2745L, 3L, -1L, -1L, &p->node->link_model->model);
    /*$endif TRACE*/
    print_model_tree(&p->node, &(*link_model_tree)->link_model,
		     link_parant_decomposable, dept + 1);
    p = p->pointer;

  }
}  /* print_model_tree */


Static Void dispose_model_tree(link_model_tree)
t_model_tree_node **link_model_tree;
{
  t_list_of_model_tree_nodes *q, *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " DisposeModelTree   ", sizeof(pch20));
  ntr(tzt, 20L, 2746L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if (*link_model_tree == NULL) {
    /*$ifdef TRACE*/
    /*$endif TRACE*/
    ntr(tzt, 20L, 2746L, 2L, -1L, -1L);
    return;
  }
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 2746L, 3L, -1L, -1L,
		&(*link_model_tree)->link_model->model);
  /*$endif TRACE*/
  p = (*link_model_tree)->sub_models;
  dispose_model_and_link(&(*link_model_tree)->link_model->model);
  _Free((*link_model_tree)->link_model);
  _Free(*link_model_tree);
  while (p != NULL) {
    /*$ifdef TRACE*/
    ntr_model_g_c(tzt, 20L, 2746L, 4L, -1L, -1L, &p->node->link_model->model);
    /*$endif TRACE*/
    q = p->pointer;
    dispose_model_tree(&p->node);
    _Free(p);
    p = q;
  }
}  /* dispose_model_tree */


Static Void redo_model_tree(link_model_tree, new_model_tree)
t_model_tree_node **link_model_tree, **new_model_tree;
{
  t_list_of_model_tree_nodes *q, *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " RedoModelTree      ", sizeof(pch20));
  ntr(tzt, 20L, 2747L, 1L, -1L, -1L);
  /*$endif TRACE*/
  if (*link_model_tree == NULL) {
    /*$ifdef TRACE*/
    /*$endif TRACE*/
    ntr(tzt, 20L, 2747L, 2L, -1L, -1L);
    return;
  }
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 2747L, 3L, -1L, -1L,
		&(*link_model_tree)->link_model->model);
  /*$endif TRACE*/
  insert_model_in_model_tree(new_model_tree, &(*link_model_tree)->link_model,
			     true);
  p = (*link_model_tree)->sub_models;
  _Free(*link_model_tree);
  while (p != NULL) {
    /*$ifdef TRACE*/
    ntr_model_g_c(tzt, 20L, 2747L, 4L, -1L, -1L, &p->node->link_model->model);
    /*$endif TRACE*/
    q = p->pointer;
    redo_model_tree(&p->node, new_model_tree);
    _Free(p);
    p = q;
  }
}  /* redo_model_tree */


Static Void permute_set_list(g_c, permutation, g_c_list)
t_set_list *g_c, *permutation;
t_g_c_list **g_c_list;
{
  t_set_list *p, *q;
  t_g_c_list *r;

  if (g_c == NULL) {
    r = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (r == NULL)
      _OutMem();
    copy_set_list(permutation, &r->g_c);
    r->pointer = *g_c_list;
    *g_c_list = r;
    return;
  }
  q = g_c->pointer;
  g_c->pointer = permutation;
  permute_set_list(q, g_c, g_c_list);
  g_c->pointer = q;
  if (g_c->pointer == NULL)
    return;
  p = g_c;
  while (p->pointer != NULL) {
    q = p->pointer;
    p->pointer = q->pointer;
    q->pointer = permutation;
    permute_set_list(g_c, q, g_c_list);
    q->pointer = p->pointer;
    p->pointer = q;
    p = q;
  }
}  /* permute_set_list */


Static t_set_list *return_union_g_c(q)
t_g_c_list *q;
{
  t_set_list *g_c = NULL;
  t_set_list *p;

  while (q != NULL) {
    p = q->g_c;
    while (p != NULL) {
      insert_clique(p->vertex_set, &g_c);
      p = p->pointer;
    }
    q = q->pointer;
  }
  return g_c;
}  /* return_union_g_c */


Static boolean check_quadratic(q)
t_g_c_list *q;
{
  t_set_list *g_c = NULL;
  t_set_list *p;
  boolean ok;

  while (q != NULL) {
    p = q->g_c;
    while (p != NULL) {
      insert_set_in_set_list(p->vertex_set, &g_c);
      p = p->pointer;
    }
    q = q->pointer;
  }
  ok = test_hierarchical(g_c);
  /* if ok then
       ok := mim_quadratic_g_c(g_c); */
  dispose_set_list(&g_c);
  return ok;
}  /* check_quadratic */


/* Local variables for from_discrete_vertex: */
struct LOC_from_discrete_vertex {
  t_discrete_vertex v;
} ;


Static t_vertex from_discrete_vertex(v_)
t_discrete_vertex v_;
{
  struct LOC_from_discrete_vertex Local_Var;
  t_vertex u;
  t_discrete_vertex w;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.v = v_;
  /*$ifdef TRACE*/
  memcpy(tzt, " FromDiscreteVertex ", sizeof(pch20));
  ntr_discrete_vertex(tzt, 20L, 2751L, 1L, 1L, (long)Local_Var.v,
		      &Local_Var.v);
  /*$endif TRACE*/
  w = first_discrete_vertex;
  u = first_vertex;
  while ((u < last_vertex) & (!P_inset(u, delta)))
    u++;
  /*$ifdef TRACE*/
  ntr_vertex(tzt, 20L, 2751L, 1L, 2L, (long)u, &u);
  /*$endif TRACE*/
  while (w < Local_Var.v) {
    u++;
    if (P_inset(u, delta))
      w++;
    /*$ifdef TRACE*/
    ntr_discrete_vertex(tzt, 20L, 2751L, 1L, 3L, (long)w, &w);
    /*$endif TRACE*/
    ntr_vertex(tzt, 20L, 2751L, 1L, 3L, (long)u, &u);
  }
  /*$ifdef TRACE*/
  ntr_vertex(tzt, 20L, 2751L, 1L, 4L, (long)u, &u);
  /*$endif TRACE*/
  return u;
}  /* from_discrete_vertex */


Static t_vertex from_continuous_vertex(v)
t_continuous_vertex *v;
{
  t_vertex u;
  t_continuous_vertex w;

  w = first_continuous_vertex;
  u = first_vertex;
  while ((u < last_vertex) & (!P_inset(u, gamma_)))
    u++;
  while (w < *v) {
    u++;
    if (P_inset(u, gamma_))
      w++;
  }
  return u;
}  /* from_continuous_vertex */


Static Void find_set_number(offset_index, v_set)
t_offset_index offset_index;
long *v_set;
{
  short sum;
  t_discrete_vertex v;
  t_vertex u;
  /*$ifdef TRACE*/
  pch20 tzt;
  t_discrete_vertex FORLIM;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " FindSetNumber      ", sizeof(pch20));
  /*$endif TRACE*/
  P_setcpy(v_set, empty_set);
  sum = offset_index - 1;
  FORLIM = first_discrete_vertex;
  for (v = last_discrete_vertex; v >= FORLIM; v--) {
    if (sum >= power2((double)(v - first_discrete_vertex))) {
      u = from_discrete_vertex(v);
      P_addset(v_set, u);
      sum -= power2((double)(v - first_discrete_vertex));
    }
    /*$ifdef TRACE*/
  }
  /*$endif TRACE*/
  ntr_set(tzt, 20L, 2753L, 1L, 2L, (long)offset_index, v_set);
}  /* find_set_number */


Static Void identify_super(model)
t_model **model;
{
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " IdentifyModel      ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 2754L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  if ((*model)->id->model_type == pure_discrete)
    identify_discrete_model(model);
  else if ((*model)->id->model_type == pure_continuous)
    identify_continuous_model(model);
  else if ((*model)->id->model_type == mixed)
    identify_mixed_model(model);
  join_model_g_c_and_dimension(model);
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 2754L, 8L, -1L, -1L, model);
  /*$endif TRACE*/
}  /* identify_super */


Static boolean ok_log_super(model, silent)
t_model **model;
boolean silent;
{
  boolean Result, ok;
  t_model_list *p;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  /*$ifdef TRACE*/
  memcpy(tzt, " OkLogModel         ", sizeof(pch20));
  ntr_model_g_c(tzt, 20L, 2755L, 1L, -1L, -1L, model);
  /*$endif TRACE*/
  ok = return_model(model, &p);
  if (ok) {
    /*$ifdef TRACE*/
    ntr_model_g_c(tzt, 20L, 2755L, 2L, -1L, 1L, &p->model);
    ntr_model_numbers(tzt, 20L, 2755L, 2L, -1L, 2L, &p->model);
    /*$endif TRACE*/
    (*model)->log_l = compute_log_l(&p->model, p->model->id->vertices);
    /* copy_model(p^.model, model); */
    /* Dim ??? */
    (*model)->dim = p->model->dim;
  }
  /*$ifdef TRACE*/
  ntr_model_numbers(tzt, 20L, 2755L, 3L, -1L, -1L, model);
  /*$endif TRACE*/
  if ((!ok) | is_invalid_real((*model)->log_l)) {
    if (!(*model)->found_log_l) {
      if (!(*model)->found_ps)
	do_model(model, true, true, &ok);
      if (ok || permit_log_l)
	(*model)->log_l = compute_log_l(model, (*model)->id->vertices);
    }
  }
  /*$ifdef TRACE*/
  ntr_model_g_c(tzt, 20L, 2755L, 8L, -1L, 998L, model);
  ntr_model_numbers(tzt, 20L, 2755L, 8L, -1L, 999L, model);
  /*$endif TRACE*/
  ok = (ok || permit_log_l);
  Result = ok;
  if (!ok && !silent)
    write_pch(stdout, " Out of space: Log", 18L);
  return Result;
}  /* ok_log_super */


/* Local variables for new_count_mixed_models: */
struct LOC_new_count_mixed_models {
  t_long_integer discrete_dimension, *c_hie3, *c_hie2, *c_hie1, *c_mim, *c_hom,
		 *c_lin, *c_gra, *c_h_g, *c_dec, *c_h_d;
  t_vertex_set a;
  t_vertex_set vertex_set[MAX_OFFSET_CELL_NUMBER];
  boolean dummy, b, ok_sets, ok_quadratic, ok_degenerated, gra, dec, hom, mim,
	  mln, deg;
  t_set_list *quadratic_gc, *linear_gc, *discrete_gc;
  t_g_c_list *linear_gcs, *quadratic_gcs;
  t_model *model, *super_model;
  t_model_tree_node *link_model_tree;
} ;

/* Local variables for find_quadratic_gc: */
struct LOC_find_quadratic_gc {
  struct LOC_new_count_mixed_models *LINK;
  t_continuous_vertex v1, v2;
} ;

Local Void find_quadratic_gc(set_number, v1_, v2_, LINK)
t_integer set_number;
t_continuous_vertex v1_, v2_;
struct LOC_new_count_mixed_models *LINK;
{
  struct LOC_find_quadratic_gc Local_Var;
  t_set_list *p;
  t_g_c_list *q;
  t_vertex_set a0, a1, a2;
  t_vertex u;
  t_g_c_list *permutations_discrete, *permutations_linear,
	     *permutations_quadratic, *q_0, *q_1, *q_2;
  t_mixed_characteristics *mixed_characteristics;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.LINK = LINK;
  Local_Var.v1 = v1_;
  Local_Var.v2 = v2_;
  /*$ifdef TRACE*/
  memcpy(tzt, " FindQuadraticGc    ", sizeof(pch20));
  ntr_4(tzt, 20L, 2757L, 1L, -1L, set_number, (long)Local_Var.v1,
	(long)Local_Var.v2);
  /*$endif TRACE*/
  if (set_number == 0) {
    if ((Local_Var.v1 != last_continuous_vertex ||
	 Local_Var.v2 != last_continuous_vertex) && mixed_data) {
      q = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
      if (q == NULL)
	_OutMem();
      q->pointer = LINK->quadratic_gcs;
      LINK->quadratic_gcs = q;
      LINK->quadratic_gcs->g_c = NULL;
      if (Local_Var.v1 == last_continuous_vertex)
	find_quadratic_gc(power2((double)LINK->discrete_dimension),
			  Local_Var.v2 + 1, Local_Var.v2 + 1, LINK);
      else
	find_quadratic_gc(power2((double)LINK->discrete_dimension),
			  Local_Var.v1 + 1, Local_Var.v2, LINK);
      LINK->quadratic_gcs = LINK->quadratic_gcs->pointer;
      _Free(q);
      return;
    }
    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2757L, 2L, -1L, -1L);
    /*$endif TRACE*/
    P_setcpy(a0, empty_set);
    add_union_of_gc(LINK->discrete_gc, a0);

    LINK->quadratic_gc = return_union_g_c(LINK->quadratic_gcs);

    P_setcpy(a1, empty_set);
    add_union_of_gc(LINK->linear_gc, a1);
    P_setunion(a0, a0, a1);
    P_setint(a1, a1, gamma_);

    P_setcpy(a2, empty_set);
    add_union_of_gc(LINK->quadratic_gc, a2);
    P_remset(a2, double_vertex);
    P_setunion(a0, a0, a2);
    P_setint(a2, a2, gamma_);

    LINK->ok_sets = P_subset(a1, a2);
    LINK->ok_quadratic = check_quadratic(LINK->quadratic_gcs);

    if (boolean_option[110] && boolean_option[85])
      LINK->ok_degenerated = !degenerated_g_c(a0, &LINK->quadratic_gc);
    else
      LINK->ok_degenerated = true;

    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2757L, 3L, -1L, 0L);
    /*$endif TRACE*/

    /* new_model(model); */
    erase_mixed_model(&LINK->model);
    new_model(&LINK->super_model);
    if (LINK->ok_sets && LINK->ok_quadratic && LINK->ok_degenerated) {
      LINK->model->id->UU.U1.g_c_discrete = LINK->discrete_gc;
      LINK->model->id->UU.U1.g_c_quadratic = LINK->quadratic_gc;
      LINK->model->id->UU.U1.g_c_linear = LINK->linear_gc;
      P_setcpy(LINK->model->id->vertices, empty_set);
      LINK->model->id->UU.U1.full_specified = boolean_option[85];
      add_union_of_gc(LINK->model->id->UU.U1.g_c_discrete,
		      LINK->model->id->vertices);
      add_union_of_gc(LINK->model->id->UU.U1.g_c_linear,
		      LINK->model->id->vertices);
      add_union_of_gc(LINK->model->id->UU.U1.g_c_quadratic,
		      LINK->model->id->vertices);
      P_remset(LINK->model->id->vertices, double_vertex);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2757L, 3L, -1L, 1L);   /**/
      /*$endif TRACE*/
      check_mixed_model(&LINK->model, " FindQuadraticGC", 16L, false);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2757L, 3L, -1L, 2L);
      /*$endif TRACE*/
      identify_model(&LINK->model);
      LINK->dummy = ok_log_model(&LINK->model, true);
      generate_decomposable_model(&LINK->super_model, &LINK->model);
      /* identify_model(super_model); */
      identify_super(&LINK->super_model);
      /* dummy := ok_log_model(super_model, true); */
      LINK->dummy = ok_log_super(&LINK->super_model, true);
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2757L, 3L, -1L, 3L);
      /*$endif TRACE*/

      super_insert_model_in_model_tree(&LINK->link_model_tree, &LINK->model,
				       false);

      /*$ifdef TRACE*/
      if (boolean_option[81]) {
	write_line(stdout);
	print_model_tree(&LINK->link_model_tree->sub_models->node,
			 &LINK->link_model_tree->link_model,
			 LINK->link_model_tree->link_model, 0L);
      }
      /*$endif TRACE*/
      mixed_characteristics = return_mixed_characteristics(&LINK->model);
      LINK->mim = mixed_characteristics->mim_model;
      LINK->gra = LINK->model->graphical;
      LINK->dec = LINK->model->decomposable;
      LINK->hom = false;
      if (LINK->model->id->model_type == mixed)
	LINK->hom = LINK->model->id->UU.U1.homogeneous;
      LINK->mln = mixed_characteristics->mean_linear;
      LINK->deg = mixed_characteristics->degenerated;
      _Free(mixed_characteristics);
    } else {
      erase_mixed_model(&LINK->super_model);
      LINK->mim = false;
      LINK->gra = false;
      LINK->dec = false;
      LINK->hom = false;
      LINK->mln = false;
      LINK->deg = false;
    }

    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2757L, 4L, -1L, 0L);
    /*$endif TRACE*/

    /*$ifdef TRACE*/
    if (boolean_option[83]) {
      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2757L, 4L, -1L, 1L);
      /*$endif TRACE*/

      write_integer(stdout, *LINK->c_hie3 + 1, 5L);

      write_char(stdout, ' ');
      write_char(stdout, '|');

      if (LINK->ok_sets)
	write_char(stdout, ' ');
      else
	write_char(stdout, '%');
      if (LINK->ok_quadratic)
	write_char(stdout, ' ');
      else
	write_char(stdout, '#');
      if (LINK->ok_degenerated)
	write_char(stdout, ' ');
      else
	write_char(stdout, '$');

      if (LINK->model->copy)
	write_char(stdout, 'C');
      else
	write_char(stdout, ' ');

      if (LINK->mim)
	write_char(stdout, 'M');
      else
	write_char(stdout, ' ');
      if (LINK->gra)
	write_char(stdout, 'G');
      else
	write_char(stdout, ' ');
      if (LINK->dec)
	write_char(stdout, 'D');
      else
	write_char(stdout, ' ');

      if (LINK->hom)
	write_char(stdout, 'H');
      else
	write_char(stdout, ' ');
      if (LINK->mln)
	write_char(stdout, 'L');
      else
	write_char(stdout, ' ');
      if (LINK->deg)
	write_char(stdout, '0');
      else
	write_char(stdout, ' ');

      write_char(stdout, ' ');
      write_char(stdout, '|');
      write_char(stdout, ' ');

      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2757L, 4L, -1L, 2L);
      ntr_model_g_c(tzt, 20L, 2757L, 4L, -1L, -1L, &LINK->model);
      ntr_model_g_c(tzt, 20L, 2757L, 4L, -1L, -1L, &LINK->super_model);
      /*$endif TRACE*/

      if (LINK->ok_quadratic && LINK->ok_sets && LINK->ok_degenerated)
	print_tree_model(&LINK->model, &LINK->super_model);
      else
	write_space(stdout, 15L);

      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2757L, 4L, -1L, 3L);
      /*$endif TRACE*/

      write_char(stdout, ' ');
      write_char(stdout, '(');
      write_char(stdout, ' ');
      print_vertex_set_table(a0);
      write_char(stdout, ' ');
      write_char(stdout, '/');
      write_char(stdout, '/');
      write_char(stdout, ' ');
      print_g_c_slash(LINK->discrete_gc, 0L, line_length);
      print_g_c_slash(LINK->linear_gc, 0L, line_length);
      print_g_c(LINK->quadratic_gc, 0L, line_length);

      write_char(stdout, ')');
      write_char(stdout, ' ');

      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2757L, 4L, -1L, 4L);
      /*$endif TRACE*/

      if (!boolean_option[85]) {
	write_char(stdout, '+');
	write_char(stdout, ' ');
	q = LINK->quadratic_gcs;
	while (q != NULL) {
	  print_g_c(q->g_c, 0L, line_length);
	  write_char(stdout, ' ');
	  q = q->pointer;
	}
      }

      /*$ifdef TRACE*/
      ntr(tzt, 20L, 2757L, 4L, -1L, 5L);
      /*$endif TRACE*/

      write_line(stdout);

      if (boolean_option[84]) {
	if (LINK->ok_quadratic && LINK->ok_sets) {
	  /*$ifdef TRACE*/
	  ntr(tzt, 20L, 2757L, 4L, -1L, 6L);
	  /*$endif TRACE*/

	  permutations_discrete = NULL;
	  permute_set_list(LINK->discrete_gc, NULL, &permutations_discrete);
	  permutations_quadratic = NULL;
	  permute_set_list(LINK->quadratic_gc, NULL, &permutations_quadratic);
	  permutations_linear = NULL;
	  permute_set_list(LINK->linear_gc, NULL, &permutations_linear);

	  q_0 = permutations_discrete;
	  while (q_0 != NULL) {
	    q_1 = permutations_linear;
	    while (q_1 != NULL) {
	      q_2 = permutations_quadratic;
	      while (q_2 != NULL) {
		/*$ifdef TRACE*/
		ntr(tzt, 20L, 2757L, 4L, -1L, 9L);
		/*$endif TRACE*/

		write_char(stdout, '@');
		write_char(stdout, ' ');
		write_char(stdout, ' ');
		write_char(stdout, ' ');
		write_char(stdout, '(');
		write_char(stdout, ' ');
		print_vertex_set_table(a0);
		write_char(stdout, ' ');

		write_char(stdout, '/');
		write_char(stdout, '/');
		write_char(stdout, ' ');
		print_g_c_slash(q_0->g_c, 0L, line_length);
		print_g_c_slash(q_1->g_c, 0L, line_length);
		print_g_c(q_2->g_c, 0L, line_length);

		write_char(stdout, ')');
		write_line(stdout);

		q_2 = q_2->pointer;
	      }

	      q_1 = q_1->pointer;
	    }
	    q_0 = q_0->pointer;
	  }

	  dispose_g_c_list(&permutations_discrete);
	  dispose_g_c_list(&permutations_linear);
	  dispose_g_c_list(&permutations_quadratic);
	}

      }


    }

    /*$endif TRACE*/

    if (LINK->ok_quadratic && LINK->ok_sets) {
      LINK->model->id->UU.U1.g_c_discrete = NULL;
      LINK->model->id->UU.U1.g_c_quadratic = NULL;
      LINK->model->id->UU.U1.g_c_linear = NULL;

      dispose_model(&LINK->model);
      /* dispose_model_link(model); */
    }

    dispose_model_and_link(&LINK->super_model);

    /*$ifdef TRACE*/
    ntr(tzt, 20L, 2757L, 5L, -1L, 0L);
    /*$endif TRACE*/

    (*LINK->c_hie3)++;
    *LINK->c_hie2 += LINK->ok_sets;
    if (boolean_option[110] && boolean_option[85])
      *LINK->c_hie1 += LINK->ok_degenerated;
    else
      *LINK->c_hie1 += LINK->ok_quadratic;
    if (LINK->ok_sets && LINK->ok_quadratic) {
      *LINK->c_mim += LINK->mim;
      *LINK->c_lin += LINK->mln;
      LINK->dec = (LINK->dec && LINK->gra);
      *LINK->c_hom += (LINK->hom && LINK->mim);
      *LINK->c_gra += LINK->gra;
      *LINK->c_h_g += (LINK->gra && LINK->hom);
      *LINK->c_dec += LINK->dec;
      *LINK->c_h_d += (LINK->dec && LINK->hom);
    }


    dispose_set_list(&LINK->quadratic_gc);
    return;
  }

  find_quadratic_gc(set_number - 1, Local_Var.v1, Local_Var.v2, LINK);
  P_setcpy(LINK->a, LINK->vertex_set[set_number-1]);
  u = from_continuous_vertex(&Local_Var.v1);
  P_setcpy(a1, LINK->a);
  P_addset(a1, u);
  u = from_continuous_vertex(&Local_Var.v2);
  P_setcpy(a2, LINK->a);
  P_addset(a2, u);
  LINK->b = subset_of_an_edge(a1, &LINK->linear_gc);
  if (LINK->b)
    LINK->b = subset_of_an_edge(a2, &LINK->linear_gc);
  if (Local_Var.v1 == Local_Var.v2 && boolean_option[85])
    P_addset(P_expset(LINK->a, 0L), double_vertex);   /* empty_set + */
  else
    P_setcpy(LINK->a, empty_set);
  P_setunion(LINK->a, LINK->a, a1);
  P_setunion(LINK->a, LINK->a, a2);
  if (LINK->b) {
    if (!P_setequal(LINK->a, empty_set)) {
      p = LINK->quadratic_gcs->g_c;
      while (p != NULL && LINK->b) {
	if (P_subset(LINK->a, p->vertex_set) ||
	    P_subset(p->vertex_set, LINK->a))
	  LINK->b = false;
	else
	  p = p->pointer;
      }
    } else
      LINK->b = (LINK->quadratic_gcs->g_c == NULL);
  }
  if (!LINK->b)
    return;
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, LINK->a);
  p->pointer = LINK->quadratic_gcs->g_c;
  LINK->quadratic_gcs->g_c = p;
  find_quadratic_gc(set_number - 1, Local_Var.v1, Local_Var.v2, LINK);
  LINK->quadratic_gcs->g_c = LINK->quadratic_gcs->g_c->pointer;
  _Free(p);
}  /* find_quadratic_gc */

/* Local variables for find_linear_gc: */
struct LOC_find_linear_gc {
  struct LOC_new_count_mixed_models *LINK;
  t_continuous_vertex v;
} ;

Local Void find_linear_gc(set_number, v_, LINK)
t_integer set_number;
t_continuous_vertex v_;
struct LOC_new_count_mixed_models *LINK;
{
  struct LOC_find_linear_gc Local_Var;
  t_set_list *p;
  t_g_c_list *q;
  t_vertex u;
  /*$ifdef TRACE*/
  pch20 tzt;

  /*$endif TRACE*/
  Local_Var.LINK = LINK;
  Local_Var.v = v_;
  /*$ifdef TRACE*/
  memcpy(tzt, " FindLinearGc       ", sizeof(pch20));
  ntr(tzt, 20L, 2758L, 1L, (long)Local_Var.v, set_number);
  /*$endif TRACE*/
  if (set_number == 0) {
    if (Local_Var.v < last_continuous_vertex && mixed_data) {
      q = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
      if (q == NULL)
	_OutMem();
      q->pointer = LINK->linear_gcs;
      LINK->linear_gcs = q;
      LINK->linear_gcs->g_c = NULL;
      find_linear_gc(power2((double)LINK->discrete_dimension),
		     Local_Var.v + 1, LINK);
      LINK->linear_gcs = LINK->linear_gcs->pointer;
      _Free(q);
      return;
    }
    /*$ifdef TRACE*/
    if (false) {
      write_char(stdout, '(');
      write_char(stdout, ' ');
      print_g_c_slash(LINK->discrete_gc, 0L, line_length);
      q = LINK->linear_gcs;
      while (q != NULL) {
	print_g_c(q->g_c, 0L, line_length);
	write_char(stdout, ' ');
	q = q->pointer;
      }
      write_char(stdout, ')');
      write_char(stdout, ' ');
      write_line(stdout);
    }
    /*$endif TRACE*/

    if (false)   /* discrete_gc <> nil */
      return;

    q = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (q == NULL)
      _OutMem();
    LINK->quadratic_gcs = q;
    LINK->quadratic_gcs->g_c = NULL;
    LINK->quadratic_gcs->pointer = NULL;
    LINK->linear_gc = return_union_g_c(LINK->linear_gcs);
    find_quadratic_gc(power2((double)LINK->discrete_dimension),
		      first_continuous_vertex, first_continuous_vertex, LINK);
    dispose_set_list(&LINK->linear_gc);
    LINK->quadratic_gcs = NULL;
    _Free(q);
    return;
  }

  find_linear_gc(set_number - 1, Local_Var.v, LINK);
  P_setcpy(LINK->a, LINK->vertex_set[set_number-1]);
  if (!P_setequal(LINK->a, empty_set)) {
    LINK->b = subset_of_an_edge(LINK->a, &LINK->discrete_gc);
    p = LINK->linear_gcs->g_c;
    while (p != NULL && LINK->b) {
      if (P_subset(LINK->a, p->vertex_set) || P_subset(p->vertex_set, LINK->a))
	LINK->b = false;
      else
	p = p->pointer;
    }
  } else
    LINK->b = (LINK->linear_gcs->g_c == NULL);
  if (!LINK->b)
    return;
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  u = from_continuous_vertex(&Local_Var.v);
  P_setcpy(p->vertex_set, LINK->a);
  P_addset(p->vertex_set, u);
  p->pointer = LINK->linear_gcs->g_c;
  LINK->linear_gcs->g_c = p;
  find_linear_gc(set_number - 1, Local_Var.v, LINK);
  LINK->linear_gcs->g_c = LINK->linear_gcs->g_c->pointer;
  _Free(p);
}

Local Void find_discrete_gc(set_number, LINK)
t_integer set_number;
struct LOC_new_count_mixed_models *LINK;
{
  t_set_list *p;
  t_g_c_list *q;

  /*$ifdef TRACE*/
  ntr(" FindDiscreteGc     ", 20L, 2759L, 1L, -1L, set_number);   /**/
  /*$endif TRACE*/
  if (set_number == 0) {
    if (LINK->discrete_gc == NULL)
      return;
    q = (t_g_c_list *)Malloc(sizeof(t_g_c_list));
    if (q == NULL)
      _OutMem();
    LINK->linear_gcs = q;
    LINK->linear_gcs->g_c = NULL;
    LINK->linear_gcs->pointer = NULL;
    find_linear_gc(power2((double)LINK->discrete_dimension),
		   first_continuous_vertex, LINK);
    LINK->linear_gcs = NULL;
    _Free(q);
    return;
  }
  find_discrete_gc(set_number - 1, LINK);
  P_setcpy(LINK->a, LINK->vertex_set[set_number-1]);
  LINK->b = true;
  p = LINK->discrete_gc;
  while (p != NULL && LINK->b) {
    if (P_subset(LINK->a, p->vertex_set) || P_subset(p->vertex_set, LINK->a))
      LINK->b = false;
    else
      p = p->pointer;
  }
  if (!LINK->b)
    return;
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, LINK->a);
  p->pointer = LINK->discrete_gc;
  LINK->discrete_gc = p;
  find_discrete_gc(set_number - 1, LINK);
  LINK->discrete_gc = LINK->discrete_gc->pointer;
  _Free(p);
}


Static Void new_count_mixed_models(discrete_dimension_, c_hie3_, c_hie2_,
  c_hie1_, c_mim_, c_hom_, c_lin_, c_gra_, c_h_g_, c_dec_, c_h_d_)
t_long_integer discrete_dimension_, *c_hie3_, *c_hie2_, *c_hie1_, *c_mim_,
	       *c_hom_, *c_lin_, *c_gra_, *c_h_g_, *c_dec_, *c_h_d_;
{
  /* ,
                                   continuous_dimension */
  /* c_gen, */
  struct LOC_new_count_mixed_models Local_Var;
  t_offset_index offset_index;
  t_model_tree_node *new_model_tree;
  t_offset_index FORLIM;

  Local_Var.discrete_dimension = discrete_dimension_;
  Local_Var.c_hie3 = c_hie3_;
  Local_Var.c_hie2 = c_hie2_;
  Local_Var.c_hie1 = c_hie1_;
  Local_Var.c_mim = c_mim_;
  Local_Var.c_hom = c_hom_;
  Local_Var.c_lin = c_lin_;
  Local_Var.c_gra = c_gra_;
  Local_Var.c_h_g = c_h_g_;
  Local_Var.c_dec = c_dec_;
  Local_Var.c_h_d = c_h_d_;
  /*$ifdef TRACE*/
  ntr(" NewCountMixed      ", 20L, 2759L, 1L, -1L,
      Local_Var.discrete_dimension);
  FORLIM = power2((double)Local_Var.discrete_dimension);
  /*$endif TRACE*/
  for (offset_index = 1; offset_index <= FORLIM; offset_index++)
    find_set_number(offset_index, Local_Var.vertex_set[offset_index-1]);
  /*$ifdef TRACE*/
  ntr(" NewCountMixed      ", 20L, 2759L, 1L, -1L, *Local_Var.c_mim);
  /*$endif TRACE*/

  Local_Var.discrete_gc = NULL;
  insert_set_in_set_list(delta_gamma, &Local_Var.discrete_gc);
  new_model(&Local_Var.model);
  erase_mixed_model(&Local_Var.model);
  P_setcpy(Local_Var.model->id->vertices, delta_gamma);
  if (boolean_option[85])
    split_g_c_in_mixed_terms(Local_Var.discrete_gc, true, false,
      &Local_Var.model->id->UU.U1.g_c_discrete,
      &Local_Var.model->id->UU.U1.g_c_linear,
      &Local_Var.model->id->UU.U1.g_c_quadratic);
  else
    copy_g_c_to_mixed_graphical_model(Local_Var.discrete_gc, false, false,
				      &Local_Var.model);
  dispose_set_list(&Local_Var.discrete_gc);   /**/

  check_mixed_model(&Local_Var.model, " NewCountMixed      ", 16L, false);
  identify_model(&Local_Var.model);
  Local_Var.dummy = ok_log_model(&Local_Var.model, true);
  Local_Var.link_model_tree = NULL;

  super_insert_model_in_model_tree(&Local_Var.link_model_tree,
				   &Local_Var.model, false);
  /* Hack for starting !!! */

  dispose_model(&Local_Var.model);

  Local_Var.discrete_gc = NULL;
  Local_Var.linear_gcs = NULL;
  Local_Var.quadratic_gcs = NULL;
  /* c_gen := 0; */
  *Local_Var.c_mim = 0;
  *Local_Var.c_gra = 0;
  *Local_Var.c_h_g = 0;
  *Local_Var.c_dec = 0;
  *Local_Var.c_h_d = 0;
  *Local_Var.c_hom = 0;
  *Local_Var.c_lin = 0;
  /*$ifdef TRACE*/
  if (boolean_option[83])
    write_line(stdout);
  /*$endif TRACE*/
  find_discrete_gc(power2((double)Local_Var.discrete_dimension), &Local_Var);
  write_line(stdout);
  print_model_tree(&Local_Var.link_model_tree->sub_models->node,
		   &Local_Var.link_model_tree->link_model,
		   Local_Var.link_model_tree->link_model, 0L);
      /**/
  if (!boolean_option[80])
    dispose_model_tree(&Local_Var.link_model_tree);
  else {
    new_model_tree = NULL;
    redo_model_tree(&Local_Var.link_model_tree, &new_model_tree);
    /*$ifdef TRACE*/
    ntr(" RedoModelTree: Done", 20L, 2756L, 7L, -1L, -1L);
    /*$endif TRACE*/
    write_line(stdout);
    print_model_tree(&new_model_tree->sub_models->node,
		     &new_model_tree->link_model, new_model_tree->link_model,
		     0L);
	/**/
    dispose_model_tree(&new_model_tree);
  }
  dispose_model_link(&Local_Var.model);
  /*$ifdef TRACE*/
  ntr(" NewCountMixed      ", 20L, 2756L, 8L, -1L, *Local_Var.c_mim);
  /*$endif TRACE*/
}  /* new_count_mixed_models */


/* Local variables for count_mixed_models: */
struct LOC_count_mixed_models {
  t_integer dimension;
  long *c_hie, *c_gra, *c_dec;
  t_set_list *sets_gc;
  /*, hie*/
  boolean b, gra, dec;
  t_vertex_set a;
  t_vertex_set vertex_set[MAX_OFFSET_CELL_NUMBER];
} ;

/* Local variables for split_mixed: */
struct LOC_split_mixed {
  struct LOC_count_mixed_models *LINK;
  boolean *gra, *dec;
  t_set_list *discrete_g_c, *linear_g_c, *quadratic_g_c, *homogene_g_c,
	     *heterogene_g_c;
} ;

Local Void test_mixed_model(discrete_g_c, linear_g_c, quadratic_g_c, gra, dec,
			    LINK)
t_set_list *discrete_g_c, *linear_g_c, *quadratic_g_c;
boolean *gra, *dec;
struct LOC_split_mixed *LINK;
{
  t_vertex_set vertex_set;
  t_v_arr_of_v_lists adj_list;
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_set_list *g_c = NULL, *p = discrete_g_c;

  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c);
    p = p->pointer;
  }
  p = linear_g_c;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c);
    p = p->pointer;
  }
  p = quadratic_g_c;
  while (p != NULL) {
    insert_clique(p->vertex_set, &g_c);
    p = p->pointer;
  }
  *gra = false;
  *dec = false;
  hypergraph_sets_to_graph_sets(g_c, vertex_set, adj_set);
  if (test_graphical(adj_set, &g_c)) {
    *gra = true;
    adj_set_to_adj_list(adj_set, adj_list);
    maximum_cardinality_search(adj_list, order, invers_order);
    *dec = test_for_zero_fill_in(adj_list, order, invers_order);
    dispose_adj_list(adj_list);
  }
  /*$ifdef TRACE*/
  if (boolean_option[83]) {
    write_char(stdout, '(');
    write_char(stdout, ' ');
    print_vertex_set_table(vertex_set);
    write_char(stdout, ' ');
    write_char(stdout, '/');
    write_char(stdout, ' ');
    print_g_c_slash(discrete_g_c, 0L, line_length);
    print_g_c_slash(linear_g_c, 0L, line_length);
    print_g_c(quadratic_g_c, 0L, line_length);
    write_char(stdout, ' ');
    write_char(stdout, ')');
    write_char(stdout, ' ');
    write_char(stdout, '(');
    write_char(stdout, ' ');
    print_g_c_slash(LINK->homogene_g_c, 0L, line_length);
    print_g_c(LINK->heterogene_g_c, 0L, line_length);
    write_char(stdout, ' ');
    write_char(stdout, ')');
    write_char(stdout, ' ');
    if (*gra)
      write_char(stdout, 'G');
    if (*dec)
      write_char(stdout, 'D');
    write_line(stdout);
  }
  /*$endif TRACE*/
  dispose_set_list(&g_c);
}  /* test_mixed_model */

Local Void find_mixed_list_of_sets(set_number, LINK)
t_integer set_number;
struct LOC_split_mixed *LINK;
{
  t_set_list *p;

  if (set_number == 1) {
    if (test_sub_g_c(LINK->homogene_g_c, LINK->quadratic_g_c))
      test_mixed_model(LINK->discrete_g_c, LINK->linear_g_c,
		       LINK->quadratic_g_c, LINK->gra, LINK->dec, LINK);
    (*LINK->LINK->c_hie)++;
    *LINK->LINK->c_gra += *LINK->gra;
    *LINK->LINK->c_dec += *LINK->dec;
    return;
  }
  find_mixed_list_of_sets(set_number - 1, LINK);
  P_setcpy(LINK->LINK->a, LINK->LINK->vertex_set[set_number-1]);
  LINK->LINK->b = true;
  if (P_subset(LINK->LINK->a, delta))
    LINK->LINK->b = false;
  p = LINK->quadratic_g_c;
  while (p != NULL && LINK->LINK->b) {
    if (P_subset(LINK->LINK->a, p->vertex_set) ||
	P_subset(p->vertex_set, LINK->LINK->a))
      LINK->LINK->b = false;
    else
      p = p->pointer;
  }
  if (!LINK->LINK->b)
    return;
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, LINK->LINK->a);
  p->pointer = LINK->quadratic_g_c;
  LINK->quadratic_g_c = p;
  if (test_sub_g_c(LINK->quadratic_g_c, LINK->heterogene_g_c))
    find_mixed_list_of_sets(set_number - 1, LINK);
  LINK->quadratic_g_c = LINK->quadratic_g_c->pointer;
  _Free(p);
}

Local Void split_mixed(g_c, gra_, dec_, LINK)
t_set_list *g_c;
boolean *gra_, *dec_;
struct LOC_count_mixed_models *LINK;
{
  struct LOC_split_mixed Local_Var;

  Local_Var.LINK = LINK;
  Local_Var.gra = gra_;
  Local_Var.dec = dec_;
  split_g_c_in_mixed_terms(g_c, boolean_option[85], true,
			   &Local_Var.discrete_g_c, &Local_Var.linear_g_c,
			   &Local_Var.homogene_g_c);
  dispose_set_list(&Local_Var.discrete_g_c);
  dispose_set_list(&Local_Var.linear_g_c);
  split_g_c_in_mixed_terms(g_c, boolean_option[85], false,
			   &Local_Var.discrete_g_c, &Local_Var.linear_g_c,
			   &Local_Var.heterogene_g_c);
  Local_Var.quadratic_g_c = NULL;
  /*$ifdef TRACE*/
  if (boolean_option[83])
    write_line(stdout);
  /*$endif TRACE*/
  find_mixed_list_of_sets((long)floor(exp_2((double)LINK->dimension) + 0.5),
			  &Local_Var);
  dispose_set_list(&Local_Var.discrete_g_c);
  dispose_set_list(&Local_Var.linear_g_c);
  dispose_set_list(&Local_Var.homogene_g_c);
  dispose_set_list(&Local_Var.heterogene_g_c);
}

Local Void find_list_of_sets(set_number, LINK)
t_integer set_number;
struct LOC_count_mixed_models *LINK;
{
  t_set_list *p;

  if (set_number == 1) {
    split_mixed(LINK->sets_gc, &LINK->gra, &LINK->dec, LINK);
    (*LINK->c_hie)++;
    *LINK->c_gra += LINK->gra;
    *LINK->c_dec += LINK->dec;
    return;
  }
  find_list_of_sets(set_number - 1, LINK);
  P_setcpy(LINK->a, LINK->vertex_set[set_number-1]);
  LINK->b = true;
  p = LINK->sets_gc;
  while (p != NULL && LINK->b) {
    if (P_subset(LINK->a, p->vertex_set) || P_subset(p->vertex_set, LINK->a))
      LINK->b = false;
    else
      p = p->pointer;
  }
  if (!LINK->b)
    return;
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, LINK->a);
  p->pointer = LINK->sets_gc;
  LINK->sets_gc = p;
  find_list_of_sets(set_number - 1, LINK);
  LINK->sets_gc = LINK->sets_gc->pointer;
  _Free(p);
}


/* new page */
Static Void count_mixed_models(dimension_, c_gen, c_hie_, c_gra_, c_dec_)
t_integer dimension_;
t_long_integer *c_gen, *c_hie_, *c_gra_, *c_dec_;
{
  struct LOC_count_mixed_models Local_Var;
  t_offset_index offset_index, FORLIM;

  Local_Var.dimension = dimension_;
  Local_Var.c_hie = c_hie_;
  Local_Var.c_gra = c_gra_;
  Local_Var.c_dec = c_dec_;
  FORLIM = (long)floor(exp_2((double)Local_Var.dimension) + 0.5);
  for (offset_index = 1; offset_index <= FORLIM; offset_index++)
    invers_offset_hash(offset_index, Local_Var.vertex_set[offset_index-1]);
  Local_Var.sets_gc = NULL;
  *Local_Var.c_hie = 0;
  *Local_Var.c_gra = 0;
  *Local_Var.c_dec = 0;
  *c_gen = (long)floor(exp_2(exp_2((double)Local_Var.dimension) - 1) + 0.5);
  find_list_of_sets((long)floor(exp_2((double)Local_Var.dimension) + 0.5),
		    &Local_Var);
}  /* count_mixed_models */


Static Void write_integer_plus_report(f, i, w)
FILE *f;
t_long_integer i;
t_integer w;
{
  write_integer(f, i, w);
  if (i == _INVALID)
    write_char_w_text(report_file, '-', 11L);
  else
    write_integer_text(report_file, i, 11L);
}  /* write_integer_plus_report */


/* new page */
Static Void proc_count_mixed(command_file, as_argument, ifail, sub_code,
			     arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_long_integer over_hie3 = 0, over_hie2 = 0, over_hie1 = 0, over_hie = 0,
		 over_gra = 0, over_dec = 0, count_hie3 = 0, count_hie2 = 0,
		 count_hie1 = 0, count_gen = 0, count_mim = 0, count_gra = 0,
		 count_h_g = 0, count_dec = 0, count_h_d = 0, count_hom = 0,
		 count_lin = 0, i = 0;
  t_long_integer m_ty;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Type->   ", 7L, &m_ty);
  /*
  if m_ty > 0 then begin
     read_integer(command_file, ' dim.->   ', 7, d);
     count_dim := dimension;
     dimension := d;
     w := last_vertex;
     last_vertex := first_vertex;
     while 1 + ord(last_vertex) - ord(first_vertex) < dimension do
        last_vertex := succ(last_vertex);
  end;
  */
  if (m_ty == -2)
    m_ty = 2;
  if (!mixed_data)
    m_ty = 1;
  switch (m_ty) {

  case 1:
    count_mixed_models((long)dimension, &count_gen, &count_mim, &count_gra,
		       &count_dec);
    break;

  case 2:   /* cardinality(gamma_), */
    /* count_gen, */
    new_count_mixed_models(cardinality(delta), &count_hie3, &count_hie2,
			   &count_hie1, &count_mim, &count_hom, &count_lin,
			   &count_gra, &count_h_g, &count_dec, &count_h_d);
    break;
  }
  count_gen = _INVALID;

  write_line(stdout);
  write_pch_20_text(report_file, " :: CountMixed: ", 16L);
  write_pch(stdout, " Dimension:         ", 20L);
  write_integer_plus_report(stdout, (long)dimension, 20L);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_integer_plus_report(stdout, cardinality(delta), 4L);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_integer_plus_report(stdout, cardinality(gamma_), 4L);
  write_line(stdout);
  write_pch(stdout, " General:           ", 20L);
  write_integer_plus_report(stdout, count_gen, 20L);
  write_line(stdout);
  write_line(stdout);

  write_space(stdout, 20L);
  write_pch(stdout, "                 All", 20L);
  write_pch(stdout, "        Homogeneuous", 20L);
  write_pch(stdout, "             Invalid", 20L);
  write_line(stdout);

  write_line(stdout);
  write_pch(stdout, " (Hierarchical, all:", 20L);
  write_integer_plus_report(stdout, count_hie3, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer_plus_report(stdout, over_hie3, 5L);
  }
  write_char(stdout, ')');

  write_line(stdout);
  if (boolean_option[85])
    write_pch(stdout, " Hierarchical:      ", 20L);
  else
    write_pch(stdout, " (Linear in Quad.:  ", 20L);
  write_integer_plus_report(stdout, count_hie2, 20L);
  write_integer(stdout, _INVALID, 20L);
  write_integer(stdout, count_hie3 - count_hie2, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer(stdout, over_hie2, 5L);
  }
  if (!boolean_option[85])
    write_char(stdout, ')');
  write_line(stdout);

  if (boolean_option[110] && boolean_option[85]) {
    /* write_pch(output, ' - degenerated:     ', 20) */
    write_pch(stdout, " Non-degenerated:   ", 20L);
  } else
    write_pch(stdout, " (Quadratic GC:     ", 20L);
  write_integer_plus_report(stdout, count_hie1, 20L);
  write_integer(stdout, _INVALID, 20L);
  write_integer(stdout, count_hie3 - count_hie1, 20L);
  if (over_hie != 0) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer_plus_report(stdout, over_hie1, 5L);
  }
  if (!(boolean_option[110] && boolean_option[85]))
    write_char(stdout, ')');
  write_line(stdout);
  write_line(stdout);

  write_pch(stdout, " Mim models:        ", 20L);
  /* write_pch(output, ' Mim models: 133/760', 20); */
  write_integer_plus_report(stdout, count_mim, 20L);
  write_integer_plus_report(stdout, count_hom, 20L);
  write_integer(stdout, count_hie3 - count_mim, 20L);
  if (over_hie != 0) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer_plus_report(stdout, -1L, 5L);
  }
  write_line(stdout);

  write_pch(stdout, " Graphical:         ", 20L);
  /* write_pch(output, ' Graphical:  113/201', 20); */
  write_integer_plus_report(stdout, count_gra, 20L);
  write_integer_plus_report(stdout, count_h_g, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer_plus_report(stdout, over_gra, 5L);
  }
  write_line(stdout);

  write_pch(stdout, " Decomposable:      ", 20L);
  /* write_pch(output, ' Decomposable:93/161', 20); */
  write_integer_plus_report(stdout, count_dec, 20L);
  write_integer_plus_report(stdout, count_h_d, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer_plus_report(stdout, 0, 5L);
  }
  write_line(stdout);
  /*
  write_pch(output, ' Homogeneuous:      ', 20);
  write_integer(output, _invalid, 20);
  write_integer_plus_report(output, count_hom, 20);
  if over_dec <> 0 then begin
     write_pch  (output, ' + @@@@@@@', 3);
     write_integer(output, maxint, 20);
     write_pch  (output, ' * @@@@@@@', 3);
     write_integer(output, -1, 5)
  end;
  write_line(output);
   */
  write_pch(stdout, " Mean linear:       ", 20L);
  write_integer_plus_report(stdout, count_lin, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer(stdout, -1L, 5L);
  }
  write_line(stdout);
  write_line_text(report_file);
  /*
  if m_ty <> 0 then begin
     last_vertex := w;
     dimension := count_dim;
  end;
  */
  if (echo_note)
    write_pch(stdout, " Models counted     ", 20L);
}


/* Local variables for count_decomposable_models: */
struct LOC_count_decomposable_models {
  long *c_hie, *c_gra, *c_dec;
  t_set_list *sets_gc;
  /*, hie*/
  boolean b, gra, dec;
  t_vertex_set a;
  t_vertex_set vertex_set[MAX_OFFSET_CELL_NUMBER];
} ;

Local Void test_hier_model(sets_gc, gra, dec, LINK)
t_set_list *sets_gc;
boolean *gra, *dec;
struct LOC_count_decomposable_models *LINK;
{
  t_vertex_set vertex_set;
  t_v_arr_of_v_lists adj_list;
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;

  *gra = false;
  *dec = false;
  hypergraph_sets_to_graph_sets(sets_gc, vertex_set, adj_set);
  if (test_graphical(adj_set, &sets_gc)) {
    *gra = true;
    adj_set_to_adj_list(adj_set, adj_list);
    maximum_cardinality_search(adj_list, order, invers_order);
    *dec = test_for_zero_fill_in(adj_list, order, invers_order);
    dispose_adj_list(adj_list);
  }
  /*$ifdef TRACE*/
  if (!(boolean_option[83] || boolean_option[84] && *gra ||
	boolean_option[85] && *dec))
    return;
  /*$endif TRACE*/
  write_char(stdout, '(');
  write_char(stdout, ' ');
  print_vertex_set_table(vertex_set);
  write_char(stdout, ' ');
  write_char(stdout, '/');
  write_char(stdout, ' ');
  print_g_c(sets_gc, 0L, line_length);
  write_char(stdout, ' ');
  write_char(stdout, ')');
  write_char(stdout, ' ');
  if (*gra)
    write_char(stdout, 'G');
  if (*dec)
    write_char(stdout, 'D');
  write_line(stdout);
}  /* test_hier_model */

Local Void find_list_of_sets_(set_number, LINK)
t_long_integer set_number;
struct LOC_count_decomposable_models *LINK;
{
  t_set_list *p;

  if (set_number == 1) {
    test_hier_model(LINK->sets_gc, &LINK->gra, &LINK->dec, LINK);
    (*LINK->c_hie)++;
    *LINK->c_gra += LINK->gra;
    *LINK->c_dec += LINK->dec;
    return;
  }
  find_list_of_sets_(set_number - 1, LINK);
  P_setcpy(LINK->a, LINK->vertex_set[set_number-1]);
  LINK->b = true;
  p = LINK->sets_gc;
  while (p != NULL && LINK->b) {
    if (P_subset(LINK->a, p->vertex_set) || P_subset(p->vertex_set, LINK->a))
      LINK->b = false;
    else
      p = p->pointer;
  }
  if (!LINK->b)
    return;
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, LINK->a);
  p->pointer = LINK->sets_gc;
  LINK->sets_gc = p;
  find_list_of_sets_(set_number - 1, LINK);
  LINK->sets_gc = LINK->sets_gc->pointer;
  _Free(p);
}


/*@+"countd.p"*/


/*

2768:    +++  ++
2769:    +++  ++
2770:    ---  -- p/countd.p         30     140    1860 p/countd.p
2771: |    2:    procedure count_decomposable_models
2772: |   12:    procedure test_hier_model
2773: |   55:    procedure find_list_of_sets
2774: |   98:    procedure count_hierarchical_models
2775: |  107:    procedure find_list_of_sets
2776: |  145:    procedure new_count_decomposable_models
2777: |  156:    procedure test_hier_model
2778: |  179:    procedure find_list_of_sets
2779: |  183:    procedure plus_one
2780: |  241:    procedure new_count_hierarchical_models
2781: |  251:    procedure find_list_of_sets
2782: |  255:    procedure plus_one
2783: |  305:    procedure count_cliques_1
2784: |  313:    procedure find_cliques_1
2785: |  325:    procedure find_cliques_1
2786: |  329:    procedure find_complete_1
2787: |  375:    procedure insert_edge_1
2788: |  412:    procedure count_cliques_2
2789: |  422:    procedure find_cliques_2
2790: |  434:    procedure find_cliques_2
2791: |  438:    procedure find_complete_2
2792: |  485:    procedure insert_edge_2
2793: |  530:    procedure count_cliques_3
2794: |  538:    procedure find_cliques_3
2795: |  552:    procedure find_cliques_3
2796: |  556:    procedure find_complete_3
2797: |  603:    procedure insert_edge_3
2798: |  648:    procedure proc_count_cliques
2799: |  730:    procedure proc_count_decomposable
2800: |  814:    procedure proc_count_hierarchical
2801:    +++  ++
2802:    +++  ++

*/


/* new page */
Static Void count_decomposable_models(dimension, c_gen, c_hie_, c_gra_, c_dec_)
t_long_integer dimension, *c_gen, *c_hie_, *c_gra_, *c_dec_;
{
  struct LOC_count_decomposable_models Local_Var;
  t_offset_index offset_index, FORLIM;

  Local_Var.c_hie = c_hie_;
  Local_Var.c_gra = c_gra_;
  Local_Var.c_dec = c_dec_;
  FORLIM = (long)floor(exp_2((double)dimension) + 0.5);
  for (offset_index = 1; offset_index <= FORLIM; offset_index++)
    invers_offset_hash(offset_index, Local_Var.vertex_set[offset_index-1]);
  Local_Var.sets_gc = NULL;
  *Local_Var.c_hie = 0;
  *Local_Var.c_gra = 0;
  *Local_Var.c_dec = 0;
  *c_gen = (long)floor(exp_2(exp_2((double)dimension) - 1) + 0.5);
  find_list_of_sets_((long)floor(exp_2((double)dimension) + 0.5), &Local_Var);
}  /* count_decomposable_models */


/* Local variables for count_hierarchical_models: */
struct LOC_count_hierarchical_models {
  long *c_hie;
  t_set_list *sets_gc;
  /*, hie, gra, dec*/
  boolean b;
  t_vertex_set a;
  t_vertex_set vertex_set[MAX_OFFSET_CELL_NUMBER];
} ;

Local Void find_list_of_sets__(set_number, LINK)
t_long_integer set_number;
struct LOC_count_hierarchical_models *LINK;
{
  t_set_list *p;

  if (set_number == 1) {
    (*LINK->c_hie)++;
    return;
  }
  find_list_of_sets__(set_number - 1, LINK);
  P_setcpy(LINK->a, LINK->vertex_set[set_number-1]);
  LINK->b = true;
  p = LINK->sets_gc;
  while (p != NULL && LINK->b) {
    if (P_subset(LINK->a, p->vertex_set) || P_subset(p->vertex_set, LINK->a))
      LINK->b = false;
    else
      p = p->pointer;
  }
  if (!LINK->b)
    return;
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, LINK->a);
  p->pointer = LINK->sets_gc;
  LINK->sets_gc = p;
  find_list_of_sets__(set_number - 1, LINK);
  LINK->sets_gc = LINK->sets_gc->pointer;
  _Free(p);
}  /* find_list_of_sets */


/* new page */
Static Void count_hierarchical_models(dimension, c_gen, c_hie_)
t_long_integer dimension, *c_gen, *c_hie_;
{
  struct LOC_count_hierarchical_models Local_Var;
  t_offset_index offset_index, FORLIM;

  Local_Var.c_hie = c_hie_;
  FORLIM = (long)floor(exp_2((double)dimension) + 0.5);
  for (offset_index = 1; offset_index <= FORLIM; offset_index++)
    invers_offset_hash(offset_index, Local_Var.vertex_set[offset_index-1]);
  Local_Var.sets_gc = NULL;
  *Local_Var.c_hie = 0;
  *c_gen = (long)floor(exp_2(exp_2((double)dimension) - 1) + 0.5);
  find_list_of_sets__((long)floor(exp_2((double)dimension) + 0.5), &Local_Var);
}  /* count_hierarchical_models */


/* Local variables for new_count_decomposable_models: */
struct LOC_new_count_decomposable_models {
  long *c_hie, *c_gra, *c_dec, d_hie, d_gra, d_dec;
  t_set_list *sets_gc;
  boolean b, gra, dec;
  t_vertex_set a;
  t_vertex_set vertex_set[MAX_OFFSET_CELL_NUMBER];
} ;

Local Void test_hier_model_(sets_gc, gra, dec, LINK)
t_set_list *sets_gc;
boolean *gra, *dec;
struct LOC_new_count_decomposable_models *LINK;
{
  t_vertex_set vertex_set;
  t_v_arr_of_v_lists adj_list;
  t_v_arr_of_v_sets adj_set;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;

  *gra = false;
  *dec = false;
  hypergraph_sets_to_graph_sets(sets_gc, vertex_set, adj_set);
  if (!test_graphical(adj_set, &sets_gc))
    return;
  *gra = true;
  adj_set_to_adj_list(adj_set, adj_list);
  maximum_cardinality_search(adj_list, order, invers_order);
  *dec = test_for_zero_fill_in(adj_list, order, invers_order);
  dispose_adj_list(adj_list);
}  /* test_hier_model */

Local Void plus_one(c, d)
t_long_integer *c, *d;
{
  if (*c == LONG_MAX) {
    *c = 0;
    (*d)++;
  } else
    (*c)++;
}  /* plus_one */

Local Void find_list_of_sets___(set_number, LINK)
t_long_integer set_number;
struct LOC_new_count_decomposable_models *LINK;
{
  t_set_list *p;

  if (set_number == 1) {
    test_hier_model_(LINK->sets_gc, &LINK->gra, &LINK->dec, LINK);
    plus_one(LINK->c_hie, &LINK->d_hie);
    if (LINK->gra)
      plus_one(LINK->c_gra, &LINK->d_gra);
    if (LINK->dec)
      plus_one(LINK->c_dec, &LINK->d_dec);
    return;
  }
  find_list_of_sets___(set_number - 1, LINK);
  P_setcpy(LINK->a, LINK->vertex_set[set_number-1]);
  LINK->b = true;
  p = LINK->sets_gc;
  while (p != NULL && LINK->b) {
    if (P_subset(LINK->a, p->vertex_set) || P_subset(p->vertex_set, LINK->a))
      LINK->b = false;
    else
      p = p->pointer;
  }
  if (!LINK->b)
    return;
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, LINK->a);
  p->pointer = LINK->sets_gc;
  LINK->sets_gc = p;
  find_list_of_sets___(set_number - 1, LINK);
  LINK->sets_gc = LINK->sets_gc->pointer;
  _Free(p);
}  /* find_list_of_sets */


/* new page */
Static Void new_count_decomposable_models(dimension, c_gen, c_hie_, c_gra_,
					  c_dec_, d_hie_, d_gra_, d_dec_)
t_long_integer dimension, *c_gen, *c_hie_, *c_gra_, *c_dec_, d_hie_, d_gra_,
	       d_dec_;
{
  struct LOC_new_count_decomposable_models Local_Var;
  t_offset_index offset_index, FORLIM;

  Local_Var.c_hie = c_hie_;
  Local_Var.c_gra = c_gra_;
  Local_Var.c_dec = c_dec_;
  Local_Var.d_hie = d_hie_;
  Local_Var.d_gra = d_gra_;
  Local_Var.d_dec = d_dec_;
  FORLIM = (long)floor(exp_2((double)dimension) + 0.5);
  for (offset_index = 1; offset_index <= FORLIM; offset_index++)
    invers_offset_hash(offset_index, Local_Var.vertex_set[offset_index-1]);
  Local_Var.sets_gc = NULL;
  *Local_Var.c_hie = 0;
  Local_Var.d_hie = 0;
  *Local_Var.c_gra = 0;
  Local_Var.d_gra = 0;
  *Local_Var.c_dec = 0;
  Local_Var.d_dec = 0;
  if (log(2.0) * (exp_2((double)dimension) - 1) < log((double)LONG_MAX))
    *c_gen = (long)floor(exp_2(exp_2((double)dimension) - 1) + 0.5);
  else
    *c_gen = 0;
  find_list_of_sets___((long)floor(exp_2((double)dimension) + 0.5),
		       &Local_Var);
}  /* new_count_decomposable_models */


/* Local variables for new_count_hierarchical_models: */
struct LOC_new_count_hierarchical_models {
  long *c_hie, *d_hie;
  t_set_list *sets_gc;
  /*, hie, gra, dec*/
  boolean b;
  t_vertex_set a;
  t_vertex_set vertex_set[MAX_OFFSET_CELL_NUMBER];
} ;

Local Void plus_one_(c, d)
t_long_integer *c, *d;
{
  if (*c == LONG_MAX) {
    *c = 0;
    (*d)++;
  } else
    (*c)++;
}  /* plus_one */

Local Void find_list_of_sets____(set_number, LINK)
t_long_integer set_number;
struct LOC_new_count_hierarchical_models *LINK;
{
  t_set_list *p;

  if (set_number == 1) {
    plus_one_(LINK->c_hie, LINK->d_hie);
    return;
  }
  find_list_of_sets____(set_number - 1, LINK);
  P_setcpy(LINK->a, LINK->vertex_set[set_number-1]);
  LINK->b = true;
  p = LINK->sets_gc;
  while (p != NULL && LINK->b) {
    if (P_subset(LINK->a, p->vertex_set) || P_subset(p->vertex_set, LINK->a))
      LINK->b = false;
    else
      p = p->pointer;
  }
  if (!LINK->b)
    return;
  p = (t_set_list *)Malloc(sizeof(t_set_list));
  if (p == NULL)
    _OutMem();
  P_setcpy(p->vertex_set, LINK->a);
  p->pointer = LINK->sets_gc;
  LINK->sets_gc = p;
  find_list_of_sets____(set_number - 1, LINK);
  LINK->sets_gc = LINK->sets_gc->pointer;
  _Free(p);
}  /* find_list_of_sets */


/* new page */
Static Void new_count_hierarchical_models(dimension, c_gen, c_hie_, d_hie_)
t_long_integer dimension, *c_gen, *c_hie_, *d_hie_;
{
  struct LOC_new_count_hierarchical_models Local_Var;
  t_offset_index offset_index, FORLIM;

  Local_Var.c_hie = c_hie_;
  Local_Var.d_hie = d_hie_;
  FORLIM = (long)floor(exp_2((double)dimension) + 0.5);
  for (offset_index = 1; offset_index <= FORLIM; offset_index++)
    invers_offset_hash(offset_index, Local_Var.vertex_set[offset_index-1]);
  Local_Var.sets_gc = NULL;
  *Local_Var.c_hie = 0;
  *Local_Var.d_hie = 0;
  if (log(2.0) * (exp_2((double)dimension) - 1) < log((double)LONG_MAX))
    *c_gen = (long)floor(exp_2(exp_2((double)dimension) - 1) + 0.5);
  else
    *c_gen = 0;
  find_list_of_sets____((long)floor(exp_2((double)dimension) + 0.5),
			&Local_Var);
}  /* new_count_hierarchical_models */


/* Local variables for count_cliques_1: */
struct LOC_count_cliques_1 {
  long *gra, *dec, max_ord;
  t_vertex_set g;
} ;

/* Local variables for find_cliques_1_: */
struct LOC_find_cliques_1_ {
  t_v_arr_of_v_sets adj_set;
  t_set_list **list_of_cliques;
} ;

Local Void find_complete_1(a_, v, LINK)
long *a_;
t_vertex v;
struct LOC_find_cliques_1_ *LINK;
{
  t_vertex_set a, b;

  P_setcpy(a, a_);
  if (v != last_vertex)
    find_complete_1(a, v + 1, LINK);
  if (!P_subset(a, LINK->adj_set[v - MIN_VERTEX]))   /* and (v in sub_set) */
    return;
  P_setcpy(b, a);
  P_addset(b, v);
  insert_clique(b, LINK->list_of_cliques);
  if (v != last_vertex)
    find_complete_1(b, v + 1, LINK);
}  /* find_complete_1 */

Local Void find_cliques_1_(adj_set_, list_of_cliques_)
t_vertex_set *adj_set_;
t_set_list **list_of_cliques_;
{
  /*         sub_set                     : t_vertex_set;                     */
  struct LOC_find_cliques_1_ Local_Var;

  memcpy(Local_Var.adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  Local_Var.list_of_cliques = list_of_cliques_;
  *Local_Var.list_of_cliques = NULL;
  find_complete_1(empty_set, first_vertex, &Local_Var);
}  /* find_cliques_1 */

Local Void find_cliques_1(adj_set_, sub_set_, list_of_cliques, decomposable,
			  LINK)
t_vertex_set *adj_set_;
long *sub_set_;
t_set_list **list_of_cliques;
boolean *decomposable;
struct LOC_count_cliques_1 *LINK;
{
  t_v_arr_of_v_sets adj_set;
  t_vertex_set sub_set;
  t_v_arr_of_v_lists adj_list, fill_in_adj_list;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;
  t_vertex v;

  memcpy(adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  P_setcpy(sub_set, sub_set_);
  *decomposable = false;
  *list_of_cliques = NULL;
  if (c_partitioning) {
    if (P_setequal(sub_set, LINK->g))   /* [first_vertex .. last_vertex] */
      find_cliques_1_(adj_set, list_of_cliques);
    /*sub_set, */
    else
      find_sub_cliques(adj_set, sub_set, list_of_cliques);
    return;
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, sub_set))
      P_setint(adj_set[v - MIN_VERTEX], sub_set, adj_set[v - MIN_VERTEX]);
    else
      P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  }
  adj_set_to_adj_list(adj_set, adj_list);
  find_cliques_and_order(adj_set, adj_list, fill_in_adj_list, order,
			 invers_order, c, complete, decomposable, sub_set,
			 list_of_cliques);
  if (!*decomposable)
    dispose_adj_list(fill_in_adj_list);
  dispose_adj_list(adj_list);
}  /* find_cliques_1 */

/* new page */
Local Void insert_edge_1(adj_set_, v, w, LINK)
t_vertex_set *adj_set_;
t_vertex v, w;
struct LOC_count_cliques_1 *LINK;
{
  t_v_arr_of_v_sets adj_set;
  t_set_list *l = NULL;
  boolean decomp;

  memcpy(adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  if (w < LINK->max_ord)
    insert_edge_1(adj_set, v, w + 1, LINK);
  else if (v < LINK->max_ord - 1)
    insert_edge_1(adj_set, v + 1, v + 2, LINK);
  P_addset(adj_set[v - MIN_VERTEX], w);
  P_addset(adj_set[w - MIN_VERTEX], v);
  find_cliques_1(adj_set, LINK->g, &l, &decomp, LINK);
  dispose_set_list(&l);
  if (decomp)
    (*LINK->dec)++;
  (*LINK->gra)++;
  if (w < LINK->max_ord)
    insert_edge_1(adj_set, v, w + 1, LINK);
  else if (v < LINK->max_ord - 1)
    insert_edge_1(adj_set, v + 1, v + 2, LINK);
}  /* insert_edge_1 */


/* new page */
Static Void count_cliques_1(dim, gra_, dec_)
t_long_integer dim, *gra_, *dec_;
{
  /* all models of dim. */
  struct LOC_count_cliques_1 Local_Var;
  t_vertex v;
  t_v_arr_of_v_sets adj_set;

  Local_Var.gra = gra_;
  Local_Var.dec = dec_;
  Local_Var.max_ord = dim + first_vertex - 1;
  *Local_Var.gra = 1;
  *Local_Var.dec = 1;
  for (v = first_vertex; v <= last_vertex; v++)
    P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  P_addsetr(P_expset(Local_Var.g, 0L), first_vertex, last_vertex);
  insert_edge_1(adj_set, first_vertex, first_vertex + 1, &Local_Var);
}  /* count_cliques_1 */


/* Local variables for count_cliques_2: */
struct LOC_count_cliques_2 {
  long *gra, *dec, max_ord;
  t_vertex_set g;
} ;

/* Local variables for find_cliques_2_: */
struct LOC_find_cliques_2_ {
  t_v_arr_of_v_sets adj_set;
  t_set_list **list_of_cliques;
} ;

Local Void find_complete_2(a_, v, LINK)
long *a_;
t_vertex v;
struct LOC_find_cliques_2_ *LINK;
{
  t_vertex_set a, b;

  P_setcpy(a, a_);
  if (v != last_vertex)
    find_complete_2(a, v + 1, LINK);
  if (!P_subset(a, LINK->adj_set[v - MIN_VERTEX]))   /* and (v in sub_set) */
    return;
  P_setcpy(b, a);
  P_addset(b, v);
  insert_clique(b, LINK->list_of_cliques);
  if (v != last_vertex)
    find_complete_2(b, v + 1, LINK);
}  /* find_complete_2 */

Local Void find_cliques_2_(adj_set_, list_of_cliques_)
t_vertex_set *adj_set_;
t_set_list **list_of_cliques_;
{
  /*         sub_set : t_vertex_set; */
  struct LOC_find_cliques_2_ Local_Var;

  memcpy(Local_Var.adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  Local_Var.list_of_cliques = list_of_cliques_;
  *Local_Var.list_of_cliques = NULL;
  find_complete_2(empty_set, first_vertex, &Local_Var);
}  /* find_cliques_2 */


Local Void find_cliques_2(adj_set_, sub_set_, list_of_cliques, decomposable,
			  LINK)
t_vertex_set *adj_set_;
long *sub_set_;
t_set_list **list_of_cliques;
boolean *decomposable;
struct LOC_count_cliques_2 *LINK;
{
  t_v_arr_of_v_sets adj_set;
  t_vertex_set sub_set;
  t_v_arr_of_v_lists adj_list, fill_in_adj_list;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;
  t_vertex v;

  memcpy(adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  P_setcpy(sub_set, sub_set_);
  *decomposable = false;
  *list_of_cliques = NULL;
  if (c_partitioning) {
    if (P_setequal(sub_set, LINK->g))   /* [first_vertex .. last_vertex] */
      find_cliques_2_(adj_set, list_of_cliques);
    /*sub_set, */
    else
      find_sub_cliques(adj_set, sub_set, list_of_cliques);
    return;
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, sub_set))
      P_setint(adj_set[v - MIN_VERTEX], sub_set, adj_set[v - MIN_VERTEX]);
    else
      P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  }
  adj_set_to_adj_list(adj_set, adj_list);
  find_cliques_and_order(adj_set, adj_list, fill_in_adj_list, order,
			 invers_order, c, complete, decomposable, sub_set,
			 list_of_cliques);
  if (!*decomposable)
    dispose_adj_list(fill_in_adj_list);
  dispose_adj_list(adj_list);
}  /* find_cliques_2 */

/* new page */
Local Void insert_edge_2(adj_set_, v, w, LINK)
t_vertex_set *adj_set_;
t_vertex v, w;
struct LOC_count_cliques_2 *LINK;
{
  t_v_arr_of_v_sets adj_set;
  t_set_list *l = NULL;
  boolean decomp;

  memcpy(adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  /*   if ord(w) < max_ord
   then
   insert_edge_2(adj_set, v, succ(w))
    else if ord(v) < max_ord - 1
   then
   insert_edge_2(adj_set, succ(v), succ(succ(succ(v))));                     */
  P_addset(adj_set[v - MIN_VERTEX], w);
  P_addset(adj_set[w - MIN_VERTEX], v);
  find_cliques_2(adj_set, LINK->g, &l, &decomp, LINK);
  dispose_set_list(&l);
  if (decomp)
    (*LINK->dec)++;
  (*LINK->gra)++;
  if (w < LINK->max_ord)
    insert_edge_2(adj_set, v, w + 1, LINK);
  else if (v < LINK->max_ord - 1)
    insert_edge_2(adj_set, v + 1, v + 3, LINK);
}  /* insert_edge_2 */


/* new page */
Static Void count_cliques_2(dim, gra_, dec_)
t_long_integer dim, *gra_, *dec_;
{
  /* graphical with dec. */
  struct LOC_count_cliques_2 Local_Var;
  t_vertex v;
  t_v_arr_of_v_sets adj_set;

  Local_Var.gra = gra_;
  Local_Var.dec = dec_;
  Local_Var.max_ord = dim + first_vertex - 3;
  *Local_Var.gra = 1;
  *Local_Var.dec = 1;
  for (v = first_vertex; v <= last_vertex; v++)
    P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  P_addsetr(P_expset(Local_Var.g, 0L), first_vertex, last_vertex);
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    P_addset(adj_set[v - MIN_VERTEX], v + 1);
    P_addset(adj_set[v - MIN_VERTEX + 1], v);
  }
  P_addset(adj_set[first_vertex - MIN_VERTEX], last_vertex);
  P_addset(adj_set[last_vertex - MIN_VERTEX], first_vertex);
  insert_edge_2(adj_set, first_vertex, first_vertex + 2, &Local_Var);
}  /* count_cliques_2 */


/* Local variables for count_cliques_3: */
struct LOC_count_cliques_3 {
  long *gra, *dec, max_ord;
  t_vertex_set g;
} ;

/* Local variables for find_cliques_3_: */
struct LOC_find_cliques_3_ {
  t_v_arr_of_v_sets adj_set;
  t_set_list **list_of_cliques;
} ;

Local Void find_complete_3(a_, v, LINK)
long *a_;
t_vertex v;
struct LOC_find_cliques_3_ *LINK;
{
  t_vertex_set a, b;

  P_setcpy(a, a_);
  if (v != last_vertex)
    find_complete_3(a, v + 1, LINK);
  if (!P_subset(a, LINK->adj_set[v - MIN_VERTEX]))   /* and (v in sub_set) */
    return;
  P_setcpy(b, a);
  P_addset(b, v);
  insert_clique(b, LINK->list_of_cliques);
  if (v != last_vertex)
    find_complete_3(b, v + 1, LINK);
}  /* find_complete_3 */


Local Void find_cliques_3_(adj_set_, list_of_cliques_)
t_vertex_set *adj_set_;
t_set_list **list_of_cliques_;
{
  /*   sub_set : t_vertex_set; */
  struct LOC_find_cliques_3_ Local_Var;

  memcpy(Local_Var.adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  Local_Var.list_of_cliques = list_of_cliques_;
  *Local_Var.list_of_cliques = NULL;
  find_complete_3(empty_set, first_vertex, &Local_Var);
}  /* find_cliques_3 */

Local Void find_cliques_3(adj_set_, sub_set_, list_of_cliques, decomposable,
			  LINK)
t_vertex_set *adj_set_;
long *sub_set_;
t_set_list **list_of_cliques;
boolean *decomposable;
struct LOC_count_cliques_3 *LINK;
{
  t_v_arr_of_v_sets adj_set;
  t_vertex_set sub_set;
  t_v_arr_of_v_lists adj_list, fill_in_adj_list;
  t_v_arr_of_order order;
  t_o_arr_of_vertex invers_order;
  t_v_arr_of_v_sets c;
  t_v_arr_of_boolean complete;
  t_vertex v;

  memcpy(adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  P_setcpy(sub_set, sub_set_);
  *decomposable = false;
  *list_of_cliques = NULL;
  if (c_partitioning) {
    if (P_setequal(sub_set, LINK->g))   /* [first_vertex .. last_vertex] */
      find_cliques_3_(adj_set, list_of_cliques);
    /*sub_set, */
    else
      find_sub_cliques(adj_set, sub_set, list_of_cliques);
    return;
  }
  for (v = first_vertex; v <= last_vertex; v++) {
    if (P_inset(v, sub_set))
      P_setint(adj_set[v - MIN_VERTEX], sub_set, adj_set[v - MIN_VERTEX]);
    else
      P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  }
  adj_set_to_adj_list(adj_set, adj_list);
  find_cliques_and_order(adj_set, adj_list, fill_in_adj_list, order,
			 invers_order, c, complete, decomposable, sub_set,
			 list_of_cliques);
  if (!*decomposable)
    dispose_adj_list(fill_in_adj_list);
  dispose_adj_list(adj_list);
}  /* find_cliques_3 */

/* new page */
Local Void insert_edge_3(adj_set_, v, w, LINK)
t_vertex_set *adj_set_;
t_vertex v, w;
struct LOC_count_cliques_3 *LINK;
{
  t_v_arr_of_v_sets adj_set;
  t_set_list *l = NULL;
  boolean decomp;

  memcpy(adj_set, adj_set_, sizeof(t_v_arr_of_v_sets));
  /*   if ord(w) < max_ord
   then
   insert_edge_3(adj_set, v, succ(w))
    else if ord(v) < max_ord - 1
   then
   insert_edge_3(adj_set, succ(v), succ(succ(succ(succ(v)))));              */
  P_addset(adj_set[v - MIN_VERTEX], w);
  P_addset(adj_set[w - MIN_VERTEX], v);
  find_cliques_3(adj_set, LINK->g, &l, &decomp, LINK);
  dispose_set_list(&l);
  if (decomp)
    (*LINK->dec)++;
  (*LINK->gra)++;
  if (w < LINK->max_ord)
    insert_edge_3(adj_set, v, w + 1, LINK);
  else if (v < LINK->max_ord - 1)
    insert_edge_3(adj_set, v + 1, v + 4, LINK);
}  /* insert_edge_3 */


/* new page */
Static Void count_cliques_3(dim, gra_, dec_)
t_long_integer dim, *gra_, *dec_;
{
  /* graphical without dec. */
  struct LOC_count_cliques_3 Local_Var;
  t_vertex v;
  t_v_arr_of_v_sets adj_set;

  Local_Var.gra = gra_;
  Local_Var.dec = dec_;
  Local_Var.max_ord = dim + first_vertex - 3;
  *Local_Var.gra = 1;
  *Local_Var.dec = 1;
  for (v = first_vertex; v <= last_vertex; v++)
    P_setcpy(adj_set[v - MIN_VERTEX], empty_set);
  P_addsetr(P_expset(Local_Var.g, 0L), first_vertex, last_vertex);
  for (v = first_vertex; v <= last_vertex - 1; v++) {
    P_addset(adj_set[v - MIN_VERTEX], v + 1);
    P_addset(adj_set[v - MIN_VERTEX + 1], v);
  }
  P_addset(adj_set[first_vertex - MIN_VERTEX], last_vertex);
  P_addset(adj_set[last_vertex - MIN_VERTEX], first_vertex);
  insert_edge_3(adj_set, first_vertex, first_vertex + 3, &Local_Var);
}  /* count_cliques_3 */


/* new page */
Static Void proc_count_cliques(command_file, as_argument, ifail, sub_code,
			       arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  /* over_hie, count_gen, count_hie,*/
  t_long_integer over_gra = 0, over_dec = 0, count_gra = 0, count_dec = 0;
  t_long_integer count_dim, d;
  t_vertex w;
  t_long_integer i = 0;
  t_long_integer m_ty;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Type->   ", 7L, &m_ty);
  if (m_ty > 0) {
    get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		     nargs, arg_int, " Dim.->   ", 7L, &d);
    count_dim = dimension;
    dimension = d;
    w = last_vertex;
    last_vertex = first_vertex;
    while (last_vertex - first_vertex + 1 < dimension) {
      last_vertex++;
      /* over_hie := 0; */
    }
  }
  /* count_gen := 0; */
  /* count_hie := 0; */
  switch (m_ty) {

  case 1:
    count_cliques_1((long)dimension, &count_gra, &count_dec);
    break;

  case 2:
    count_cliques_2((long)dimension, &count_gra, &count_dec);
    break;

  case 3:
    count_cliques_3((long)dimension, &count_gra, &count_dec);
    break;
  }
  write_pch(stdout, " Dimension:         ", 20L);
  write_integer(stdout, (long)dimension, 20L);
  write_line(stdout);
  /*
  write_pch(output, ' General:           ', 20);
  write_integer(output, count_gen, 20);
  write_line(output);
  write_pch(output, ' Hierarchical:      ', 20);
  write_integer(output, count_hie, 20);
  if over_hie <> 0 then begin
     write_pch  (output, ' + @@@@@@@', 3);
     write_integer(output, maxint, 20);
     write_pch  (output, ' * @@@@@@@', 3);
     write_integer(output, over_hie, 5)
  end;
  write_line(output);
  */
  write_pch(stdout, " Graphical:         ", 20L);
  write_integer(stdout, count_gra, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer(stdout, over_gra, 5L);
  }
  write_line(stdout);
  write_pch(stdout, " Decomposable:      ", 20L);
  write_integer(stdout, count_dec, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer(stdout, over_dec, 5L);
  }
  write_line(stdout);
  if (m_ty != 0) {
    last_vertex = w;
    dimension = count_dim;
  }
  if (echo_note)
    write_pch(stdout, " Models counted     ", 20L);
}  /* proc_count_cliques */


/* new page */
Static Void proc_count_decomposable(command_file, as_argument, ifail,
				    sub_code, arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_long_integer over_hie = 0, over_gra = 0, over_dec = 0, count_gen = 0,
		 count_hie = 0, count_gra = 0, count_dec = 0;
  t_long_integer count_dim, d;
  t_vertex w;
  t_long_integer i = 0;
  t_long_integer m_ty;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Type->   ", 7L, &m_ty);
  if (m_ty > 0) {
    get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		     nargs, arg_int, " Dim.->   ", 7L, &d);
    count_dim = dimension;
    dimension = d;
    w = last_vertex;
    last_vertex = first_vertex;
    while (last_vertex - first_vertex + 1 < dimension)
      last_vertex++;
  }
  switch (m_ty) {

  case 0:
    count_decomposable_models((long)dimension, &count_gen, &count_hie,
			      &count_gra, &count_dec);
    break;

  case 1:
    count_decomposable_models((long)dimension, &count_gen, &count_hie,
			      &count_gra, &count_dec);
    break;

  case 2:
    new_count_decomposable_models((long)dimension, &count_gen, &count_hie,
				  &count_gra, &count_dec, 0, 0, 0);
    break;

  case 3:
    count_cliques_1((long)dimension, &count_gra, &count_dec);
    break;

  case 4:
    count_cliques_2((long)dimension, &count_gra, &count_dec);
    break;

  case 5:
    count_cliques_3((long)dimension, &count_gra, &count_dec);
    break;
  }
  write_pch(stdout, " Dimension:         ", 20L);
  write_integer(stdout, (long)dimension, 20L);
  write_line(stdout);
  write_pch(stdout, " General:           ", 20L);
  write_integer(stdout, count_gen, 20L);
  write_line(stdout);
  write_pch(stdout, " Hierarchical:      ", 20L);
  write_integer(stdout, count_hie, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer(stdout, over_hie, 5L);
  }
  write_line(stdout);
  write_pch(stdout, " Graphical:         ", 20L);
  write_integer(stdout, count_gra, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer(stdout, over_gra, 5L);
  }
  write_line(stdout);
  write_pch(stdout, " Decomposable:      ", 20L);
  write_integer(stdout, count_dec, 20L);
  if (false) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer(stdout, over_dec, 5L);
  }
  write_line(stdout);
  if (m_ty != 0) {
    last_vertex = w;
    dimension = count_dim;
  }
  if (echo_note)
    write_pch(stdout, " Models counted     ", 20L);
}  /* proc_count_decomposable */


/* new page */
Static Void proc_count_hierarchical(command_file, as_argument, ifail,
				    sub_code, arg_pos, nargs, arg_int)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs, **arg_int;
{
  t_long_integer count_gen, count_hie;
  t_long_integer over_hie = 0;
  t_long_integer count_dim, d;
  t_vertex w;
  t_long_integer i = 0;
  t_long_integer m_ty;

  get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		   nargs, arg_int, " Type->   ", 7L, &m_ty);
  if (m_ty != 0) {
    get_next_integer(command_file, as_argument, &i, ifail, sub_code, arg_pos,
		     nargs, arg_int, " Dim.->   ", 7L, &d);
    count_dim = dimension;
    dimension = d;
    w = last_vertex;
    last_vertex = first_vertex;
    while (last_vertex - first_vertex + 1 < dimension)
      last_vertex++;
  }
  switch (m_ty) {

  case 0:
    count_hierarchical_models((long)dimension, &count_gen, &count_hie);
    break;

  case 1:
    count_hierarchical_models((long)dimension, &count_gen, &count_hie);
    break;

  case 2:
    new_count_hierarchical_models((long)dimension, &count_gen, &count_hie,
				  &over_hie);
    break;
  }
  write_pch(stdout, " Dimension:         ", 20L);
  write_integer(stdout, (long)dimension, 20L);
  write_line(stdout);
  write_pch(stdout, " General:           ", 20L);
  write_integer(stdout, count_gen, 20L);
  write_line(stdout);
  write_pch(stdout, " Hierarchical:      ", 20L);
  write_integer(stdout, count_hie, 20L);
  if (over_hie != 0) {
    write_pch(stdout, " + ", 3L);
    write_integer(stdout, LONG_MAX, 20L);
    write_pch(stdout, " * ", 3L);
    write_integer(stdout, over_hie, 5L);
  }
  write_line(stdout);
  if (m_ty != 0) {
    last_vertex = w;
    dimension = count_dim;
  }
  if (echo_note)
    write_pch(stdout, " Models counted     ", 20L);
}  /* proc_count_hierarchical */


/*@+"maincase.p"*/

/*

2803:    +++  ++
2804:    +++  ++
2805:    ---  -- p/maincase.p         9      32     435 p/maincase.p
2806: |    5:    procedure main_coco
2807: |   14:    procedure set_input_file_arg
2808: |   42:    procedure set_command_file
2809: |   62:    procedure read_start_up_files
2810: |   73:    procedure internal_main_case
2811: | 1187:    procedure main_case
2812: | 1211:    procedure external_main_case
2813: | 1271:    procedure main_coco
2814: | 1276:    procedure main_coco
2815:    +++  ++
2816:    +++  ++

*/


/*Has-forward-1*/

Static Void main_coco PP((FILE *command_file, int source));


/*Has-forward-1*/

/*@-"maincase.c"*/


Static Void set_input_file_arg(new_name, ok, note, in_cocolib)
Char *new_name;
boolean *ok, note, in_cocolib;
{
  FILE *command_file = NULL;
  pch_long old_name;
  boolean old_status;

  copy_pch_long(command_name, old_name);
  old_status = std_input_set;
  copy_pch_long(new_name, command_name);
  std_input_set = false;
  if (in_cocolib)
    assign_read_cocolib(&command_file, command_name, ok);
  else
    assign_read(&command_file, command_name, ok);
  if (*ok) {
    main_coco(command_file, true);
    close_file(command_file);
    write_pch(stdout, prompt, prompt_length);
  } else if (note)
    write_file_not_found(stdout, command_name);
  copy_pch_long(old_name, command_name);
  std_input_set = old_status;
  if (log_on)
    write_line_text(log_file);
  if (command_file != NULL)
    fclose(command_file);
}  /* set_input_file_arg */


Static Void set_command_file(command_file, as_argument, ifail, sub_code,
			     arg_pos, nargs, arg_char)
FILE *command_file;
boolean as_argument;
t_integer *ifail, *sub_code, arg_pos;
long **nargs;
Char **arg_char;
{
  boolean ok;
  pch_long new_name;

  if (!get_file_name(command_file, as_argument, ifail, *sub_code, arg_pos,
		     nargs, arg_char, command_name, new_name))
    return;
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("set_command_file 11 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
  set_input_file_arg(new_name, &ok, true, false);
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("set_command_file 12 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
  if (!ok)
    set_ifail(ifail, 51L);
  write_line(stdout);
}  /* set_command_file */


Static Void read_start_up_files()
{
  boolean ok;
  pch_long new_name;

  default_to_file_name(FILE_NAME_START_UP_HOME, new_name);
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("read_start_up_files 11 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
  set_input_file_arg(new_name, &ok, false, true);
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("read_start_up_files 12 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
  default_to_file_name(FILE_NAME_START_UP, new_name);
  set_input_file_arg(new_name, &ok, false, false);
#ifdef CoCo_Cygwin
#ifdef DEBUG_G
    /* G */ printf("read_start_up_files 13 \n");
#endif /* G */
#endif /* CoCo_Cygwin */
}  /* read_start_up_files */


Static Void push_model_references()
{
  t_model_references *p;

  /* write_pch(output, ' Push model ref.@@@@', 16);
  write_line(output); */
  p = (t_model_references *)Malloc(sizeof(t_model_references));
  if (p == NULL)
    _OutMem();
  p->link_current = link_current;
  p->link_base = link_base;
  p->pointer = model_references;
  model_references = p;
}  /* push_model_references */


Static Void pop_model_references()
{
  t_model_references *p;

  /* write_pch(output, ' Pop model refe.@@@@', 16);
  write_line(output); */
  if (model_references == NULL)
    return;
  p = model_references;
  link_current = p->link_current;
  link_base = p->link_base;
  model_references = p->pointer;
  _Free(p);
}  /* pop_model_references */


#define pos_char        0
#define pos_int         1
#define pos_double      2


Static Void internal_main_case(command_file, simple_command, as_argument,
			       ifail, code, sub_code, nargs, arg_char,
			       arg_int, arg_double, arg_char_int)
FILE *command_file;
boolean *simple_command, as_argument;
t_integer *ifail, *code, *sub_code;
long **nargs;
Char **arg_char;
long **arg_int;
double **arg_double;
long **arg_char_int;
{
  boolean set_current = false, set_base = false, do_pop = false;

  /*$ifdef TRACE*/
  /* Remove for DOS */
  if (as_argument & trace_flag_set(20L, 2810L, 1L)) {
    test_arguments(11L, ifail, *code, *sub_code, nargs, arg_char, arg_int,
		   arg_double, arg_char_int);
    /*$endif TRACE*/
    /* Remove for DOS */

  }

  if (neg_pos_flag_set(sub_code, 16485L))
    set_base = true;
  if (neg_pos_flag_set(sub_code, 8192L))
    set_current = true;
  if (neg_pos_flag_set(sub_code, 4096L))
    global_write_options->write_test = false;
  if (neg_pos_flag_set(sub_code, 2048L))
    do_pop = true;
  if (neg_pos_flag_set(sub_code, 1024L))
    push_model_references();
  if (neg_pos_flag_set(sub_code, 512L))
    link_current = link_model_list;
  if (neg_pos_flag_set(sub_code, 256L))
    link_base = link_model_list;
  in_search = (205 < *code && *code <= 228);
  if (in_search) {
    note_mixed(stdout, " InSearch", 9L);
    if (link_eh_pack == NULL) {
      if (command_test[*code][2] == 1)
	write_line_diary();
      start_search(&link_eh_pack);
    }
    if (link_eh_pack->a == NULL ||
	(link_eh_pack->r == NULL && *code >= 224 && *code != 228 &&
	 *code != 248))
      init_graphical_search();
  }
  switch (*code) {

  case 0:
    if (!eof_command(command_file) && std_input_set) {
      if (link_eh_pack != NULL) {
	end_search(&link_eh_pack);
	*code = 200;
      } else if (*sub_code == 1)
	*code = 200;
    }
    break;

  case 1:
    restart(command_file);
    break;

  case 2:
    help(command_file);
    break;

  case 3:
    menu_nr(command_file);
    break;

  case 4:
    next_menu();
    break;

  case 5:
    show_menu(&menu_number);
    break;

  case 6:
    previous_menu();
    break;

  case 7:
    proc_pa(command_file);
    break;

  case 8:
    proc_ma(command_file);
    break;

  case 9:
    proc_da(command_file);
    break;

  case 10:
    init_command_parser(ifail, true);
    break;

  case 11:
    make_parser_table();
    break;

  case 12:
    dump_status(sub_code);
    break;

  case 13:
    status(sub_code);
    break;

  case 14:
    export_data(command_file, as_argument, ifail, sub_code, (long)pos_char,
		nargs, arg_char);
    break;

  case 15:
    import_data(command_file, as_argument, ifail, sub_code, (long)pos_char,
		nargs, arg_char);
    break;

  case 16:
    switch_(27L, *sub_code - 2);
    break;

  case 17:
    switch_(28L, *sub_code - 2);
    break;

  case 18:
    switch_(29L, *sub_code - 2);
    break;

  case 31:
    switch_(31L, *sub_code - 2);
    break;

  case 19:
    switch_(2L, *sub_code - 2);
    break;

  case 20:
    set_spec_file(command_file, as_argument, ifail, sub_code, (long)pos_char,
		  nargs, arg_char);
    break;

  case 21:
    set_observations_file(command_file, as_argument, ifail, sub_code,
			  (long)pos_char, nargs, arg_char);
    break;

  case 22:
    set_data_file(command_file, as_argument, ifail, sub_code, (long)pos_char,
		  nargs, arg_char);
    break;

  case 23:
    set_command_file(command_file, as_argument, ifail, sub_code,
		     (long)pos_char, nargs, arg_char);
    break;

  case 24:
    proc_mam();
    ni();
    break;

  case 25:
    set_diary_file(command_file, as_argument, ifail, sub_code, (long)pos_char,
		   nargs, arg_char);
    break;

  case 26:
    set_output(command_file, as_argument, ifail, sub_code, (long)pos_char,
	       nargs, arg_char);
    break;

  case 27:
    set_output(command_file, as_argument, ifail, sub_code, (long)pos_char,
	       nargs, arg_char);
    break;


  /*$ifdef On-DOS
  set_output(command_file);
   $endif On-DOS*/
  case 28:
    set_report_file(command_file, as_argument, ifail, sub_code,
		    (long)pos_char, nargs, arg_char);
    break;

  case 29:
    set_log_file(command_file, as_argument, ifail, sub_code, (long)pos_char,
		 nargs, arg_char);
    break;

  case 30:
    set_dump_file(command_file, as_argument, ifail, sub_code, (long)pos_char,
		  nargs, arg_char);
    break;

  case 32:
    switch_(4L, *sub_code - 2);
    break;

  case 33:
    switch_(5L, *sub_code - 2);
    break;

  case 34:
    switch_(3L, *sub_code - 2);
    break;

  case 35:
    switch_(21L, *sub_code - 2);
    break;

  case 36:
    switch_(10L, *sub_code - 2);
    break;

  case 37:
    switch_(13L, *sub_code - 2);
    break;

  case 38:
    switch_(22L, *sub_code - 2);
    break;

  case 39:
    set_option_on_off(command_file, as_argument, ifail, sub_code,
		      (long)pos_int, nargs, arg_int);
    break;

  case 40:
    switch_(24L, *sub_code - 2);
    break;

  case 41:
    switch_(25L, *sub_code - 2);
    if (!default_dump_set && !dump_set && dump)
      set_default_dump_file();
    break;

  case 42:
    set_signal_on_off(command_file, *sub_code);
    break;

  case 43:
    set_interrupt_on_off(*sub_code);
    break;

  case 44:
    switch_(30L, *sub_code - 2);
    break;

  case 45:
    proc_set_print_formats(command_file, as_argument, ifail, sub_code,
			   (long)pos_int, nargs, arg_int);
    break;

  case 46:
    proc_set_table_formats(command_file, as_argument, ifail, sub_code,
			   (long)pos_int, nargs, arg_int);
    break;

  case 47:
    proc_set_test_formats(command_file, as_argument, ifail, sub_code,
			  (long)pos_int, nargs, arg_int);
    break;

  case 48:
    proc_set_page_formats(command_file, as_argument, ifail, sub_code,
			  (long)pos_int, nargs, arg_int);
    break;

  case 49:
    proc_set_nrow(command_file, as_argument, ifail, sub_code, (long)pos_int,
		  nargs, arg_int);
    break;

  case 50:
    proc_set_ncol(command_file, as_argument, ifail, sub_code, (long)pos_int,
		  nargs, arg_int);
    break;

  case 51:
    switch_(9L, *sub_code - 2);
    break;

  case 52:
    switch_(32L, *sub_code - 2);
    break;

  case 63:
    proc_set_pause_page_length(command_file, as_argument, ifail, sub_code,
			       (long)pos_int, nargs, arg_int);
    break;

  case 53:
    if (labs(*sub_code) > 32) {
      if (*sub_code < 0)
	*sub_code = -1;
      proc_set_ips(command_file, as_argument, ifail, sub_code, (long)pos_int,
		   (long)pos_double, nargs, arg_int, arg_double);
    } else if (*sub_code == -1)
      *sub_code = ips_in_use;
    else
      ips_in_use = *sub_code;
    break;

  case 54:
    proc_set_ips(command_file, as_argument, ifail, sub_code, (long)pos_int,
		 (long)pos_double, nargs, arg_int, arg_double);
    break;

  case 55:
    proc_set_ips_eps(command_file, as_argument, ifail, sub_code,
		     (long)pos_double, nargs, arg_double);
    break;

  case 56:
    proc_set_ips_it(command_file, as_argument, ifail, sub_code, (long)pos_int,
		    nargs, arg_int);
    break;

  case 57:
    proc_set_em_initial(as_argument, ifail, sub_code, (long)pos_int, nargs,
			arg_int);
    break;

  case 58:
    proc_set_em_eps(command_file, as_argument, ifail, sub_code,
		    (long)pos_double, nargs, arg_double);
    break;

  case 59:
    proc_set_em_it(command_file, as_argument, ifail, sub_code, (long)pos_int,
		   nargs, arg_int);
    break;

  case 60:
    proc_set_mips(command_file, as_argument, ifail, sub_code, (long)pos_int,
		  (long)pos_double, nargs, arg_int, arg_double);
    break;

  case 61:
    if (labs(*sub_code) > 32) {
      if (*sub_code < 0)
	*sub_code = -1;
      proc_set_mips(command_file, as_argument, ifail, sub_code, (long)pos_int,
		    (long)pos_double, nargs, arg_int, arg_double);
    } else if (*sub_code == -1)
      *sub_code = mips_in_use;
    else
      mips_in_use = *sub_code;
    break;

  case 62:
    if (*sub_code == -1) {
      switch (mean_ips_in_use) {

      case normal_ips:
	*sub_code = 1;
	break;

      case arithmetic:
	*sub_code = 2;
	break;

      case geometric:
	*sub_code = 3;
	break;

      case harmonic:
	*sub_code = 4;
	break;
      }
    } else {
      switch (*sub_code) {

      case 1:
	mean_ips_in_use = normal_ips;
	break;

      case 2:
	mean_ips_in_use = arithmetic;
	break;

      case 3:
	mean_ips_in_use = geometric;
	break;

      case 4:
	mean_ips_in_use = harmonic;
	break;
      }
    }
    break;

  case 64:
    switch_(1L, *sub_code - 2);
    partitioning_output = c_partitioning;
    break;

  case 65:
    if (*sub_code == -1)
      *sub_code = c_factorizes;
    else
      c_factorizes = *sub_code;
    break;

  case 66:
    switch_(6L, *sub_code - 2);
    break;

  case 67:
    switch_(7L, *sub_code - 2);
    break;

  case 68:
    switch_(12L, *sub_code - 2);
    break;

  case 69:
    proc_set_acceptance_limit(command_file, as_argument, ifail, sub_code,
			      (long)pos_double, nargs, arg_double);
    break;

  case 70:
    if (*sub_code == -1)
      *sub_code = test_choice;
    else
      test_choice = *sub_code;
    break;

  case 71:
    proc_set_power_lambda(command_file, as_argument, ifail, sub_code,
			  (long)pos_double, nargs, arg_double);
    break;

  case 72:
    switch (*sub_code) {

    case -1:
      proc_set_ic_kappa(command_file, as_argument, ifail, sub_code,
			(long)pos_double, nargs, arg_double);
      break;

    case 1:
      proc_set_aic();
      break;

    case 2:
      proc_set_bic();
      break;

    case 3:
      proc_set_ic_off();
      break;

    case 4:
      proc_set_ic_kappa(command_file, as_argument, ifail, sub_code,
			(long)pos_double, nargs, arg_double);
      break;

    case 5:
      proc_set_ic_on();
      break;
    }
    break;

  case 73:
    proc_set_parts_limit(command_file, as_argument, ifail, sub_code,
			 (long)pos_double, nargs, arg_double);
    break;

  case 74:
    proc_set_separators_limit(command_file, as_argument, ifail, sub_code,
			      (long)pos_double, nargs, arg_double);
    break;

  case 75:
    if (*sub_code == -1) {
      if (exact_test) {
	if (exact_log_l)
	  *sub_code = 5;
	else
	  *sub_code = 4;
      } else
	*sub_code = 1;
    } else if (*sub_code < 4) {
      switch_(14L, *sub_code - 2);
      write_line(stdout);
    } else {
      switch_(14L, 1L);
      write_line(stdout);
      if (*sub_code == 4)
	switch_(15L, -1L);
      else if (*sub_code == 5)
	switch_(15L, 1L);
      else if (*sub_code == 6)
	switch_(15L, 0L);
      write_line(stdout);
    }
    break;

  case 76:
    proc_set_asymptotic_limit(command_file, as_argument, ifail, sub_code,
			      (long)pos_double, nargs, arg_double);
    break;

  case 77:
    switch_(16L, *sub_code - 2);
    break;

  case 78:
    proc_set_seed(command_file, as_argument, ifail, sub_code, (long)pos_int,
		  nargs, arg_int);
    break;

  case 79:
    if (labs(*sub_code) > 32) {
      if (*sub_code < 0)
	*sub_code = -1;
      proc_set_cips(command_file, as_argument, ifail, sub_code, (long)pos_int,
		    (long)pos_double, nargs, arg_int, arg_double);
    } else if (*sub_code == -1)
      *sub_code = cips_in_use;
    else
      cips_in_use = *sub_code;
    break;

  case 80:
    proc_set_number_of_tables(command_file, as_argument, ifail, sub_code,
			      (long)pos_int, nargs, arg_int);
    break;

  case 81:
    switch_(17L, *sub_code - 2);
    break;

  case 82:
    switch_(18L, *sub_code - 2);
    break;

  case 83:
    switch_(19L, *sub_code - 2);
    break;

  case 84:
    proc_set_exact_eps(command_file, as_argument, ifail, sub_code,
		       (long)pos_double, nargs, arg_double);
    break;

  case 85:
    proc_set_list_of_number_of_tables(command_file, as_argument, ifail,
      sub_code, (long)pos_int, nargs, arg_int);
    break;

  case 86:
    switch_(11L, *sub_code - 2);
    break;

  case 87:
    proc_set_rejection_limit(command_file, as_argument, ifail, sub_code,
			     (long)pos_double, nargs, arg_double);
    break;

  case 88:
    proc_enter_data(command_file, 1L, as_argument, ifail, sub_code,
		    (long)pos_char, (long)pos_int, (long)pos_double, nargs,
		    arg_char, arg_int, arg_double);
    break;

  case 89:
    proc_enter_data(command_file, 2L, as_argument, ifail, sub_code,
		    (long)pos_char, (long)pos_int, (long)pos_double, nargs,
		    arg_char, arg_int, arg_double);
    break;

  case 90:
    proc_enter_data(command_file, 3L, as_argument, ifail, sub_code,
		    (long)pos_char, (long)pos_int, (long)pos_double, nargs,
		    arg_char, arg_int, arg_double);
    break;

  case 91:
    proc_enter_data(command_file, 4L, as_argument, ifail, sub_code,
		    (long)pos_char, (long)pos_int, (long)pos_double, nargs,
		    arg_char, arg_int, arg_double);
    break;

  case 92:
    if (*sub_code == 1)
      set_read_all();
    else
      proc_set_read_subset(command_file, as_argument, ifail, sub_code,
			   (long)pos_char, nargs, arg_char);
    break;

  case 93:
    switch (*sub_code) {

    case -1:
      switch (datastructure) {

      case all:
	*sub_code = 1;
	break;

      case necessary:
	*sub_code = 2;
	break;

      case list_file:
	*sub_code = 3;
	break;
      }
      break;

    case 1:
      set_data(all);
      break;

    case 2:
      set_data(necessary);
      break;

    case 3:
      set_data(list_file);
      break;

    case 4:
      switch_(8L, 0L);
      break;

    case 5:
      switch_(33L, 0L);
      if (datastructure != list_file && permit_log_l)
	switch_(33L, -1L);
      if (permit_log_l)
	large = true;
      break;
    }
    break;

  case 94:
    switch_(8L, *sub_code - 2);
    break;

  case 95:
    switch_(26L, *sub_code - 2);
    break;

  case 96:
    proc_select_reject(command_file, as_argument, ifail, code, (long)pos_char,
		       (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 97:
    proc_select_reject(command_file, as_argument, ifail, code, (long)pos_char,
		       (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 98:
    proc_select_reject(command_file, as_argument, ifail, code, (long)pos_char,
		       (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 99:
    proc_select_reject(command_file, as_argument, ifail, code, (long)pos_char,
		       (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 100:
    proc_redefine_factor(command_file, as_argument, ifail, sub_code,
			 (long)pos_char, (long)pos_int, nargs, arg_char,
			 arg_int);
    break;

  case 101:
    proc_enter_cutpoints(command_file, as_argument, ifail, sub_code,
			 (long)pos_char, (long)pos_double, nargs, arg_char,
			 arg_double);
    break;

  case 102:
    skip_missing();
    break;

  case 103:
    proc_enter_data(command_file, 5L, as_argument, ifail, sub_code,
		    (long)pos_char, (long)pos_int, (long)pos_double, nargs,
		    arg_char, arg_int, arg_double);
    break;

  case 104:
    proc_enter_data(command_file, 6L, as_argument, ifail, sub_code,
		    (long)pos_char, (long)pos_int, (long)pos_double, nargs,
		    arg_char, arg_int, arg_double);
    break;

  case 105:
    proc_enter_data(command_file, 7L, as_argument, ifail, sub_code,
		    (long)pos_char, (long)pos_int, (long)pos_double, nargs,
		    arg_char, arg_int, arg_double);
    break;

  case 106:
    proc_enter_q_table(command_file, as_argument, ifail, sub_code,
		       (long)pos_char, (long)pos_int, nargs, arg_char,
		       arg_int);
    break;

  case 107:
    proc_enter_q_list(command_file, as_argument, ifail, sub_code,
		      (long)pos_char, (long)pos_int, (long)pos_double, nargs,
		      arg_char, arg_int, arg_double);
    break;

  case 108:
    clean_data();
    break;

  case 110:
    switch (*sub_code) {

    case -1:
      proc_excl_in(command_file, as_argument, ifail, sub_code, (long)pos_char,
		   nargs, arg_char);
      break;

    case 1:
      proc_excl_off();
      break;

    case 2:
      proc_excl_mis();
      break;

    case 3:
      proc_excl_on();
      break;

    case 4:
      proc_excl_in(command_file, as_argument, ifail, sub_code, (long)pos_char,
		   nargs, arg_char);
      break;
    }
    break;

  case 112:
    proc_em_on();
    break;

  case 113:
    proc_print_table(command_file, true, true, false, as_argument, ifail,
		     sub_code, (long)pos_char, (long)pos_int,
		     (long)pos_double, nargs, arg_char, arg_int, arg_double);
    break;

  case 114:
    proc_print_sparse_table(command_file, as_argument, ifail, sub_code,
			    (long)pos_char, (long)pos_int, (long)pos_double,
			    nargs, arg_char, arg_int, arg_double);
    break;

  case 115:
    proc_print_table(command_file, false, false, false, as_argument, ifail,
		     sub_code, (long)pos_char, (long)pos_int,
		     (long)pos_double, nargs, arg_char, arg_int, arg_double);
    break;

  case 116:
    proc_plot(command_file, as_argument, ifail, sub_code, (long)pos_char,
	      (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 117:
    proc_list(command_file, false, true, as_argument, ifail, sub_code,
	      (long)pos_char, (long)pos_int, (long)pos_double, nargs,
	      arg_char, arg_int, arg_double);
    break;

  case 118:
    proc_list(command_file, true, true, as_argument, ifail, sub_code,
	      (long)pos_char, (long)pos_int, (long)pos_double, nargs,
	      arg_char, arg_int, arg_double);
    break;

  case 119:
    proc_print_table(command_file, false, true, true, as_argument, ifail,
		     sub_code, (long)pos_char, (long)pos_int,
		     (long)pos_double, nargs, arg_char, arg_int, arg_double);
    break;

  case 120:
    proc_return_matrix(command_file, as_argument);
    break;

  case 121:
    proc_print_table(command_file, true, false, false, as_argument, ifail,
		     sub_code, (long)pos_char, (long)pos_int,
		     (long)pos_double, nargs, arg_char, arg_int, arg_double);
    break;

  case 122:
    proc_print_table(command_file, false, false, true, as_argument, ifail,
		     sub_code, (long)pos_char, (long)pos_int,
		     (long)pos_double, nargs, arg_char, arg_int, arg_double);
    break;

  case 123:
    proc_print_continuous(command_file, true, true, false, as_argument, ifail,
			  sub_code, (long)pos_char, (long)pos_int,
			  (long)pos_double, nargs, arg_char, arg_int,
			  arg_double);
    break;

  case 124:
    proc_print_continuous(command_file, false, true, true, as_argument, ifail,
			  sub_code, (long)pos_char, (long)pos_int,
			  (long)pos_double, nargs, arg_char, arg_int,
			  arg_double);
    break;

  case 127:
    proc_get_model(command_file, as_argument, ifail, sub_code, (long)pos_char,
		   nargs, arg_char);
    break;

  case 128:
    proc_read_n_interactions(command_file, as_argument, ifail, sub_code,
			     (long)pos_char, (long)pos_int, nargs, arg_char,
			     arg_int);
    break;

  case 125:   /* command_file, */
    /* , ifail, sub_code,
                        pos_char, nargs, arg_char */
    proc_normal_to_dual(as_argument);
    break;

  case 126:   /* command_file, */
    /* , ifail, sub_code,
                        pos_char, nargs, arg_char */
    proc_dual_to_normal(as_argument);
    break;

  case 129:
    if (*sub_code == -2 || *sub_code == 2)   /* Marginalize, Kreiner */
      proc_collaps_model(command_file, as_argument, ifail, sub_code,
			 (long)pos_char, (long)pos_int, nargs, arg_char,
			 arg_int);
    else
      proc_collaps_model(command_file, as_argument, ifail, sub_code,
			 (long)pos_char, (long)pos_int, nargs, arg_char,
			 arg_int);
    break;

  case 130:
    proc_base();
    break;

  case 131:
    proc_current();
    break;

  case 132:
    proc_make_base(command_file, as_argument, ifail, sub_code, (long)pos_int,
		   nargs, arg_int);
    break;

  case 133:
    proc_make_current(command_file, as_argument, ifail, sub_code,
		      (long)pos_int, nargs, arg_int);
    break;

  case 134:
    if (*sub_code >= 0)
      proc_print_form();
    else
      proc_get_expression(ifail, sub_code, (long)pos_char, (long)pos_int,
			  (long)pos_double, nargs, arg_char, arg_int,
			  arg_double);
    break;

  /* command_file, as_argument, */
  case 135:
    if (*sub_code >= 0)
      proc_print_order(sub_code);
    else {
      if (*sub_code < -32)
	proc_return_path_order(command_file, as_argument, ifail, sub_code,
			       (long)pos_char, (long)pos_int, nargs, arg_char,
			       arg_int);
      else
	proc_return_order(command_file, as_argument, ifail, sub_code,
			  (long)pos_char, (long)pos_int, (long)pos_double,
			  nargs, arg_char, arg_int, arg_double);
    }
    break;

  case 136:
    proc_dispose_of_form();
    break;

  case 137:
    switch (*sub_code) {

    case 1:
      proc_print_base(true);
      break;

    case 2:
      proc_print_current(true);
      break;

    case 3:
      proc_print_last(true);
      break;

    case 4:
      proc_print_all(true);
      break;

    case 5:
      proc_print_model(command_file, true, as_argument, ifail, sub_code,
		       (long)pos_int, nargs, arg_int);
      break;

    case 6:
      proc_print_models(command_file, true, as_argument, ifail, sub_code,
			(long)pos_int, nargs, arg_int);
      break;

    case 7:
      proc_print_internal_models(true);
      break;
    }
    break;

  case 138:
    switch (*sub_code) {

    case 1:
      proc_print_base(false);
      break;

    case 2:
      proc_print_current(false);
      break;

    case 3:
      proc_print_last(false);
      break;

    case 4:
      proc_print_all(false);
      break;

    case 5:
      proc_print_model(command_file, false, as_argument, ifail, sub_code,
		       (long)pos_int, nargs, arg_int);
      break;

    case 6:
      proc_print_models(command_file, false, as_argument, ifail, sub_code,
			(long)pos_int, nargs, arg_int);
      break;

    case 7:
      proc_print_internal_models(false);
      break;
    }
    break;

  case 139:
    switch (*sub_code) {

    case 1:
      proc_dispose_of_base();
      break;

    case 2:
      proc_dispose_of_current();
      break;

    case 3:
      proc_dispose_of_last();
      break;

    case 4:
      proc_dispose_of_all();
      break;

    case 5:
      proc_dispose_of_model(command_file, as_argument, ifail, sub_code,
			    (long)pos_int, nargs, arg_int);
      break;

    case 6:
      proc_dispose_of_models(command_file, as_argument, ifail, sub_code,
			     (long)pos_int, nargs, arg_int);
      break;
    }
    break;

  case 140:
    return_model_set_integer(ifail, sub_code, (long)pos_int, nargs, arg_int);
    break;

  case 141:
    return_model_set(ifail, sub_code, (long)pos_char, nargs, arg_char);
    break;

  case 142:
    return_marginal_dimension(ifail, sub_code, (long)pos_char, (long)pos_int,
			      nargs, arg_char, arg_int);
    break;

  case 143:
    return_edges(ifail, sub_code, (long)pos_int, nargs, arg_int);
    break;

  case 144:
    return_names(ifail, sub_code, (long)pos_char, nargs, arg_char);
    break;

  case 145:
    return_levels(ifail, sub_code, (long)pos_int, nargs, arg_int);
    break;

  case 146:
    return_dimension(ifail, sub_code, (long)pos_int, nargs, arg_int);
    break;

  case 150:
    proc_set_causal_structure(command_file, as_argument, ifail, sub_code,
			      (long)pos_char, nargs, arg_char);
    break;

  case 151:
    proc_set_ordinal_factors(command_file, as_argument, ifail, sub_code,
			     (long)pos_char, nargs, arg_char);
    break;

  case 152:
    proc_set_response_variables(command_file, as_argument, ifail, sub_code,
				(long)pos_char, nargs, arg_char);
    break;

  case 156:
    /*Return components*/
    switch (-*sub_code) {

    case 1:
      proc_connected_component(command_file, as_argument, ifail, sub_code,
			       (long)pos_char, (long)pos_int, nargs, arg_char,
			       arg_int);
      break;

    /* "connected.component" */
    case 2:
      proc_connected_components(command_file, as_argument, ifail, sub_code,
				(long)pos_char, (long)pos_int, nargs,
				arg_char, arg_int);
      break;

    /* "connected.components" */
    case 3:   /* "prime.components" */
      ni();
      break;

    case 4:   /* "junction.tree.components" */
      ni_discrete();
      break;

    case 5:   /* "chain.components" */
      ni_discrete();
      break;

    case 6:   /* "ancestral.set" */
      ni_discrete();
      break;

    case 8:
      proc_shortest_paths(command_file, as_argument, ifail, sub_code,
			  (long)pos_char, (long)pos_int, nargs, arg_char,
			  arg_int);
      break;

    /* "shortests.paths" */
    case 9:
      proc_all_cut_sets(command_file, as_argument, ifail, sub_code,
			(long)pos_char, (long)pos_int, nargs, arg_char,
			arg_int);
      break;

    /* "cut.sets" */
    case 10:
      proc_all_cut_sets_sets(command_file, as_argument, ifail, sub_code,
			     (long)pos_char, (long)pos_int, nargs, arg_char,
			     arg_int);
      break;
      /* "cut.sets" */

    case 11:   /* "separators" */
      ni();
      break;

    case 12:   /* "d-separators" */
      ni_discrete();
      break;

    case 13:   /* "is.separator" */
      ni();
      break;

    case 14:   /* "is.d-separator" */
      ni_discrete();
      break;
    }
    break;

  case 157:
    proc_print_common();
    break;

  case 158:
    proc_decompose(command_file, as_argument, ifail, sub_code, (long)pos_char,
		   nargs, arg_char);
    break;

  case 159:
    /* pos_int, */
    /* , arg_int */
    proc_slice(command_file, as_argument, ifail, sub_code, (long)pos_char,
	       nargs, arg_char);
    break;

  case 160:
    in_test = true;
    proc_compute_test(command_file, as_argument, ifail, sub_code,
		      (long)pos_int, (long)pos_double, nargs, arg_int,
		      arg_double);
    in_test = false;
    break;

  case 161:
    proc_log_l();
    break;

  case 162:
    proc_compute_deviance(as_argument, ifail, sub_code, (long)pos_int,
			  (long)pos_double, nargs, arg_int, arg_double);
    break;

  case 163:
    proc_exact_test();
    break;

  case 164:
    proc_partitioning();
    break;

  case 165:
    proc_test_one_edge();
    break;

  case 166:
    proc_fact_edge(command_file, as_argument, ifail, sub_code, (long)pos_char,
		   nargs, arg_char);
    break;

  case 167:
    proc_fact_inter(command_file, as_argument, ifail, sub_code,
		    (long)pos_char, nargs, arg_char);
    break;

  case 168:
    ni();
    break;

  case 169:
    ni();
    break;

  case 109:
    proc_substitute();
    break;

  case 170:
    show_tests();
    break;

  case 171:
    dispose_tests();
    break;

  case 172:
    proc_dispose_of_marginals();
    break;

  case 173:
    proc_dispose_of_q_table(command_file, as_argument, ifail, sub_code,
			    (long)pos_char, nargs, arg_char);
    break;

  case 174:
    dispose_ps();
    break;

  case 175:
    proc_dispose_of_all_q();
    break;

  case 176:
    proc_set_ordinal_factors(command_file, as_argument, ifail, sub_code,
			     (long)pos_char, nargs, arg_char);
    break;

  case 177:
    proc_meet_models(command_file, as_argument, ifail, sub_code,
		     (long)pos_char, (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 178:
    proc_join_models(command_file, as_argument, ifail, sub_code,
		     (long)pos_char, (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 179:
    proc_difference_models(command_file, as_argument, ifail, sub_code,
			   (long)pos_char, (long)pos_int, nargs, arg_char,
			   arg_int);
    break;

  case 180:
    proc_add_fill_in(command_file, as_argument, ifail, sub_code,
		     (long)pos_char, (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 181:
    proc_generate_graphical(command_file, as_argument, ifail, sub_code,
			    (long)pos_char, (long)pos_int, nargs, arg_char,
			    arg_int);
    break;

  case 182:
    proc_drop_factor(command_file, as_argument, ifail, sub_code,
		     (long)pos_char, (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 183:
    proc_drop_edges(command_file, as_argument, ifail, sub_code,
		    (long)pos_char, (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 184:
    proc_add_edges(command_file, as_argument, ifail, sub_code, (long)pos_char,
		   (long)pos_int, nargs, arg_char, arg_int);
    break;

  case 185:
    proc_drop_interactions(command_file, as_argument, ifail, sub_code,
			   (long)pos_char, (long)pos_int, nargs, arg_char,
			   arg_int);
    break;

  case 186:
    proc_add_interactions(command_file, as_argument, ifail, sub_code,
			  (long)pos_char, (long)pos_int, nargs, arg_char,
			  arg_int);
    break;

  case 187:
    proc_reduce_generator(command_file, as_argument, ifail, sub_code,
			  (long)pos_char, (long)pos_int, nargs, arg_char,
			  arg_int);
    break;

  case 188:
    proc_remove_generator(command_file, as_argument, ifail, sub_code,
			  (long)pos_char, (long)pos_int, nargs, arg_char,
			  arg_int);
    break;

  case 189:
    proc_drop_generator_total(command_file, as_argument, ifail, sub_code,
			      (long)pos_char, (long)pos_int, nargs, arg_char,
			      arg_int);
    break;

  case 190:   /* Generate model */
    switch (*sub_code) {

    case 1:   /* ("graphical") */
      ni();
      break;

    case 2:   /* ("decomposable") | ("chordal") | ("rigid.circuit") */
      ni();
      break;

    case 3:   /* ("tree") */
      ni();
      break;

    case 5:   /* ("connected") */
      ni();
      break;

    case 7:   /* ("undirected") | ("skeleton") */
      ni_discrete();
      break;

    case 8:   /* ("moral") */
      ni_discrete();
      break;

    case 9:   /* ("acyclic") */
      ni_discrete();
      break;

    case 11:   /* ("MIM-model") */
      ni_discrete();
      break;

    case 12:   /* ("degenerated") */
      ni_discrete();
      break;

    case 13:   /* ("mean-linear") */
      ni_discrete();
      break;

    case 14:   /* ("d-collapsible") */
      ni_discrete();
      break;

    case 15:   /* ("q-equivalent") */
      ni_discrete();
      break;
    }
    break;

  case 191:
    proc_fix_edges(command_file, as_argument, ifail, sub_code, (long)pos_char,
		   nargs, arg_char);
    break;

  case 192:
    proc_and_fix_edges(command_file, as_argument, ifail, sub_code,
		       (long)pos_char, nargs, arg_char);
    break;

  case 199:
    *simple_command = true;
    switch (*sub_code) {

    case 1:
      global_write_options->write_test = false;
      break;

    case 2:
      global_stepwise_options->reversed = true;
      break;

    case 3:
      global_stepwise_options->sorted_list = true;
      break;

    case 5:
      global_stepwise_options->short_report = true;
      break;

    case 7:   /* ! */
      global_stepwise_options->decomposable = true;
      break;

    case 8:   /* ! */
      global_stepwise_options->graphical = true;
      break;

    case 9:   /* ! */
      global_stepwise_options->hierarchical = true;
      break;

    case 10:
      global_stepwise_options->recursive = true;
      break;

    case 11:
      global_stepwise_options->coherent = true;
      break;

    case 12:
      global_stepwise_options->headlong = true;
      break;

    case 13:
      global_stepwise_options->follow = true;
      break;

    case 14:
      global_stepwise_options->blockwise = true;
      break;

    case 15:
      global_stepwise_options->separators = true;
      break;

    case 19:   /* ! */
      global_stepwise_options->partitioning = true;
      break;

    case 20:
      global_stepwise_options->alternative = true;
      break;

    case 21:
      global_stepwise_options->alternative = true;
      break;
    }
    break;

  case 200:
    proc_backward(sub_code, ifail, (long)pos_int, (long)pos_double, nargs,
		  arg_int, arg_double);
    break;

  case 201:
    proc_forward(sub_code, ifail, (long)pos_int, (long)pos_double, nargs,
		 arg_int, arg_double);
    break;

  case 202:   /* IS GRAPHICAL */
    if (!as_argument)
      *sub_code = 1;
    switch (*sub_code) {

    case 1:
      break;
      /* ("graphical") */

    case 2:
      break;
      /* ("decomposable") | ("chordal") | ("rigid.circuit") */

    case 3:
      break;
      /* ("tree") */

    case 5:
      break;
      /* ("connected") */

    case 7:   /* ("undirected") | ("skeleton") */
      ni_discrete();
      break;

    case 8:   /* ("moral") */
      ni_discrete();
      break;

    case 9:   /* ("acyclic") */
      ni_discrete();
      break;

    case 11:
      break;
      /* ("MIM-model") */

    case 12:
      break;
      /* ("degenerated") */

    case 13:
      break;
      /* ("mean-linear") */

    case 14:
      break;
      /* ("d-collapsible") */

    case 15:
      break;
      /* ("q-equivalent") */

    case 16:
      break;
      /* ("homogeneous") */

    case 17:
      break;
      /* ("full_specified") */

    case 21:
      break;
      /* ("pure_discrete") */

    case 22:
      break;
      /* ("pure_continuous") */

    case 23:
      break;
      /* ("mixed") */

    case 24:
      break;
      /* ("cg_regression") */
    }

    proc_property_model(command_file, as_argument, ifail, sub_code,
			(long)pos_char, (long)pos_int, nargs, arg_char,
			arg_int);
    break;

  case 203:   /* IS DECOMPOSABLE */
    if (!as_argument)
      *sub_code = 2;
    switch (*sub_code) {

    case 1:   /**/
      break;
      /**/
      /* ("graphical") */

    case 2:
      break;
      /* ("decomposable") | ("chordal") | ("rigid.circuit") */

    case 3:   /**/
      break;
      /**/
      /* ("tree") */

    case 5:   /**/
      break;
      /**/
      /* ("connected") */
    }
    proc_property_model(command_file, as_argument, ifail, sub_code,
			(long)pos_char, (long)pos_int, nargs, arg_char,
			arg_int);
    break;

  case 204:
    proc_is_submodel_of(command_file, as_argument, ifail, sub_code,
			(long)pos_char, (long)pos_int, nargs, arg_char,
			arg_int);
    break;

  case 205:
    if (!as_argument)
      *sub_code = -1;
    if (-*sub_code < 4) {
      switch (-*sub_code) {

      case 1:
	break;
	/* ("in one clique") */

      case 2:
	break;
	/* ("separator") */

      case 3:   /* ("d-separator") */
	ni_discrete();
	break;
      }
    }
    if (*sub_code < -1)
      proc_is_decomposition(command_file, as_argument, ifail, sub_code,
			    (long)pos_char, (long)pos_int, nargs, arg_char,
			    arg_int);
    else
      proc_is_in_one_clique(command_file, as_argument, ifail, sub_code,
			    (long)pos_char, (long)pos_int, nargs, arg_char,
			    arg_int);
    break;

  case 206:
    proc_set_main_effects(command_file, as_argument, ifail, sub_code,
			  (long)pos_char, nargs, arg_char);
    break;

  case 207:
    proc_set_base_model(command_file, as_argument, ifail, sub_code,
			(long)pos_char, nargs, arg_char);
    break;

  case 208:
    proc_set_fix_in(command_file, as_argument, ifail, sub_code,
		    (long)pos_char, nargs, arg_char);
    break;

  case 209:
    proc_set_fix_out(command_file, as_argument, ifail, sub_code,
		     (long)pos_char, nargs, arg_char);
    break;

  case 210:
    proc_add_fix_in(command_file, as_argument, ifail, sub_code,
		    (long)pos_char, nargs, arg_char);
    break;

  case 211:
    proc_add_fix_out(command_file, as_argument, ifail, sub_code,
		     (long)pos_char, nargs, arg_char);
    break;

  case 212:
    redo_fix_in();
    break;

  case 213:
    redo_fix_out();
    break;

  case 214:
    link_eh_pack->search_strategy = *sub_code;
    break;

  case 215:
    switch_(20L, *sub_code - 2);
    dispose_duals();
    break;

  case 216:
    switch (*sub_code) {

    case 10:
      dispose_duals_and_models();
      break;

    case 1:
      dispose_duals();
      break;

    case 2:
      dispose_g_c_list(&link_eh_pack->d_a);
      break;

    case 3:
      dispose_g_c_list(&link_eh_pack->d_r);
      break;

    case 5:
      dispose_classes();
      break;

    case 6:
      dispose_g_c_list(&link_eh_pack->a);
      break;

    case 7:
      dispose_g_c_list(&link_eh_pack->r);
      break;
    }
    break;

  case 217:
    if (*sub_code > 10)
      decomposable_mode = false;
    if (*sub_code == 20)
      link_eh_pack->graphical_search = true;
    else if (*sub_code == 30)
      link_eh_pack->graphical_search = false;
    proc_set_start_models(command_file, as_argument, ifail, sub_code,
			  (long)pos_char, nargs, arg_char);
    break;

  case 218:
    proc_set_accepted_models(command_file, as_argument, ifail, sub_code,
			     (long)pos_char, nargs, arg_char);
    break;

  case 219:
    proc_set_rejected_models(command_file, as_argument, ifail, sub_code,
			     (long)pos_char, nargs, arg_char);
    break;

  case 220:
    set_search_class(sub_code);
    proc_extract_models(*sub_code);
    break;

  case 221:
    switch (*sub_code) {

    case 1:
      proc_export_one(true, false, 0L);
      break;

    case 2:
      proc_export_one(false, true, 0L);
      break;

    case 3:
      proc_export_one(false, false, 0L);
      break;

    case 4:
      proc_export_interval(command_file, true, false, 0L, as_argument, ifail,
			   sub_code, (long)pos_int, nargs, arg_int);
      break;

    case 5:
      proc_export_interval(command_file, false, true, 0L, as_argument, ifail,
			   sub_code, (long)pos_int, nargs, arg_int);
      break;

    case 6:
      proc_export_interval(command_file, false, false, 0L, as_argument, ifail,
			   sub_code, (long)pos_int, nargs, arg_int);
      break;
    }
    break;

  case 222:
    switch (*sub_code) {

    case 1:
      proc_export_one(true, false, 1L);
      break;

    case 2:
      proc_export_one(false, true, 1L);
      break;

    case 3:
      proc_export_one(false, false, 1L);
      break;

    case 4:
      proc_export_interval(command_file, true, false, 1L, as_argument, ifail,
			   sub_code, (long)pos_int, nargs, arg_int);
      break;

    case 5:
      proc_export_interval(command_file, false, true, 1L, as_argument, ifail,
			   sub_code, (long)pos_int, nargs, arg_int);
      break;

    case 6:
      proc_export_interval(command_file, false, false, 1L, as_argument, ifail,
			   sub_code, (long)pos_int, nargs, arg_int);
      break;
    }
    break;

  case 223:
    switch (*sub_code) {

    case 1:
      proc_export_one(true, false, 2L);
      break;

    case 2:
      proc_export_one(false, true, 2L);
      break;

    case 3:
      proc_export_one(false, false, 2L);
      break;

    case 4:
      proc_export_interval(command_file, true, false, 2L, as_argument, ifail,
			   sub_code, (long)pos_int, nargs, arg_int);
      break;

    case 5:
      proc_export_interval(command_file, false, true, 2L, as_argument, ifail,
			   sub_code, (long)pos_int, nargs, arg_int);
      break;

    case 6:
      proc_export_interval(command_file, false, false, 2L, as_argument, ifail,
			   sub_code, (long)pos_int, nargs, arg_int);
      break;
    }
    break;

  case 224:
    set_search_class(sub_code);
    if (*sub_code % 10 == 1)
      find_a_dual(link_eh_pack->g, &link_eh_pack->graphical_search,
		  link_eh_pack->r, &link_eh_pack->d_a);
    else if (*sub_code % 10 == 2)
      find_r_dual(link_eh_pack->g, &link_eh_pack->graphical_search,
		  link_eh_pack->a, &link_eh_pack->d_r);
    else
      find_duals();
    break;

  case 225:
    set_search_class(sub_code);
    switch (*sub_code % 10) {

    case 1:
      fit_a_dual(&alfa_, link_eh_pack->g, &link_eh_pack->graphical_search,
		 &link_eh_pack->a, &link_eh_pack->r, &link_eh_pack->d_a,
		 &link_eh_pack->d_r);
      break;

    case 2:
      fit_r_dual(&alfa_, link_eh_pack->g, &link_eh_pack->graphical_search,
		 &link_eh_pack->a, &link_eh_pack->r, &link_eh_pack->d_a,
		 &link_eh_pack->d_r);
      break;

    case 3:
      fit_size(true, &alfa_, link_eh_pack->g, &link_eh_pack->graphical_search,
	       &link_eh_pack->a, &link_eh_pack->r, &link_eh_pack->d_a,
	       &link_eh_pack->d_r);
      break;

    case 4:
      fit_size(false, &alfa_, link_eh_pack->g,
	       &link_eh_pack->graphical_search, &link_eh_pack->a,
	       &link_eh_pack->r, &link_eh_pack->d_a, &link_eh_pack->d_r);
      break;

    case 5:
      fit_both(&alfa_, link_eh_pack->g, &link_eh_pack->graphical_search,
	       &link_eh_pack->a, &link_eh_pack->r, &link_eh_pack->d_a,
	       &link_eh_pack->d_r);
      break;
    }
    break;

  case 226:
    proc_search(sub_code);
    break;

  case 227:
    set_search_class(sub_code);
    switch (*sub_code) {

    case 1:
      add_a_dual_to_accepted(&link_eh_pack->a, &link_eh_pack->d_r);
      break;

    case 2:
      add_models_to_accepted(link_eh_pack->d_r, true, &link_eh_pack->a,
			     &link_eh_pack->d_r);
      break;

    case 3:
      add_models_to_rejected(link_eh_pack->d_a, true, &link_eh_pack->r,
			     &link_eh_pack->d_a);
      break;

    case 4:
      add_r_dual_to_rejected(&link_eh_pack->r, &link_eh_pack->d_a);
      break;
    }
    break;

  case 228:
    search_base();
    break;

  case 241:
    proc_count_decomposable(command_file, as_argument, ifail, sub_code,
			    (long)pos_int, nargs, arg_int);
    break;

  case 242:
    proc_count_hierarchical(command_file, as_argument, ifail, sub_code,
			    (long)pos_int, nargs, arg_int);
    break;

  case 243:
    proc_count_mixed(command_file, as_argument, ifail, sub_code,
		     (long)pos_int, nargs, arg_int);
    break;

  case 244:
    proc_count_cliques(command_file, as_argument, ifail, sub_code,
		       (long)pos_int, nargs, arg_int);
    break;

  case 246:
    no_action(command_file);
    break;

  case 247:
    search_directed(command_file, &alfa_, link_eh_pack->g,
		    &link_eh_pack->graphical_search, &link_eh_pack->a,
		    &link_eh_pack->r, &link_eh_pack->d_a, &link_eh_pack->d_r);
    break;

  case 248:
    init_graphical_search();
    break;

  case 249:
    read_integer(command_file, " Option-> ", 9L, &link_eh_pack->search_opt);
    break;

  case 250:
    if (link_eh_pack != NULL)
      end_search(&link_eh_pack);
    start_search(&link_eh_pack);
    write_pch(stdout, " SEARCH STARTED", 15L);
    write_line(stdout);
    break;

  case 253:
    mode = menu;
    break;

  case 254:
    mode = command;
    break;

  case 255:
    proc_read_exact_level(command_file);
    break;
  }
  if (set_current)
    link_current = link_model_list;
  if (set_base)
    link_base = link_model_list;
  if (do_pop)
    pop_model_references();
}  /* internal_main_case */

#undef pos_char
#undef pos_int
#undef pos_double


Static Void main_case(command_file, code, sub_code, simple_command)
FILE *command_file;
t_integer *code, *sub_code;
boolean *simple_command;
{
  t_integer ifail = 0;
  long *nargs = NULL;
  Char *arg_char = NULL;
  long *arg_int = NULL, *arg_char_int = NULL;
  double *arg_double = NULL;

  if (test_data(code))
    internal_main_case(command_file, simple_command, false, &ifail, code,
		       sub_code, &nargs, &arg_char, &arg_int, &arg_double,
		       &arg_char_int);
}  /* main_case */



Static Void external_main_case(command_file, ifail, code, sub_code, nargs,
			       arg_string, arg_int, arg_double, arg_char_int)
FILE *command_file;
t_integer *ifail, *code, *sub_code;
long **nargs;
t_char_array **arg_string;
long **arg_int;
double **arg_double;
long **arg_char_int;
{
  Char *arg_char;
  t_integer i;
  boolean simple_command, char_input;
  long FORLIM;

  arg_char = (Char *)Malloc(sizeof(pch_long));
  if (arg_char == NULL)
    _OutMem();
  /*$ifdef TRACE*/
  /* Remove for DOS */
  ntr(" ExternalMainCase", 17L, 2812L, 1L, *code, *sub_code);
  if (trace_flag_set(20L, 2812L, 1L)) {
    FORLIM = (*nargs)[0];
    for (i = 0; i < FORLIM; i++)
      arg_char[i - PCH_START] = (*arg_string)[0][i];
    test_arguments(1L, ifail, *code, *sub_code, nargs, &arg_char, arg_int,
		   arg_double, arg_char_int);
  }
  /*$endif TRACE*/
  /* Remove for DOS */
  if (*nargs == NULL)
    set_ifail(ifail, 60L);
  else {
    arg_int_to_pch(ifail, code, sub_code, nargs, arg_string, arg_int,
		   arg_double, arg_char_int, &arg_char, &char_input);
    simple_command = false;
    if (test_data(code))
      internal_main_case(command_file, &simple_command, true, ifail, code,
			 sub_code, nargs, &arg_char, arg_int, arg_double,
			 arg_char_int);

    /*$ifdef TRACE*/
    /* Remove for DOS */
    if (trace_flag_set(20L, 2812L, 4L))
      test_arguments(2L, ifail, *code, *sub_code, nargs, &arg_char, arg_int,
		     arg_double, arg_char_int);
    /*$endif TRACE*/
    /* Remove for DOS */

    if (char_input) {
      FORLIM = (*nargs)[0];
      for (i = 1; i <= FORLIM; i++)
	(*arg_string)[0][i-1] = arg_char[i - PCH_START];
    } else {
      
       pch_to_int_vector(*arg_char_int, (*nargs)[3], arg_char);
      
      /* #  ifdef CC-minus     
      pch_to_int_vector(*arg_char_int, (long)PCH_END, arg_char);
           #  endif CC-minus */
      (*nargs)[3] = (*nargs)[0];
      (*nargs)[0] = 0;
    }
    /*$ifdef TRACE*/
    /* Remove for DOS */
    if (trace_flag_set(20L, 2812L, 8L)) {
      /*$endif TRACE*/
      /* Remove for DOS */
      test_arguments(3L, ifail, *code, *sub_code, nargs, &arg_char, arg_int,
		     arg_double, arg_char_int);
    }
  }
  _Free(arg_char);
}  /* external_main_case */



/*Has-forward-2*/

Static Void main_coco(command_file, source)
FILE *command_file;
boolean source;
{

  /*Has-forward-2*/

  /* No-forward

procedure main_coco(var command_file : text;
                          source     : boolean);
    No-forward */
  t_long_real clock_0, start_clock;
  t_integer valg, kode;
  boolean simple_command;
  FILE *TEMP;

  if (!source)
    clock_0 = my_clock()/1;
  do {
    interrupt_1 = false;
    interrupt_2 = false;
    interrupt_3 = false;
    simple_command = false;
    test_space();
    TEMP = stdout;
    flush_file(&TEMP);
    TEMP = stdout;
    flush_file(&TEMP);
    flush_file(&diary_file);
    flush_file(&log_file);
    if (dump)
      flush_file(&dump_file);
    if (mode == menu)
      read_command_nr(command_file, &valg, &kode, " MENU->   ", 7L, 0L, 0L);
    else
      read_command(command_file, &valg, &kode, false, prompt, prompt_length,
		   0L, 0L);
    start_clock = my_clock()/1;
    TEMP = stdout;
    flush_file(&TEMP);
    TEMP = stdout;
    flush_file(&TEMP);
    flush_file(&diary_file);
    flush_file(&log_file);
    dispose_part_list(&link_part_list);
    if (test_data(&valg))
      main_case(command_file, &valg, &kode, &simple_command);
    if (204 < valg && valg < 251 && link_eh_pack != NULL) {
      link_eh_pack->search_time += my_clock()/1 - start_clock;
      write_pch_20_text(report_file, " .. SearchTime:     ", 20L);
      write_time_text(report_file, " ", 1L, (double)my_clock()/1,
		      start_clock, 8L, 3L);
      write_line_text(report_file);
      write_pch_20_text(report_file, " .. TotalSearchTime:", 20L);
      write_time_text(report_file, " ", 1L,
		      link_eh_pack->search_time, 0.0, 8L, 3L);
      write_line_text(report_file);
    }
    if (char_count > prompt_length || echo_note)
      write_line(stdout);
    if (char_count == prompt_length && !simple_command)
      write_line_diary();
    if (exact_test && (mixed_data || em || incomplete_table)) {
      switch_(14L, -1L);
      write_line(stdout);
    }
    /* if em and incomplete_table then begin
         write_pch(output,
                     ' Warning: Using EM on Incomplete table@@', 38);
         write_line(output)
      end; */
    if (em) {
      if (mixed_data)
	write_pch(stdout, " Warning: EM not implementet for mixed", 38L);
      else
	write_pch(stdout, " Warning: Use CoCo for EM on discrete", 37L);
      write_line(stdout);
    }
    if (timer && !simple_command) {
      write_pch(stdout, " TIME:       ", 13L);
      write_real(stdout, (my_clock()/1 - start_clock) / 1000, 10L, 3L);
      write_pch(stdout, "secs.", 5L);
      write_line(stdout);
    }
  } while (valg != 0);
  if (log_on)
    write_line_text(log_file);
  if (!(timer || TURBO_PC && !source))
    return;
  write_pch(stdout, " TOTAL TIME: ", 13L);
  write_real(stdout, (my_clock()/1 - clock_0) / 1000, 10L, 3L);
  write_pch(stdout, "secs.", 5L);
  write_line(stdout);
}  /* main_coco */


/*@-"maindos.c"*/
/*@+"mainprog.p"*/


/*

2817:    +++  ++
2818:    +++  ++
2819:    ---  -- p/mainprog.p         4      23     222 p/mainprog.p
2820: |    5:    function traceovrreadbuf
2821: |   12:    procedure getuseroptions
2822: |   17:    function stringtoint
2823: |   76:    procedure init_overlay
2824:    +++  ++
2825:    +++  ++

*/


/*$ifdef Really-On-DOS

function traceovrreadbuf(ovrseg: word): t_integer;
begin
   traceovrreadbuf := stdovrreadbuf(ovrseg);
   writeln(' Overlay read: ', ovrseg: 10, ' Trap: ', ovrtrapcount: 4, ' Load:', ovrloadcount: 4)
end;

procedure getuseroptions;
var
   i: word;
   pastr: string;

function stringtoint(s: string): longint;
var
   i: word;
   r: longint;
begin
   if s[1] = '-' then
      i := 3
   else if s[i] in ['a'..'z', 'A'..'Z'] then
      i := 2
   else
      i := 1;
   while (s[i] = ' ') and (i <= length(s)) do
      i := i + 1;
   while not (s[i] in ['0'..'9']) and (i < length(s)) do
      i := i + 1;
   r := 0;
   while (s[i] in ['0'..'9']) and (i <= length(s)) do begin
      r := 10 * r + ord(s[i]) - ord('0');
      i := i + 1
   end;
   stringtoint := r
end;

begin
   for i := 0 to paramcount do begin
      pastr := paramstr(i);
      writeln(i: 3, ' "', paramstr(i), '" ', length(paramstr(i)): 3);
      if (pastr[1] = 't') or (pastr[1] = '-') and (pastr[2] = 't') or
         (pastr[1] = 'T') or (pastr[1] = '-') and (pastr[2] = 'T') then
         traceoverlay := true;
      if (pastr[1] = 'o') or (pastr[1] = '-') and (pastr[2] = 'o') or
         (pastr[1] = 'O') or (pastr[1] = '-') and (pastr[2] = 'O') then
      begin
         if ((length(pastr) = 1) or (length(pastr) = 2) and (pastr[1] = '-'))
            and (i < paramcount) then
            pastr := paramstr(i + 1);
         useroverlaysize := stringtoint(pastr)
      end;
      if (pastr[1] = 'r') or (pastr[1] = '-') and (pastr[2] = 'r') or
         (pastr[1] = 'R') or (pastr[1] = '-') and (pastr[2] = 'R') then
      begin
         if ((length(pastr) = 1) or (length(pastr) = 2) and (pastr[1] = '-'))
            and (i < paramcount) then
            pastr := paramstr(i + 1);
         userretrysize := stringtoint(pastr)
      end;
      if (pastr[1] = 'c') or (pastr[1] = '-') and (pastr[2] = 'c') or
         (pastr[1] = 'C') or (pastr[1] = '-') and (pastr[2] = 'C') then
      begin
         if ((length(pastr) = 1) or (length(pastr) = 2) and (pastr[1] = '-'))
            and (i < paramcount) then
            pastr := paramstr(i + 1);
         max_cases_in_list_var := stringtoint(pastr)
      end
   end
end;

 $endif Really-On-DOS*/

Static Void init_overlay()
{
  /*$ifdef Really-On-DOS
     traceoverlay := false;
     useroverlaysize := 96000;
     userretrysize := 0;
     max_cases_in_list_var := max_cases_in_list;
     getuseroptions;
     writeln(' Start:');
     writeln(' UserOverlaySize:       ', useroverlaysize: 8, ' bytes.');
     writeln(' Memory available:      ', memavail: 8, ' bytes.');
     ovrinit('coco.exe');
     if ovrresult <> ovrok then begin
        writeln(' Do: copy/b coco.exe + coco.ovr');
        ovrinit('coco.ovr')
     end;
     if ovrresult <> ovrok then begin
        writeln(' Overlay manager error.');
        halt(1)
     end;
     ovrinitems;
     if traceoverlay then begin
        stdovrreadbuf := ovrreadbuf;
        ovrreadbuf := traceovrreadbuf
     end;
     if ovrresult <> ovrok then begin
        case ovrresult of
          ovrioerror:
                     writeln(' Overlay file I/O error.');
          ovrnoemsdriver:
                         writeln(' EMS driver not installed.');
          ovrnoemsmemory:
                         writeln(' Not enough EMS memory.')
        end
     end;
     ovrsetretry(ovrgetbuf div 3);
     writeln(' Overlay buffer size:   ', ovrgetbuf: 8, ' bytes.');
     writeln(' Overlay retry size:    ', ovrgetretry: 8, ' bytes.');
     writeln(' After change of overlay buffer:');
     ovrsetbuf(useroverlaysize);
     case ovrresult of
       ovrerror:
                writeln(' Overlay manager error.');
       ovrnomemory:
                   writeln(' Not enough memory for overlay buffer.')
     end;
     if userretrysize <> 0 then
        ovrsetretry(userretrysize)
     else
        ovrsetretry(ovrgetbuf div 3);
     writeln(' Overlay buffer size:   ', ovrgetbuf: 8, ' bytes.');
     writeln(' Overlay retry size:    ', ovrgetretry: 8, ' bytes.');
     writeln(' Memory available:      ', memavail: 8, ' bytes.')
   $endif Really-On-DOS*/
}


/*MAIN PROGRAM START*/




 #ifndef SCOCO
 



/* #  ifdef Multiple-Objects-minus */

main(argc, argv)
int argc;
Char *argv[];
{
  PASCAL_MAIN(argc, argv);
  report_file = NULL;
  dump_file = NULL;
  log_file = NULL;
  diary_file = NULL;
  file_excluded = NULL;
  file_read = NULL;
  spec_file = NULL;
  data_file = NULL;
  exit_after_start_up = false;
  init_overlay();
  start_coco(argc, argv);
  read_start_up_files();
  if (!exit_after_start_up)
    main_coco(stdin, false);
  end_coco();
  if (data_file != NULL)
    fclose(data_file);
  if (spec_file != NULL)
    fclose(spec_file);
  if (file_read != NULL)
    fclose(file_read);
  if (file_excluded != NULL)
    fclose(file_excluded);
  if (diary_file != NULL)
    fclose(diary_file);
  if (log_file != NULL)
    fclose(log_file);
  if (dump_file != NULL)
    fclose(dump_file);
  if (report_file != NULL)
    fclose(report_file);
  exit(EXIT_SUCCESS);
}
/* #  endif Multiple-Objects-minus */

/* #  ifdef Multiple-Objects-plus
begin
 init_overlay;
 start_coco;
 read_start_up_files;
 if not exit_after_start_up then
 main_coco(input, false);
 end_coco
end;
  #  endif Multiple-Objects-plus */

/* #  ifdef Multiple-Objects-plus
begin
 coco
end.
  #  endif Multiple-Objects-plus */




   # endif
 




/*

  " Copyright (c) 1991, 1996, 2002, by Jens Henrik Badsberg "

  The source code in C for this version of CoCo is available free of
  charge for non-commercial use.

  The source code may only be read and edited for the purpose of
  compiling CoCo, and porting CoCo to machines not currently
  supported by the author.
  No new features may be added to CoCo and no parts of the program
  may be included in other systems or new interface-procedures (at
  the C-side) to R, Splus, XLISP-STAT or other programs made without
  the written permission from the author.

  */

/*@-"apix.C"*/





/* End. */
